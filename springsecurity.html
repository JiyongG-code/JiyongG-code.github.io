<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="SpringSecurity, 记录">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="yCy2azpds5XSuGZvis6OuA-XIGF5GuGpYRAaGfD6o48">
    <meta name="360-site-verification" content="b7c11a830ef90fd1464ad6206bb7b6e7">
    <meta name="description" content="Spring SecuritySpring Security 的运行流程大致如下：

当用户发送一个请求到 Web 应用程序时，请求会被 Spring Security 的过滤器链（Filter Chain）拦截。
过滤器链中有多个过滤器，">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>SpringSecurity | Ji`s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>

    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?4d1d73af45a62734730491a6b6c41da4";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
   </script>


    <script>(function (i, s, o, g, r, a, m) {
        i['DaoVoiceObject'] = r;
        i[r] = i[r] ||
          function () {
            (i[r].q = i[r].q || []).push(arguments);
          };
        i[r].l = 1 * new Date();
        a = s.createElement(o);
        m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        a.charset = 'utf-8';
        m.parentNode.insertBefore(a, m);
      })(window, document, 'script', ('https:' === document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/xxx.js", 'daovoice');
      daovoice('init', {
        app_id: "xxx",
      });
      daovoice('update');
    </script>
  
  


    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

    <script>
        (function(){
        var src = "https://jspassport.ssl.qhimg.com/11.0.1.js?d182b3f28525f2db83acfaaf6e696dba";
        document.write('<script src="' + src + '" id="sozz"><\/script>');
        })();
    </script>

    <meta name="baidu-site-verification" content>




<style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loaderҳ����ʧ���ý����ķ�ʽ*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }

    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }

   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}


    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo���ֶ��� */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//ʹ�ý����ķ�������loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//ǿ����ʾloading page 1s  
    };
    loaded();
})()
 </script><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loaderҳ����ʧ���ý����ķ�ʽ*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }

    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }

   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}


    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo���ֶ��� */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//ʹ�ý����ķ�������loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//ǿ����ʾloading page 1s  
    };
    loaded();
})()
 </script></head>


 <div id="loading-container">
     <p class="loading-text"></p> 
     <div class="loading-image">
         <div></div>
         <div></div>
         <div></div>
         <div></div> 
         <div></div>
     </div>
 </div><body>

    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Ji`s Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/contact" class="waves-effect waves-light">
            
            <span>留言板</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Ji`s Blog</div>
        <div class="logo-desc">
            
            Java | Spring | Redis
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                友情链接
            </a>
        </li>
        
        <li>
            <a href="/contact" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-link"></i>
                
                留言板
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/jiyongg-code" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/jiyongg-code" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/7.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        SpringSecurity
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                        <a href="/tags/SpringSecuritt/" target="_blank">
                            <span class="chip bg-color">SpringSecuritt</span>
                        </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                        <a href="/categories/Auth/" class="post-category" target="_blank">
                            Auth
                        </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-03-22
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                    jiyonggang
                    
                </div>

                
                
                <div class="info-break-policy">
                    <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                    26k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    111 分
                </div>
                
                

                
                <div id="busuanzi_container_page_pv" class="info-break-policy">
                    <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                    <span id="busuanzi_value_page_pv"></span>
                </div>
                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h1><p>Spring Security 的运行流程大致如下：</p>
<ul>
<li>当用户发送一个请求到 Web 应用程序时，请求会被 Spring Security 的过滤器链（Filter Chain）拦截。</li>
<li>过滤器链中有多个过滤器，每个过滤器负责处理不同的安全逻辑，如用户名密码认证、记住我功能、异常处理等。</li>
<li>如果请求需要身份验证，过滤器链会调用 AuthenticationManager 接口，该接口是认证管理器的核心接口，它委托给不同的 AuthenticationProvider 实现类来完成具体的认证逻辑。</li>
<li>AuthenticationProvider 会调用 UserDetailsService 接口，该接口负责从数据库或其他数据源获取用户的详细信息（UserDetails），如用户名、密码、角色等。</li>
<li>AuthenticationProvider 会比较用户输入的密码和 UserDetailsService 返回的密码是否匹配，如果匹配，认证成功，返回一个 Authentication 对象，该对象包含了用户的身份信息和权限信息。</li>
<li>过滤器链会将 Authentication 对象存储到 SecurityContextHolder 中，该类是一个全局的安全上下文容器，可以在任何地方访问当前用户的安全信息。</li>
<li>如果请求需要授权，过滤器链会调用 AccessDecisionManager 接口，该接口是授权管理器的核心接口，它根据不同的授权策略（如基于角色、基于资源等）来决定用户是否有权限访问请求的资源。</li>
<li>AccessDecisionManager 会调用 SecurityMetadataSource 接口，该接口负责获取请求资源所需的权限信息。</li>
<li>AccessDecisionManager 会比较 SecurityContextHolder 中的用户权限信息和 SecurityMetadataSource 返回的资源权限信息是否匹配，如果匹配，授权成功，放行请求，否则抛出异常或重定向到错误页面。</li>
</ul>
<h1 id="AbstractAuthenticationToken"><a href="#AbstractAuthenticationToken" class="headerlink" title="AbstractAuthenticationToken"></a>AbstractAuthenticationToken</h1><p>在Spring Security认证过程中，AbstractAuthenticationToken是一个非常重要的类，它主要用于存储和管理主体的各种信息，以及主体经过认证后的相关信息。</p>
<p>它是一个基础类，可以用来扩展和定制自己的Authentication对象。在AbstractAuthenticationToken中，一般会存储一些如主体信息（principal）和凭证（credentials）等基础数据。</p>
<p>我们可以从AbstractAuthenticationToken类中继承并创建自己的Authentication对象，比如在上面的代码片段中，MyUserNamePassToken就是继承了AbstractAuthenticationToken的一个具体应用。在这个例子中，我们在自定义的Authentication对象中，存储了用户名（account）和密码（pwd），并且在登录成功后，这些信息会被传递给MyAuthenticationSuccessHandler进行处理。</p>
<p>需要注意的是，在Spring Security中，Authentication对象的认证状态是由isAuthenticated()方法来设定的，如果该方法返回true，表示认证通过，反之则表示认证未通过。在上述代码中，我们在创建MyUserNamePassToken对象时，通过调用setAuthenticated(false)方法，设定了认证状态为未通过，这表示用户在登录过程中还需要进行进一步的认证。</p>
<p>总的来说，AbstractAuthenticationToken为我们提供了一个扩展和自定义Authentication对象的基类，使我们能够更灵活地处理登录过程中的各种逻辑和信息。</p>
<p>Spring Security 采用的是责任链的设计模式，它有一条很长的过滤器链。</p>
<p>Spring Security对Web资源的保护是靠Filter实现的</p>
<p>当初始化Spring Security时，会创建一个名为SpringSecurityFilterChain的Servlet过滤器，类型为 org.springframework.security.web.FilterChainProxy，它实现了javax.servlet.Filter，因此外部的请求会经过此类，<img src="/springsecurity/image-20230325122446975.png" alt="image-20230325122446975"></p>
<p>FilterChainProxy是一个代理，真正起作用的是FilterChainProxy中SecurityFilterChain所包含的各个Filter，同时这些Filter作为Bean被Spring管理，它们是Spring Security核心，各有各的职责，但他们并不直接处理用户的<strong>认证</strong>，也不直接处理用户的<strong>授权</strong>，而是把它们交给了认证管理器（AuthenticationManager）和决策管理器（AccessDecisionManager）进行处理。</p>
<p>spring Security功能的实现主要是由一系列过滤器链相互配合完成。</p>
<p>密码登录流程</p>
<ul>
<li><p>UsernamePasswordAuthenticationFilter：它是一个类，继承了AbstractAuthenticationProcessingFilter，用于处理表单登录请求。它会从请求中获取用户名和密码，然后使用UsernamePasswordAuthenticationToken构造一个认证请求对象，然后交给AuthenticationManager进行认证。</p>
</li>
<li><p>AuthenticationManager：它是一个接口，用于管理认证逻辑，它的authenticate方法接受一个Authentication对象作为参数，然后返回一个认证成功的Authentication对象或者抛出一个认证异常。它的默认实现类是ProviderManager。</p>
</li>
<li><p>ProviderManager：它是一个类，实现了AuthenticationManager接口，它管理一系列的AuthenticationProvider，每个AuthenticationProvider负责处理一种类型的认证请求，例如用户名密码、短信验证码、社交账号等。ProviderManager会遍历所有的AuthenticationProvider，找到能够支持当前认证请求的那个，然后调用它的authenticate方法进行认证。</p>
</li>
<li><p>DaoAuthenticationProvider：它是一个类，实现了AuthenticationProvider接口，它负责处理用户名密码的认证请求。它会调用UserDetailsService接口的loadUserByUsername方法根据用户名加载用户信息，包括密码和权限。然后它会调用PasswordEncoder接口的matches方法对比用户输入的密码和数据库中的密码是否匹配。如果匹配成功，就返回一个认证成功的UsernamePasswordAuthenticationToken对象。</p>
</li>
<li><p>UserDetailsService：它是一个接口，用于根据用户名加载用户信息，包括密码和权限。它的loadUserByUsername方法接受一个用户名作为参数，然后返回一个UserDetails对象或者抛出一个用户不存在的异常。它有多个实现类，例如JdbcUserDetailsManager、InMemoryUserDetailsManager等。</p>
</li>
<li><p>PasswordEncoder：它是一个接口，用于对密码进行加密和匹配。它的encode方法接受一个明文密码作为参数，然后返回一个加密后的密码。它的matches方法接受一个明文密码和一个加密后的密码作为参数，然后返回一个布尔值表示是否匹配。它有多个实现类，例如BCryptPasswordEncoder、NoOpPasswordEncoder等。</p>
</li>
</ul>
<h1 id="SpringSecurity执行流程图"><a href="#SpringSecurity执行流程图" class="headerlink" title="SpringSecurity执行流程图"></a>SpringSecurity执行流程图</h1><p><img src="/springsecurity/d359fe34bc7860c11a1b6e50bfd0e086.png" alt="img"></p>
<ol>
<li><p>WebAsyncManagerIntegrationFilter：将 Security 上下文与 Spring Web 中用于处理异步请求映射的 WebAsyncManager 进行集成。</p>
</li>
<li><p>SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到 SecurityContextHolder 中，然后在该次请求处理完成之后，将 SecurityContextHolder 中关于这次请求的信息存储到一个“仓储”中，然后将 SecurityContextHolder 中的信息清除，例如在Session中维护一个用户的安全信息就是这个过滤器处理的。默认是将SecurityContext存储在threadlocal中，可能是spring考虑到目前大多数为BS应用，一个应用同时可能有多个使用者，每个使用者又对应不同的安全上下，Security Context Holder为了保存这些安全上下文。</p>
</li>
<li><p>HeaderWriterFilter：用于将头信息加入响应中。</p>
</li>
<li><p>CsrfFilter：用于处理跨站请求伪造。</p>
</li>
<li><p>LogoutFilter：用于处理退出登录。</p>
</li>
<li><p>UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自 /login 的请求。从表单中获取用户名和密码时，默认使用的表单 name 值为 username 和 password，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。</p>
</li>
<li><p>DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。</p>
</li>
<li><p>BasicAuthenticationFilter：检测和处理 http basic 认证。</p>
</li>
<li><p>RequestCacheAwareFilter：用来处理请求的缓存。</p>
</li>
<li><p>SecurityContextHolderAwareRequestFilter：主要是包装请求对象request。</p>
</li>
<li><p>AnonymousAuthenticationFilter：检测 SecurityContextHolder 中是否存在 Authentication 对象，如果不存在为其提供一个匿名 Authentication。</p>
</li>
<li><p>SessionManagementFilter：管理 session 的过滤器</p>
</li>
<li><p>ExceptionTranslationFilter：处理 AccessDeniedException 和 AuthenticationException 异常。</p>
</li>
<li><p>FilterSecurityInterceptor：可以看做过滤器链的出口。</p>
</li>
<li><p>RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从 cookie 里找出用户的信息, 如果 Spring Security 能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。</p>
</li>
</ol>
<h1 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h1><p>客户端发起一个请求，进入 Security 过滤器链。</p>
<p>当到 LogoutFilter 的时候判断是否是登出路径，如果是登出路径则到 logoutHandler ，如果登出成功则到 logoutSuccessHandler 登出成功处理，如果登出失败则由 ExceptionTranslationFilter ；如果不是登出路径则直接进入下一个过滤器。</p>
<p>当到 UsernamePasswordAuthenticationFilter 的时候判断是否为登录路径，如果是，则进入该过滤器进行登录操作，如果登录失败则到 AuthenticationFailureHandler 登录失败处理器处理，如果登录成功则到 AuthenticationSuccessHandler 登录成功处理器处理，如果不是登录请求则不进入该过滤器。</p>
<p>当到 FilterSecurityInterceptor 的时候会拿到 uri ，根据 uri 去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到 Controller 层否则到 AccessDeniedHandler 鉴权失败处理器处理。</p>
<h1 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h1><p>WebSecurityConfigurerAdapte 这个类将在5.7版本被<code>@Deprecated</code>所标记了，未来这个类将被移除。</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>    
<span class="token annotation punctuation">@EnableWebSecurity</span>    
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SecurityConfig</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>    
    <span class="token annotation punctuation">@Override</span>    
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>AuthenticationManagerBuilder auth<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>

        auth<span class="token punctuation">.</span><span class="token function">userDetailsService</span><span class="token punctuation">(</span>userDetailService<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">passwordEncoder</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BCryptPasswordEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//认证提供者</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>WebSecurity web<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    
        web<span class="token punctuation">.</span><span class="token function">ignoring</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">antMatchers</span><span class="token punctuation">(</span><span class="token string">"/resources/**/*.html"</span><span class="token punctuation">,</span> <span class="token string">"/resources/**/*.js"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token punctuation">}</span>    
    <span class="token annotation punctuation">@Override</span>    
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>HttpSecurity http<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    
       http    
       <span class="token punctuation">.</span><span class="token function">formLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    
       <span class="token punctuation">.</span><span class="token function">loginPage</span><span class="token punctuation">(</span><span class="token string">"/login_page"</span><span class="token punctuation">)</span>    
       <span class="token punctuation">.</span><span class="token function">passwordParameter</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span>    
       <span class="token punctuation">.</span><span class="token function">passwordParameter</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span>    
       <span class="token punctuation">.</span><span class="token function">loginProcessingUrl</span><span class="token punctuation">(</span><span class="token string">"/sign_in"</span><span class="token punctuation">)</span>    
       <span class="token punctuation">.</span><span class="token function">permitAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    
       <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authorizeRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">antMatchers</span><span class="token punctuation">(</span><span class="token string">"/test"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasRole</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//权限设置</span>
       <span class="token punctuation">.</span><span class="token function">anyRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">accessDecisionManager</span><span class="token punctuation">(</span><span class="token function">accessDecisionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    
       <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">logout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">logoutUrl</span><span class="token punctuation">(</span><span class="token string">"/logout"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">logoutSuccessHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyLogoutSuccessHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    
       <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">csrf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
       http<span class="token punctuation">.</span><span class="token function">addFilterAt</span><span class="token punctuation">(</span><span class="token function">getAuthenticationFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>UsernamePasswordAuthenticationFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
       http<span class="token punctuation">.</span><span class="token function">exceptionHandling</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">accessDeniedHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyAccessDeniedHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
       http<span class="token punctuation">.</span><span class="token function">addFilterAfter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyFittler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> LogoutFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>配置介绍</p>
<p>@EnableWebSecurity</p>
<p> 加载了WebSecurityConfiguration配置类, 配置安全认证策略。2: 加载了AuthenticationConfiguration, 配置了认证信息。</p>
<h2 id="configure-AuthenticationManagerBuilder-auth"><a href="#configure-AuthenticationManagerBuilder-auth" class="headerlink" title="configure(AuthenticationManagerBuilder auth)"></a>configure(AuthenticationManagerBuilder auth)</h2><p>AuthenticationManager 的建造器，配置 AuthenticationManagerBuilder 会让Security 自动构建一个 AuthenticationManager（该类的功能参考流程图）；</p>
<p>该接口的作用是对用户的未授信凭据进行认证，认证通过则返回授信状态的凭据，否则将抛出认证异常。</p>
<p>如果想要使用该功能需要配置一个 UserDetailService 和 PasswordEncoder。UserDetailsService 用于在认证器中根据用户传过来的用户名查找一个用户， PasswordEncoder 用于密码的加密与比对，我们存储用户密码的时候用PasswordEncoder.encode() 加密存储，在认证器里会调用 PasswordEncoder.matches() 方法进行密码比对。</p>
<p>如果重写了该方法，Security 会启用 DaoAuthenticationProvider 这个认证器，该认证就是先调用 UserDetailsService.loadUserByUsername 然后使用 PasswordEncoder.matches() 进行密码比对，如果认证成功成功则返回一个 Authentication 对象。</p>
<p>DaoAuthenticationProvider  实现了 AuthenticationProvider（鉴定提供者）</p>
<h2 id="configure-WebSecurity-web"><a href="#configure-WebSecurity-web" class="headerlink" title="configure(WebSecurity web)"></a>configure(WebSecurity web)</h2><p>这个配置方法用于配置静态资源的处理方式，可使用 Ant 匹配规则。</p>
<h2 id="configure-HttpSecurity-http"><a href="#configure-HttpSecurity-http" class="headerlink" title="configure(HttpSecurity http)"></a>configure(HttpSecurity http)</h2><pre><code>http    
.formLogin()    
.loginPage(&quot;/login_page&quot;)    
.passwordParameter(&quot;username&quot;)    
.passwordParameter(&quot;password&quot;)    
.loginProcessingUrl(&quot;/sign_in&quot;)    
.permitAll()</code></pre><p>这是配置登录相关的操作从方法名可知，</p>
<p>配置了登录页请求路径.loginPage(“/login_page”)，</p>
<p>密码属性名，.passwordParameter(“username”)    </p>
<p>用户名属性名， .passwordParameter(“username”)    </p>
<p>登录请求路径，.loginProcessingUrl(“/sign_in”)     //就是验证成功后转跳的页面</p>
<p>permitAll()代表任意用户可访问。</p>
<pre><code>http    
.authorizeRequests()    
.antMatchers(&quot;/test&quot;).hasRole(&quot;test&quot;)    
.anyRequest().authenticated()    
.accessDecisionManager(accessDecisionManager());</code></pre><p>以上配置是权限相关的配置，</p>
<p>配置了一个 <code>/test</code> url 该有什么权限才能访问， </p>
<p>anyRequest() 表示所有请求，</p>
<p>authenticated() 表示已登录用户才能访问， </p>
<p>accessDecisionManager() 表示绑定在 url 上的鉴权管理器</p>
<pre><code>http    
.logout()    
.logoutUrl(&quot;/logout&quot;)    
.logoutSuccessHandler(new MyLogoutSuccessHandler())</code></pre><p>登出相关配置，这里配置了登出 url 和登出成功处理器</p>
<pre><code>http    
.exceptionHandling()    
.accessDeniedHandler(new MyAccessDeniedHandler());</code></pre><p>代码是配置鉴权失败的处理器</p>
<pre><code>http.addFilterAfter(new MyFittler(), LogoutFilter.class);    
http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</code></pre><p>上面代码展示如何在过滤器链中插入自己的过滤器，addFilterBefore 加在对应的过滤器之前，addFilterAfter 加在对应的过滤器之后，addFilterAt 加在过滤器同一位置，事实上框架原有的 Filter 在启动 HttpSecurity 配置的过程中，都由框架完成了其一定程度上固定的配置，是不允许更改替换的。根据测试结果来看，调用 addFilterAt 方法插入的 Filter ，会在这个位置上的原有 Filter 之前执行。</p>
<p>注：关于 HttpSecurity 使用的是链式编程，其中 http.xxxx.and.yyyyy 这种写法和 http.xxxx;http.yyyy 写法意义一样。</p>
<ul>
<li>自定义 AuthenticationManager 认证管理器 和 AccessDecisionManager 访问决策管理器</li>
</ul>
<p>重写 authenticationManagerBean() 方法，并构造一个 authenticationManager：</p>
<pre><code>@Override    
public AuthenticationManager authenticationManagerBean() throws Exception {    
    ProviderManager authenticationManager = new ProviderManager(Arrays.asLis(getMyAuthenticationProvider(),daoAuthenticationProvider()));    
    return authenticationManager;    
}</code></pre><p>authenticationManager 配置了两个认证器</p>
<pre><code>public AccessDecisionManager accessDecisionManager(){    
    List&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt; decisionVoters    
            = Arrays.asList(    
            new MyExpressionVoter(),    
            new WebExpressionVoter(),    
            new RoleVoter(),    
            new AuthenticatedVoter());    
    return new UnanimousBased(decisionVoters);    
}</code></pre><p>投票管理器会收集投票器投票结果做统计，最终结果大于等于0代表通过；每个投票器会返回三个结果：-1（反对），0（通过），1（赞成）。</p>
<h1 id="Security-权限系统"><a href="#Security-权限系统" class="headerlink" title="Security 权限系统"></a>Security 权限系统</h1><h2 id="UserDetails"><a href="#UserDetails" class="headerlink" title="UserDetails"></a>UserDetails</h2><p>该接口是提供用户<strong>信息</strong>的核心接口。该接口实现仅仅存储用户的信息。后续会将该接口提供的用户信息封装到认证对象<code>Authentication</code>中去。</p>
<p><code>UserDetails</code> 默认提供了：</p>
<ul>
<li>用户的权限集， 默认需要添加<code>ROLE_</code> 前缀</li>
<li>用户的加密后的密码， 不加密会使用<code>{noop}</code>前缀</li>
<li>应用内唯一的用户名</li>
<li>账户是否过期</li>
<li>账户是否锁定</li>
<li>凭证是否过期</li>
<li>用户是否可用</li>
</ul>
<p>如果以上的信息满足不了使用，可以自行实现扩展以存储更多的用户信息。比如用户的邮箱、手机号等等。通常使用其实现类</p>
<pre><code>org.springframework.security.core.userdetails.User</code></pre><p>该类内置一个建造器<code>UserBuilder</code> 会很方便地构建<code>UserDetails</code> 对象。</p>
<h2 id="GrantedAuthority"><a href="#GrantedAuthority" class="headerlink" title="GrantedAuthority"></a>GrantedAuthority</h2><pre><code>public interface GrantedAuthority extends Serializable {
    String getAuthority();
}</code></pre><p><img src="/springsecurity/image-20230323174655629.png" alt="image-20230323174655629"></p>
<p>自带了三个实现类</p>
<p>Security 中的用户权限接口，自定义权限需要实现该接口:</p>
<pre><code>public class MyGrantedAuthority implements GrantedAuthority {    
    private String authority;    
}</code></pre><p>authority 表示权限字段，需要注意的是在 config 中配置的权限会被加上 ROLE_ 前缀，比如我们的配置 authorizeRequests().antMatchers(“/test”).hasRole(“test”)，配置了一个 test 权限但我们存储的权限字段（authority）应该是 ROLE_test 。</p>
<p>GrantedAuthority代表的就是一种权限对象，而一个 UserDetails 对象具备一个或多个 GrantedAuthority 对象。通过这种关联关系，实际上我们就可以对用户的权限做一些限制</p>
<p>Authentication 的 getAuthorities() 可以返回当前 Authentication 对象拥有的权限，即当前用户拥有的权限。其返回值是一个 GrantedAuthority 类型的数组，每一个 GrantedAuthority 对象代表赋予给当前用户的一种权限。GrantedAuthority 是一个接口，其通常是通过 UserDetailsService 进行加载，然后赋予给 UserDetails 的。</p>
<p>GrantedAuthority 中只定义了一个 getAuthority() 方法，该方法返回一个字符串，表示对应权限的字符串表示，如果对应权限不能用字符串表示，则应当返回 null。</p>
<p>Spring Security 针对 GrantedAuthority 有一个简单实现 SimpleGrantedAuthority。该类只是简单的接收一个表示权限的字符串。Spring Security 内部的所有 AuthenticationProvider 都是使用 SimpleGrantedAuthority 来封装 Authentication 对象。</p>
<h2 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h2><p><code>UserDetailsService</code>接口。该接口只提供了一个方法：</p>
<pre><code>public interface UserDetailsService {
    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
</code></pre><p>根据用户名来定位用户。在实际执行中，搜索可能是区分大小写的，也可能是不区分大小写的，这取决于执行实例是如何配置的。在这种情况下，返回的UserDetails对象可能有一个与实际请求的不同大小写的用户名。</p>
<p>loadUserByUsername的作用，就是根据用户名查询用户对象。</p>
<h2 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h2><p>用户在完成登录后 Security 会将用户信息存储到这个类中，之后其他流程需要得到用户信息时都是从这个类中获得，用户信息被封装成 SecurityContext ，而实际存储的类是 SecurityContextHolderStrategy ，默认的SecurityContextHolderStrategy 实现类是 ThreadLocalSecurityContextHolderStrategy 它使用了ThreadLocal来存储了用户信息。</p>
<h2 id="使用注解在方法上进行权限认"><a href="#使用注解在方法上进行权限认" class="headerlink" title="使用注解在方法上进行权限认"></a>使用注解在方法上进行权限认</h2><p>Spring Security<code>默认是禁用注解的，要想开启注解，要在继承</code>WebSecurityConfigurerAdapter<code>的类加</code>@EnableMethodSecurity<code>注解，并在该类中将</code>AuthenticationManager<code>定义为</code>Bean。</p>
<pre><code>@EnableWebSecurity
@Configuration
@EnableGlobalMethodSecurity(
  prePostEnabled = true, 
  securedEnabled = true, 
  jsr250Enabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }
}
</code></pre><p>分别有prePostEnabled 、securedEnabled、jsr250Enabled三个字段，其中每个字段代码一种注解支持，默认为false，true为开启。那么我们就一一来说一下这三总注解支持。</p>
<p>prePostEnabled = true 的作用的是启用Spring Security的@PreAuthorize 以及@PostAuthorize 注解。</p>
<p>securedEnabled = true 的作用是启用Spring Security的@Secured 注解。</p>
<p>jsr250Enabled = true 的作用是启用@RoleAllowed 注解</p>
<h3 id="JSR-250注解"><a href="#JSR-250注解" class="headerlink" title="JSR-250注解"></a>JSR-250注解</h3><p>遵守了JSR-250标准注解</p>
<p>主要注解</p>
<ol>
<li>@DenyAll</li>
<li>@RolesAllowed</li>
<li>@PermitAll</li>
</ol>
<p>这里面<code>@DenyAll</code> 和 <code>@PermitAll</code> 相信就不用多说了 代表拒绝和通过。</p>
<p><code>@RolesAllowed</code> 使用示例</p>
<pre><code>@RolesAllowed(&quot;ROLE_VIEWER&quot;)
public String getUsername2() {
    //...
}

@RolesAllowed({ &quot;USER&quot;, &quot;ADMIN&quot; })
public boolean isValidUsername2(String username) {
    //...
}</code></pre><p>代表标注的方法只要具有USER, ADMIN任意一种权限就可以访问。这里可以省略前缀ROLE_，实际的权限可能是ROLE_ADMIN</p>
<p>在功能及使用方法上与 <code>@Secured</code> 完全相同</p>
<h3 id="securedEnabled注解"><a href="#securedEnabled注解" class="headerlink" title="securedEnabled注解"></a>securedEnabled注解</h3><p>主要注解</p>
<p>@Secured</p>
<p>Spring Security的@Secured注解。注解规定了访问访方法的角色列表，在列表中最少指定一种角色</p>
<p>@Secured在方法上指定安全性，要求 角色/权限等 只有对应 角色/权限 的用户才可以调用这些方法。 如果有人试图调用一个方法，但是不拥有所需的 角色/权限，那会将会拒绝访问将引发异常。</p>
<pre><code>@Secured(&quot;ROLE_VIEWER&quot;)
public String getUsername() {
    SecurityContext securityContext = SecurityContextHolder.getContext();
    return securityContext.getAuthentication().getName();
}

@Secured({ &quot;ROLE_DBA&quot;, &quot;ROLE_ADMIN&quot; })
public String getUsername2() {
    //...
}
</code></pre><p>@Secured(“ROLE_VIEWER”) 表示只有拥有ROLE_VIEWER角色的用户，才能够访问getUsername()方法。</p>
<p>@Secured({ “ROLE_DBA”, “ROLE_ADMIN” }) 表示用户拥有”ROLE_DBA”, “ROLE_ADMIN” 两个角色中的任意一个角色，均可访问 getUsername2 方法。</p>
<p>还有一点就是@Secured,不支持Spring EL表达式</p>
<h3 id="prePostEnabled注解"><a href="#prePostEnabled注解" class="headerlink" title="prePostEnabled注解"></a>prePostEnabled注解</h3><p>这个开启后支持Spring EL表达式 算是蛮厉害的。如果没有访问方法的权限，会抛出AccessDeniedException。</p>
<p>主要注解</p>
<p>@PreAuthorize –适合进入方法之前验证授权</p>
<p>@PostAuthorize –检查授权方法之后才被执行并且可以影响执行方法的返回值</p>
<p>@PostFilter –在方法执行之后执行，而且这里可以调用方法的返回值，然后对返回值进行过滤或处理或修改并返回</p>
<p>@PreFilter –在方法执行之前执行，而且这里可以调用方法的参数，然后对参数值进行过滤或处理或修改</p>
<h3 id="PreAuthorize注解使用"><a href="#PreAuthorize注解使用" class="headerlink" title="PreAuthorize注解使用"></a>PreAuthorize注解使用</h3><pre><code>@PreAuthorize(&quot;hasRole(&#39;ROLE_VIEWER&#39;)&quot;)
public String getUsernameInUpperCase() {
    return getUsername().toUpperCase();
}
</code></pre><p>@PreAuthorize(“hasRole(‘ROLE_VIEWER’)”) 相当于@Secured(“ROLE_VIEWER”)。</p>
<p>同样的@Secured({“ROLE_VIEWER”,”ROLE_EDITOR”}) 也可以替换为：@PreAuthorize(“hasRole(‘ROLE_VIEWER’) or hasRole(‘ROLE_EDITOR’)”)。</p>
<p>在方法执行之前执行，这里可以调用方法的参数，也可以得到参数值，这里利用JAVA8的参数名反射特性，如果没有JAVA8，那么也可以利用Spring Secuirty的@P标注参数，或利用Spring Data的@Param标注参数</p>
<pre><code>//无java8
@PreAuthorize(&quot;#userId == authentication.principal.userId or hasAuthority(‘ADMIN’)&quot;)
void changePassword(@P(&quot;userId&quot;) long userId ){}
//有java8
@PreAuthorize(&quot;#userId == authentication.principal.userId or hasAuthority(‘ADMIN’)&quot;)
void changePassword(long userId ){}

</code></pre><p>这里表示在<code>changePassword</code>方法执行之前，判断方法参数userId的值是否等于principal中保存的当前用户的userId，或者当前用户是否具有ROLE_ADMIN权限，两种符合其一，就可以访问该 方法。</p>
<h3 id="PostAuthorize注解使用"><a href="#PostAuthorize注解使用" class="headerlink" title="@PostAuthorize注解使用"></a>@PostAuthorize注解使用</h3><p>在方法执行之后执行可,以获取到方法的返回值，并且可以根据该方法来决定最终的授权结果（是允许访问还是不允许访问):</p>
<pre><code>@PostAuthorize
  (&quot;returnObject.username == authentication.principal.nickName&quot;)
public CustomUser loadUserDetail(String username) {
    return userRoleRepository.loadUserByUserName(username);
}
</code></pre><p>上述代码中，仅当<code>loadUserDetail</code>方法的返回值中的username与当前登录用户的username相同时才被允许访问</p>
<h3 id="PreFilter以及-PostFilter注解使用"><a href="#PreFilter以及-PostFilter注解使用" class="headerlink" title="@PreFilter以及@PostFilter注解使用"></a>@PreFilter以及@PostFilter注解使用</h3><p>Spring Security提供了一个<code>@PreFilter</code> 注解来对传入的参数进行过滤：</p>
<pre><code>@PreFilter(&quot;filterObject != authentication.principal.username&quot;)
public String joinUsernames(List&lt;String&gt; usernames) {
    return usernames.stream().collect(Collectors.joining(&quot;;&quot;));
}
</code></pre><p>当usernames中的子项与当前登录用户的用户名不同时，则保留；当usernames中的子项与当前登录用户的用户名相同时，则移除。比如当前使用用户的用户名为zhangsan，此时usernames的值为{“zhangsan”, “lisi”, “wangwu”}，则经@PreFilter过滤后，实际传入的usernames的值为{“lisi”, “wangwu”}</p>
<p>如果执行方法中包含有多个类型为Collection的参数，filterObject 就不太清楚是对哪个Collection参数进行过滤了。此时，便需要加入 filterTarget 属性来指定具体的参数名称：</p>
<pre><code>@PreFilter
  (value = &quot;filterObject != authentication.principal.username&quot;,
  filterTarget = &quot;usernames&quot;)
public String joinUsernamesAndRoles(
  List&lt;String&gt; usernames, List&lt;String&gt; roles) {

    return usernames.stream().collect(Collectors.joining(&quot;;&quot;)) 
      + &quot;:&quot; + roles.stream().collect(Collectors.joining(&quot;;&quot;));
}
</code></pre><p>同样的我们还可以使用@PostFilter注解来过返回的Collection进行过滤：</p>
<pre><code>@PostFilter(&quot;filterObject != authentication.principal.username&quot;)
public List&lt;String&gt; getAllUsernamesExceptCurrent() {
    return userRoleRepository.getAllUsernames();
}

</code></pre><p>此时 filterObject 代表返回值。如果按照上述代码则实现了：移除掉返回值中与当前登录用户的用户名相同的子项。</p>
<p>手动填充 SecurityContextHolder 示例：</p>
<pre><code>UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(&quot;test&quot;,&quot;test&quot;,list);    
SecurityContextHolder.getContext().setAuthentication(token);</code></pre><p>对于使用 token 鉴权的系统，就可以验证token后手动填充SecurityContextHolder，填充时机只要在执行投票器之前即可，或者干脆可以在投票器中填充，然后在登出操作中清空SecurityContextHolder。</p>
<h1 id="Authority、Role的区别"><a href="#Authority、Role的区别" class="headerlink" title="Authority、Role的区别"></a>Authority、Role的区别</h1><p>可以看到，hasRole 的处理逻辑和 hasAuthority 似乎一模一样，不同的是，hasRole 这里会自动给传入的字符串加上 ROLE_ 前缀，所以在数据库中的权限字符串需要加上 ROLE_ 前缀。即数据库中存储的用户角色如果是 ROLE_admin，这里就是 admin。</p>
<p>在调用 hasAuthority 方法时，如果数据是从数据库中查询出来的，这里的权限和数据库中保存一致即可，可以不加 ROLE_ 前缀。即数据库中存储的用户角色如果是 admin，这里就是 admin</p>
<p>。</p>
<p>也就是说，使用 hasAuthority 更具有一致性，你不用考虑要不要加 ROLE_ 前缀，数据库什么样这里就是什么样！而 hasRole 则不同，代码里如果写的是 admin，框架会自动加上 ROLE_ 前缀，所以数据库就必须是 ROLE_admin。</p>
<p><img src="/springsecurity/image-20230323195413928.png" alt="image-20230323195413928"></p>
<p>使用方法</p>
<h1 id="Security-扩展"><a href="#Security-扩展" class="headerlink" title="Security 扩展"></a>Security 扩展</h1><p>Security 可扩展的有</p>
<ol>
<li><p>鉴权失败处理器</p>
</li>
<li><p>验证器</p>
</li>
<li><p>登录成功处理器</p>
</li>
<li><p>投票器</p>
</li>
<li><p>自定义token处理过滤器</p>
</li>
<li><p>登出成功处理器</p>
</li>
<li><p>登录失败处理器</p>
</li>
<li><p>自定义 UsernamePasswordAuthenticationFilter</p>
</li>
</ol>
<p>鉴权失败处理器</p>
<p>Security 鉴权失败默认跳转登录页面，我们可以实现 AccessDeniedHandler 接口，重写 handle() 方法来自定义处理逻辑；然后参考配置类说明将处理器加入到配置当中。</p>
<p>验证器</p>
<p>实现 AuthenticationProvider 接口来实现自己验证逻辑。需要注意的是在这个类里面就算你抛出异常，也不会中断验证流程，而是算你验证失败，我们由流程图知道，只要有一个验证器验证成功，就算验证成功，所以你需要留意这一点。</p>
<p>登录成功处理器</p>
<p>在 Security 中验证成功默认跳转到上一次请求页面或者路径为 “/“ 的页面，我们同样可以自定义：继承 SimpleUrlAuthenticationSuccessHandler 这个类或者实现 AuthenticationSuccessHandler 接口。我这里建议采用继承的方式,SimpleUrlAuthenticationSuccessHandler 是默认的处理器，采用继承可以契合里氏替换原则，提高代码的复用性和避免不必要的错误。</p>
<p>投票器</p>
<p>投票器可继承 WebExpressionVoter 或者实现 AccessDecisionVoter接口；WebExpressionVoter 是 Security 默认的投票器；我这里同样建议采用继承的方式；添加到配置的方式参考 上文；</p>
<p>注意：投票器 vote 方法返回一个int值；-1代表反对，0代表弃权，1代表赞成；投票管理器收集投票结果，如果最终结果大于等于0则放行该请求。</p>
<p>自定义token处理过滤器</p>
<p>自定义 token 处理器继承自 OncePerRequestFilter 或者 GenericFilterBean 或者 Filter 都可以，在这个处理器里面需要完成的逻辑是：获取请求里的 token，验证 token 是否合法然后填充 SecurityContextHolder ，虽然说过滤器只要添加在投票器之前就可以，但我这里还是建议添加在 http.addFilterAfter(new MyFittler(), LogoutFilter.class);</p>
<p>登出成功处理器</p>
<p>实现LogoutSuccessHandler接口，添加到配置的方式参考上文。</p>
<p>登录失败处理器</p>
<p>登录失败默认跳转到登录页，我们同样可以自定义。继承 SimpleUrlAuthenticationFailureHandler 或者实现 AuthenticationFailureHandler，建议采用继承。</p>
<p>自定义UsernamePasswordAuthenticationFilter</p>
<p>我们自定义UsernamePasswordAuthenticationFilter可以极大提高我们 Security的灵活性（比如添加验证验证码是否正确的功能）。</p>
<p>我们直接继承 UsernamePasswordAuthenticationFilter ，然后在配置类中初始化这个过滤器，给这个过滤器添加登录失败处理器，登录成功处理器，登录管理器，登录请求 url 。</p>
<p>这里配置略微复杂，贴一下代码清单</p>
<p>初始化过滤器：</p>
<pre><code>MyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){    
    MyUsernamePasswordAuthenticationFilter myUsernamePasswordAuthenticationFilter = new MyUsernamePasswordAuthenticationFilter(redisService);    
    myUsernamePasswordAuthenticationFilter.setAuthenticationFailureHandler(new MyUrlAuthenticationFailureHandler());    
    myUsernamePasswordAuthenticationFilter.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler());    
    myUsernamePasswordAuthenticationFilter.setFilterProcessesUrl(&quot;/sign_in&quot;);    
    myUsernamePasswordAuthenticationFilter.setAuthenticationManager(getAuthenticationManager());    
    return myUsernamePasswordAuthenticationFilter;    
}</code></pre><p>添加到配置：</p>
<pre><code>http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</code></pre><p>总结<br>对于 Security 的扩展配置关键在于 configure(HttpSecurityhttp) 方法；扩展认证方式可以自定义 authenticationManager 并加入自己验证器，在验证器中抛出异常不会终止验证流程；扩展鉴权方式可以自定义 accessDecisionManager 然后添加自己的投票器并绑定到对应的 url（url 匹配方式为 ant）上，投票器 vote(Authenticationauthentication,FilterInvocationfi,Collection<configattribute>attributes) 方法返回值为三种：-1 0 1，分别表示反对弃权赞成。</configattribute></p>
<p>对于 token 认证的校验方式，可以暴露一个获取的接口，或者重写 UsernamePasswordAuthenticationFilter 过滤器和扩展登录成功处理器来获取 token，然后在 LogoutFilter 之后添加一个自定义过滤器，用于校验和填充 SecurityContextHolder。</p>
<p>另外，Security 的处理器大部分都是重定向的，我们的项目如果是前后端分离的话，我们希望无论什么情况都返回 json ,那么就需要重写各个处理器了。</p>
<h1 id="认证原理和自定义认证"><a href="#认证原理和自定义认证" class="headerlink" title="认证原理和自定义认证"></a>认证原理和自定义认证</h1><ul>
<li>认证配置</li>
<li>表单认证</li>
<li>注销登录</li>
<li>前后端分离认证</li>
<li>添加验证码</li>
</ul>
<p>密码登录主要经过这几个类</p>
<ul>
<li><strong>UsernamePasswordAuthenticationFilter</strong>：这个过滤器用于拦截登录请求，创建一个UsernamePasswordAuthenticationToken对象，表示身份验证请求。</li>
<li><strong>AuthenticationManager</strong>：这个接口用于对身份验证请求进行身份验证，委派给一个或多个AuthenticationProvider来进行身份验证，并返回一个Authentication对象，表示身份验证结果。</li>
<li><strong>ProviderManager</strong>：这个类是AuthenticationManager的一种实现，它包含一个或多个AuthenticationProvider，并根据需要来调用它们。</li>
<li><strong>DaoAuthenticationProvider</strong>：这个类是AuthenticationProvider的一种实现，它使用UserDetailsService来加载用户的信息，如密码、权限等，并使用PasswordEncoder来比较用户输入的密码和数据库中的密码是否匹配。</li>
<li><strong>UserDetailsService</strong>：这个接口用于根据用户名来加载用户的信息，如密码、权限等。它可以有不同的实现，如内存用户、数据库用户或者自定义用户服务。</li>
<li><strong>SecurityContextHolder</strong>：这个类用于保存身份验证结果，作为当前的安全上下文。它使用SecurityContext和Authentication两个接口来表示安全上下文和身份验证结果。</li>
<li><strong>SavedRequestAwareAuthenticationSuccessHandler</strong>：这个类是身份验证成功处理器的一种实现，它用于处理身份验证成功的情况，通常是重定向到请求的资源或者其他的页面。<a href="https://edgeservices.bing.com/edgesvc/chat?udsframed=1&form=SHORUN&clientscopes=chat,noheader,channeldev,&shellsig=c9c1911c54c8b7293de4656beea472846ecfa276&setlang=zh-CN&lightschemeovr=1#sjevt|Discover.Chat.SydneyClickPageCitation|adpclick|0|8a5712c9-20f6-46a8-a4e4-000286514ce6" target="_blank" rel="noopener">1</a></li>
<li><strong>FilterSecurityInterceptor</strong>：这个过滤器用于拦截资源请求，根据安全上下文中的身份验证结果和资源的访问规则来进行授权判断，如果授权通过，就返回资源给用户。</li>
</ul>
<h2 id="自定义认证"><a href="#自定义认证" class="headerlink" title="自定义认证"></a>自定义认证</h2><h3 id="自定义资源权限规则"><a href="#自定义资源权限规则" class="headerlink" title="自定义资源权限规则"></a>自定义资源权限规则</h3><p>  /index  公共资源 </p>
<p>/hello …. 受保护资源 </p>
<p>权限管理 在项⽬中添加如下配置就可以实现对资源权限规则设定:</p>
<pre><code>@Configuration
 public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
 @Override
 protected void configure(HttpSecurity http) throws Exception {
 http.authorizeHttpRequests()
  .mvcMatchers(&quot;/index&quot;).permitAll()
  .anyRequest().authenticated()
  .and().formLogin();
  }
 }</code></pre><p>说明</p>
<p>-permitAll() 代表放⾏该资源,该资源为公共资源 ⽆需认证和授权可以直接访问</p>
<p>-anyRequest().authenticated() 代表所有请求,必须认证之后才能访问</p>
<p>-formLogin() 代表开启表单认证 </p>
<p>!” 注意: 放⾏资源必须放在所有认证请求之前!</p>
<h4 id="antMatchers和mvcMatchers的区别"><a href="#antMatchers和mvcMatchers的区别" class="headerlink" title="antMatchers和mvcMatchers的区别"></a>antMatchers和mvcMatchers的区别</h4><p>antMatchers和mvcMatchers都是用于配置HttpSecurity的方法，但是它们使用了不同的表达式语言来匹配请求。</p>
<p>antMatchers使用Ant风格的路径模式，例如”/index”或者”/index/*”或者”/index/**”等。</p>
<p>mvcMatchers使用Spring MVC的请求映射规则，例如”/index”或者”/index/“或者”/index.*”等。</p>
<p>通常mvcMatchers比antMatchers更安全，因为mvcMatchers可以匹配更多的可能的请求，而antMatchers可能会漏掉一些请求。</p>
<p>例如，antMatchers(“/secured”)只能匹配精确的”/secured”路径，而mvcMatchers(“/secured”)可以匹配”/secured”以及”/secured/“或者”/secured.html”或者”/secured.xyz”等。</p>
<h3 id="自定义登录页面"><a href="#自定义登录页面" class="headerlink" title="自定义登录页面"></a>自定义登录页面</h3><p>配置 Spring Security 配置类</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebSecurityConfigurer</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>
 <span class="token annotation punctuation">@Override</span>
 <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>HttpSecurity http<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
         http<span class="token punctuation">.</span><span class="token function">authorizeHttpRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">mvcMatchers</span><span class="token punctuation">(</span><span class="token string">"/login.html"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">permitAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//放行的资源</span>
          <span class="token punctuation">.</span><span class="token function">mvcMatchers</span><span class="token punctuation">(</span><span class="token string">"/index"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">permitAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//放行的资源</span>
          <span class="token punctuation">.</span><span class="token function">anyRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">formLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//表单登录</span>
          <span class="token punctuation">.</span><span class="token function">loginPage</span><span class="token punctuation">(</span><span class="token string">"/login.html"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//登录页面</span>
          <span class="token punctuation">.</span><span class="token function">loginProcessingUrl</span><span class="token punctuation">(</span><span class="token string">"/doLogin"</span><span class="token punctuation">)</span>
          <span class="token punctuation">.</span><span class="token function">usernameParameter</span><span class="token punctuation">(</span><span class="token string">"uname"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//表单里面用uname作为用户名参数的名称</span>
          <span class="token punctuation">.</span><span class="token function">passwordParameter</span><span class="token punctuation">(</span><span class="token string">"passwd"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//同上</span>
          <span class="token punctuation">.</span><span class="token function">successForwardUrl</span><span class="token punctuation">(</span><span class="token string">"/index"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//登录成功的页面</span>
        <span class="token comment" spellcheck="true">//注意:不会跳转到之前请求路径</span>
        <span class="token comment" spellcheck="true">//".defaultSuccessUrl("/index")   </span>
        <span class="token comment" spellcheck="true">//"forward 跳转 </span>
        <span class="token comment" spellcheck="true">//"redirect 重定向  注意:如果之前请求路径,会有优先跳转之前请求路径</span>
  <span class="token punctuation">.</span><span class="token function">failureUrl</span><span class="token punctuation">(</span><span class="token string">"/login.html"</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">csrf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">!</span>"这⾥先关闭 CSRF
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="/springsecurity/image-20230714194303240.png" alt="image-20230714194303240"></p>
<p>successForwardUrl 、defaultSuccessUrl 这两个⽅法都可以实现成功之后 </p>
<p>跳转 successForwardUrl  默认使⽤ forward跳转  （请求转发）     </p>
<p>注意:不会跳转到之前请求路径 </p>
<p>defaultSuccessUrl    默认使⽤ redirect 跳转 （重定向）      </p>
<p>注意:如果之前 请求路径,会有优先跳转之前请求路径,可以传⼊第⼆个参数进⾏修改</p>
<p>请求转发</p>
<p>请求转发是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,因为<strong>这个跳转过程实在服务器实现</strong>的，并不是在客户端实现的所以客户端并不知道这个跳转动作，所以它<strong>的地址栏还是原来的地址.</strong></p>
<p>重定向</p>
<p>是服务端根据逻辑,<strong>发送一个状态码</strong>,告诉浏览器重新去请求那个地址.<strong>所以地址栏显示的是新的URL</strong></p>
<h3 id="使用JSON格式参数登录"><a href="#使用JSON格式参数登录" class="headerlink" title="使用JSON格式参数登录"></a>使用JSON格式参数登录</h3><ul>
<li>方式一：重写 <code>UsernamePasswordAuthenticationFilter</code> 过滤器</li>
<li>方式二：自定义登录接口</li>
</ul>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p><code>UsernamePasswordAuthenticationFilter</code> 过滤器中提取的，因此我们只需要模仿<code>UsernamePasswordAuthenticationFilter</code>过滤器重写一个过滤器，替代原有的<code>UsernamePasswordAuthenticationFilter</code>过滤器即可</p>
<p>可以看到登录接口源码</p>
<p>是从servlet里面拿username,password</p>
<p><img src="/springsecurity/image-20230727183107128.png" alt="image-20230727183107128"></p>
<p><img src="/springsecurity/image-20230727174154297.png" alt="image-20230727174154297"></p>
<p>代码实现</p>
<pre><code>public class LoginFilter extends UsernamePasswordAuthenticationFilter {

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        // 需要是 POST 请求
        if (!request.getMethod().equals(&quot;POST&quot;)) {
            throw new AuthenticationServiceException(
                    &quot;Authentication method not supported: &quot; + request.getMethod());
        }
        HttpSession session = request.getSession();
        // 获得 session 中的 验证码值
        String sessionVerifyCode = (String) session.getAttribute(&quot;verify_code&quot;);
        // 判断请求格式是否是 JSON
        if (request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE) || request.getContentType().equals(MediaType.APPLICATION_JSON_UTF8_VALUE)) {
            Map&lt;String, String&gt; loginData = new HashMap&lt;&gt;();
            try {
                loginData = new ObjectMapper().readValue(request.getInputStream(), Map.class);
            } catch (IOException e) {
            }finally {
            //判断
                String code = loginData.get(&quot;code&quot;);
                checkVerifyCode(sessionVerifyCode, code);
            }
            String username = loginData.get(getUsernameParameter());
            String password = loginData.get(getPasswordParameter());
            if(StringUtils.isEmpty(username)){
                throw new AuthenticationServiceException(&quot;用户名不能为空&quot;);
            }
            if(StringUtils.isEmpty(password)){
                throw new AuthenticationServiceException(&quot;密码不能为空&quot;);
            }
            // // 然后把账号名、密码封装到 一个认证Token对象中，这是就是一个通行证，但是这时的状态时不可信的，一旦通过认证就变为可信的
            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(
                    username, password);
             // 会将 HttpServletRequest 中的一些细节 request.getRemoteAddr()  request.getSession 存入的到Token中
            setDetails(request, authRequest);
             // 然后 使用 父类中的 AuthenticationManager 对Token 进行认证
            return this.getAuthenticationManager().authenticate(authRequest);
        }else {
            checkVerifyCode(sessionVerifyCode, request.getParameter(&quot;code&quot;));
            return super.attemptAuthentication(request, response);
        }
    }

    private void checkVerifyCode(String sessionVerifyCode, String code) {
        if (StringUtils.isEmpty(code)){
            throw new AuthenticationServiceException(&quot;验证码不能为空!&quot;);
        }
        if(StringUtils.isEmpty(sessionVerifyCode)){
            throw new AuthenticationServiceException(&quot;请重新申请验证码!&quot;);
        }
        if (!sessionVerifyCode.equalsIgnoreCase(code)) {
            throw new AuthenticationServiceException(&quot;验证码错误!&quot;);
        }
    }
}
</code></pre><p>1、当前登录请求是否是 POST 请求，如果不是，则抛出异常。</p>
<p>2、判断请求格式是否是 JSON，如果是则走我们自定义的逻辑，如果不是则调用 <code>super.attemptAuthentication</code> 方法，进入父类原本的处理逻辑中；当然也可以抛出异常。</p>
<p>3、如果是 JSON 请求格式的数据，通过 ObjectMapper 读取 request 中的 I/O 流，将 JSON 映射到Map 上。</p>
<p>4、从 Map 中取出 code key的值，判断验证码是否正确，如果验证码有错，则直接抛出异常。</p>
<p>5、根据用户名、密码构建 <code>UsernamePasswordAuthenticationToken</code> 对象，然后调用官方的方法进行验证，验证用户名、密码是否真实有效</p>
<p>接下来就是将我们自定义的 LoginFilter 过滤器代替默认的 <code>UsernamePasswordAuthenticationFilter</code>。</p>
<pre><code>@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    PasswordEncoder passwordEncoder() {
        return NoOpPasswordEncoder.getInstance();
    }

    @Bean
    @Override
    protected UserDetailsService userDetailsService() {
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(User.withUsername(&quot;cxyxj&quot;).password(&quot;123&quot;).roles(&quot;admin&quot;).build());
        manager.createUser(User.withUsername(&quot;security&quot;).password(&quot;security&quot;).roles(&quot;user&quot;).build());
        return manager;
    }


    @Override
    @Bean
    public AuthenticationManager authenticationManagerBean()
            throws Exception {
        return super.authenticationManagerBean();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // 用自定义的 LoginFilter 实例代替 UsernamePasswordAuthenticationFilter
        http.addFilterBefore(loginFilter(), UsernamePasswordAuthenticationFilter.class);

        http.authorizeRequests()  //开启配置
                // 验证码、登录接口放行
                .antMatchers(&quot;/verify-code&quot;,&quot;/auth/login&quot;).permitAll()
                .anyRequest() //其他请求
                .authenticated().and()//验证   表示其他请求需要登录才能访问
                .csrf().disable();  // 禁用 csrf 保护

                http.exceptionHandling().authenticationEntryPoint(new MyAuthenticationEntryPoint());
    }

    @Bean
    LoginFilter loginFilter() throws Exception {
        LoginFilter loginFilter = new LoginFilter();
        loginFilter.setFilterProcessesUrl(&quot;/auth/login&quot;);
        loginFilter.setUsernameParameter(&quot;account&quot;);
        loginFilter.setPasswordParameter(&quot;pwd&quot;);
        loginFilter.setAuthenticationManager(authenticationManagerBean());
        loginFilter.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler());
        loginFilter.setAuthenticationFailureHandler(new MyAuthenticationFailureHandler());
        return loginFilter;
    }

}

</code></pre><p>当我们替换了 <code>UsernamePasswordAuthenticationFilter</code> 之后，原本在 SecurityConfig#configure 方法中关于 form 表单的配置就会失效，那些失效的属性，都可以在配置 LoginFilter 实例的时候配置；还需要记得配置<code>AuthenticationManager</code>，否则启动时会报错。</p>
<h5 id="AuthenticationFailureHandler登录失败回调"><a href="#AuthenticationFailureHandler登录失败回调" class="headerlink" title="AuthenticationFailureHandler登录失败回调"></a>AuthenticationFailureHandler登录失败回调</h5><pre><code>public class MyAuthenticationFailureHandler implements AuthenticationFailureHandler {
    @Override
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException {
        response.setContentType(&quot;application/json;charset=utf-8&quot;);
        PrintWriter out = response.getWriter();
        String msg = &quot;&quot;;
        if (e instanceof LockedException) {
            msg = &quot;账户被锁定，请联系管理员!&quot;;
        }
       else if (e instanceof BadCredentialsException) {
            msg = &quot;用户名或者密码输入错误，请重新输入!&quot;;
        }
        out.write(e.getMessage());
        out.flush();
        out.close();
    }
}</code></pre><h5 id="MyAuthenticationSuccessHandler登录成功回调"><a href="#MyAuthenticationSuccessHandler登录成功回调" class="headerlink" title="MyAuthenticationSuccessHandler登录成功回调"></a>MyAuthenticationSuccessHandler登录成功回调</h5><pre><code>public class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler {

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        Object principal = authentication.getPrincipal();
        response.setContentType(&quot;application/json;charset=utf-8&quot;);
        PrintWriter out = response.getWriter();
        out.write(new ObjectMapper().writeValueAsString(principal));
        out.flush();
        out.close();
    }

}
//可以在这里实现返回jwt之类的逻辑
//public class JwtAuthenticationSuccessHandler implements AuthenticationSuccessHandler {

//    @Override
//  public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        // 在这里生成 JWT 并将其放入响应头或响应体中
//        String jwt = generateJwt(authentication.getName()); // 这里需要实现自己的 JWT 生成逻辑
//       response.setHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + jwt); // 将 JWT 放入响应头
//        response.getWriter().write(&quot;{\&quot;token\&quot;: \&quot;&quot; + jwt + &quot;\&quot;}&quot;); // 或将 JWT 放入响应体
//    }

    // 实现 JWT 生成逻辑
//    private String generateJwt(String username) {
        // 这里可以使用第三方库生成 JWT，也可以自行实现
        // 返回生成的 JWT 字符串
//   }
//}
</code></pre><p>AuthenticationEntryPoint</p>
<p>用于处理身份验证异常，主要作用是在用户未通过身份验证访问受保护的资源时，决定如何返回适当的响应。</p>
<pre><code>public class MyAuthenticationEntryPoint implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException {
        response.setContentType(&quot;application/json;charset=utf-8&quot;);
        PrintWriter out = response.getWriter();
        out.write(&quot;您未登录，请先登录！&quot;);
        out.flush();
        out.close();
    }
}

</code></pre><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><pre><code>@PostMapping(&quot;/doLogin&quot;)
public Object login(@RequestBody LoginReq req) {
    String account = req.getAccount();
    String pwd = req.getPwd();
    String code = req.getCode();
    UsernamePasswordAuthenticationToken authenticationToken =
            new UsernamePasswordAuthenticationToken(account, pwd);
    Authentication authentication = authenticationManager.authenticate(authenticationToken);
    SecurityContextHolder.getContext().setAuthentication(authentication);
    return authentication.getPrincipal();
}


public class LoginReq {

    private String account;

    private String pwd;

    private String code;
}

</code></pre><p>方式二就是在我们自己的 Controller 层中，编写一个登录接口，接收用户名、密码、验证码参数。根据用户名、密码构建 <code>UsernamePasswordAuthenticationToken</code> 对象，然后调用官方的方法进行验证，验证用户名、密码是否真实有效；最后将认证对象放入到 Security 的上下文中。就三行代码就实现了简单的登录功能。</p>
<pre><code>@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    PasswordEncoder passwordEncoder() {
        return NoOpPasswordEncoder.getInstance();
    }

    @Bean
    @Override
    protected UserDetailsService userDetailsService() {
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(User.withUsername(&quot;cxyxj&quot;).password(&quot;123&quot;).roles(&quot;admin&quot;).build());
        manager.createUser(User.withUsername(&quot;security&quot;).password(&quot;security&quot;).roles(&quot;user&quot;).build());
        return manager;
    }


    @Override
    @Bean
    public AuthenticationManager authenticationManagerBean()
            throws Exception {
        return super.authenticationManagerBean();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()  //开启配置
                // 验证码、登录接口放行
                .antMatchers(&quot;/verify-code&quot;,&quot;/doLogin&quot;).permitAll()
                .anyRequest() //其他请求
                .authenticated().and()//验证   表示其他请求需要登录才能访问
                .csrf().disable();  // 禁用 csrf 保护

       http.exceptionHandling().authenticationEntryPoint(new MyAuthenticationEntryPoint());

    }
}

</code></pre><h3 id="自定义登录成功处理"><a href="#自定义登录成功处理" class="headerlink" title="自定义登录成功处理"></a>自定义登录成功处理</h3><p>有时候⻚⾯跳转并不能满⾜我们，特别是在前后端分离开发中就不需要成功之后跳转⻚⾯。 只需要给前端返回⼀个 JSON 通知登录成功还是失败与否。这个时候可以通过⾃定义  AuthenticationSucccessHandler 实现</p>
<p>根据接⼝的描述信息,也可以得知登录成功会⾃动回调这个⽅法，进⼀步查看它的默认实现</p>
<p>successForwardUrl、defaultSuccessUrl也是由它的⼦类实现的</p>
<p><img src="/springsecurity/image-20230714194943686.png" alt="image-20230714194943686"></p>
<h4 id="自定义-AuthenticationSuccessHandler-实现"><a href="#自定义-AuthenticationSuccessHandler-实现" class="headerlink" title="自定义 AuthenticationSuccessHandler 实现"></a>自定义 AuthenticationSuccessHandler 实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAuthenticationSuccessHandler</span> <span class="token keyword">implements</span> <span class="token class-name">AuthenticationSuccessHandler</span> <span class="token punctuation">{</span>
 <span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onAuthenticationSuccess</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Authentication authentication<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ServletException <span class="token punctuation">{</span>
     Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"登录成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"status"</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"application/json;charset=UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     String s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//转成json</span>
     response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="配置-AuthenticationSuccessHandler"><a href="#配置-AuthenticationSuccessHandler" class="headerlink" title="配置 AuthenticationSuccessHandler"></a>配置 AuthenticationSuccessHandler</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebSecurityConfigurer</span> <span class="token keyword">extends</span> 
<span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>
 <span class="token annotation punctuation">@Override</span>
 <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>HttpSecurity http<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
 http<span class="token punctuation">.</span><span class="token function">authorizeHttpRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token operator">!</span>"<span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>
  <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">formLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token operator">!</span>"<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">.</span><span class="token function">successHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyAuthenticationSuccessHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//new一个自己实现类</span>
  <span class="token punctuation">.</span><span class="token function">failureUrl</span><span class="token punctuation">(</span><span class="token string">"/login.html"</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">csrf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">!</span>"这⾥先关闭 CSRF
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="显示登录失败信息"><a href="#显示登录失败信息" class="headerlink" title="显示登录失败信息"></a>显示登录失败信息</h3><p>为了能更直观在登录⻚⾯看到异常错误信息，可以在登录⻚⾯中直接获取异常信息。Spring  Security 在登录失败之后会将异常信息存储到 request 、session作⽤域中 key 为  SPRING_SECURITY_LAST_EXCEPTION 命名属性中</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebSecurityConfigurer</span> <span class="token keyword">extends</span> 
<span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>
 <span class="token annotation punctuation">@Override</span>
 <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>HttpSecurity http<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
             http<span class="token punctuation">.</span><span class="token function">authorizeHttpRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
              <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
              <span class="token punctuation">.</span><span class="token function">formLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true">//.failureUrl("/login.html")</span>
              <span class="token punctuation">.</span><span class="token function">failureForwardUrl</span><span class="token punctuation">(</span><span class="token string">"/login.html"</span><span class="token punctuation">)</span>
              <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
              <span class="token punctuation">.</span><span class="token function">csrf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">!</span>"这⾥先关闭 CSRF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>failureUrl、failureForwardUrl 关系类似于之前提到的successForwardUrl 、defaultSuccessUrl ⽅法</p>
<p>failureUrl 失败以后的重定向跳转</p>
<p> failureForwardUrl 失败以后的 forward 跳转 </p>
<p>注意:因此获取 request 中异常信息,这⾥只能使⽤failureForwardUrl</p>
<h3 id="自定义登录失败处理"><a href="#自定义登录失败处理" class="headerlink" title="自定义登录失败处理"></a>自定义登录失败处理</h3><p>和⾃定义登录成功处理⼀样，Spring Security 同样为前后端分离开发提供了登录失败的处理AuthenticationFailureHandler</p>
<p>根据接⼝的描述信息,也可以得知登录失败会⾃动回调这个⽅法，进⼀步查看它的默认实现， 会发现failureUrl、failureForwardUrl也是由它的⼦类实现的。</p>
<p><img src="/springsecurity/image-20230714212944569.png" alt="image-20230714212944569"></p>
<h4 id="自定义-AuthenticationFailureHandler-实现"><a href="#自定义-AuthenticationFailureHandler-实现" class="headerlink" title="自定义 AuthenticationFailureHandler 实现"></a>自定义 AuthenticationFailureHandler 实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAuthenticationFailureHandler</span> <span class="token keyword">implements</span> 
<span class="token class-name">AuthenticationFailureHandler</span> <span class="token punctuation">{</span>
 <span class="token annotation punctuation">@Override</span>
 <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onAuthenticationFailure</span><span class="token punctuation">(</span>HttpServletRequest 
request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> AuthenticationException 
exception<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ServletException <span class="token punctuation">{</span>
 Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span>
 <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"登录失败: "</span><span class="token operator">+</span>exception<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 result<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"status"</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"application/json;charset=UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 String s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
 response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="配置-AuthenticationFailureHandler"><a href="#配置-AuthenticationFailureHandler" class="headerlink" title="配置 AuthenticationFailureHandler"></a>配置 AuthenticationFailureHandler</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebSecurityConfigurer</span> <span class="token keyword">extends</span> 
<span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>
 <span class="token annotation punctuation">@Override</span>
 <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>HttpSecurity http<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
 http<span class="token punctuation">.</span><span class="token function">authorizeHttpRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token operator">!</span>"<span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>
  <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">formLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token operator">!</span>"<span class="token operator">!</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span><span class="token function">failureHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> 
<span class="token class-name">MyAuthenticationFailureHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">csrf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">!</span>"这⾥先关闭 CSRF
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="注销登录"><a href="#注销登录" class="headerlink" title="注销登录"></a>注销登录</h3><p>Spring Security 中也提供了默认的注销登录配置，在开发时也可以按照⾃⼰需求对注销 进⾏个性化定制。</p>
<h4 id="开启注销登录默认开启"><a href="#开启注销登录默认开启" class="headerlink" title="开启注销登录默认开启"></a>开启注销登录默认开启</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebSecurityConfigurer</span> <span class="token keyword">extends</span> 
<span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>
 <span class="token annotation punctuation">@Override</span>
 <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>HttpSecurity http<span class="token punctuation">)</span> <span class="token keyword">throws</span> 
Exception <span class="token punctuation">{</span>
 http<span class="token punctuation">.</span><span class="token function">authorizeHttpRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">formLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">logout</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">logoutUrl</span><span class="token punctuation">(</span><span class="token string">"/logout"</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">invalidateHttpSession</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">clearAuthentication</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">logoutSuccessUrl</span><span class="token punctuation">(</span><span class="token string">"/login.html"</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">csrf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">!</span>"这⾥先关闭 CSRF

  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>通过 logout() ⽅法开启注销配置
logoutUrl 指定退出登录请求地址，默认是 GET 请求，路径为 /logout
invalidateHttpSession 退出时是否是 session 失效，默认值为 true
clearAuthentication 退出时是否清除认证信息，默认值为 true
logoutSuccessUrl 退出登录时跳转地址</code></pre><h4 id="配置多个注销登录请求"><a href="#配置多个注销登录请求" class="headerlink" title="配置多个注销登录请求"></a>配置多个注销登录请求</h4><p>如果项⽬中有需要，开发者还可以配置多个注销登录的请求，同时还可以指定请求的⽅ 法：</p>
<pre><code>@Configuration
 public class WebSecurityConfigurer extends 
WebSecurityConfigurerAdapter {
 @Override
 protected void configure(HttpSecurity http) throws 
Exception {
 http.authorizeHttpRequests()
  .and()
  .formLogin()
  .and()
  .logout()
  .logoutRequestMatcher(new OrRequestMatcher(
  new  AntPathRequestMatcher(&quot;/logout1&quot;,&quot;GET&quot;),
  new  AntPathRequestMatcher(&quot;/logout&quot;,&quot;GET&quot;)
  ))
  .invalidateHttpSession(true)
  .clearAuthentication(true)
  .logoutSuccessUrl(&quot;/login.html&quot;)
  .and()
  .csrf().disable();//这⾥先关闭 CSRF
  }
 }</code></pre><h4 id="前后端分离注销登录配置"><a href="#前后端分离注销登录配置" class="headerlink" title="前后端分离注销登录配置"></a>前后端分离注销登录配置</h4><p>如果是前后端分离开发，注销成功之后就不需要⻚⾯跳转了，只需要将注销成功的信息 返回前端即可，此时可以通过⾃定义 LogoutSuccessHandler  实现来返回注销 之后信息：</p>
<h4 id="实现登出成功过滤器"><a href="#实现登出成功过滤器" class="headerlink" title="实现登出成功过滤器"></a>实现登出成功过滤器</h4><pre><code>public class MyLogoutSuccessHandler implements LogoutSuccessHandler {
 @Override
 public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
         Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;();
         result.put(&quot;msg&quot;, &quot;注销成功&quot;);
         result.put(&quot;status&quot;, 200);
         response.setContentType(&quot;application/json;charset=UTF8&quot;);
        String s = new ObjectMapper().writeValueAsString(result);
         response.getWriter().println(s);
  }
 }</code></pre><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebSecurityConfigurer</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>
     <span class="token annotation punctuation">@Override</span>
     <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>HttpSecurity http<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
     http<span class="token punctuation">.</span><span class="token function">authorizeHttpRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">formLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">logout</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">//.logoutUrl("/logout")</span>
  <span class="token punctuation">.</span><span class="token function">logoutRequestMatcher</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OrRequestMatcher</span><span class="token punctuation">(</span>
    <span class="token keyword">new</span> <span class="token class-name">AntPathRequestMatcher</span><span class="token punctuation">(</span><span class="token string">"/logout1"</span><span class="token punctuation">,</span><span class="token string">"GET"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token keyword">new</span> <span class="token class-name">AntPathRequestMatcher</span><span class="token punctuation">(</span><span class="token string">"/logout"</span><span class="token punctuation">,</span><span class="token string">"GET"</span><span class="token punctuation">)</span>
     <span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">invalidateHttpSession</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">clearAuthentication</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
 <span class="token comment" spellcheck="true">//.logoutSuccessUrl("/login.html")</span>
  <span class="token punctuation">.</span><span class="token function">logoutSuccessHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyLogoutSuccessHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">csrf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">!</span>"这⾥先关闭 CSRF
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="登录用户数据获取"><a href="#登录用户数据获取" class="headerlink" title="登录用户数据获取"></a>登录用户数据获取</h3><h4 id="SecurityContextHolder-1"><a href="#SecurityContextHolder-1" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h4><p>Spring Security 会将登录⽤户数据保存在 Session 中。但是，为了使⽤⽅ 便,Spring Security在此基础上还做了⼀些改进，其中最主要的⼀个变化就是线程绑定。 当⽤户登录成功后,Spring Security 会将登录成功的⽤户信息保存到  SecurityContextHolder 中。 SecurityContextHolder 中的数据保存默认是通过ThreadLocal 来实现的，使⽤  ThreadLocal 创建的变量只能被当前线程访问，不能被其他线程访问和修改，也就是⽤户 数据和请求线程绑定在⼀起。当登录请求处理完毕后，Spring Security 会将  SecurityContextHolder 中的数据拿出来保存到 Session 中，同时将  SecurityContexHolder 中的数据清空。以后每当有请求到来时，Spring Security  就会先从 Session 中取出⽤户登录数据，保存到SecurityContextHolder 中，⽅便在 该请求的后续处理过程中使⽤，同时在请求结束时将 SecurityContextHolder 中的数据 拿出来保存到 Session 中，然后将SecurityContextHolder 中的数据清空。 实际上 SecurityContextHolder 中存储是 SecurityContext，在  SecurityContext 中存储是 Authentication。</p>
<p><img src="/springsecurity/image-20230715003628775.png" alt="image-20230715003628775"></p>
<p>里面有几个策略</p>
<ol>
<li>MODE THREADLOCAL：这种存放策略是将 SecurityContext 存放在 ThreadLocal 中，⼤家知道 Threadlocal 的特点是在哪个线程中存储就要在哪个线程中读取，这其 实⾮常适合 web 应⽤，因为在默认情况下，⼀个请求⽆论经过多少 Filter 到达  Servlet，都是由⼀个线程来处理的。这也是 SecurityContextHolder 的默认存储 策略，这种存储策略意味着如果在具体的业务处理代码中，开启了⼦线程，在⼦线程中 去获取登录⽤户数据，就会获取不到。</li>
<li>MODE INHERITABLETHREADLOCAL：这种存储模式适⽤于多线程环境，如果希望在⼦ 线程中也能够获取到登录⽤户数据，那么可以使⽤这种存储模式。</li>
<li>MODE GLOBAL：这种存储模式实际上是将数据保存在⼀个静态变量中，在 JavaWeb开 发中，这种模式很少使⽤到</li>
</ol>
<h4 id="SecurityContextHolderStrategy"><a href="#SecurityContextHolderStrategy" class="headerlink" title="SecurityContextHolderStrategy"></a>SecurityContextHolderStrategy</h4><p>通过 SecurityContextHolder 可以得知，SecurityContextHolderStrategy 接⼝ ⽤来定义存储策略⽅法</p>
<p>接口中一共定义了四种方法：</p>
<p>clearContext：该⽅法⽤来清除存储的 SecurityContext对象。</p>
<p> getContext：该⽅法⽤来获取存储的 SecurityContext 对象。</p>
<p> setContext：该⽅法⽤来设置存储的 SecurityContext 对象。</p>
<p> create Empty Context：该⽅法则⽤来创建⼀个空的 SecurityContext 对象。</p>
<h3 id="代码中获取认证之后⽤户数据"><a href="#代码中获取认证之后⽤户数据" class="headerlink" title="代码中获取认证之后⽤户数据"></a>代码中获取认证之后⽤户数据</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span>
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token punctuation">{</span>
     <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>
     <span class="token keyword">public</span> String <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     Authentication authentication <span class="token operator">=</span> SecurityContextHolder
      <span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAuthentication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     User principal <span class="token operator">=</span> <span class="token punctuation">(</span>User<span class="token punctuation">)</span> authentication<span class="token punctuation">.</span><span class="token function">getPrincipal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"身份 :"</span><span class="token operator">+</span>principal<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"凭证 :"</span><span class="token operator">+</span>authentication<span class="token punctuation">.</span><span class="token function">getCredentials</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"权限 :"</span><span class="token operator">+</span>authentication<span class="token punctuation">.</span><span class="token function">getAuthorities</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> <span class="token string">"hello security"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="多线程情况下获取用户户数据"><a href="#多线程情况下获取用户户数据" class="headerlink" title="多线程情况下获取用户户数据"></a>多线程情况下获取用户户数据</h3><pre><code>@RestController
 public class HelloController {
     @RequestMapping(&quot;/hello&quot;)
     public String hello() {
     new Thread(()-&gt;{
     Authentication authentication = SecurityContextHolder
      .getContext().getAuthentication();
    User principal = (User) authentication.getPrincipal();
     System.out.println(&quot;身份 :&quot;+principal.getUsername());
     System.out.println(&quot;凭证 :&quot;+authentication.getCredentials());
    System.out.println(&quot;权限 :&quot;+authentication.getAuthorities());
      }).start();
     return &quot;hello security&quot;;
  }
 }</code></pre><p><img src="/springsecurity/image-20230715004128465.png" alt="image-20230715004128465"></p>
<p>可以看到默认策略，是⽆法在⼦线程中获取⽤户信息，如果需要在⼦线程中获取必须使⽤第 ⼆种策略，默认策略是通过 System.getProperty 加载的，因此我们可以通过增加 VM  Options 参数进⾏修改。</p>
<p>-Dspring.security.strategy=MODE_INHERITABLETHREADLOCA</p>
<h3 id="自定义认证数据源"><a href="#自定义认证数据源" class="headerlink" title="自定义认证数据源"></a>自定义认证数据源</h3><p><img src="/springsecurity/image-20230715004804063.png" alt="image-20230715004804063"></p>
<p>发起认证请求，请求中携带⽤户名、密码，该请求会被 UsernamePasswordAuthenticationFilter 拦截</p>
<p>在UsernamePasswordAuthenticationFilter的attemptAuthentication⽅法 中将请求中⽤户名和密码，封装为Authentication对象，并交给 AuthenticationManager 进⾏认证</p>
<p>认证成功，将认证信息存储到 SecurityContextHodler 以及调⽤记住我等，并回调  AuthenticationSuccessHandler 处理</p>
<p>认证失败，清除 SecurityContextHodler 以及 记住我中信息，回调  AuthenticationFailureHandler 处理</p>
<h4 id="三者关系-AuthenticationManager-ProviderManager-AuthenticationProvider"><a href="#三者关系-AuthenticationManager-ProviderManager-AuthenticationProvider" class="headerlink" title="三者关系 AuthenticationManager ProviderManager AuthenticationProvider"></a>三者关系 AuthenticationManager ProviderManager AuthenticationProvider</h4><p>从上⾯分析中得知，AuthenticationManager 是认证的核⼼类，但实际上在底层真正认证时还离不开 ProviderManager 以及  AuthenticationProvider 。</p>
<p>AuthenticationManager 是⼀个认证管理器，它定义了 Spring Security 过滤 器要执⾏认证操作。</p>
<p>ProviderManager 是AuthenticationManager接⼝的实现类。Spring Security  认证时默认使⽤就是 ProviderManager。</p>
<p>AuthenticationProvider 就是针对不同的身份类型执⾏的具体的身份认证。</p>
<p>AuthenticationManager 与 ProviderManager</p>
<p><img src="/springsecurity/image-20230715005028283.png" alt="image-20230715005028283"></p>
<p>ProviderManager 是 AuthenticationManager 的唯⼀实现，也是 Spring  Security 默认使⽤实现。从这⾥不难看出默认情况下AuthenticationManager 就是⼀ 个ProviderManager</p>
<h4 id="ProviderManager-与-AuthenticationProvider"><a href="#ProviderManager-与-AuthenticationProvider" class="headerlink" title="ProviderManager 与 AuthenticationProvider"></a>ProviderManager 与 AuthenticationProvider</h4><p><img src="/springsecurity/image-20230715005100551.png" alt="image-20230715005100551"></p>
<p>在 Spring Seourity 中，允许系统同时⽀持多种不同的认证⽅式，例如同时⽀持⽤ 户名/密码认证、ReremberMe 认证、⼿机号码动态认证等，⽽不同的认证⽅式对应了不同AuthenticationProvider，所以⼀个完整的认证流程可能由多个  AuthenticationProvider 来提供。 </p>
<p>多个 AuthenticationProvider 将组成⼀个列表，这个列表将由  ProviderManager 代理。换句话说，在ProviderManager 中存在⼀个  AuthenticationProvider 列表，在Provider Manager 中遍历列表中的每⼀个  AuthenticationProvider 去执⾏身份认证，最终得到认证结果。</p>
<p>ProviderManager 本身也可以再配置⼀个 AuthenticationManager 作为  parent，这样当ProviderManager 认证失败之后，就可以进⼊到 parent 中再次进⾏认 证。理论上来说，ProviderManager 的 parent 可以是任意类型的  AuthenticationManager，但是通常都是由 ProviderManager 来扮演 parent 的⻆⾊，也就是 ProviderManager 是  ProviderManager 的 parent。</p>
<p>ProviderManager 本身也可以有多个，多个ProviderManager 共⽤同⼀个  parent。有时，⼀个应⽤程序有受保护资源的逻辑组（例如，所有符合路径模式的⽹络资 源，如/api!!*），每个组可以有⾃⼰的专⽤ AuthenticationManager。通常，每个组 都是⼀个ProviderManager，它们共享⼀个⽗级。然后，⽗级是⼀种 全局资源，作为所有 提供者的后备资源。</p>
<p><img src="/springsecurity/image-20230715142221252.png" alt="image-20230715142221252"></p>
<p>默认情况下  AuthenticationProvider  是由 DaoAuthenticationProvider 类来实现认证的， 在DaoAuthenticationProvider 认证时⼜通过 UserDetailsService 完成数据源的校验。调用关系</p>
<p><img src="/springsecurity/image-20230715143426299.png" alt="image-20230715143426299"></p>
<p>总结: AuthenticationManager 是认证管理器，在 Spring Security 中有全局 AuthenticationManager，也可以有局部AuthenticationManager。全局的 AuthenticationManager⽤来对全局认证进⾏处理，局部的AuthenticationManager⽤ 来对某些特殊资源认证处理。当然⽆论是全局认证管理器还是局部认证管理器都是由  ProviderManger 进⾏实现。 每⼀个ProviderManger中都代理⼀个 AuthenticationProvider的列表，列表中每⼀个实现代表⼀种身份认证⽅式。认证时底 层数据源需要调⽤ UserDetailService 来实现。</p>
<h4 id="配置全局-AuthenticationManager"><a href="#配置全局-AuthenticationManager" class="headerlink" title="配置全局 AuthenticationManager"></a>配置全局 AuthenticationManager</h4><p>默认的全局 AuthenticationManager</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebSecurityConfigurer</span> <span class="token keyword">extends</span> 
<span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>
 <span class="token annotation punctuation">@Autowired</span>
 <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span>AuthenticationManagerBuilder builder<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
     <span class="token comment" spellcheck="true">//builder..</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>⾃定义全局 AuthenticationManager</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebSecurityConfigurer</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>
         <span class="token annotation punctuation">@Override</span>
     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>AuthenticationManagerBuilder builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment" spellcheck="true">//builder ....</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>springboot 对 security 进⾏⾃动配置时⾃动在⼯⼚中创建⼀个全局 AuthenticationManager</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>默认⾃动配置创建全局AuthenticationManager 默认找当前项⽬中是否存在⾃ 定义 UserDetailService 实例 ⾃动将当前项⽬ UserDetailService 实例 设置为数据源</li>
<li>默认⾃动配置创建全局AuthenticationManager 在⼯⼚中使⽤时直接在代码中注⼊即可 </li>
<li>⼀旦通过 configure ⽅法⾃定义 AuthenticationManager实现 就回将⼯⼚ 中⾃动配置AuthenticationManager 进⾏覆盖 </li>
<li>⼀旦通过 configure ⽅法⾃定义 AuthenticationManager实现 需要在实现 中指定认证数据源对象 UserDetaiService 实例</li>
<li>⼀旦通过 configure ⽅法⾃定义 AuthenticationManager实现 这种⽅式创 建AuthenticationManager对象⼯⼚内部本地⼀个 AuthenticationManager  对象 不允许在其他⾃定义组件中进⾏注⼊</li>
</ol>
<p>⽤来在⼯⼚中暴露⾃定义AuthenticationManager 实例</p>
<h3 id="自定义内存数据源"><a href="#自定义内存数据源" class="headerlink" title="自定义内存数据源"></a>自定义内存数据源</h3><pre><code>@Configuration
 public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
     @Bean
     public UserDetailsService userDetailsService(){
     InMemoryUserDetailsManager inMemoryUserDetailsManager= new         InMemoryUserDetailsManager();
     UserDetails u1 = User.withUsername(&quot;zhangs&quot;)
      .password(&quot;{noop}111&quot;).roles(&quot;USER&quot;).build();
     inMemoryUserDetailsManager.createUser(u1);
     return inMemoryUserDetailsManager;
      }
 }
 @Override
 protected void configure(AuthenticationManagerBuilder auth) throws Exception {
     auth.userDetailsService(userDetailsService());
  }  </code></pre><h3 id="自定义数据库数据源"><a href="#自定义数据库数据源" class="headerlink" title="自定义数据库数据源"></a>自定义数据库数据源</h3><p>在springboot中配置数据库之类</p>
<h4 id="创建-entity"><a href="#创建-entity" class="headerlink" title="创建 entity"></a>创建 entity</h4><p>扩展UserDetails中的信息，</p>
<p>还有一种方案是不扩展直接把信息全部装到username中</p>
<p>创建 user 对象</p>
<pre><code>public class User  implements UserDetails {
 private Integer id;
 private String username;
 private String password;
 private Boolean enabled;
 private Boolean accountNonExpired;
 private Boolean accountNonLocked;
 private Boolean credentialsNonExpired;
 private List&lt;Role&gt; roles = new ArrayList!)();
@Override
 public Collection&lt;? extends GrantedAuthority&gt; 
getAuthorities() {
 List&lt;GrantedAuthority&gt; grantedAuthorities = new 
ArrayList!)();
 roles.forEach(role!.grantedAuthorities.add(new 
SimpleGrantedAuthority(role.getName())));
 return grantedAuthorities;
  }
 @Override
 public String getPassword() {
 return password;
  }
 @Override
 public String getUsername() {
 return username;
  }
 @Override
 public boolean isAccountNonExpired() {
 return accountNonExpired;
  }
 @Override
 public boolean isAccountNonLocked() {
 return accountNonLocked;
  }
 @Override
 public boolean isCredentialsNonExpired() {
 return credentialsNonExpired;
  }
 @Override
 public boolean isEnabled() {
return enabled;
  }
 !&quot;get/set....
 }</code></pre><p>创建 role 对象</p>
<pre><code>public class Role {
 private Integer id;
 private String name;
 private String nameZh;
 !&quot;get set!,
 }</code></pre><p>创建 UserDao 接⼝</p>
<p>创建 UserMapper 实现</p>
<h4 id="创建-UserDetailService-实例"><a href="#创建-UserDetailService-实例" class="headerlink" title="创建 UserDetailService 实例"></a>创建 UserDetailService 实例</h4><pre><code>@Component
 public class MyUserDetailService implements UserDetailsService 
{
     private  final UserDao userDao;
     @Autowired
     public MyUserDetailService(UserDao userDao) {
     this.userDao = userDao;
  }
 @Override
 public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
     User user = userDao.loadUserByUsername(username);
     if(ObjectUtils.isEmpty(user))throw new 
    RuntimeException(&quot;⽤户不存在&quot;);
     user.setRoles(userDao.getRolesByUid(user.getId()));
    return user;
  }
 }</code></pre><p>配置 authenticationManager 使⽤⾃定义UserDetailService</p>
<pre><code>@Configuration
 public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
     private final UserDetailsService userDetailsService;
     @Autowired
     public WebSecurityConfigurer(UserDetailsService userDetailsService) {
         this.userDetailsService = userDetailsService;
      }
     @Override
     protected void configure(AuthenticationManagerBuilder builder) throws Exception {
     builder.userDetailsService(userDetailsService);
  }
 @Override
 protected void configure(HttpSecurity http) throws Exception {
     //web security!,
  }
 }</code></pre><h3 id="添加认证验证码"><a href="#添加认证验证码" class="headerlink" title="添加认证验证码"></a>添加认证验证码</h3><p>配置验证码</p>
<h4 id="传统-web-开发"><a href="#传统-web-开发" class="headerlink" title="传统 web 开发"></a>传统 web 开发</h4><p>⽣成验证码 controller，验证码存到session或者redis里面</p>
<h5 id="⾃定义验证码异常类"><a href="#⾃定义验证码异常类" class="headerlink" title="⾃定义验证码异常类"></a>⾃定义验证码异常类</h5><pre><code>public class KaptchaNotMatchException extends AuthenticationException {
 public KaptchaNotMatchException(String msg) {
 super(msg);
  }
 public KaptchaNotMatchException(String msg, Throwable 
cause) {
 super(msg, cause);
  }
 }</code></pre><h5 id="自定义filter验证验证码"><a href="#自定义filter验证验证码" class="headerlink" title="自定义filter验证验证码"></a>自定义filter验证验证码</h5><pre><code>public class KaptchaFilter extends UsernamePasswordAuthenticationFilter {
     public static final String KAPTCHA_KEY = &quot;kaptcha&quot;;//默认值
    private String kaptcha = KAPTCHA_KEY;
     public String getKaptcha() {
     return kaptcha;
  }
public void setKaptcha(String kaptcha) {
     this.kaptcha = kaptcha;
 }
@Override
public Authentication attemptAuthentication(HttpServletRequest request, 
HttpServletResponse response) throws AuthenticationException {
 //1.判断是否是 post ⽅式
    if (request.getMethod().equals(&quot;POST&quot;)) {
    throw new AuthenticationServiceException(&quot;Authentication method not 
    supported: &quot; + request.getMethod());
  }
 //2.获取验证码
 String kaptcha = request.getParameter(getKaptcha());
 String sessionKaptcha = (String) request.getSession().getAttribute(&quot;kaptcha&quot;);
 if (!ObjectUtils.isEmpty(kaptcha) &amp;&amp; ！ObjectUtils.isEmpty(sessionKaptcha) &amp;&amp;！kaptcha.equalsIgnoreCase(sessionKaptcha)) {
     return super.attemptAuthentication(request, response);
  }
         throw new KaptchaNotMatchException(&quot;验证码输⼊错误!&quot;);
  }
 }</code></pre><h5 id="放⾏以及配置验证码-filter"><a href="#放⾏以及配置验证码-filter" class="headerlink" title="放⾏以及配置验证码 filter"></a>放⾏以及配置验证码 filter</h5><pre><code>@Configuration
public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
private final UserDetailsService userDetailsService;
@Autowired
public WebSecurityConfigurer(UserDetailsService userDetailsService) {
 this.userDetailsService = userDetailsService;
  }
 @Override
protected void configure(AuthenticationManagerBuilder builder) throws Exception {
 builder.userDetailsService(userDetailsService);
  }
 @Override
 @Bean
 public AuthenticationManager authenticationManagerBean() throws Exception {
     return super.authenticationManagerBean();
  }
 @Bean
 public KaptchaFilter kaptchaFilter() throws Exception {
 KaptchaFilter kaptchaFilter = new KaptchaFilter();
 //指定接收验证码请求参数名
    kaptchaFilter.setKaptcha(&quot;kaptcha&quot;);
 //指定认证管理器
    kaptchaFilter.setAuthenticationManager(authenticationManagerBean());
 //指定认证成功和失败处理
    kaptchaFilter.setAuthenticationSuccessHandler(new     MyAuthenticationSuccessHandler());
 kaptchaFilter.setAuthenticationFailureHandler(new 
MyAuthenticationFailureHandler());
//指定处理登录
    kaptchaFilter.setFilterProcessesUrl(&quot;/doLogin&quot;);
    kaptchaFilter.setUsernameParameter(&quot;uname&quot;);
     kaptchaFilter.setPasswordParameter(&quot;passwd&quot;);
     return kaptchaFilter;
  }
 @Override
 protected void configure(HttpSecurity http) throws Exception {
     http.authorizeHttpRequests()
      .mvcMatchers(&quot;/vc.jpg&quot;).permitAll()
      .mvcMatchers(&quot;/login.html&quot;).permitAll()
      .anyRequest().authenticated()
      .and()
      .formLogin()
      .loginPage(&quot;/login.html&quot;)
     http.addFilterAt(kaptchaFilter(), 
    UsernamePasswordAuthenticationFilter.class);
  }
 }</code></pre><h4 id="前后端分离开发"><a href="#前后端分离开发" class="headerlink" title="前后端分离开发"></a>前后端分离开发</h4><p>Spring Security默认提供账号密码认证方式，具体实现是在UsernamePasswordAuthenticationFilter类中。因为是表单提交，所以Filter中用request.getParameter(this.usernameParameter) 来获取用户账号和密码信息。当我们将请求类型改成application/json后，getParameter方法就获取不到信息。</p>
<p>要解决这个问题，就要新建一个Filter来替换UsernamePasswordAuthenticationFilter ，然后重新实现获取用户的方法。</p>
<p>⽣成验证码 controller</p>
<pre><code>@RestController
public class KaptchaController {
private final Producer producer;
 @Autowired
public KaptchaController(Producer producer) {
 this.producer = producer;
  }
@GetMapping(&quot;/vc.png&quot;)
public String getVerifyCode(HttpSession session) throws IOException {
 //⽣成验证码
String code = producer.createText();
 session.setAttribute(&quot;kaptcha&quot;, code);//可以更换成 redis 
实现
BufferedImage bi = producer.createImage(code);
 //写⼊内存
FastByteArrayOutputStream fos = new 
FastByteArrayOutputStream();
ImageIO.write(bi, &quot;png&quot;, fos);
 //⽣成 base64
 return Base64.encodeBase64String(fos.toByteArray());
  }
 }</code></pre><h4 id="定义验证码异常类"><a href="#定义验证码异常类" class="headerlink" title="定义验证码异常类"></a>定义验证码异常类</h4><pre><code>public class KaptchaNotMatchException extends 
AuthenticationException {
 public KaptchaNotMatchException(String msg) {
 super(msg);
  }
 public KaptchaNotMatchException(String msg, Throwable 
cause) {
 super(msg, cause);
  }
 }</code></pre><h4 id="在⾃定义LoginKaptchaFilter中加⼊验证码验证"><a href="#在⾃定义LoginKaptchaFilter中加⼊验证码验证" class="headerlink" title="在⾃定义LoginKaptchaFilter中加⼊验证码验证"></a>在⾃定义LoginKaptchaFilter中加⼊验证码验证</h4><pre><code>
//自定义 filter
public class LoginKaptchaFilter extends UsernamePasswordAuthenticationFilter {

    public static final String FORM_KAPTCHA_KEY = &quot;kaptcha&quot;;

    private String kaptchaParameter = FORM_KAPTCHA_KEY;

    public String getKaptchaParameter() {
        return kaptchaParameter;
    }

    public void setKaptchaParameter(String kaptchaParameter) {
        this.kaptchaParameter = kaptchaParameter;
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        if (!request.getMethod().equals(&quot;POST&quot;)) {
            throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod());
        }
        try {
            //1.获取请求数据
            Map&lt;String, String&gt; userInfo = new ObjectMapper().readValue(request.getInputStream(), Map.class);
            String kaptcha = userInfo.get(getKaptchaParameter());//用来获取数据中验证码
            String username = userInfo.get(getUsernameParameter());//用来接收用户名
            String password = userInfo.get(getPasswordParameter());//用来接收密码
            //2.获取 session 中验证码
            String sessionVerifyCode = (String) request.getSession().getAttribute(&quot;kaptcha&quot;);
            if (!ObjectUtils.isEmpty(kaptcha) &amp;&amp; !ObjectUtils.isEmpty(sessionVerifyCode) &amp;&amp;
                    kaptcha.equalsIgnoreCase(sessionVerifyCode)) {
                //3.获取用户名 和密码认证
                UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);
                setDetails(request, authRequest);//把用户和账号
                return this.getAuthenticationManager().authenticate(authRequest);//交给认证管理器
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        throw new KaptchaNotMatchException(&quot;验证码不匹配!&quot;);
    }
}
</code></pre><p>UsernamePasswordAuthenticationToken 是 Spring Security 中用于封装用户名密码认证信息的一个类，它实现了 Authentication 接口，用于表示一个认证请求。它有两个构造方法，一个用于创建一个未认证的认证请求，一个用于创建一个已认证的认证请求。你可以通过它的 getPrincipal () 和 getCredentials () 方法获取认证的主体和凭证信息²³。你还可以通过 SecurityContextHolder 对象获取当前的认证信息。</p>
<h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><pre><code>
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    //自定义内存数据源
    @Bean
    public UserDetailsService userDetailsService() {
        InMemoryUserDetailsManager inMemoryUserDetailsManager = new InMemoryUserDetailsManager();
        inMemoryUserDetailsManager.createUser(User.withUsername(&quot;root&quot;).password(&quot;{noop}123&quot;).roles(&quot;admin&quot;).build());
        return inMemoryUserDetailsManager;
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService());
    }

    @Override
    @Bean
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    //配置
    @Bean
    public LoginKaptchaFilter loginKaptchaFilter() throws Exception {
        LoginKaptchaFilter loginKaptchaFilter = new LoginKaptchaFilter();
        //1.认证 url
        loginKaptchaFilter.setFilterProcessesUrl(&quot;/doLogin&quot;);
        //2.认证 接收参数
        loginKaptchaFilter.setUsernameParameter(&quot;uname&quot;);
        loginKaptchaFilter.setPasswordParameter(&quot;passwd&quot;);
        loginKaptchaFilter.setKaptchaParameter(&quot;kaptcha&quot;);
        //3.指定认证管理器
        loginKaptchaFilter.setAuthenticationManager(authenticationManagerBean());
        //4.指定成功时处理
        loginKaptchaFilter.setAuthenticationSuccessHandler((req, resp, authentication) -&gt; {
            Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;();
            result.put(&quot;msg&quot;, &quot;登录成功&quot;);
            result.put(&quot;用户信息&quot;, authentication.getPrincipal());
            resp.setContentType(&quot;application/json;charset=UTF-8&quot;);
            resp.setStatus(HttpStatus.OK.value());
            String s = new ObjectMapper().writeValueAsString(result);
            resp.getWriter().println(s);
        });
        //5.认证失败处理
        loginKaptchaFilter.setAuthenticationFailureHandler((req, resp, ex) -&gt; {
            Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;();
            result.put(&quot;msg&quot;, &quot;登录失败: &quot; + ex.getMessage());
            resp.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
            resp.setContentType(&quot;application/json;charset=UTF-8&quot;);
            String s = new ObjectMapper().writeValueAsString(result);
            resp.getWriter().println(s);
        });
        return loginKaptchaFilter;
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .mvcMatchers(&quot;/vc.jpg&quot;).permitAll()
                .anyRequest().authenticated()
                .and()
                .formLogin()
                .and()
                .exceptionHandling()
                .authenticationEntryPoint((req, resp, ex) -&gt; {
                    resp.setContentType(&quot;application/json;charset=UTF-8&quot;);
                    resp.setStatus(HttpStatus.UNAUTHORIZED.value());
                    resp.getWriter().println(&quot;必须认证之后才能访问!&quot;);
                })
                .and()
                .logout()
                .and()
                .csrf().disable();

        http.addFilterAt(loginKaptchaFilter(), UsernamePasswordAuthenticationFilter.class);
    }
}
</code></pre><h1 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h1><p>常⻅⽅案  Hash 算法  最早我们使⽤类似 SHA-256 、SHA-512 、MD5等这样的单向 Hash 算法。⽤户注册 成功后，保存在数据库中不再是⽤户的明⽂密码，⽽是经过 SHA-256 加密计算的⼀个字⾏ 串，当⽤户进⾏登录时，⽤户输⼊的明⽂密码⽤ SHA-256 进⾏加密，加密完成之后，再和 存储在数据库中的密码进⾏⽐对，进⽽确定⽤户登录信息是否有效。如果系统遭遇攻击，最 多也只是存储在数据库中的密⽂被泄漏。 这样就绝对安全了吗？由于彩虹表这种攻击⽅式的存在以及随着计算机硬件的发展，每 秒执⾏数⼗亿次 HASH计算⼰经变得轻轻松松，这意味着即使给密码加密加盐也不再安全。</p>
<h2 id="单向自适应函数"><a href="#单向自适应函数" class="headerlink" title="单向自适应函数"></a>单向自适应函数</h2><p>在Spring Security 中，我们现在是⽤⼀种⾃适应单向函数 (Adaptive One-way  Functions)来处理密码问题，这种⾃适应单向函数在进⾏密码匹配时，会有意占⽤⼤量系 统资源（例如CPU、内存等），这样可以增加恶意⽤户攻击系统的难度。在Spring  Securiy 中，开发者可以通过 bcrypt、PBKDF2、sCrypt 以及 argon2 来体验这种⾃ 适应单向函数加密。<strong>由于自适应单向函数有意占⽤⼤量系统资源，因此每个登录认证请求都 会⼤⼤降低应⽤程序的性能，但是 Spring Secuity 不会采取任何措施来提⾼密码验证速 度，因为它正是通过这种⽅式来增强系统的安全性。</strong></p>
<p>BCryptPasswordEncoder </p>
<p>BCryptPasswordEncoder 使⽤ bcrypt 算法对密码进⾏加密，为了提⾼密码的安全 性，bcrypt算法故意降低运⾏速度，以增强密码破解的难度。同时 BCryptP  asswordEncoder “为⾃⼰带盐”开发者不需要额外维护⼀个“盐” 字段，使⽤ BCryptPasswordEncoder 加密后的字符串就已经“带盐”了，即使相同的明⽂每次⽣ 成的加密字符串都不相同。 Argon2PasswordEncoder </p>
<p>Argon2PasswordEncoder 使⽤ Argon2 算法对密码进⾏加密，Argon2 曾在  Password Hashing Competition 竞赛中获胜。为了解决在定制硬件上密码容易被 破解的问题，Argon2也是故意降低运算速度，同时需要⼤量内存，以确保系统的安全 性。</p>
<p>Pbkdf2PasswordEncoder </p>
<p>Pbkdf2PasswordEncoder 使⽤ PBKDF2 算法对密码进⾏加密，和前⾯⼏种类似， PBKDF2 算法也是⼀种故意降低运算速度的算法，当需要 FIPS (Federal Information  Processing Standard,美国联邦信息处理标准）认证时，PBKDF2 算法是⼀个很好 的选择。</p>
<p>SCryptPasswordEncoder </p>
<p>SCryptPasswordEncoder 使⽤scrypt 算法对密码进⾏加密，和前⾯的⼏种类似， serypt 也是⼀种故意降低运算速度的算法，⽽且需要⼤量内存。</p>
<h3 id="PasswordEncoder"><a href="#PasswordEncoder" class="headerlink" title="PasswordEncoder"></a>PasswordEncoder</h3><p>通过对认证流程源码分析得知，实际密码⽐较是由PasswordEncoder完成的，因此只需要 使⽤PasswordEncoder 不同实现就可以实现不同⽅式加密。</p>
<pre><code>public interface PasswordEncoder {
     String encode(CharSequence rawPassword);
     boolean matches(CharSequence rawPassword, String encodedPassword);
     default boolean upgradeEncoding(String encodedPassword) {
     return false;
     }
 }</code></pre><ul>
<li>encode ⽤来进⾏明⽂加密的 </li>
<li>matches ⽤来⽐较密码的⽅法 </li>
<li>upgradeEncoding ⽤来给密码进⾏升级的⽅法</li>
</ul>
<p><img src="/springsecurity/image-20230715175148056.png" alt="image-20230715175148056"></p>
<h3 id="DelegatingPasswordEncoder"><a href="#DelegatingPasswordEncoder" class="headerlink" title="DelegatingPasswordEncoder"></a>DelegatingPasswordEncoder</h3><p>根据上⾯ PasswordEncoder的介绍，可能会以为 Spring security 中默认的密码加密 ⽅案应该是四种⾃适应单向加密函数中的⼀种，其实不然，在 spring Security 5.0之 后，默认的密码加密⽅案其实是 DelegatingPasswordEncoder。从名字上来看， DelegatingPaswordEncoder 是⼀个代理类，⽽并⾮⼀种全新的密码加密⽅案， DeleggtinePasswordEncoder 主要⽤来代理上⾯介绍的不同的密码加密⽅案。为什么采 DelegatingPasswordEncoder ⽽不是某⼀个具体加密⽅式作为默认的密码加密⽅案呢？ </p>
<p>主要考虑了如下两⽅⾯的因素：</p>
<ul>
<li><p>兼容性：使⽤ DelegatingPasswrordEncoder 可以帮助许多使⽤旧密码加密⽅式的 系统顺利迁移到 Spring security 中，它允许在同⼀个系统中同时存在多种不同的 密码加密⽅案。</p>
</li>
<li><p>便捷性：密码存储的最佳⽅案不可能⼀直不变，如果使⽤  DelegatingPasswordEncoder作为默认的密码加密⽅案，当需要修改加密⽅案时，只 需要修改很⼩⼀部分代码就可以实现。</p>
</li>
<li></li>
</ul>
<h3 id="密码加密实战"><a href="#密码加密实战" class="headerlink" title="密码加密实战"></a>密码加密实战</h3><p>测试⽣成的密码</p>
<pre><code>@Test
public void test() {
//1.BCryptPasswordEncoder
 BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder();
 System.out.println(bCryptPasswordEncoder.encode(&quot;123&quot;));
 //2.Pbkdf2PasswordEncoder
Pbkdf2PasswordEncoder pbkdf2PasswordEncoder = new Pbkdf2PasswordEncoder();
 System.out.println(pbkdf2PasswordEncoder.encode(&quot;123&quot;));
 //3.SCryptPasswordEncoder //需要额外引⼊依赖
SCryptPasswordEncoder sCryptPasswordEncoder = new SCryptPasswordEncoder();
System.out.println(sCryptPasswordEncoder.encode(&quot;123&quot;));

 //4.Argon2PasswordEncoder !&quot;需要额外引⼊依赖
Argon2PasswordEncoder argon2PasswordEncoder = new Argon2PasswordEncoder();
 System.out.println(argon2PasswordEncoder.encode(&quot;123&quot;));
 }</code></pre><p>使⽤固定密码加密⽅案</p>
<pre><code>@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
 @Bean
 public PasswordEncoder BcryptPasswordEncoder() {
     return new BCryptPasswordEncoder();
 }
 @Bean
public UserDetailsService userDetailsService() {
InMemoryUserDetailsManager inMemoryUserDetailsManager = new InMemoryUserDetailsManager();
inMemoryUserDetailsManager.createUser(User.withUsername(&quot;root&quot;).password(&quot;$2a$10$WGFkRsZC0kzafTKOPcWONeLvNvg2jqd3U09qd5gjJGSHE5b0yoy6a&quot;).roles(&quot;xxx&quot;).build();
     return inMemoryUserDetailsManager;
  }
 }</code></pre><p>使⽤灵活密码加密⽅案 推荐</p>
<pre><code>@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
 @Bean
public UserDetailsService userDetailsService() {
InMemoryUserDetailsManager inMemoryUserDetailsManager = new InMemoryUserDetailsManager();
inMemoryUserDetailsManager.createUser(User.withUsername(&quot;root&quot;).p
 assword(&quot;{bcrypt}$2a$10$WGFkRsZC0kzafTKOPcWONeLvNvg2jqd3U09qd5gjJGSHE5b0yoy
 6a&quot;).roles(&quot;xxx&quot;).build());
     return inMemoryUserDetailsManager;
  }
 }
</code></pre><h1 id="RememberMe"><a href="#RememberMe" class="headerlink" title="RememberMe"></a>RememberMe</h1><p>具体的实现思路就是通过 Cookie 来记录当前⽤户身份。当⽤户登录成功之后，会通过⼀定 算法，将⽤户信息、时间戳等进⾏加密，加密完成后，通过响应头带回前端存储在cookie 中，当浏览器会话过期之后，如果再次访问该⽹站，会⾃动将 Cookie 中的信息发送给服务 器，服务器对 Cookie中的信息进⾏校验分析，进⽽确定出⽤户的身份，Cookie中所保存的 ⽤户信息也是有时效的，例如三天、⼀周等</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>开启记住我</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SecurityConfig</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>

 <span class="token annotation punctuation">@Override</span>
 <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>HttpSecurity http<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
 http<span class="token punctuation">.</span><span class="token function">authorizeRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">mvcMatchers</span><span class="token punctuation">(</span><span class="token string">"/login.html"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">permitAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">anyRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">formLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">rememberMe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//开启记住我功能</span>
  <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">csrf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>RememberMeAuthenticationFilter</p>
<p>当在SecurityConfig配置中开启了”记住我”功能之后,在进⾏认证时如果勾选 了”记住我”选项，此时打开浏览器控制台，分析整个登录过程。⾸先当我们登录时，在登录 请求中多了⼀个 RememberMe 的参数。</p>
<p><img src="/springsecurity/image-20230715210021841.png" alt="image-20230715210021841"></p>
<p>很显然，这个参数就是告诉服务器应该开启 RememberMe功能的。如果⾃定义登录⻚⾯开启  RememberMe 功能应该多加⼊⼀个⼀样的请求参数就可以啦。该请求会被  RememberMeAuthenticationFilter进⾏拦截然后⾃动登录</p>
<p>(1）请求到达过滤器之后，⾸先判断 SecurityContextHolder 中是否有值，没值的 话表示⽤户尚未登录，此时调⽤ autoLogin ⽅法进⾏⾃动登录。</p>
<p> (2）当⾃动登录成功后返回的rememberMeAuth 不为null 时，表示⾃动登录成功， 此时调⽤ authenticate ⽅法对 key 进⾏校验，并且将登录成功的⽤户信息保存到  SecurityContextHolder 对象中，然后调⽤登录成功回调，并发布登录成功事件。 需要注意的是，登录成功的回调并不包含 RememberMeServices 中的  1oginSuccess ⽅法。</p>
<p> (3）如果⾃动登录失败，则调⽤ remenberMeServices.loginFail⽅法处理登录失 败回调。onUnsuccessfulAuthentication 和 onSuccessfulAuthentication  都是该过滤器中定义的空⽅法，并没有任何实现这就是  RememberMeAuthenticationFilter 过滤器所做的事情，成功将RememberMeServices的服务集成进来。</p>
<h2 id="RememberMeServices"><a href="#RememberMeServices" class="headerlink" title="RememberMeServices"></a>RememberMeServices</h2><p>这⾥⼀共定义了三个⽅法：</p>
<ol>
<li>autoLogin ⽅法可以从请求中提取出需要的参数，完成⾃动登录功能。</li>
<li>loginFail ⽅法是⾃动登录失败的回调。</li>
<li><ol start="3">
<li>1oginSuccess ⽅法是⾃动登录成功的回调。</li>
</ol>
</li>
</ol>
<p><img src="/springsecurity/image-20230715210055880.png" alt="image-20230715210055880"></p>
<h2 id="TokenBasedRememberMeServices"><a href="#TokenBasedRememberMeServices" class="headerlink" title="TokenBasedRememberMeServices"></a>TokenBasedRememberMeServices</h2><p>在开启记住我后如果没有加⼊额外配置默认实现就是由TokenBasedRememberMeServices 进⾏的实现。</p>
<p>processAutoLoginCookie ⽅法主要⽤来验证 Cookie 中的令牌信息是否合法：</p>
<p><img src="/springsecurity/image-20230715210234250.png" alt="image-20230715210234250"></p>
<ol>
<li>⾸先判断 cookieTokens ⻓度是否为3，不为3说明格式不对，则直接抛出异常。 </li>
<li>从cookieTokens 数组中提取出第 1项，也就是过期时间，判断令牌是否过期，如果 ⼰经过期，则拋出异常。</li>
<li>根据⽤户名 （cookieTokens 数组的第。项）查询出当前⽤户对象。</li>
<li>调⽤ makeTokenSignature ⽅法⽣成⼀个签名，签名的⽣成过程如下：⾸先将⽤户 名、令牌过期时间、⽤户密码以及 key 组成⼀个宇符串，中间⽤“：”隔开，然后通过  MD5 消息摘要算法对该宇符串进⾏加密，并将加密结果转为⼀个字符串返回。</li>
<li>判断第4 步⽣成的签名和通过 Cookie 传来的签名是否相等（即 cookieTokens 数 组 的第2项），如果相等，表示令牌合法，则直接返回⽤户对象，否则拋出异常。</li>
</ol>
<p><img src="/springsecurity/image-20230715210250060.png" alt="image-20230715210250060"></p>
<p>在这个回调中，⾸先获取⽤户经和密码信息，如果⽤户密码在⽤户登录成功后从successfulAuthentication对象中擦除，则从数据库中重新加载出⽤户密码。</p>
<p>计算出令牌的过期时间，令牌默认有效期是两周。</p>
<p> 根据令牌的过期时间、⽤户名以及⽤户密码，计算出⼀个签名。</p>
<p>调⽤ setCookie ⽅法设置 Cookie， 第⼀个参数是⼀个数组，数组中⼀共包含三 项。⽤户名、过期时间以及签名，在setCookie ⽅法中会将数组转为字符串，并进⾏  Base64编码后响应给前端</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>当⽤户通过⽤户名/密码的形式登录成功后，系统会根据⽤户的⽤户名、密码以及令牌的过期 时间计算出⼀个签名，这个签名使⽤ MD5 消息摘要算法⽣成，是不可逆的。然后再将⽤户 名、令牌过期时间以及签名拼接成⼀个字符串，中间⽤“:” 隔开，对拼接好的字符串进⾏ Base64 编码，然后将编码后的结果返回到前端，也就是我们在浏览器中看到的令牌。当会 话过期之后，访问系统资源时会⾃动携带上Cookie中的令牌，服务端拿到 Cookie中的令牌 后，先进⾏ Bae64解码，解码后分别提取出令牌中的三项数据：接着根据令牌中的数据判断 令牌是否已经过期，如果没有过期，则根据令牌中的⽤户名查询出⽤户信息：接着再计算出 ⼀个签名和令牌中的签名进⾏对⽐，如果⼀致，表示会牌是合法令牌，⾃动登录成功，否则 ⾃动登录失败。</p>
<p><img src="/springsecurity/image-20230715210508749.png" alt="image-20230715210508749"></p>
<p><img src="/springsecurity/image-20230715210545039.png" alt="image-20230715210545039"></p>
<h2 id="内存令牌"><a href="#内存令牌" class="headerlink" title="内存令牌"></a>内存令牌</h2><p>PersistentTokenBasedRememberMeServices</p>
<p><img src="/springsecurity/image-20230715210816451.png" alt="image-20230715210816451"></p>
<ol>
<li>不同于 TokonBasedRemornberMeServices 中的 processAutologinCookie ⽅ 法，这⾥cookieTokens 数组的⻓度为2，第⼀项是series，第⼆项是 token。 </li>
<li>从cookieTokens数组中分到提取出 series 和 token． 然后根据 series 去内存 中查询出⼀个 PersistentRememberMeToken对象。如果查询出来的对象为null，表 示内存中并没有series对应的值，本次⾃动登录失败。如果查询出来的 token 和从  cookieTokens 中解析出来的token不相同，说明⾃动登录会牌已经泄漏（恶意⽤户利 ⽤令牌登录后，内存中的token变了)，此时移除当前⽤户的所有⾃动登录记录并抛出异 常。</li>
<li>根据数据库中查询出来的结果判断令牌是否过期，如果过期就抛出异常。 </li>
<li>⽣成⼀个新的 PersistentRememberMeToken 对象，⽤户名和series 不变， token 重新 ⽣成，date 也使⽤当前时间。newToken ⽣成后，根据 series 去修改内存中的  token 和 date(即每次⾃动登录后都会产⽣新的 token 和 date）</li>
<li>调⽤ addCookie ⽅法添加 Cookie， 在addCookie ⽅法中，会调⽤到我们前⾯所 说的 setCookie ⽅法，但是要注意第⼀个数组参数中只有两项：series 和 token（即返 回到前端的令牌是通过对 series 和 token 进⾏ Base64 编码得到的） </li>
<li>最后将根据⽤户名查询⽤户对象并返回。</li>
</ol>
<h2 id="使用内存中令牌实现"><a href="#使用内存中令牌实现" class="headerlink" title="使用内存中令牌实现"></a>使用内存中令牌实现</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SecurityConfig</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span> 
<span class="token annotation punctuation">@Override</span>
 <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>HttpSecurity http<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
 http<span class="token punctuation">.</span><span class="token function">authorizeRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">anyRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">formLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">rememberMe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//开启记住我功能</span>
  <span class="token punctuation">.</span><span class="token function">rememberMeServices</span><span class="token punctuation">(</span><span class="token function">rememberMeServices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">csrf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 <span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> RememberMeServices <span class="token function">rememberMeServices</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PersistentTokenBasedRememberMeServices</span><span class="token punctuation">(</span>
     <span class="token string">"key"</span><span class="token comment" spellcheck="true">//参数 1: ⾃定义⼀个⽣成令牌 key 默认 UUID  </span>
    <span class="token function">userDetailsService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//参数 2:认证数据源  </span>
    <span class="token keyword">new</span> <span class="token class-name">InMemoryTokenRepositoryImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//参数 3:令牌存储⽅式</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h2><p>配置数据源</p>
<p>配置持久化令牌</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SecurityConfig</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>
 <span class="token annotation punctuation">@Autowired</span>
 <span class="token keyword">private</span> DataSource dataSource<span class="token punctuation">;</span>
 <span class="token annotation punctuation">@Bean</span>
 <span class="token keyword">public</span> PersistentTokenRepository <span class="token function">persistentTokenRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
 JdbcTokenRepositoryImpl jdbcTokenRepository <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JdbcTokenRepositoryImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    jdbcTokenRepository<span class="token punctuation">.</span><span class="token function">setCreateTableOnStartup</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是否自动建表</span>
     jdbcTokenRepository<span class="token punctuation">.</span><span class="token function">setDataSource</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> jdbcTokenRepository<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token annotation punctuation">@Override</span>
 <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>HttpSecurity http<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
 http<span class="token punctuation">.</span><span class="token function">authorizeRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">mvcMatchers</span><span class="token punctuation">(</span><span class="token string">"/login.html"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">permitAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">anyRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">logout</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">rememberMe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!</span>"开启记住我功能
  <span class="token punctuation">.</span><span class="token function">tokenRepository</span><span class="token punctuation">(</span><span class="token function">persistentTokenRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">csrf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>启动项⽬并查看数据库</p>
<p>注意:启动项⽬会⾃动创建⼀个表,⽤来保存记住我的 token 信息</p>
<p><img src="/springsecurity/image-20230715214328977.png" alt="image-20230715214328977"></p>
<h2 id="自定义记住我"><a href="#自定义记住我" class="headerlink" title="自定义记住我"></a>自定义记住我</h2><h3 id="传统-web-开发记住我实现"><a href="#传统-web-开发记住我实现" class="headerlink" title="传统 web 开发记住我实现"></a>传统 web 开发记住我实现</h3><p>传统 web 开发记住我实现  通过源码分析得知必须在认证请求中加⼊参数remember-me值为”true,on,yes,1”其中任 意⼀个才可以完成记住我功能,这个时候修改认证界⾯:</p>
<pre><code>&lt;!DOCTYPE html&gt;
 &lt;html lang=&quot;en&quot;&gt;
 &lt;head&gt;
 &lt;meta charset=&quot;UTF-8&quot;&gt;
 &lt;title&gt;登录!&amp;title&gt;
 !&amp;head&gt;
 &lt;body&gt;
 &lt;h1&gt;⽤户登录!&amp;h1&gt;
 &lt;form method=&quot;post&quot; th:action=&quot;@{/doLogin}&quot;&gt;
    ⽤户名:&lt;input name=&quot;uname&quot; type=&quot;text&quot;/&gt;&lt;br&gt;
    密码:&lt;input name=&quot;passwd&quot; type=&quot;password&quot;/&gt;&lt;br&gt;
    记住我: &lt;input type=&quot;checkbox&quot; name=&quot;remember-me&quot; 
    value=&quot;on|yes|true|1&quot;!&#39;&lt;br&gt;
 &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt;
 &lt;/form&gt;
 &lt;/body&gt;
 &lt;/html&gt;</code></pre><h4 id="配置中开启记住我"><a href="#配置中开启记住我" class="headerlink" title="配置中开启记住我"></a>配置中开启记住我</h4><pre><code>@Configuration
 public class SecurityConfig extends WebSecurityConfigurerAdapter {
 @Override
 protected void configure(HttpSecurity http) throws Exception {
 http.authorizeRequests()
  .....
  .and()
  .rememberMe()//开启记住我
    //.alwaysRemember(true) 总是记住我
  .and()
  .csrf().disable();
  }
 }
</code></pre><h3 id="前后端分离开发记住我实现"><a href="#前后端分离开发记住我实现" class="headerlink" title="前后端分离开发记住我实现"></a>前后端分离开发记住我实现</h3><pre><code>
/**
 * 自定义前后端分离认证 Filter
 */
public class LoginFilter extends UsernamePasswordAuthenticationFilter {

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        System.out.println(&quot;========================================&quot;);
        //1.判断是否是 post 方式请求
        if (!request.getMethod().equals(&quot;POST&quot;)) {
            throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod());
        }
        //2.判断是否是 json 格式请求类型
        if (request.getContentType().equalsIgnoreCase(MediaType.APPLICATION_JSON_VALUE)) {
            //3.从 json 数据中获取用户输入用户名和密码进行认证 {&quot;uname&quot;:&quot;xxx&quot;,&quot;password&quot;:&quot;xxx&quot;,&quot;remember-me&quot;:true}
            try {
                Map&lt;String, String&gt; userInfo = new ObjectMapper().readValue(request.getInputStream(), Map.class);
                String username = userInfo.get(getUsernameParameter());
                String password = userInfo.get(getPasswordParameter());
                String rememberValue = userInfo.get(AbstractRememberMeServices.DEFAULT_PARAMETER);
                if (!ObjectUtils.isEmpty(rememberValue)) {
                    request.setAttribute(AbstractRememberMeServices.DEFAULT_PARAMETER, rememberValue);
                }
                System.out.println(&quot;用户名: &quot; + username + &quot; 密码: &quot; + password + &quot; 是否记住我: &quot; + rememberValue);
                UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);
                setDetails(request, authRequest);
                return this.getAuthenticationManager().authenticate(authRequest);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return super.attemptAuthentication(request, response);
    }
}
</code></pre><h4 id="自定义-RememberMeService"><a href="#自定义-RememberMeService" class="headerlink" title="自定义 RememberMeService"></a>自定义 RememberMeService</h4><pre><code>
/**
 * 自定义记住我 services 实现类
 */
public class MyPersistentTokenBasedRememberMeServices extends PersistentTokenBasedRememberMeServices {


    public MyPersistentTokenBasedRememberMeServices(String key, UserDetailsService userDetailsService, PersistentTokenRepository tokenRepository) {
        super(key, userDetailsService, tokenRepository);
    }


    /**
     * 自定义前后端分离获取 remember-me 方式
     *
     * @param request
     * @param parameter
     * @return
     */
    @Override
    protected boolean rememberMeRequested(HttpServletRequest request, String parameter) {
        String paramValue = request.getAttribute(parameter).toString();
        if (paramValue != null) {
            if (paramValue.equalsIgnoreCase(&quot;true&quot;) || paramValue.equalsIgnoreCase(&quot;on&quot;)
                    || paramValue.equalsIgnoreCase(&quot;yes&quot;) || paramValue.equals(&quot;1&quot;)) {
                return true;
            }
        }
        return false;
    }
}</code></pre><h4 id="配置记住我"><a href="#配置记住我" class="headerlink" title="配置记住我"></a>配置记住我</h4><pre><code>
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {


    @Bean
    public UserDetailsService userDetailsService() {
        InMemoryUserDetailsManager inMemoryUserDetailsManager = new InMemoryUserDetailsManager();
        inMemoryUserDetailsManager.createUser(User.withUsername(&quot;root&quot;).password(&quot;{noop}123&quot;).roles(&quot;admin&quot;).build());
        return inMemoryUserDetailsManager;
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService());
    }

    @Override
    @Bean
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    //自定义 filter 交给工厂管理
    @Bean
    public LoginFilter loginFilter() throws Exception {
        LoginFilter loginFilter = new LoginFilter();
        loginFilter.setFilterProcessesUrl(&quot;/doLogin&quot;);//指定认证 url
        loginFilter.setUsernameParameter(&quot;uname&quot;);//指定接收json 用户名 key
        loginFilter.setPasswordParameter(&quot;passwd&quot;);//指定接收 json 密码 key
        loginFilter.setAuthenticationManager(authenticationManagerBean());
        loginFilter.setRememberMeServices(rememberMeServices()); //设置认证成功时使用自定义rememberMeService
        //认证成功处理
        loginFilter.setAuthenticationSuccessHandler((req, resp, authentication) -&gt; {
            Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;();
            result.put(&quot;msg&quot;, &quot;登录成功&quot;);
            result.put(&quot;用户信息&quot;, authentication.getPrincipal());
            resp.setContentType(&quot;application/json;charset=UTF-8&quot;);
            resp.setStatus(HttpStatus.OK.value());
            String s = new ObjectMapper().writeValueAsString(result);
            resp.getWriter().println(s);
        });
        //认证失败处理
        loginFilter.setAuthenticationFailureHandler((req, resp, ex) -&gt; {
            Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;();
            result.put(&quot;msg&quot;, &quot;登录失败: &quot; + ex.getMessage());
            resp.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
            resp.setContentType(&quot;application/json;charset=UTF-8&quot;);
            String s = new ObjectMapper().writeValueAsString(result);
            resp.getWriter().println(s);
        });
        return loginFilter;
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests()
                .anyRequest().authenticated()//所有请求必须认证
                .and()
                .formLogin()
                .and()
                .rememberMe() //开启记住我功能  cookie 进行实现  1.认证成功保存记住我 cookie 到客户端   2.只有 cookie 写入客户端成功才能实现自动登录功能
                .rememberMeServices(rememberMeServices())  //设置自动登录使用哪个 rememberMeServices
                .and()
                .exceptionHandling()
                .authenticationEntryPoint((req, resp, ex) -&gt; {
                    resp.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);
                    resp.setStatus(HttpStatus.UNAUTHORIZED.value());
                    resp.getWriter().println(&quot;请认证之后再去处理!&quot;);
                })
                .and()
                .logout()
                .logoutRequestMatcher(new OrRequestMatcher(
                        new AntPathRequestMatcher(&quot;/logout&quot;, HttpMethod.DELETE.name()),
                        new AntPathRequestMatcher(&quot;/logout&quot;, HttpMethod.GET.name())
                ))
                .logoutSuccessHandler((req, resp, auth) -&gt; {
                    Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;();
                    result.put(&quot;msg&quot;, &quot;注销成功&quot;);
                    result.put(&quot;用户信息&quot;, auth.getPrincipal());
                    resp.setContentType(&quot;application/json;charset=UTF-8&quot;);
                    resp.setStatus(HttpStatus.OK.value());
                    String s = new ObjectMapper().writeValueAsString(result);
                    resp.getWriter().println(s);
                })
                .and()
                .csrf().disable();


        // at: 用来某个 filter 替换过滤器链中哪个 filter
        // before: 放在过滤器链中哪个 filter 之前
        // after: 放在过滤器链中那个 filter 之后
        http.addFilterAt(loginFilter(), UsernamePasswordAuthenticationFilter.class);
    }


    @Bean
    public RememberMeServices rememberMeServices() {
        return new MyPersistentTokenBasedRememberMeServices(UUID.randomUUID().toString(), userDetailsService(), new InMemoryTokenRepositoryImpl());
    }
}
</code></pre><h3 id="基于redis的-rememberMe-token持久化功能"><a href="#基于redis的-rememberMe-token持久化功能" class="headerlink" title="基于redis的 rememberMe token持久化功能"></a>基于redis的 rememberMe token持久化功能</h3><p>rememberMe认证流程<br>简单来说，认证时首先会经过UsernamePasswordAuthenticationFilter，如果开启了rememberMe，随后会有一个RememberMeAuthenticationFilter进行token认证。该filter调用一个rememberMeServices，该service的autoLogin方法中从request中获取对应的cookie，经过解密分解为一个series和token。之后利用一个tokenRepository获取一个PersistentRememberMeToken对象，该对象包含了基本token、series、username和日期等信息。通过比较取出的PersistentRememberMeToken中的token与request中的token，进行验证。<br>因为spring security已经帮助我们完成许多处理，因此自定义实现redis持久化token，我们只需要实现一点：</p>
<p>一个自定义的tokenRepository，用以持久化token操作。</p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a><strong>实现代码</strong></h4><p>一个实现了<strong>PersistentTokenRepository</strong>的<strong>RedisPersistentRe</strong>类。<br><strong>PersistentTokenRepository</strong>接口主要包括这几个方法：</p>
<pre><code>   void createNewToken(PersistentRememberMeToken var1);
//创建新的token，每次采用密码账登录验证成功后都会执行这个方法。
    void updateToken(String var1, String var2, Date var3);
//更新token，每次新的会话都会更新token。其中var1代表series，var2代表新的token值。
    PersistentRememberMeToken getTokenForSeries(String var1);
//通过series获取PersistentRememberMeToken对象。
    void removeUserTokens(String var1);
//删除对应的token，采用默认的rememberMeServices时，var1是username。
</code></pre><h5 id="RedisPersistentRe类"><a href="#RedisPersistentRe类" class="headerlink" title="RedisPersistentRe类"></a><strong>RedisPersistentRe</strong>类</h5><pre><code>@Component
public class RedisPersistentRe implements PersistentTokenRepository {
    private final static String USERNAME_KEY =&quot;spring:security:rememberMe:USERNAME_KEY:&quot;;
    private final static String SERIES_KEY = &quot;spring:security:rememberMe:SERIES_KEY:&quot;;
    @Autowired
    RedisTemplate redisTemplate;

    @Autowired
    StringRedisTemplate stringRedisTemplate;
    @Override
    public void createNewToken(PersistentRememberMeToken persistentRememberMeToken) {
        String series = persistentRememberMeToken.getSeries();
        String key = generateKey(series,SERIES_KEY);
        String usernameKey = generateKey(persistentRememberMeToken.getUsername(),USERNAME_KEY);
        //用户只要采用账户密码重新登录，那么为了安全就有必要清除之前的token信息。deleteIfPresent方法通过
        //username查找到用户对应的series，然后删除旧的token信息。
        deleteIfPresent(usernameKey);
        HashMap&lt;String,String &gt; hashMap = new HashMap&lt;&gt;();
        hashMap.put(&quot;username&quot;,persistentRememberMeToken.getUsername());
        hashMap.put(&quot;token&quot;,persistentRememberMeToken.getTokenValue());
        hashMap.put(&quot;date&quot;,String.valueOf(persistentRememberMeToken.getDate().getTime()));
        HashOperations&lt;String ,String ,String&gt; hashOperations = redisTemplate.opsForHash();
        hashOperations.putAll(key,hashMap);
        redisTemplate.expire(key,1, TimeUnit.DAYS);//设置token保存期限
        stringRedisTemplate.opsForValue().set(usernameKey,series);
        redisTemplate.expire(usernameKey,1, TimeUnit.DAYS);
    }

    @Override
    public void updateToken(String s, String s1, Date date) {
        String key = generateKey(s,SERIES_KEY);
        if(redisTemplate.hasKey(key))
            redisTemplate.opsForHash().put(key,&quot;token&quot;,s1);
    }

    @Override
    public PersistentRememberMeToken getTokenForSeries(String s) {
        String key = generateKey(s,SERIES_KEY);
        List&lt;String&gt; hashKeys = new ArrayList&lt;&gt;();
        hashKeys.add(&quot;username&quot;);
        hashKeys.add(&quot;token&quot;);
        hashKeys.add(&quot;date&quot;);
        List&lt;String&gt; hashValues = redisTemplate.opsForHash().multiGet(key, hashKeys);
        String username =  hashValues.get(0);
        String tokenValue = hashValues.get(1);
        String date = hashValues.get(2);
        if (null == username || null == tokenValue || null == date) {
            return null;
        }
        Long timestamp = Long.valueOf(date);
        Date time = new Date(timestamp);
        return new PersistentRememberMeToken(username, s, tokenValue, time);
    }

    @Override
    public void removeUserTokens(String s) {
    //rememberMeService实现类中调用这个方法传入的参数是username，因此我们必须通过username查找到
    //对应的series，然后再通过series查找到对应的token信息再删除。
        String key = generateKey(s,USERNAME_KEY);
        deleteIfPresent(key);
    }

    private void deleteIfPresent(String key){
    //删除token时应该同时删除token信息，以及保存了对应的username与series对照数据。
        if(redisTemplate.hasKey(key)){
            String series = generateKey(stringRedisTemplate.opsForValue().get(key),SERIES_KEY);
            if(series!=null &amp;&amp; redisTemplate.hasKey(series)){
                redisTemplate.delete(series);
                redisTemplate.delete(key);
            }
        }
    }
    private String generateKey(String series,String prefix) {
        return prefix + series;
    }
}
</code></pre><p>配置</p>
<pre><code>@Configuration
@EnableWebSecurity
public class ASpringSecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    AUserDetailsService aUserDetailsService;
    @Autowired
    RedisPersistentRe redisPerSisRe;
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers(&quot;/login&quot;).permitAll()
                .anyRequest().authenticated()
                .and()
                .formLogin().permitAll()
                .defaultSuccessUrl(&quot;/success&quot;,true)
                .and()
                .rememberMe()
                .tokenRepository(redisPerSisRe)
                .rememberMeCookieName(&quot;mytoken&quot;)
                .userDetailsService(aUserDetailsService)
                .and()
                .csrf().disable()
                ;
    }
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(aUserDetailsService).passwordEncoder(new BCryptPasswordEncoder());
    }


}
</code></pre><h1 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>当浏览器调⽤登录接⼝登录成功后，服务端会和浏览器之间建⽴⼀个会话 (Session) 浏览 器在每次发送请求时都会携带⼀个 Sessionld，服务端则根据这个 Sessionld 来判断⽤ 户身份。当浏览器关闭后，服务端的 Session 并不会⾃动销毁，需要开发者⼿动在服务端 调⽤ Session销毁⽅法，或者等 Session 过期时间到了⾃动销毁。在Spring  Security 中，与HttpSession相关的功能由 SessionManagementFiter 和 SessionAutheaticationStrateey 接⼝来处理，SessionManagomentFilter 过滤 器将 Session 相关操作委托给 SessionAuthenticationStrateey 接⼝去完成。</p>
<h2 id="会话并发管理"><a href="#会话并发管理" class="headerlink" title="会话并发管理"></a>会话并发管理</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>会话并发管理就是指在当前系统中，同⼀个⽤户可以同时创建多少个会话，如果⼀个设备对 应⼀个会话，那么也可以简单理解为同⼀个⽤户可以同时在多少台设备上进⾏登录。默认情 况下，同⼀⽤户在多少台设备上登录并没有限制，不过开发者可以在 Spring Security  中对此进⾏配置。</p>
<h2 id="开启会话管理"><a href="#开启会话管理" class="headerlink" title="开启会话管理"></a>开启会话管理</h2><pre><code>@Configuration
 public class SecurityConfig extends WebSecurityConfigurerAdapter {

 @Override
 protected void configure(HttpSecurity http) throws Exception {
 http.authorizeRequests()
  .anyRequest().authenticated()
  .and()
  .formLogin()
  .and()
  .rememberMe()
  .and()
  .csrf().disable()
  .sessionManagement()  //开启会话管理
  .maximumSessions(1);  //设置会话并发数为 1
  }
 @Bean
 public HttpSessionEventPublisher httpSessionEventPublisher() {
 return new HttpSessionEventPublisher();
  }
 }</code></pre><ol>
<li>sessionManagement() ⽤来开启会话管理、maximumSessions 指定会话的并发数 为 1。 </li>
<li>HttpSessionEventPublisher 提供⼀⼀个Htp SessionEvenePubishor-实例。 Spring Security中通过⼀个 Map 集合来集护当前的 Http Session 记录，进⽽ 实现会话的并发管理。当⽤户登录成功时，就向集合中添加⼀条Http Session 记录； 当会话销毁时，就从集合中移除⼀条 Httpsession 记录。 HtpSesionEvenPublisher 实现了 Fttp SessionListener 接⼝，可以监听到  HtpSession 的创建和销毀事件，并将 Fltp Session 的创建/销毁事件发布出去， 这样，当有 HttpSession 销毀时，Spring Security 就可以感知到该事件了。</li>
</ol>
<h2 id="测试会话管理"><a href="#测试会话管理" class="headerlink" title="测试会话管理"></a>测试会话管理</h2><p>配置完成后，启动项⽬。这次测试我们需要两个浏览器，如果使⽤了 Chrome 浏览器，可以 使⽤ Chrome 浏览器中的多⽤户⽅式（相当于两个浏览器）先在第⼀个浏览器中输⼊ http :!”localhost:8080，此时会⾃动跳转到登录⻚⾯，完成登录操作，就可以访问到数据 了；接下来在第⼆个浏览器中也输⼊ http:!”localhost:8080，也需要登录， 完成登录操作；当第⼆个浏览器登录成功后，再回到第⼀个浏览器，刷新⻚⾯。结果出现下 图：</p>
<p><img src="/springsecurity/image-20230715235954166.png" alt="image-20230715235954166"></p>
<h2 id="会话失效处理"><a href="#会话失效处理" class="headerlink" title="会话失效处理"></a>会话失效处理</h2><h3 id="传统-web-开发处理"><a href="#传统-web-开发处理" class="headerlink" title="传统 web 开发处理"></a>传统 web 开发处理</h3><pre><code>protected void configure(HttpSecurity http) throws Exception {
 http.authorizeRequests()
  .anyRequest().authenticated()
  .and()
  ....
  .sessionManagement()  //开启会话管理
  .maximumSessions(1)  //允许同⼀个⽤户只允许创建⼀个会话
  .expiredUrl(&quot;/login&quot;);//会话过期处理
}</code></pre><h3 id="前后端分离开发处理"><a href="#前后端分离开发处理" class="headerlink" title="前后端分离开发处理"></a>前后端分离开发处理</h3><pre><code>@Override
 protected void configure(HttpSecurity http) throws Exception {
 http.authorizeRequests()
  .anyRequest().authenticated()
  .....
  .sessionManagement()  //开启会话管理
  .maximumSessions(1)  //允许同⼀个⽤户只允许创建⼀个会话
//.expiredUrl(&quot;/login&quot;)//会话过期处理  传统 web 开发
  .expiredSessionStrategy(event -&gt; {
     HttpServletResponse response = event.getResponse();
     response.setContentType(&quot;application/json;charset=UTF-8&quot;);
     Map&lt;String, Object&gt; result = new HashMap!)();
     result.put(&quot;status&quot;, 500);
     result.put(&quot;msg&quot;, &quot;当前会话已经失效,请重新登录!&quot;);
     String s = new ObjectMapper().writeValueAsString(result);
     response.setContentType(&quot;application/json;charset=UTF-8&quot;);
     response.getWriter().println(s);
     response.flushBuffer();
  });//前后端分离开发处理
}
</code></pre><h3 id="禁⽌再次登录"><a href="#禁⽌再次登录" class="headerlink" title="禁⽌再次登录"></a>禁⽌再次登录</h3><p>默认的效果是⼀种被 “挤下线”的效果，后⾯登录的⽤户会把前⾯登录的⽤户 “挤下线”。还 有⼀种是禁⽌后来者登录，即⼀旦当前⽤户登录成功，后来者⽆法再次使⽤相同的⽤户登 录，直到当前⽤户主动注销登录，配置如下</p>
<pre><code>@Override
 protected void configure(HttpSecurity http) throws Exception {
 http.authorizeRequests()
  .anyRequest().authenticated()
  .and()
  ....
  .sessionManagement()  //开启会话管理
  .maximumSessions(1)  //允许同⼀个⽤户只允许创建⼀个会话
//.expiredUrl(&quot;/login&quot;)!&quot;会话过期处理  传统 web 开发
  .expiredSessionStrategy(event !. {
 HttpServletResponse response = event.getResponse();
 response.setContentType(&quot;application/json;charset=UTF-8&quot;);
 Map&lt;String, Object&gt; result = new HashMap!)();
 result.put(&quot;status&quot;, 500);
 result.put(&quot;msg&quot;, &quot;当前会话已经失效,请重新登录!&quot;);
 String s = new ObjectMapper().writeValueAsString(result);
 response.getWriter().println(s);
 response.flushBuffer();
  })//前后端分离开发处理
  .maxSessionsPreventsLogin(true);//登录之后禁⽌再次登录
  //用于设置当用户达到最大登录数时，是否阻止新的登录请求。如果为true，表示当用户已经在其他设备或浏览器登录时，不允许再次登录，返回一个错误信息。如果为false，表示当用户再次登录时，踢出之前的登录会话，让新的登录会话生效。
}</code></pre><h3 id="会话共享"><a href="#会话共享" class="headerlink" title="会话共享"></a>会话共享</h3><p>前⾯所讲的会话管理都是单机上的会话管理，如果当前是集群环境，前⾯所讲的会话管 理⽅案就会失效。此时可以利⽤ spring-session 结合 redis 实现 session 共享。</p>
<p>引⼊依赖</p>
<pre><code>&lt;dependency&gt;
 &lt;groupId&gt;org.springframework.boot!&amp;groupId&gt;
 &lt;artifactId&gt;spring-boot-starter-data-redis!&amp;artifactId&gt;
 !&amp;dependency&gt;
 &lt;dependency&gt;
 &lt;groupId&gt;org.springframework.session!&amp;groupId&gt;
 &lt;artifactId&gt;spring-session-data-redis!&amp;artifactId&gt;
 !&amp;dependency&gt;</code></pre><p>编写配置</p>
<pre><code>## Session 存储方式
spring.session.store-type=redis
## Session 过期时间，默认单位为 s
server.servlet.session.timeout=600
## Session 存储到 Redis 键的前缀
spring.session.redis.namespace=test:spring:session
spring.redis.host=localhost
spring.redis.port=6379</code></pre><p>默认情况下，Session 默认使用HttpSession 序列化方式，这种值看起来不够直观。可以将其修改成 json 序列化方式，存储到 redis 中。</p>
<pre><code>@Configuration
public class HttpSessionConfig implements BeanClassLoaderAware {


    private ClassLoader loader;

    @Bean
    public RedisSerializer&lt;Object&gt; springSessionDefaultRedisSerializer() {
        return new GenericJackson2JsonRedisSerializer(objectMapper());
    }

    /**
     * Customized {@link ObjectMapper} to add mix-in for class that doesn&#39;t have default
     * constructors
     *
     * @return the {@link ObjectMapper} to use
     */
    private ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModules(SecurityJackson2Modules.getModules(this.loader));
        return mapper;
    }


    @Override
    public void setBeanClassLoader(ClassLoader classLoader) {
        this.loader = classLoader;
    }
}
</code></pre><pre><code>
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {


    private final FindByIndexNameSessionRepository findByIndexNameSessionRepository;

    @Autowired
    public SecurityConfig(FindByIndexNameSessionRepository findByIndexNameSessionRepository) {
        this.findByIndexNameSessionRepository = findByIndexNameSessionRepository;
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests()
                .anyRequest().authenticated()
                .and()
                .formLogin()
                .and()
                .logout()
                .and()
                .csrf().disable()
                .sessionManagement()//开启会话管理
                .maximumSessions(1)//允许会话最大并发只能一个客户端
                //.expiredUrl(&quot;/login&quot;);//传统架构处理方案: 当用户的挤下线之后跳转路径
                .expiredSessionStrategy(event -&gt; { //前后端分离架构处理分案
                    HttpServletResponse response = event.getResponse();
                    Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();
                    result.put(&quot;status&quot;, 500);
                    result.put(&quot;msg&quot;, &quot;当前会话已经失效,请重新登录!&quot;);
                    String s = new ObjectMapper().writeValueAsString(result);
                    response.setContentType(&quot;application/json;charset=UTF-8&quot;);
                    response.getWriter().println(s);
                    response.flushBuffer();
                })
                .sessionRegistry(sessionRegistry()) //将 session 交给谁管理
                .maxSessionsPreventsLogin(true); //一旦登录 禁止再次登录
    }


    //创建 session 同步到 redis 中方案
    @Bean
    public SpringSessionBackedSessionRegistry sessionRegistry() {
        return new SpringSessionBackedSessionRegistry(findByIndexNameSessionRepository);
    }

    /*@Bean
    public HttpSessionEventPublisher httpSessionEventPublisher() {
        return new HttpSessionEventPublisher();
    }*/
}</code></pre><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>Spring Security 异常体系 </p>
<p>⾃定义异常配置</p>
<h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p>Spring Security 中异常主要分为两⼤类: </p>
<p>AuthenticationException:  认证异常</p>
<p> AccessDeniedException:     授权异常 </p>
<p><code>AuthenticationException</code> 是在用户认证的时候出现错误时抛出的异常</p>
<p>其中认证所涉及异常类型⽐较多，默认提供的异常类型如下</p>
<p><img src="/springsecurity/image-20230716124735230.png" alt="image-20230716124735230"></p>
<p>相⽐于认证异常，权限异常类就要少了很多，默认提供的权限异常如下：</p>
<p><img src="/springsecurity/image-20230716124756429.png" alt="image-20230716124756429"></p>
<p>在实际项⽬开发中，如果默认提供异常⽆法满⾜需求时，就需要根据实际需要来⾃定义异常 类。</p>
<h2 id="自定义异常处理配置"><a href="#自定义异常处理配置" class="headerlink" title="自定义异常处理配置"></a>自定义异常处理配置</h2><p>方式一</p>
<pre><code>@Configuration
 public class SecurityConfig extends WebSecurityConfigurerAdapter {
 @Override
 protected void configure(HttpSecurity http) throws Exception {
     http.authorizeRequests().anyRequest()
      .authenticated()
      .and()
      .exceptionHandling()//异常处理
      .authenticationEntryPoint((request, response, e)-&gt; {
     response.setContentType(&quot;application/json;charset=UTF-8&quot;);
     response.setStatus(HttpStatus.UNAUTHORIZED.value());
     response.getWriter().write(&quot;尚未认证，请进⾏认证操作！&quot;);
  })
      .accessDeniedHandler((request, response, e) -&gt; {
     response.setContentType(&quot;application/json;charset=UTF-8&quot;);
     response.setStatus(HttpStatus.FORBIDDEN.value());
     response.getWriter().write(&quot;⽆权访问!&quot;);
  });
  }
 }</code></pre><p>方式二</p>
<h3 id="实现AuthenticationEntryPoint"><a href="#实现AuthenticationEntryPoint" class="headerlink" title="实现AuthenticationEntryPoint"></a>实现AuthenticationEntryPoint</h3><p>当用户请求一个需要身份验证的资源时，如果用户没有登录，系统会根据配置的AuthenticationEntryPoint，引导用户到特定的登录页面或者跳转到其他相关的认证流程</p>
<pre class="line-numbers language-text"><code class="language-text">public class SimpleAuthenticationEntryPoint implements AuthenticationEntryPoint {
     @Override
     public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {

         //todo your business
         HashMap<String, String> map = new HashMap<>(2);
         map.put("uri", request.getRequestURI());
         map.put("msg", "认证失败");
         response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
         response.setCharacterEncoding("utf-8");
         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
         ObjectMapper objectMapper = new ObjectMapper();
         String resBody = objectMapper.writeValueAsString(map);
         PrintWriter printWriter = response.getWriter();
         printWriter.print(resBody);
         printWriter.flush();
         printWriter.close();
     }
 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="实现-AccessDeniedHandler"><a href="#实现-AccessDeniedHandler" class="headerlink" title="实现 AccessDeniedHandler"></a>实现 AccessDeniedHandler</h3><p>用户已经登录了，但是访问了其自身没有权限的资源时被调用的</p>
<pre><code>public class SimpleAccessDeniedHandler implements AccessDeniedHandler {
     @Override
     public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {
         //todo your business
         HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(2);
         map.put(&quot;uri&quot;, request.getRequestURI());
         map.put(&quot;msg&quot;, &quot;认证失败&quot;);
         response.setStatus(HttpServletResponse.SC_FORBIDDEN);
         response.setCharacterEncoding(&quot;utf-8&quot;);
         response.setContentType(MediaType.APPLICATION_JSON_VALUE);
         ObjectMapper objectMapper = new ObjectMapper();
         String resBody = objectMapper.writeValueAsString(map);
         PrintWriter printWriter = response.getWriter();
         printWriter.print(resBody);
         printWriter.flush();
         printWriter.close();
     }
 }</code></pre><h3 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h3><pre><code>http.exceptionHandling().accessDeniedHandler(newSimpleAccessDeniedHandler()).authenticationEntryPoint(new SimpleAuthenticationEntryPoint())</code></pre><h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>身份认证，就是判断⼀个⽤户是否为合法⽤户的处理过程。Spring Security 中⽀持多种 不同⽅式的认证，但是⽆论开发者使⽤那种⽅式认证，都不会影响授权功能使⽤。因为  Spring Security 很好做到了认证和授权解耦。</p>
<h3 id="授权-1"><a href="#授权-1" class="headerlink" title="授权"></a>授权</h3><p>授权，即访问控制，控制谁能访问哪些资源。简单的理解授权就是根据系统提前设置好的规 则，给⽤户分配可以访问某⼀个资源的权限，⽤户根据⾃⼰所具有权限，去执⾏相应操作。</p>
<h2 id="授权核心概念"><a href="#授权核心概念" class="headerlink" title="授权核心概念"></a>授权核心概念</h2><p>认证成功之后会将当前登录⽤户信息保存到  Authentication 对象中，Authentication 对象中有⼀个getAuthorities() ⽅ 法，⽤来返回当前登录⽤户具备的权限信息，也就是当前⽤户具有权限信息。该⽅法的返回值为 Collection，当需要进⾏权限判断时，就回根据集合返回权限信息调⽤相应⽅法进⾏判断。</p>
<p>对于授权可以是基于⻆⾊权限管理和基于资源权限管理 ，从设计层⾯上来说，⻆⾊ 和权限是两个完全不同的东⻄：权限是⼀些具体操作，⻆⾊则是某些权限集合。如： READ_BOOK 和 ROLE_ADMIN 是完全不同的。</p>
<p>因此⾄于返回值是什么取决于你的业务设计 情况： </p>
<p>基于⻆⾊权限设计就是: ⽤户-&gt;⻆⾊-&gt;资源 三者关系 返回就是⽤户的⻆⾊  </p>
<p>基于资源权限设计就是: ⽤户-&gt;权限-&gt;资源 三者关系 返回就是⽤户的权限</p>
<p>基于⻆⾊和资源权限设计就是: ⽤户-&gt;⻆⾊-&gt;权限-&gt;资源 返回统称为⽤户的权限</p>
<p>为什么可以统称为权限，因为从代码层⾯⻆⾊和权限没有太⼤不同都是权限，特别是在  Spring Security 中，⻆⾊和权限处理⽅式基本上都是⼀样的。唯⼀区别  SpringSecurity 在很多时候会⾃动给⻆⾊添加⼀个ROLE_前缀，⽽权限则不会⾃动添 加</p>
<h2 id="权限管理策略"><a href="#权限管理策略" class="headerlink" title="权限管理策略"></a>权限管理策略</h2><p>Spring Security 中提供的权限管理策略主要有两种类型: </p>
<ul>
<li><p>基于过滤器(URL)的权限管理 (FilterSecurityInterceptor) 基于过滤器的权限管理主要是⽤来拦截 HTTP 请求，拦截下来之后，根据 HTTP  请求地址进⾏权限校验。</p>
</li>
<li><p>基于 AOP (⽅法)的权限管理   (MethodSecurityInterceptor) 基于 AOP 权限管理主要是⽤来处理⽅法级别的权限问题。当需要调⽤某⼀个⽅法 时，通过 AOP 将操作拦截下来，然后判断⽤户是否具备相关的权限</p>
</li>
</ul>
<h2 id="基于-URL-权限管理"><a href="#基于-URL-权限管理" class="headerlink" title="基于 URL 权限管理"></a>基于 URL 权限管理</h2><h3 id="开发-controller"><a href="#开发-controller" class="headerlink" title="开发 controller"></a>开发 controller</h3><pre><code>@RestController
 public class DemoController {
 @GetMapping(&quot;/admin&quot;)
 public String admin() {
 return &quot;admin ok&quot;;
  }
 @GetMapping(&quot;/user&quot;)
 public String user() {
 return &quot;user ok&quot;;
  }
 @GetMapping(&quot;/getInfo&quot;)
 public String getInfo() {
 return &quot;info ok&quot;;
  }
 }
</code></pre><h3 id="配置授权"><a href="#配置授权" class="headerlink" title="配置授权"></a>配置授权</h3><pre><code>@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true,jsr250Enabled = true)
public class SecurityConfig  extends WebSecurityConfigurerAdapter {


    //创建内存数据源
    @Bean
    public UserDetailsService userDetailsService() {
        InMemoryUserDetailsManager inMemoryUserDetailsManager = new InMemoryUserDetailsManager();
        inMemoryUserDetailsManager.createUser(User.withUsername(&quot;root&quot;).password(&quot;{noop}123&quot;).roles(&quot;ADMIN&quot;,&quot;USER&quot;).build());
        inMemoryUserDetailsManager.createUser(User.withUsername(&quot;lisi&quot;).password(&quot;{noop}123&quot;).roles(&quot;USER&quot;).build());
        inMemoryUserDetailsManager.createUser(User.withUsername(&quot;win7&quot;).password(&quot;{noop}123&quot;).authorities(&quot;READ_INFO&quot;).build());
        return inMemoryUserDetailsManager;
    }

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService());
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .mvcMatchers(HttpMethod.GET,&quot;/admin&quot;).hasRole(&quot;ADMIN&quot;)  //具有 admin 角色   强大 通用: /admin /admin/  /admin.html
                .mvcMatchers(&quot;/user&quot;).hasRole(&quot;USER&quot;)    //具有 user 角色
                .mvcMatchers(&quot;/getInfo&quot;).hasAuthority(&quot;READ_INFO&quot;) //READ_INFO 权限
                .antMatchers(HttpMethod.GET,&quot;/admin&quot;).hasRole(&quot;ADMIN&quot;)
                //.regexMatchers().hasRole()  //注意: 好处 支持正则表达
                .anyRequest().authenticated()
                .and().formLogin()
                .and().csrf().disable();
    }
}</code></pre><h3 id="权限表达式"><a href="#权限表达式" class="headerlink" title="权限表达式"></a>权限表达式</h3><p><img src="/springsecurity/image-20230716164802482.png" alt="image-20230716164802482"></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>hasAuthority(String authority)</td>
<td>当前⽤户是否具备指定权限</td>
</tr>
<tr>
<td>hasAnyAuthority(String…authorities)</td>
<td>当前⽤户是否具备指定权限中任意⼀</td>
</tr>
<tr>
<td>hasRole(String role)</td>
<td>当前⽤户是否具备指定⻆⾊</td>
</tr>
<tr>
<td>hasAnyRole(String … roles)</td>
<td>当前⽤户是否具备指定⻆⾊中任意 ⼀个</td>
</tr>
<tr>
<td>permitAll();</td>
<td>放⾏所有请求/调⽤</td>
</tr>
<tr>
<td>denyAll();</td>
<td>拒绝所有请求/调⽤</td>
</tr>
<tr>
<td>isAnonymous();</td>
<td>当前⽤户是否是⼀个匿名⽤户</td>
</tr>
<tr>
<td>isAuthenticated();</td>
<td>当前⽤户是否已经认证成功</td>
</tr>
<tr>
<td>isRememberMe();</td>
<td>当前⽤户是否通过 Remember-Me ⾃动登录</td>
</tr>
<tr>
<td>isFullyAuthenticated();</td>
<td>当前⽤户是否既不是匿名⽤户⼜不 是通过 Remember-Me ⾃动登录的</td>
</tr>
<tr>
<td>hasPermission(Object targetId, Object permission);</td>
<td>当前⽤户是否具备指定⽬标的指定 权限信息</td>
</tr>
<tr>
<td>hasPermission(Object targetId, String targetType, Object permission);</td>
<td>当前⽤户是否具备指定⽬标的指定 权限信息</td>
</tr>
</tbody></table>
<p>antMatcher和mvcMatcher区别</p>
<p><code>antMatcher(String antPattern)</code> - 允许将 <code>HttpSecurity</code> 配置为仅在匹配提供的 ant 模式时调用。</p>
<p><code>mvcMatcher(String mvcPattern)</code> - 允许将 <code>HttpSecurity</code> 配置为仅在匹配提供的 Spring MVC 模式时调用。</p>
<p>通常<code>mvcMatcher</code> 比<code>antMatcher</code> 更安全。举个例子：</p>
<ul>
<li><strong><code>antMatchers(&quot;/secured&quot;)</code></strong> 仅匹配<em>精确</em> <code>/secured</code> URL</li>
<li><strong><code>mvcMatchers(&quot;/secured&quot;)</code></strong> 匹配 <code>/secured</code> 以及 <code>/secured/</code>、<code>/secured.html</code>、<code>/secured.xyz</code></li>
</ul>
<p>因此更通用，也可以处理一些可能的配置错误。</p>
<p><code>mvcMatcher</code> 使用 Spring MVC 用于匹配的相同规则（使用 <code>@RequestMapping</code> 注释时）。</p>
<h2 id="基于-方法-权限管理"><a href="#基于-方法-权限管理" class="headerlink" title="基于 方法 权限管理"></a>基于 方法 权限管理</h2><p>基于⽅法的权限管理主要是通过 A0P 来实现的，Spring Security 中通过  MethodSecurityInterceptor 来提供相关的实现。不同在于  FilterSecurityInterceptor 只是在请求之前进⾏前置处理， MethodSecurityInterceptor 除了前置处理之外还可以进⾏后置处理。前置处理就是在 请求之前判断是否具备相应的权限，后置处理则是对⽅法的执⾏结果进⾏⼆次过滤。前置处 理和后置处理分别对应了不同的实现类。</p>
<h3 id="EnableGlobalMethodSecurity"><a href="#EnableGlobalMethodSecurity" class="headerlink" title="@EnableGlobalMethodSecurity"></a>@EnableGlobalMethodSecurity</h3><pre><code>@Configuration
 @EnableGlobalMethodSecurity(prePostEnabled=true,securedEnabled=true, jsr250Enabled=true)
 public class SecurityConfig extends WebsecurityConfigurerAdapter{}</code></pre><ul>
<li><p>perPostEnabled: 开启 Spring Security 提供的四个权限注解， @PostAuthorize、@PostFilter、@PreAuthorize 以及@PreFilter。 </p>
</li>
<li><p>securedEnabled: 开启 Spring Security 提供的 @Secured 注解⽀持，该注解 不⽀持权限表达式</p>
</li>
<li><p>jsr250Enabled: 开启 JSR-250 提供的注解，主要是@DenyAll、@PermitAll、 @RolesAll 同样这些注解也不⽀持权限表达式</p>
</li>
</ul>
<p>以上注解含义如下:</p>
<p>@PostAuthorize： 在⽬前标⽅法执⾏之后进⾏权限校验。</p>
<p>@PostFiter： 在⽬标⽅法执⾏之后对⽅法的返回结果进⾏过滤。</p>
<p>@PreAuthorize：在⽬标⽅法执⾏之前进⾏权限校验。</p>
<p>@PreFiter：在⽬前标⽅法执⾏之前对⽅法参数进⾏过滤。</p>
<p> @Secured：访问⽬标⽅法必须具各相应的⻆⾊。-</p>
<p>@DenyAll：拒绝所有访问。-</p>
<p>@PermitAll：允许所有访问。-</p>
<p>@RolesAllowed：访问⽬标⽅法必须具备相应</p>
<p>这些基于⽅法的权限管理相关的注解，⼀般来说只要设置 prePostEnabled=true 就够⽤ 了。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>开启注解使⽤</p>
<pre><code>@Configuration
 @EnableGlobalMethodSecurity(prePostEnabled=true,securedEnabled=tru
 e, jsr250Enabled=true)
 public class SecurityConfig extends WebsecurityConfigurerAdapter{}</code></pre><p>使⽤注解</p>
<pre><code>
@RestController
@RequestMapping(&quot;/hello&quot;)
public class AuthorizeMethodController {



    //@PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)  and authentication.name ==&#39;win7&#39;&quot;)
    @PreAuthorize(&quot;hasAuthority(&#39;READ_INFO&#39;)&quot;)
    @GetMapping
    public String hello() {
        return &quot;hello&quot;;
    }

    @PreAuthorize(&quot;authentication.name==#name&quot;)
    @GetMapping(&quot;/name&quot;)
    public String hello(String name) {
        return &quot;hello:&quot; + name;
    }

    @PreFilter(value = &quot;filterObject.id%2!=0&quot;,filterTarget = &quot;users&quot;) //filterTarget 必须是 数组  集合类型
    @PostMapping(&quot;/users&quot;)
    public void addUsers(@RequestBody List&lt;User&gt; users) {
        System.out.println(&quot;users = &quot; + users);
    }

    @PostAuthorize(&quot;returnObject.id==1&quot;)
    @GetMapping(&quot;/userId&quot;)
    public User getUserById(Integer id) {
        return new User(id, &quot;blr&quot;);
    }

    @PostFilter(&quot;filterObject.id%2==0&quot;)//用来对方法返回值进行过滤
    @GetMapping(&quot;/lists&quot;)
    public List&lt;User&gt; getAll() {
        List&lt;User&gt; users = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 10; i++) {
            users.add(new User(i, &quot;blr:&quot; + i));
        }
        return users;
    }



    @Secured({&quot;ROLE_USER&quot;}) //只能判断角色
    @GetMapping(&quot;/secured&quot;)
    public User getUserByUsername() {
        return new User(99, &quot;secured&quot;);
    }

    @Secured({&quot;ROLE_ADMIN&quot;,&quot;ROLE_USER&quot;}) //具有其中一个即可
    @GetMapping(&quot;/username&quot;)
    public User getUserByUsername2(String username) {
        return new User(99, username);
    }


    @PermitAll
    @GetMapping(&quot;/permitAll&quot;)
    public String permitAll() {
        return &quot;PermitAll&quot;;
    }

    @DenyAll
    @GetMapping(&quot;/denyAll&quot;)
    public String denyAll() {
        return &quot;DenyAll&quot;;
    }

    @RolesAllowed({&quot;ROLE_ADMIN&quot;,&quot;ROLE_USER&quot;}) //具有其中一个角色即可
    @GetMapping(&quot;/rolesAllowed&quot;)
    public String rolesAllowed() {
        return &quot;RolesAllowed&quot;;
    }
}
</code></pre><h2 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h2><p><img src="/springsecurity/image-20230716184716433.png" alt="image-20230716184716433"></p>
<ul>
<li><p>ConfigAttribute 在 Spring Security 中，⽤户请求⼀个资源(通常是⼀个接⼝ 或者⼀个 Java ⽅法)需要的⻆⾊会被封装成⼀个 ConfigAttribute 对象，在  ConfigAttribute 中只有⼀个 getAttribute⽅法，该⽅法返回⼀个 String 字符 串，就是⻆⾊的名称。⼀般来说，⻆⾊名称都带有⼀个 ROLE_ 前缀，投票器  AccessDecisionVoter 所做的事情，其实就是⽐较⽤户所具各的⻆⾊和请求某个资源 所需的 ConfigAtuibute 之间的关系。</p>
</li>
<li><p>AccesDecisionVoter 和 AccessDecisionManager 都有众多的实现类，在  AccessDecisionManager 中会换个遍历 AccessDecisionVoter，进⽽决定是否允 许⽤户访问，因⽽ AaccesDecisionVoter 和 AccessDecisionManager 两者的 关系类似于 AuthenticationProvider 和 ProviderManager 的关系。</p>
</li>
</ul>
<h2 id="自定义动态权限管理"><a href="#自定义动态权限管理" class="headerlink" title="自定义动态权限管理"></a>自定义动态权限管理</h2><p>⽤户&lt;–&gt;中间表&lt;–&gt; ⻆⾊ &lt;–&gt;中间表&lt;–&gt;菜单</p>
<p>库表设计</p>
<pre><code>SET NAMES utf8mb4;
 SET FOREIGN_KEY_CHECKS = 0;
-- ---------------------------
-- Table structure for menu
 -----------------------------
DROP TABLE IF EXISTS `menu`;
 CREATE TABLE `menu` (
 `id` int(11) NOT NULL AUTO_INCREMENT,
 `pattern` varchar(128) DEFAULT NULL,
 PRIMARY KEY (`id`)
 ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
-- ---------------------------
-- Records of menu
-- ---------------------------
BEGIN;
 INSERT INTO `menu` VALUES (1, &#39;/admin!!*&#39;);
 INSERT INTO `menu` VALUES (2, &#39;/user!!*&#39;);
 INSERT INTO `menu` VALUES (3, &#39;/guest!!*&#39;);
 COMMIT;
-- ---------------------------
-- Table structure for menu_role
-- ---------------------------
DROP TABLE IF EXISTS `menu_role`;
 CREATE TABLE `menu_role` (
 `id` int(11) NOT NULL AUTO_INCREMENT,
 `mid` int(11) DEFAULT NULL,
 `rid` int(11) DEFAULT NULL,
 PRIMARY KEY (`id`),
 KEY `mid` (`mid`),
 KEY `rid` (`rid`),
 CONSTRAINT `menu_role_ibfk_1` FOREIGN KEY (`mid`) REFERENCES 
`menu` (`id`),
 CONSTRAINT `menu_role_ibfk_2` FOREIGN KEY (`rid`) REFERENCES 
`role` (`id`)
 ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
-- ---------------------------
-- Records of menu_role
-- ---------------------------
BEGIN;
 INSERT INTO `menu_role` VALUES (1, 1, 1);
 INSERT INTO `menu_role` VALUES (2, 2, 2);
 INSERT INTO `menu_role` VALUES (3, 3, 3);
 INSERT INTO `menu_role` VALUES (4, 3, 2);
 COMMIT;
 -- ---------------------------
 -- Table structure for role
 -- ---------------------------
DROP TABLE IF EXISTS `role`;
 CREATE TABLE `role` (
 `id` int(11) NOT NULL AUTO_INCREMENT,
 `name` varchar(32) DEFAULT NULL,
 `nameZh` varchar(32) DEFAULT NULL,
 PRIMARY KEY (`id`)
 ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
 -- ---------------------------
 -- Records of role
 -- ---------------------------
BEGIN;
 INSERT INTO `role` VALUES (1, &#39;ROLE_ADMIN&#39;, &#39;系统管理员&#39;);
 INSERT INTO `role` VALUES (2, &#39;ROLE_USER&#39;, &#39;普通⽤户&#39;);
 INSERT INTO `role` VALUES (3, &#39;ROLE_GUEST&#39;, &#39;游客&#39;);
 COMMIT;
 -- ---------------------------
 -- Table structure for user
 -- ---------------------------
DROP TABLE IF EXISTS `user`;
 CREATE TABLE `user` (
 `id` int(11) NOT NULL AUTO_INCREMENT,
 `username` varchar(32) DEFAULT NULL,
 `password` varchar(255) DEFAULT NULL,
 `enabled` tinyint(1) DEFAULT NULL,
 `locked` tinyint(1) DEFAULT NULL,
PRIMARY KEY (`id`)
 ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
-- ---------------------------
-- Records of user
-- ---------------------------
BEGIN;
 INSERT INTO `user` VALUES (1, &#39;admin&#39;, &#39;{noop}123&#39;, 1, 0);
 INSERT INTO `user` VALUES (2, &#39;user&#39;, &#39;{noop}123&#39;, 1, 0);
 INSERT INTO `user` VALUES (3, &#39;blr&#39;, &#39;{noop}123&#39;, 1, 0);
 COMMIT;
-- ---------------------------
-- Table structure for user_role
-- ---------------------------
DROP TABLE IF EXISTS `user_role`;
 CREATE TABLE `user_role` (
 `id` int(11) NOT NULL AUTO_INCREMENT,
 `uid` int(11) DEFAULT NULL,
 `rid` int(11) DEFAULT NULL,
 PRIMARY KEY (`id`),
 KEY `uid` (`uid`),
 KEY `rid` (`rid`),
 CONSTRAINT `user_role_ibfk_1` FOREIGN KEY (`uid`) REFERENCES 
`user` (`id`),
 CONSTRAINT `user_role_ibfk_2` FOREIGN KEY (`rid`) REFERENCES 
`role` (`id`)
 ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
-- ---------------------------
-- Records of user_role
-- ---------------------------
BEGIN;
 INSERT INTO `user_role` VALUES (1, 1, 1);
 INSERT INTO `user_role` VALUES (2, 1, 2);
 INSERT INTO `user_role` VALUES (3, 2, 2);
 INSERT INTO `user_role` VALUES (4, 3, 3);
 COMMIT;
SET FOREIGN_KEY_CHECKS = 1;</code></pre><p>创建 springboot 应⽤</p>
<p>引⼊依赖</p>
<pre><code>&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;


        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.38&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;druid&lt;/artifactId&gt;
            &lt;version&gt;1.2.8&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.2.2&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></pre><p>配置配置⽂件</p>
<p>就是数据库之类的</p>
<h4 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h4><pre><code>public class User implements UserDetails {
    private Integer id;
    private String password;
    private String username;
    private boolean enabled;
    private boolean locked;
    private List&lt;Role&gt; roles;

    @Override
    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {
        return roles.stream().map(r -&gt; new SimpleGrantedAuthority(r.getName())).collect(Collectors.toList());
    }

    @Override
    public String getPassword() {
        return password;
    }

    @Override
    public String getUsername() {
        return username;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return !locked;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }

    public void setLocked(boolean locked) {
        this.locked = locked;
    }

    public void setRoles(List&lt;Role&gt; roles) {
        this.roles = roles;
    }

    public Integer getId() {
        return id;
    }

    public List&lt;Role&gt; getRoles() {
        return roles;
    }
}</code></pre><pre><code>public class Role {
    private Integer id;
    private String name;
    private String nameZh;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getNameZh() {
        return nameZh;
    }

    public void setNameZh(String nameZh) {
        this.nameZh = nameZh;
    }
}</code></pre><pre><code>
public class Menu {
    private Integer id;
    private String pattern;
    private List&lt;Role&gt; roles;

    public List&lt;Role&gt; getRoles() {
        return roles;
    }

    public void setRoles(List&lt;Role&gt; roles) {
        this.roles = roles;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getPattern() {
        return pattern;
    }

    public void setPattern(String pattern) {
        this.pattern = pattern;
    }
}</code></pre><h4 id="创建-service-接⼝"><a href="#创建-service-接⼝" class="headerlink" title="创建 service 接⼝"></a>创建 service 接⼝</h4><pre><code>@Service
public class UserService implements UserDetailsService {
    private final UserMapper userMapper;

    @Autowired
    public UserService(UserMapper userMapper) {
        this.userMapper = userMapper;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //1.根据用户名查询用户信息
        User user = userMapper.loadUserByUsername(username);
        if (user == null) {
            throw new UsernameNotFoundException(&quot;用户不存在&quot;);
        }
        List&lt;Role&gt; roles = userMapper.getUserRoleByUid(user.getId());
        user.setRoles(roles);
        return user;
    }
}</code></pre><h4 id="创建测试-controller"><a href="#创建测试-controller" class="headerlink" title="创建测试 controller"></a>创建测试 controller</h4><pre><code>RestController
public class HelloController {


    /**
     * /admin/**   ROLE_ADMIN
     * /user/**    ROLE_USER
     * /guest/**   ROLE_USER ROLE_GUEST
     *
     * admin      ADMIN USER
     * user       USER
     * blr        GUEST
     *
     */
    @GetMapping(&quot;/admin/hello&quot;)
    public String admin() {
        return &quot;hello admin&quot;;
    }

    @GetMapping(&quot;/user/hello&quot;)
    public String user() {
        return &quot;hello user&quot;;
    }

    @GetMapping(&quot;/guest/hello&quot;)
    public String guest() {
        return &quot;hello guest&quot;;
    }

    @GetMapping(&quot;/hello&quot;)
    public String hello() {
        return &quot;hello&quot;;
    }
}</code></pre><h4 id="创建-CustomSecurityMetadataSource"><a href="#创建-CustomSecurityMetadataSource" class="headerlink" title="创建 CustomSecurityMetadataSource"></a>创建 CustomSecurityMetadataSource</h4><pre><code>
@Component
public class CustomerSecurityMetaSource implements FilterInvocationSecurityMetadataSource {

    private final MenuService menuService;

    @Autowired
    public CustomerSecurityMetaSource(MenuService menuService) {
        this.menuService = menuService;
    }

    AntPathMatcher antPathMatcher = new AntPathMatcher();
    /**
     * 自定义动态资源权限元数据信息
     * @param object the object being secured
     * @return
     * @throws IllegalArgumentException
     */
    @Override
    public Collection&lt;ConfigAttribute&gt; getAttributes(Object object) throws IllegalArgumentException {
        //1.当前请求对象
        String requestURI = ((FilterInvocation) object).getRequest().getRequestURI();
        //2.查询所有菜单
        List&lt;Menu&gt; allMenu = menuService.getAllMenu();

        for (Menu menu : allMenu) {
            if (antPathMatcher.match(menu.getPattern(), requestURI)) {
                String[] roles = menu.getRoles().stream().map(Role::getName).toArray(String[]::new);
                return SecurityConfig.createList(roles);
            }
        }
        return null;
    }

    @Override
    public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() {
        return null;
    }

    @Override
    public boolean supports(Class&lt;?&gt; clazz) {
        return FilterInvocation.class.isAssignableFrom(clazz);
    }
}
</code></pre><h4 id="配置-Security-配置"><a href="#配置-Security-配置" class="headerlink" title="配置 Security 配置"></a>配置 Security 配置</h4><pre><code>
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true,jsr250Enabled = true,securedEnabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    private final CustomerSecurityMetaSource customSecurityMetadataSource;

    private final UserDetailsService userDetailsService;

    @Autowired
    public SecurityConfig(CustomerSecurityMetaSource customSecurityMetadataSource, UserDetailsService userDetailsService) {
        this.customSecurityMetadataSource = customSecurityMetadataSource;
        this.userDetailsService = userDetailsService;
    }


    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //1.获取工厂对象
        ApplicationContext applicationContext = http.getSharedObject(ApplicationContext.class);
        //2.设置自定义 url 权限处理
        http.apply(new UrlAuthorizationConfigurer&lt;&gt;(applicationContext))
                .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() {
                    @Override
                    public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O object) {
                        object.setSecurityMetadataSource(customSecurityMetadataSource);
                        //是否拒绝公共资源访问
                        object.setRejectPublicInvocations(false);
                        return object;
                    }
                });
        http.formLogin().and().csrf().disable();
    }
}
</code></pre><h1 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h1><p>另一篇已经介绍了Oauth2</p>
<p>OAuth2 标准接⼝ </p>
<p> /oauth/authorize：授权端点 </p>
<p>/oauth/token：获取令牌端点 </p>
<p>/oauth/confirm_access：⽤户确认授权提交端点</p>
<p> /oauth/error：授权服务错误信息端点 </p>
<p>/oauth/check_token：⽤于资源服务访问的令牌解析端点</p>
<p> /oauth/token_key：提供公有密匙的端点，如果使⽤JWT令牌的话</p>
<h2 id="授权服务器"><a href="#授权服务器" class="headerlink" title="授权服务器"></a>授权服务器</h2><p>导入依赖</p>
<pre><code>&lt;!--引入Springsecurity--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!--引入SpringSecurity oauth2 授权服务器依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;
    &lt;version&gt;2.2.4.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="AuthorizationServerConfigurerAdapter"><a href="#AuthorizationServerConfigurerAdapter" class="headerlink" title="AuthorizationServerConfigurerAdapter"></a>AuthorizationServerConfigurerAdapter</h3><p>主要继承这个类，有这个三个配置</p>
<p><img src="/springsecurity/image-20230716221443106.png" alt="image-20230716221443106"></p>
<p>AuthorizationServerConfigurerAdapter是一个配置类，用于配置OAuth2授权服务器的相关参数。它有三个抽象方法，分别代表不同的配置内容：</p>
<ul>
<li><strong>ClientDetailsServiceConfigurer</strong>：用来配置客户端详情服务（ClientDetailsService），客户端详情信息在这里进行初始化，你能够把客户端详情信息写死在这里或者是通过数据库来存储调取详情信息。</li>
<li><strong>AuthorizationServerSecurityConfigurer</strong>：用来配置令牌端点 (Token Endpoint)的安全约束，比如设置令牌访问的权限、密码加密方式等。</li>
<li><strong>AuthorizationServerEndpointsConfigurer</strong>：用来配置授权（authorization）以及令牌（token）的访问端点和令牌服务 (token services)，比如设置授权码服务、令牌存储方式、用户信息服务等。</li>
</ul>
<h3 id="EnableAuthorizationServer"><a href="#EnableAuthorizationServer" class="headerlink" title="@EnableAuthorizationServer"></a>@EnableAuthorizationServer</h3><p>作用是开启OAuth2授权服务器的功能</p>
<h3 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h3><pre><code>// 自定义授权服务器配置,指定当前应用为授权服务器
@Configuration
@EnableAuthorizationServer
public class AuthenticationServerConfig extends AuthorizationServerConfigurerAdapter {

    @Autowired
    private PasswordEncoder passwordEncoder;

    /**
     * 用来配置授权服务器可以为哪些客户端授权,使用哪种授权模式
     */
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()
                .withClient(&quot;client&quot;) //客户端id
                .secret(passwordEncoder.encode(&quot;secret&quot;)) 
                .redirectUris(&quot;http://www.baidu.com&quot;) //重定向
                // 授权模式支持授权码模式,同时支持令牌刷新模式
                .authorizedGrantTypes(&quot;authorization_code&quot;,&quot;refresh_token&quot;) 
                // 令牌允许获取的资源权限
                .scopes(&quot;read:user&quot;);
    }
}
</code></pre><p>授权码模式：</p>
<p>请求用户是否授权，获取授权码code：/oauth/authorize<br>授权之后根据获取的授权码获取令牌access_token：/oauth/token ，授权类型：authorization_code<br>① 请求用户是否授权，获取授权码code，浏览器访问完整路径：<a href="http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=http://www.baidu.com" target="_blank" rel="noopener">http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=http://www.baidu.com</a></p>
<p><img src="/springsecurity/image-20230716230400249.png" alt="image-20230716230400249"></p>
<p>点击Authorize按钮就会跳转到百度网站，并返回一个授权码 code</p>
<p><img src="/springsecurity/image-20230716230922902.png" alt="image-20230716230922902"></p>
<p>② 授权之后根据返回的授权码 code 获取访问令牌 access_token ：</p>
<p><a href="http://client:secret@localhost:8080/oauth/token" target="_blank" rel="noopener">http://client:secret@localhost:8080/oauth/token</a></p>
<p>或者这样请求</p>
<pre><code>localhost:8080/auth/oauth/token？client_id=&quot;client&amp;client_secret=secret&amp;grant_type=authorization_code&amp;code=7U2297&amp;redirect_uri=http://www.xuecheng-plus.com</code></pre><p><img src="/springsecurity/image-20230716230436041.png" alt="image-20230716230436041"></p>
<h3 id="授权服务器-支持授权码模式同时支持刷新令牌"><a href="#授权服务器-支持授权码模式同时支持刷新令牌" class="headerlink" title="授权服务器 - 支持授权码模式同时支持刷新令牌"></a>授权服务器 - 支持授权码模式同时支持刷新令牌</h3><p>在access_token即将过期的时候，我们希望支持刷新令牌</p>
<p>授权码模式：</p>
<p>请求用户是否授权，获取授权码 code：/oauth/authorize<br>授权之后根据获取的授权码 code 获取令牌 access_token 和 refresh_token：/oauth/token, 授权类型需要为authorization_code<br>令牌刷新：/oauth/token, 授权类型需要为 refresh_token</p>
<pre><code>/**
 * 自定义授权服务器配置，指定当前应用为授权服务器
 */
@Configuration
@EnableAuthorizationServer
public class AuthenticationServerConfig extends AuthorizationServerConfigurerAdapter {

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private UserDetailsService userDetailsService;

    /**
     * 用来配置授权服务器可以为哪些客户端授权,使用哪种授权模式
     */
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()
                .withClient(&quot;client&quot;)
                .secret(passwordEncoder.encode(&quot;secret&quot;))
                .redirectUris(&quot;http://www.baidu.com&quot;)
                // 授权模式支持授权码模式,同时支持令牌刷新模式
                .authorizedGrantTypes(&quot;authorization_code&quot;,&quot;refresh_token&quot;)
                // 令牌允许获取的资源权限
                .scopes(&quot;read:user&quot;);
    }

    /**
     * 刷新令牌必须配置userDetailsService，用来刷新令牌时的认证
     */
    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        endpoints.userDetailsService(userDetailsService);
    }
}
</code></pre><p>① 请求用户是否授权，获取授权码code，浏览器访问完整路径：<a href="http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=http://www.baidu.com" target="_blank" rel="noopener">http://localhost:8080/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=http://www.baidu.com</a></p>
<p><img src="/springsecurity/image-20230716232710320.png" alt="image-20230716232710320"></p>
<p>② 授权之后根据返回的授权码 code 获取访问令牌 access_token 和 刷新令牌 refresh_token</p>
<p><img src="/springsecurity/image-20230716232817695.png" alt="image-20230716232817695"></p>
<p>③ 根据 refresh_token 刷新令牌：</p>
<p><img src="/springsecurity/image-20230716232856883.png" alt="image-20230716232856883"></p>
<h3 id="授权服务器-支持密码模式"><a href="#授权服务器-支持密码模式" class="headerlink" title="授权服务器 - 支持密码模式"></a>授权服务器 - 支持密码模式</h3><pre><code>/**
 * 自定义授权服务器配置，指定当前应用为授权服务器
 */
@Configuration
@EnableAuthorizationServer
public class AuthenticationServerConfig extends AuthorizationServerConfigurerAdapter {

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private UserDetailsService userDetailsService;

    @Autowired
    private AuthenticationManager authenticationManager;

    /**
     * 用来配置授权服务器可以为哪些客户端授权,使用哪种授权模式
     */
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()
                .withClient(&quot;client&quot;)
                .secret(passwordEncoder.encode(&quot;secret&quot;))
                .redirectUris(&quot;http://www.baidu.com&quot;)
                // 授权模式支持密码模式,同时支持令牌刷新模式
                .authorizedGrantTypes(&quot;password&quot;,&quot;refresh_token&quot;)
                // 令牌允许获取的资源权限
                .scopes(&quot;read:user&quot;);
    }

    /**
     * 刷新令牌必须配置userDetailsService，用来刷新令牌时的认证
     */
    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        endpoints.userDetailsService(userDetailsService);
        //配置认证管理
        endpoints.authenticationManager(authenticationManager);
        //在密码模式下要配置.authenticationManager(authenticationManager)，是因为密码模式需要验证用户的用户名和密码，而authenticationManager是一个接口，它可以管理不同的认证提供者（AuthenticationProvider），并且调用它们的authenticate()方法来进行认证。
        //授权码模式是因为重定向到授权服务器的授权页面，让用户输入用户名和密码，并且同意授权。上


    }
}
</code></pre><p><a href="http://client:secret@localhost:8080/oauth/token" target="_blank" rel="noopener">http://client:secret@localhost:8080/oauth/token</a></p>
<p><img src="/springsecurity/image-20230716234139093.png" alt="image-20230716234139093"></p>
<p>刷新令牌：</p>
<p><img src="/springsecurity/image-20230716234159775.png" alt="image-20230716234159775"></p>
<h3 id="授权服务器-支持客户端模式"><a href="#授权服务器-支持客户端模式" class="headerlink" title="授权服务器 - 支持客户端模式"></a>授权服务器 - 支持客户端模式</h3><pre><code>/**
 * 自定义授权服务器配置，指定当前应用为授权服务器
 */
@Configuration
@EnableAuthorizationServer
public class AuthenticationServerConfig extends AuthorizationServerConfigurerAdapter {

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private UserDetailsService userDetailsService;

    @Autowired
    private AuthenticationManager authenticationManager;

    /**
     * 用来配置授权服务器可以为哪些客户端授权,使用哪种授权模式
     */
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()
                .withClient(&quot;client&quot;)
                .secret(passwordEncoder.encode(&quot;secret&quot;))
                .redirectUris(&quot;http://www.baidu.com&quot;)
                // 授权模式支持授权码模式,同时支持令牌刷新模式
                .authorizedGrantTypes(&quot;client_credentials&quot;,&quot;refresh_token&quot;)
                // 令牌允许获取的资源权限
                .scopes(&quot;read:user&quot;);
    }

    /**
     * 刷新令牌必须配置userDetailsService，用来刷新令牌时的认证
     */
    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        endpoints.userDetailsService(userDetailsService);
        endpoints.authenticationManager(authenticationManager);
    }
}
</code></pre><p><img src="/springsecurity/image-20230716234759929.png" alt="image-20230716234759929"></p>
<h3 id="授权服务器-基于redis令牌存储，用户信息采用数据库存储"><a href="#授权服务器-基于redis令牌存储，用户信息采用数据库存储" class="headerlink" title="授权服务器 - 基于redis令牌存储，用户信息采用数据库存储"></a>授权服务器 - 基于redis令牌存储，用户信息采用数据库存储</h3><p>redis存token，配置</p>
<pre><code>#配置contextPath，要和客户端应用的接口保持一致
server.servlet.context-path=/auth
#数据库配置
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/sc
spring.datasource.username=root
spring.datasource.password=123456
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true</code></pre><p>授权服务器配置</p>
<pre><code>/**
*
* client_secret和password需要加密才存到数据库中: &quot;{bcrypt}&quot; + bCryptPasswordEncoder.encode(&quot;8080&quot;)
* **/
Configuration
@EnableAuthorizationServer
public class Oauth2AuthorizationConfigure extends AuthorizationServerConfigurerAdapter {

    @Autowired
    AuthenticationManager authenticationManager;

    @Autowired
    RedisConnectionFactory redisConnectionFactory;

    @Autowired
    private DataSource dataSource;

    @Autowired
    Oauth2UserDetailsService userDetailsService;

    @Autowired
    ClientDetailsService clientDetailsService;

    /**
     * jdbc加载client_details
     * 要求数据库中的表名为:oauth_client_details
     * @return
     */
    @Bean
    public ClientDetailsService clientDetailsService() {
        return new JdbcClientDetailsService(dataSource);
    }

    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.withClientDetails(clientDetailsService);
    }

    /**
     * 设置token存入redis
     * @param endpoints
     * @throws Exception
     */
    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        endpoints.tokenStore(new RedisTokenStore(redisConnectionFactory))
                .authenticationManager(authenticationManager)
                .userDetailsService(userDetailsService);
    }

    @Override
    public void configure(AuthorizationServerSecurityConfigurer oauthServer) {
        oauthServer.tokenKeyAccess(&quot;permitAll()&quot;).checkTokenAccess(&quot;isAuthenticated()&quot;);
    }
}
</code></pre><pre><code>@Autowired
private DataSource dataSource;

@Autowired
ClientDetailsService clientDetailsService;

/**
* jdbc加载client_details
 * 要求数据库中的表名为:oauth_client_details
 * @return
 */
@Bean
public ClientDetailsService clientDetailsService() {
    return new JdbcClientDetailsService(dataSource);
}

@Override
public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
    clients.withClientDetails(clientDetailsService);
}
</code></pre><pre><code>@Autowired
Oauth2UserDetailsService userDetailsService;

 /**
     * 设置token存入redis
     * @param endpoints
     * @throws Exception
     */
    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        endpoints.tokenStore(new RedisTokenStore(redisConnectionFactory))
                .authenticationManager(authenticationManager)
                //用户信息加载
                .userDetailsService(userDetailsService);
    }
</code></pre><h1 id="弃用WebSecurityConfigurerAdapter配置类"><a href="#弃用WebSecurityConfigurerAdapter配置类" class="headerlink" title="弃用WebSecurityConfigurerAdapter配置类"></a>弃用WebSecurityConfigurerAdapter配置类</h1><p><a href="https://spring.io/blog/2022/02/21/spring-security-without-the-websecurityconfigureradapter#ldap-authentication" target="_blank" rel="noopener">Spring Security without the WebSecurityConfigurerAdapter</a>这个是</p>
<pre><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

@Configuration
@EnableWebSecurity    // 添加 security 过滤器
@EnableGlobalMethodSecurity(prePostEnabled = true)    // 启用方法级别的权限认证
public class SpringSecurityConfig {
    @Autowired
    private XxxUserService xxxUserService;

    // 权限不足错误信息处理，包含认证错误与鉴权错误处理
    @Autowired
    private JwtAuthError jwtAuthError;

    // jwt 校验过滤器，从 http 头部 Authorization 字段读取 token 并校验
    @Bean
    public JwtAuthFilter authFilter() throws Exception {
        return new JwtAuthFilter();
    }

    /**
     * 密码明文加密方式配置
     * @return
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /**
     * 获取AuthenticationManager（认证管理器），登录时认证使用
     * @param authenticationConfiguration
     * @return
     * @throws Exception
     */
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                // 基于 token，不需要 csrf
                .csrf().disable()
                // 基于 token，不需要 session
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
                // 设置 jwtAuthError 处理认证失败、鉴权失败
                .exceptionHandling().authenticationEntryPoint(jwtAuthError).accessDeniedHandler(jwtAuthError).and()
                // 下面开始设置权限
                .authorizeRequests(authorize -&gt; authorize
                        // 请求放开
                        .antMatchers(&quot;/**&quot;).permitAll()
                        .antMatchers(&quot;/**&quot;).permitAll()
                        // 其他地址的访问均需验证权限
                        .anyRequest().authenticated()
                )
                // 添加 JWT 过滤器，JWT 过滤器在用户名密码认证过滤器之前
                .addFilterBefore(authFilter(), UsernamePasswordAuthenticationFilter.class)
                // 认证用户时用户信息加载配置，注入springAuthUserService
                .userDetailsService(xxxAuthUserService)
                .build();
    }

    /**
     * 配置跨源访问(CORS)
     * @return
     */
    @Bean
    CorsConfigurationSource corsConfigurationSource() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration(&quot;/**&quot;, new CorsConfiguration().applyPermitDefaultValues());
        return source;
    }

}
</code></pre>
            </div>
            <hr />

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">写作不易，客官能否打赏一杯奶茶？</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《SpringSecurity》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/springsecurity.html" property="cc:attributionName"
               rel="cc:attributionURL">
                jiyonggang
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
    <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: 'jiyongg-code.github.io',
        owner: 'jiyongg-code',
        admin: "jiyongg-code",
        id: 'springsecurity.html',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    
    <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="//code.bdstatic.com/npm/leancloud-storage@4.12.2/dist/av-min.js"></script>
<!-- <script src="/libs/valine/av-min.js"></script> -->
<!-- <script src="/libs/valine/Valine.min.js"></script> -->
<script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script> 

<script>
    new Valine({
        el: '#vcomments',
        appId: '',
        appKey: '',
        notify: 'true' === 'true',
        verify: 'false' === 'true',
        visitor: 'false' === 'true',
        avatar: 'wavatar',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '如果你没有GitHub账号，还可以在这里评论啦！'
    });
</script>

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/eureka.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="Eureka注册中心">
                        
                        <span class="card-title">Eureka注册中心</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Eureka注册中心
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2023-03-23
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/SpringCloud/" class="post-category" target="_blank">
                                    SpringCloud
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Eureka/" target="_blank">
                        <span class="chip bg-color">Eureka</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/jwt.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="JWT">
                        
                        <span class="card-title">JWT</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            JWT介绍
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2023-03-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Auth/" class="post-category" target="_blank">
                                    Auth
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JWT/" target="_blank">
                        <span class="chip bg-color">JWT</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: Ji`s Blog<br />'
            + '作者: jiyonggang<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () { bodyElement.removeChild(newdiv); }, 200);
    });
</script>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>

<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>
<script type="text/javascript" src="/libs/codeBlock/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>


    <footer class="page-footer bg-color">
    <div class="container row center-align">
       <div class="Copy-right">
            &copy; 2020 Ji. All Rights Reserved.

                    
           <!--<a href="/sitemap.xml" target="_blank">站点地图</a>丨-->
           
            &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
            <span class="white-color">195.7k
             丨            
          

            <span id="sitetime"></span>

            
            
            
            
            <span id="busuanzi_container_site_pv" style='display:none'>
                <i class="fa fa-users"></i>
                本站总访问量 <span id="busuanzi_value_site_pv" class="red-color"></span>
            </span>
            
            
            <span id="busuanzi_container_site_uv" style='display:none'>
               人次,&nbsp;<i class="fa fa-user"></i>访客数 <span id="busuanzi_value_site_uv" class="blue-color"></span> 人.
            </span>
            
            
        </div>        
        <div class="social-link social-statis">
    <a href="https://github.com/jiyongg-code" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="https://www.csdn.net/无" class="tooltipped" target="_blank" data-tooltip="访问我的CSDN主页" data-position="top" data-delay="50">
        <i class="fa fa-codiepie"></i>
    </a>



    <a href="https://www.zhihu.com/无" class="tooltipped" target="_blank" data-tooltip="访问我的知乎" data-position="top" data-delay="50">
        <i class="fa fa-inverse">知</i>
    </a>



    <a href="https://user.qzone.qq.com/1320159539" class="tooltipped" target="_blank" data-tooltip="访问我的QQ空间" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="mailto:1320159539@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
    <div class="container row center-align">
    <div class="github-badge">
      <a style="color: #fff" rel="license" href="https://hexo.io/" target="_blank" title="由 Hexo 强力驱动">
      <span class="badge-subject">Powered</span><span class="badge-value bg-blue">Hexo</span></a>
    </div>
    <div class="github-badge">
      <a style="color: #fff" rel="license" href="https://github.com/" target="_blank" title="静态网页托管于 GitHub Pages 和 Coding Pages">
      <span class="badge-subject">Hosted</span><span class="badge-value bg-brightgreen">GitHub & Coding</span></a>
    </div>
    <div class="github-badge">
      <a style="color: #fff" rel="license" href="https://www.cloud.tencent.com/" target="_blank" title="腾讯云提供域名相关服务">
      <span class="badge-subject">DNS</span><span class="badge-value bg-blueviolet">Tencent cloud</span></a>
    </div>
    <div class="github-badge">
      <a style="color: #fff" rel="license" href="https://www.jsdelivr.com/" target="_blank" title="jsDelivr 提供 CDN 加速服务">
      <span class="badge-subject">CDN</span><span class="badge-value bg-orange">jsDelivr</span></a>
    </div>
    <div class="github-badge">
        <a style="color: #fff" rel="license" href="https://github.com/blinkfox/hexo-theme-matery/" target="_blank" title="站点使用 Matery 主题">
      <span class="badge-subject">Theme</span><span class="badge-value bg-blue">Matery</span></a>
    </div>
    <div class="github-badge">
      <a style="color: #fff" rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="本站点采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可">
      <span class="badge-subject"><i class="fa fa-copyright"></i></span><span class="badge-value bg-lightgrey">BY-NC-SA 4.0</span></a>
    </div>
    <div class="github-badge">
      <a style="color: #fff" rel="license" href="https://996.icu/" target="_blank" title="支持 996.ICU">
      <span class="badge-subject">Link</span><span class="badge-value bg-red">996.ICU</span></a>
    </div>
    <div class="github-badge">
      <span class="badge-subject">UV</span><span class="badge-value bg-orange" id="busuanzi_value_site_uv"></span>
    </div>
    <div class="github-badge">
      <span class="badge-subject">PV</span><span class="badge-value bg-brightgreen" id="busuanzi_value_site_pv"></span>
    </div>
    <div class="github-badge">
      <span class="badge-subject">WordCount</span><span class="badge-value bg-blueviolet">195.7k</span>
    </div>
</footer>

<div class="progress-bar"></div>

<!-- 不蒜子计数初始值纠正 -->
<script>
    $(document).ready(function () {

        var int = setInterval(fixCount, 50);
        var pvcountOffset = 80000;
        var uvcountOffset = 20000;

        function fixCount() {
            if (document.getElementById("busuanzi_container_site_pv").style.display != "none") {
                $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + pvcountOffset);
                clearInterval(int);
            }
            if ($("#busuanzi_container_site_pv").css("display") != "none") {
                $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + uvcountOffset); // 加上初始数据 
                clearInterval(int);
            }
        }
    });
</script>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */
        var t1 = Date.UTC(2020, 01, 01, 00, 00, 00); //北京时间2018-2-13 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
    }/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <script type="text/javascript"> var OriginTitile = document.title, st; document.addEventListener("visibilitychange", function () { document.hidden ? (document.title = "Σ(っ °Д °;)っ喔哟，崩溃啦！", clearTimeout(st)) : (document.title = "φ(゜▽゜*)♪咦，又好了！", st = setTimeout(function () { document.title = OriginTitile }, 3e3)) })
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>



    
    <script src="/libs/others/clicklove.js"></script>
    

    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    <!-- 雪花特效 -->
    

   <!--单击显示文字-->
   <script type="text/javascript" src="/js/click_show_text.js"></script> 

   <!--动态线条背景-->
   <script type="text/javascript"
   color="220,220,220" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
   </script>

   <script async src =“ https://cdn.jsdelivr.net/npm/perfops-rom”> </ script>

  <!--自定义看板娘-->
  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  <script src="/live2d-widget/autoload.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"/>

</body>

</html>