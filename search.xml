<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql-01</title>
      <link href="/mysql-01.html"/>
      <url>/mysql-01.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-MySQL概述"><a href="#1-MySQL概述" class="headerlink" title="1.MySQL概述"></a>1.MySQL概述</h1><h2 id="1-1-数据库相关概念"><a href="#1-1-数据库相关概念" class="headerlink" title="1.1 数据库相关概念"></a>1.1 数据库相关概念</h2><table><thead><tr><th>名称</th><th>全称</th><th>简称</th></tr></thead><tbody><tr><td>数据库</td><td>存储数据的仓库，数据是有组织的进行存储</td><td>DataBase（DB）</td></tr><tr><td>数据库管理系统</td><td>操纵和管理数据库的大型软件</td><td>DataBase Management System (DBMS)</td></tr><tr><td>SQL</td><td>操作关系型数据库的编程语言，定义了一套操作 关系型数据库统一标准</td><td>Structured Query Language (SQL)</td></tr></tbody></table><h3 id="1-1-1mysql数据库连接"><a href="#1-1-1mysql数据库连接" class="headerlink" title="1.1.1mysql数据库连接"></a>1.1.1mysql数据库连接</h3><ol><li>使用MySQL提供的客户端命令行工具</li><li>使用系统自带的命令行工具执行指令</li></ol><pre><code>mysql [-h 127.0.0.1] [-P 3306] -u root -p参数：-h : MySQL服务所在的主机IP-P : MySQL服务端口号， 默认3306-u : MySQL数据库用户名-p ： MySQL数据库用户名对应的密码</code></pre><p>[]内为可选参数，如果需要连接远程的MySQL，需要加上这两个参数来指定远程主机IP、端口，如果 连接本地的MySQL，则无需指定这两个参数。</p><h3 id="1-1-2-数据模型"><a href="#1-1-2-数据模型" class="headerlink" title="1.1.2 数据模型"></a>1.1.2 数据模型</h3><p>1). 关系型数据库（RDBMS） 概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。 而所谓二维表，指的是由行和列组成的表，如下图（就类似于Excel表格数据，有表头、有列、有行， 还可以通过一列关联另外一个表格中的某一列数据）。MySQL、Oracle、DB2、 SQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。简单说，基于二维表存储 数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库。</p><p><img src="/mysql-01/image-20230317200345320.png" alt="image-20230317200345320"></p><p>特点： A. 使用表存储数据，格式统一，便于维护。 </p><p>​            B. 使用SQL语言操作，标准统一，使用方便。</p><p>2). 数据模型 MySQL是关系型数据库，是基于二维表进行数据存储的，具体的结构图下:</p><p><img src="/mysql-01/image-20230317200415240.png" alt="image-20230317200415240"></p><p>可以通过MySQL客户端连接数据库管理系统DBMS，然后通过DBMS操作数据库。 </p><p>可以使用SQL语句，通过数据库管理系统操作数据库，以及操作数据库中的表结构及数据。 一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包 含多行记录。</p><h1 id="2-SQL"><a href="#2-SQL" class="headerlink" title="2.SQL"></a>2.SQL</h1><p>全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了 一套操作关系型数据库统一标准 。</p><h2 id="2-1-SQL通用语法"><a href="#2-1-SQL通用语法" class="headerlink" title="2.1 SQL通用语法"></a>2.1 SQL通用语法</h2><ol><li>SQL语句可以单行或多行书写，以分号结尾。</li><li>SQL语句可以使用空格/缩进来增强语句的可读性。</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</li><li>注释： 单行注释：– 注释内容 或 # 注释内容 多行注释：/* 注释内容 */</li></ol><h2 id="2-2-sql分类"><a href="#2-2-sql分类" class="headerlink" title="2.2 sql分类"></a>2.2 sql分类</h2><p>SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL。</p><table><thead><tr><th>分类</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>数据定义语言，用来定义数据库对象(数据库，表， 字段)</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>数据操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据查询语言，用来查询数据库中表的记录</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>数据控制语言，用来创建数据库用户、控制数据库的 访问权限</td></tr></tbody></table><h2 id="2-3-DDL"><a href="#2-3-DDL" class="headerlink" title="2.3 DDL"></a>2.3 DDL</h2><p>Data Definition Language，数据定义语言，用来定义数据库对象(数据库，表，字段) 。</p><h3 id="2-3-1-数据库操作"><a href="#2-3-1-数据库操作" class="headerlink" title="2.3.1 数据库操作"></a>2.3.1 数据库操作</h3><p>1). 查询所有数据库</p><pre><code>show databases ;</code></pre><p>2). 查询当前数据库</p><pre><code>select database() ;</code></pre><p>3). 创建数据库</p><pre><code>create database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ;</code></pre><p>在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。</p><p>可以通过if not exists 参数来解决这个问题，数据库不存在, 则创建该数据库，如果存在，则不 创建。</p><pre><code>create database if not extists itcast;</code></pre><p>B. 创建一个itheima数据库，并且指定字符集</p><pre><code>create database 数据库名称 default charset utf8mb4;</code></pre><p>4). 删除数据库</p><pre><code> drop database [ if exists ] 数据库名 ;</code></pre><p>如果删除一个不存在的数据库，将会报错。此时，可以加上参数 if exists ，如果数据库存在，再 执行删除，否则不执行删除。</p><p>5). 切换数据库</p><pre><code>use 数据库名 ;</code></pre><p>要操作某一个数据库下的表时，就需要通过该指令，切换到对应的数据库下，否则是不能操作的。</p><h3 id="2-3-2-表操作"><a href="#2-3-2-表操作" class="headerlink" title="2.3.2 表操作"></a>2.3.2 表操作</h3><h4 id="2-3-2-1-表操作-查询创建"><a href="#2-3-2-1-表操作-查询创建" class="headerlink" title="2.3.2.1 表操作-查询创建"></a>2.3.2.1 表操作-查询创建</h4><p>1). 查询当前数据库所有表</p><pre><code>show tables;</code></pre><p>2). 查看指定表结构</p><pre><code>desc 表名 ;</code></pre><p>3). 查询指定表的建表语句</p><pre><code>show create table 表名 ;</code></pre><p>4). 创建表结构</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE 表名(字段1 字段1类型 [ COMMENT 字段1注释 ],字段2 字段2类型 [COMMENT 字段2注释 ],字段3 字段3类型 [COMMENT 字段3注释 ],......字段n 字段n类型 [COMMENT 字段n注释 ]) [ COMMENT 表注释 ] ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意: […] 内为可选参数，最后一个字段后面没有逗号</p><p>比如，创建一张表 tb_user ，对应的结构如下，那么建表语句为：</p><p><img src="/mysql-01/image-20230318122920257.png" alt="image-20230318122920257"></p><pre class="line-numbers language-mysql"><code class="language-mysql">create table tb_user(id int comment '编号',name varchar(50) comment '姓名',age int comment '年龄',gender varchar(1) comment '性别') comment '用户表';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-2-2-表操作-数据类型"><a href="#2-3-2-2-表操作-数据类型" class="headerlink" title="2.3.2.2 表操作-数据类型"></a>2.3.2.2 表操作-数据类型</h4><p> MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。</p><p>1). 数值类型</p><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">范围（有符号）</th><th align="left">范围（无符号）</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1 Bytes</td><td align="left">(-128，127)</td><td align="left">(0，255)</td><td align="left">小整数值</td></tr><tr><td align="left">SMALLINT</td><td align="left">2 Bytes</td><td align="left">(-32 768，32 767)</td><td align="left">(0，65 535)</td><td align="left">大整数值</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3 Bytes</td><td align="left">(-8 388 608，8 388 607)</td><td align="left">(0，16 777 215)</td><td align="left">大整数值</td></tr><tr><td align="left">INT或INTEGER</td><td align="left">4 Bytes</td><td align="left">(-2 147 483 648，2 147 483 647)</td><td align="left">(0，4 294 967 295)</td><td align="left">大整数值</td></tr><tr><td align="left">BIGINT</td><td align="left">8 Bytes</td><td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td align="left">(0，18 446 744 073 709 551 615)</td><td align="left">极大整数值</td></tr><tr><td align="left">FLOAT</td><td align="left">4 Bytes</td><td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="left">单精度 浮点数值</td></tr><tr><td align="left">DOUBLE</td><td align="left">8 Bytes</td><td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">双精度 浮点数值</td></tr><tr><td align="left">DECIMAL</td><td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="left">依赖于M和D的值</td><td align="left">依赖于M和D的值</td><td align="left">小数值</td></tr></tbody></table><pre><code>如:1). 年龄字段 -- 不会出现负数, 而且人的年龄不会太大age tinyint unsigned2). 分数 -- 总分100分, 最多出现一位小数score double(4,1)</code></pre><p>2). 字符串类型</p><table><thead><tr><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 bytes</td><td>定长字符串(需要指定长度)</td></tr><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串(需要指定长度)</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过255个字符的二进制数据</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table><p>char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和 字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性 能会更高些。</p><pre><code>如：1). 用户名 username ------&gt; 长度不定, 最长不会超过50username varchar(50)2). 性别 gender ---------&gt; 存储值, 不是男,就是女gender char(1)3). 手机号 phone --------&gt; 固定长度为11phone char(11)</code></pre><p>3). 日期时间类型</p><table><thead><tr><th align="left">类型</th><th align="left">大小 ( bytes)</th><th align="left">范围</th><th align="left">格式</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01/9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="left">日期值</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’/‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="left">时间值或持续时间</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901/2155</td><td align="left">YYYY</td><td align="left">年份值</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="left">混合日期和时间值</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="left">混合日期和时间值，时间戳</td></tr></tbody></table><pre><code>1). 生日字段 birthdaybirthday date2). 创建时间 createtimecreatetime datetime</code></pre><p>2.3.2.3 表操作-案例 设计一张员工信息表，要求如下：</p><ol><li>编号（纯数字） </li><li>员工工号 (字符串类型，长度不超过10位) </li><li>员工姓名（字符串类型，长度不超过10位）</li><li>性别（男/女，存储一个汉字） </li><li>年龄（正常人年龄，不可能存储负数）</li><li>身份证号（二代身份证号均为18位，身份证中有X这样的字符） </li><li>入职时间（取值年月日即可）</li></ol><pre><code>create table emp(    id int comment &quot;编号&quot;,    workno varchar(10) comment&#39;工号&#39;,    name varchar(10) comment&#39;姓名&#39;,    gender char(1) comment &#39;性别&#39;,    age tinyint unsigned comment &#39;年龄&#39;,    idcard char(10) comment &#39;身份证号&#39;,    entrydate date comment &#39;入职时间&#39;)comment &#39;员工表&#39;,</code></pre><h4 id="2-3-2-4-表操作-修改"><a href="#2-3-2-4-表操作-修改" class="headerlink" title="2.3.2.4 表操作-修改"></a>2.3.2.4 表操作-修改</h4><p>1). 添加字段</p><pre><code>ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</code></pre><p>案例:</p><p>为emp表增加一个新的字段”昵称”为nickname，类型为varchar(20)</p><pre><code>ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;</code></pre><p>2). 修改数据类型</p><pre><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型（长度);</code></pre><p>3). 修改字段名和字段类型</p><pre><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</code></pre><p>案例: 将emp表的nickname字段修改为username，类型为varchar(30)</p><pre><code>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;</code></pre><p>4). 删除字段</p><pre><code>ALTER TABLE 表名 DROP 字段名</code></pre><p>案例: </p><p>将emp表的字段username删除</p><pre><code>ALTER TABLE emp DROP username</code></pre><p>5). 修改表名</p><pre><code>ALTER TABLE 表名 RENAME TO 新表名;</code></pre><p>案例: </p><p>将emp表的表名修改为 employee</p><pre><code> ALTER TABLE emp RENAME TO employee;</code></pre><h4 id="2-3-2-5-表操作-删除"><a href="#2-3-2-5-表操作-删除" class="headerlink" title="2.3.2.5 表操作-删除"></a>2.3.2.5 表操作-删除</h4><pre><code>DROP TABLE [ IF EXISTS ] 表名;</code></pre><p>可选项 IF EXISTS 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不 加该参数项，删除一张不存在的表，执行将会报错)。 案例: 如果tb_user表存在，则删除tb_user表</p><pre><code>DROP TABLE IF EXISTS tb_user;</code></pre><p>2). 删除指定表, 并重新创建表</p><pre><code>TRUNCATE TABLE 表名</code></pre><p>注意: 在删除表的时候，表中的全部数据也都会被删除。</p><h2 id="2-4-图形化界面工具"><a href="#2-4-图形化界面工具" class="headerlink" title="2.4 图形化界面工具"></a>2.4 图形化界面工具</h2><p><img src="/mysql-01/image-20230318143403192.png" alt="image-20230318143403192"></p><p>个人感觉DataGrip好用</p><h2 id="2-5-DML"><a href="#2-5-DML" class="headerlink" title="2.5 DML"></a>2.5 DML</h2><p>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进 行增、删、改操作。</p><ul><li>添加数据（INSERT）</li><li>修改数据（UPDATE） </li><li>删除数据（DELETE）</li></ul><h3 id="2-5-1-添加数据"><a href="#2-5-1-添加数据" class="headerlink" title="2.5.1 添加数据"></a>2.5.1 添加数据</h3><p> 1). 给指定字段添加数据</p><pre><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code></pre><p>给employee表所有的字段添加数据 ；</p><pre><code>insert into employee(id,workno,name,gender,age,idcard,entrydate)values(1,&#39;1&#39;,&#39;Itcast&#39;,&#39;男&#39;,10,&#39;123456789012345678&#39;,&#39;2000-01-01&#39;);</code></pre><p>2). 给全部字段添加数据</p><pre><code>INSERT INTO 表名 VALUES (值1, 值2, ...);</code></pre><p>插入数据到employee表，具体的SQL如下：</p><pre><code>insert into employee values(2,&#39;2&#39;,&#39;张无忌&#39;,&#39;男&#39;,18,&#39;123456789012345670&#39;,&#39;2005-01-01&#39;);</code></pre><p>3). 批量添加数据</p><pre><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;</code></pre><pre><code>INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;</code></pre><p>注意事项: </p><ul><li>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。</li><li>字符串和日期型数据应该包含在引号中。 </li><li>插入的数据大小，应该在字段的规定范围内。</li></ul><h3 id="2-5-2-修改数据"><a href="#2-5-2-修改数据" class="headerlink" title="2.5.2 修改数据"></a>2.5.2 修改数据</h3><p>修改数据的具体语法为:</p><pre><code>UPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ] ;</code></pre><p>案例:</p><p>A. 修改id为1的数据，将name修改为nametest</p><pre><code>update employee set name = &#39;nametest&#39; where id = 1;</code></pre><p>B. 修改id为1的数据, 将name修改为小昭, gender修改为 女</p><pre><code>update employee set name = &#39;小昭&#39; , gender = &#39;女&#39; where id = 1;</code></pre><p>C. 将所有的员工入职日期修改为 2008-01-01</p><pre><code> update employee set entrydate = &#39;2008-01-01&#39;;</code></pre><p>注意事项: 修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。</p><h3 id="2-5-3-删除数据"><a href="#2-5-3-删除数据" class="headerlink" title="2.5.3 删除数据"></a>2.5.3 删除数据</h3><p>删除数据的具体语法为：</p><pre><code> DELETE FROM 表名 [ WHERE 条件 ] ;</code></pre><p>案例: A. 删除gender为女的员工</p><pre><code> delete from employee where gender = &#39;女&#39;;</code></pre><p>B. 删除所有员工</p><pre><code>delete from employee</code></pre><p>注意事项:</p><ul><li>DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数 据。</li><li>DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即 可)。 </li><li>当进行删除全部数据操作时，datagrip会提示，询问是否确认删除，直接点击 Execute即可。</li></ul><h2 id="2-6-DQL"><a href="#2-6-DQL" class="headerlink" title="2.6 DQL"></a>2.6 DQL</h2><p>DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记 录。</p><p>查询关键字: SELECT</p><p>数据准备</p><pre><code>drop table if exists employee;create table emp(id int comment &#39;编号&#39;,workno varchar(10) comment &#39;工号&#39;,name varchar(10) comment &#39;姓名&#39;,gender char(1) comment &#39;性别&#39;,age tinyint unsigned comment &#39;年龄&#39;,idcard char(18) comment &#39;身份证号&#39;,workaddress varchar(50) comment &#39;工作地址&#39;,entrydate date comment &#39;入职时间&#39;)comment &#39;员工表&#39;;INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (1, &#39;00001&#39;, &#39;柳岩666&#39;, &#39;女&#39;, 20, &#39;123456789012345678&#39;, &#39;北京&#39;, &#39;2000-01-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (2, &#39;00002&#39;, &#39;张无忌&#39;, &#39;男&#39;, 18, &#39;123456789012345670&#39;, &#39;北京&#39;, &#39;2005-09-01&#39;)INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (3, &#39;00003&#39;, &#39;韦一笑&#39;, &#39;男&#39;, 38, &#39;123456789712345670&#39;, &#39;上海&#39;, &#39;2005-08-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (4, &#39;00004&#39;, &#39;赵敏&#39;, &#39;女&#39;, 18, &#39;123456757123845670&#39;, &#39;北京&#39;, &#39;2009-12-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (5, &#39;00005&#39;, &#39;小昭&#39;, &#39;女&#39;, 16, &#39;123456769012345678&#39;, &#39;上海&#39;, &#39;2007-07-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (6, &#39;00006&#39;, &#39;杨逍&#39;, &#39;男&#39;, 28, &#39;12345678931234567X&#39;, &#39;北京&#39;, &#39;2006-01-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (7, &#39;00007&#39;, &#39;范瑶&#39;, &#39;男&#39;, 40, &#39;123456789212345670&#39;, &#39;北京&#39;, &#39;2005-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (8, &#39;00008&#39;, &#39;黛绮丝&#39;, &#39;女&#39;, 38, &#39;123456157123645670&#39;, &#39;天津&#39;, &#39;2015-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (9, &#39;00009&#39;, &#39;范凉凉&#39;, &#39;女&#39;, 45, &#39;123156789012345678&#39;, &#39;北京&#39;, &#39;2010-04-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (10, &#39;00010&#39;, &#39;陈友谅&#39;, &#39;男&#39;, 53, &#39;123456789012345670&#39;, &#39;上海&#39;, &#39;2011-01-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (11, &#39;00011&#39;, &#39;张士诚&#39;, &#39;男&#39;, 55, &#39;123567897123465670&#39;, &#39;江苏&#39;, &#39;2015-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (12, &#39;00012&#39;, &#39;常遇春&#39;, &#39;男&#39;, 32, &#39;123446757152345670&#39;, &#39;北京&#39;, &#39;2004-02-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (13, &#39;00013&#39;, &#39;张三丰&#39;, &#39;男&#39;, 88, &#39;123656789012345678&#39;, &#39;江苏&#39;, &#39;2020-11-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (14, &#39;00014&#39;, &#39;灭绝&#39;, &#39;女&#39;, 65, &#39;123456719012345670&#39;, &#39;西安&#39;, &#39;2019-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (15, &#39;00015&#39;, &#39;胡青牛&#39;, &#39;男&#39;, 70, &#39;12345674971234567X&#39;, &#39;西安&#39;, &#39;2018-04-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (16, &#39;00016&#39;, &#39;周芷若&#39;, &#39;女&#39;, 18, null, &#39;北京&#39;, &#39;2012-06-01&#39;);</code></pre><h3 id="2-6-1-基本语法"><a href="#2-6-1-基本语法" class="headerlink" title="2.6.1 基本语法"></a>2.6.1 基本语法</h3><p>DQL 查询语句，语法结构如下：</p><pre><code>SELECT    字段列表FROM    表名列表WHERE    条件列表GROUP BY    分组字段列表HAVING    分组后条件列表ORDER BY    排序字段列表LIMIT    分页参数</code></pre><h3 id="2-6-2-基础查询"><a href="#2-6-2-基础查询" class="headerlink" title="2.6.2 基础查询"></a>2.6.2 基础查询</h3><p>1). 查询多个字段</p><pre><code>SELECT 字段1, 字段2, 字段3 ... FROM 表名 ;</code></pre><pre><code>SELECT * FROM 表名 ；</code></pre><p>注意 : * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。</p><p>2). 字段设置别名</p><pre><code> SELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名;</code></pre><pre><code> SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;</code></pre><p>3). 去除重复记录</p><pre><code>SELECT DISTINCT 字段列表 FROM 表名;</code></pre><h3 id="2-6-3-条件查询"><a href="#2-6-3-条件查询" class="headerlink" title="2.6.3 条件查询"></a>2.6.3 条件查询</h3><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 WHERE 条件列表 ;</code></pre><p>2). 条件</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">等号，检测两个值是否相等，如果相等返回true</td><td align="left">(A = B) 返回false。</td></tr><tr><td align="left">&lt;&gt;, !=</td><td align="left">不等于，检测两个值是否相等，如果不相等返回true</td><td align="left">(A != B) 返回 true。</td></tr><tr><td align="left">&gt;</td><td align="left">大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true</td><td align="left">(A &gt; B) 返回false。</td></tr><tr><td align="left">&lt;</td><td align="left">小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true</td><td align="left">(A &lt; B) 返回 true。</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true</td><td align="left">(A &gt;= B) 返回false。</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于号，检测左边的值是否小于或等于右边的值, 如果左边的值小于或等于右边的值返回true</td><td align="left">(A &lt;= B) 返回 true。</td></tr><tr><td align="left">BETWEEN … AND …</td><td align="left">在某个范围之内(含最小、最大值)</td><td align="left">(between15 and 20) 返回15到20之间</td></tr><tr><td align="left">IN(…)</td><td align="left">在in之后的列表中的值，多选一</td><td align="left">[in(18,80,40) ] 返回18，20，40</td></tr><tr><td align="left">LIKE 占位符</td><td align="left">模糊匹配(_匹配单个字符, %匹配任意个字符)</td><td align="left"></td></tr><tr><td align="left">IS NULL</td><td align="left">是NULL</td><td align="left"></td></tr></tbody></table><h3 id="2-6-4-聚合函数"><a href="#2-6-4-聚合函数" class="headerlink" title="2.6.4 聚合函数"></a>2.6.4 聚合函数</h3><p>1). 介绍</p><p>将一列数据作为一个整体，进行纵向计算 。</p><p>2). 常见的聚合函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p>3). 语法</p><pre><code> SELECT 聚合函数(字段列表) FROM 表名 ;</code></pre><p>注意 : NULL值是不参与所有聚合函数运算的。</p><p>案例：</p><p>A. 统计该企业员工数量</p><pre><code>select count(*) from emp; -- 统计的是总记录数select count(idcard) from emp; -- 统计的是idcard字段不为null的记录数</code></pre><p>对于count聚合函数，统计符合条件的总记录数，还可以通过 count(数字/字符串)的形式进行统计 查询，比如：</p><pre><code> select count(1) from emp;</code></pre><h3 id="2-6-5-分组查询"><a href="#2-6-5-分组查询" class="headerlink" title="2.6.5 分组查询"></a>2.6.5 分组查询</h3><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后过滤条件 ];</code></pre><p>2). where与having区别 执行时机不同：</p><ul><li>where是分组之前进行过滤，不满足where条件，不参与分组；</li><li>而having是分组 之后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><p>案例:</p><p>A. 根据性别分组 , 统计男性员工 和 女性员工的数量</p><pre><code>select gender, count(*) from emp group by gender ;</code></pre><p>B. 根据性别分组 , 统计男性员工 和 女性员工的平均年龄</p><pre><code> select gender, avg(age) from emp group by gender ;</code></pre><p>C. 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址</p><pre><code>select workaddress, count(*) address_count from emp where age &lt; 45 group byworkaddress having address_count &gt;= 3;</code></pre><p>D. 统计各个工作地址上班的男性及女性员工的数量</p><pre><code>select workaddress, gender, count(*) &#39;数量&#39; from emp group by gender , workaddress;</code></pre><h3 id="2-6-6-排序查询"><a href="#2-6-6-排序查询" class="headerlink" title="2.6.6 排序查询"></a>2.6.6 排序查询</h3><p>排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序</p><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ;</code></pre><p>2). 排序方式</p><ul><li>ASC : 升序(默认值) </li><li>DESC: 降序</li></ul><p>注意事项：</p><ul><li>如果是升序, 可以不指定排序方式ASC ; </li><li>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;</li></ul><h3 id="2-6-7-分页查询"><a href="#2-6-7-分页查询" class="headerlink" title="2.6.7 分页查询"></a>2.6.7 分页查询</h3><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;</code></pre><p>注意事项: </p><p>起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数。 </p><p>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。 </p><p>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</p><p>案例: </p><p>A. 查询第1页员工数据, 每页展示10条记录</p><pre><code>select * from emp limit 0,10;select * from emp limit 10;</code></pre><p>B. 查询第2页员工数据, 每页展示10条记录 ——–&gt; (页码-1)*页展示记录数</p><pre><code> select * from emp limit 10,10;</code></pre><h3 id="2-6-9-执行顺序"><a href="#2-6-9-执行顺序" class="headerlink" title="2.6.9 执行顺序"></a>2.6.9 执行顺序</h3><p><img src="/mysql-01/image-20230318153026758.png" alt="image-20230318153026758"></p><p>执行顺序为</p><p>from … where … group by … having … select … order by … limit …</p><h2 id="2-7-DCL"><a href="#2-7-DCL" class="headerlink" title="2.7 DCL"></a>2.7 DCL</h2><p>DCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访 问权限。</p><h3 id="2-7-1-管理用户"><a href="#2-7-1-管理用户" class="headerlink" title="2.7.1 管理用户"></a>2.7.1 管理用户</h3><p>1). 查询用户</p><pre><code>select * from mysql.user;</code></pre><p><img src="/mysql-01/image-20230318153333941.png" alt="image-20230318153333941"></p><p>其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以 远程访问的。 User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一 个用户。</p><p>2). 创建用户</p><pre><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></pre><p>3). 修改用户密码</p><pre><code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39; ;</code></pre><p>4). 删除用户</p><pre><code>DROP USER &#39;用户名&#39;@&#39;主机名&#39; ;</code></pre><p>注意事项:</p><ul><li>在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。</li><li>主机名可以使用 % 通配。 </li></ul><h3 id="2-7-2-权限控制"><a href="#2-7-2-权限控制" class="headerlink" title="2.7.2 权限控制"></a>2.7.2 权限控制</h3><p>Mysql中常用的的权限</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库/表/视图</td></tr><tr><td>CREATE</td><td>创建数据库/表</td></tr></tbody></table><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" target="_blank" rel="noopener">MySQL :: MySQL 8.0 Reference Manual :: 6.2.2 Privileges Provided by MySQL</a></p><p>1). 查询权限</p><pre><code> SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39; ;</code></pre><p>2). 授予权限</p><pre><code> GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>3). 撤销权限</p><pre><code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>注意事项： • 多个权限之间，使用逗号分隔 • 授权时， 数据库名和表名可以使用 * 进行通配，代表所有。</p><h1 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h1><p>函数 是指一段可以直接被另一段程序调用的程序或代码。 也就意味着，这一段程序或代码在MySQL中 已经给我们提供了，我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可</p><p>MySQL中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数。</p><h2 id="3-1-字符串函数"><a href="#3-1-字符串函数" class="headerlink" title="3.1 字符串函数"></a>3.1 字符串函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(S1,S2,…Sn)</td><td>字符串拼接，将S1，S2，… Sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串str全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串str全部转为大写</td></tr><tr><td>LPAD(str,n,pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符 串长度</td></tr><tr><td>RPAD(str,n,pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符 串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str,start,len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><p>lpad : 左填充</p><pre><code>select lpad(&#39;01&#39;, 5, &#39;-&#39;);</code></pre><p>trim : 去除空格</p><pre><code>select trim(&#39; Hello MySQL &#39;)</code></pre><p>substring : 截取子字符串</p><pre><code> select substring(&#39;Hello MySQL&#39;,1,5);</code></pre><h2 id="3-2-数值函数"><a href="#3-2-数值函数" class="headerlink" title="3.2 数值函数"></a>3.2 数值函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x,y)</td><td>返回x/y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x,y)</td><td>求参数x的四舍五入的值，保留y位小数</td></tr></tbody></table><h2 id="3-3-日期函数"><a href="#3-3-日期函数" class="headerlink" title="3.3 日期函数"></a>3.3 日期函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期/时间值加上一个时间间隔expr后的 时间值</td></tr><tr><td>DATEDIFF(date1,date2)</td><td>返回起始时间date1 和 结束时间date2之间的天 数</td></tr></tbody></table><h2 id="3-4-流程函数"><a href="#3-4-流程函数" class="headerlink" title="3.4 流程函数"></a>3.4 流程函数</h2><p>流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value , t , f)</td><td>如果value为true，则返回t，否则返回 f</td></tr><tr><td>IFNULL(value1 , value2)</td><td>如果value1不为空，返回value1，否则 返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否 则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td><td>如果expr的值等于val1，返回 res1，… 否则返回default默认值</td></tr></tbody></table><p>需求: 查询emp表的员工姓名和工作地址 (北京/上海 —-&gt; 一线城市 , 其他 —-&gt; 二线城市)</p><pre><code>selectname,( case workaddress when &#39;北京&#39; then &#39;一线城市&#39; when &#39;上海&#39; then &#39;一线城市&#39; else&#39;二线城市&#39; end ) as &#39;工作地址&#39;from emp;</code></pre><h1 id="4-约束"><a href="#4-约束" class="headerlink" title="4.约束"></a>4.约束</h1><p>概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。</p><p> 目的：保证数据库中数据的正确、有效性和完整性。</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束(8.0.16版本 之后)</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张表的数据之间建立连接，保证数据的一致 性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><p>注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。</p><h2 id="4-3-外键约束"><a href="#4-3-外键约束" class="headerlink" title="4.3 外键约束"></a>4.3 外键约束</h2><p>外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</p><p><img src="/mysql-01/image-20230318161258249.png" alt="image-20230318161258249"></p><p>左侧的emp表是员工表，里面存储员工的基本信息，包含员工的ID、姓名、年龄、职位、薪资、入职日 期、上级主管ID、部门ID，在员工的信息中存储的是部门的ID dept_id，而这个部门的ID是关联的 部门表dept的主键id，那emp表的dept_id就是外键,关联的是另一张表的主键。</p><p>注意：目前上述两张表，只是在逻辑上存在这样一层关系；在数据库层面，并未建立外键关联， 所以是无法保证数据的一致性和完整性的。</p><h3 id="4-3-2-语法"><a href="#4-3-2-语法" class="headerlink" title="4.3.2 语法"></a>4.3.2 语法</h3><p>1). 添加外键</p><pre><code>CREATE TABLE 表名(    字段名 数据类型,    ...    [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名));</code></pre><pre><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名)REFERENCES 主表 (主表列名) ;</code></pre><p>为emp表的dept_id字段添加外键约束,关联dept表的主键id。</p><pre><code>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id);</code></pre><p><img src="/mysql-01/image-20230318161641788.png" alt="image-20230318161641788"></p><p>添加了外键约束之后，到dept表(父表)删除id为1的记录。 此时 将会报错，不能删除或更新父表记录，因为存在外键约束。</p><p>2). 删除外键</p><pre><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</code></pre><p>案例： 删除emp表的外键fk_emp_dept_id。</p><pre><code>alter table emp drop foreign key fk_emp_dept_id;</code></pre><h3 id="4-3-3-删除-更新行为"><a href="#4-3-3-删除-更新行为" class="headerlink" title="4.3.3 删除/更新行为"></a>4.3.3 删除/更新行为</h3><p>添加了外键之后，再删除父表数据时产生的约束行为，称为删除/更新行为。具体的删除/更新行 为有以下几种</p><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 RESTRICT 一致) 默认行为</td></tr><tr><td>RESTRICT</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 NO ACTION 一致) 默认行为</td></tr><tr><td>CASCADE</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则 也删除/更新外键在子表中的记录。</td></tr><tr><td>SET NULL</td><td>当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表 中该外键值为null（这就要求该外键允许取null）。</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)</td></tr></tbody></table><p>具体语法为:</p><pre><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;</code></pre><p>演示如下：</p><p>1). CASCADE</p><pre><code>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id) on update cascade on delete cascade ;</code></pre><p>A. 修改父表id为1的记录，将id修改为6</p><p><img src="/mysql-01/image-20230318162417947.png" alt="image-20230318162417947"></p><p>原来在子表中dept_id值为1的记录，现在也变为6了，这就是cascade级联的效果。</p><p>在一般的业务系统中，不会修改一张表的主键值。</p><p>B. 删除父表id为6的记录</p><p><img src="/mysql-01/image-20230318162446703.png" alt="image-20230318162446703"></p><p>父表的数据删除成功了，但是子表中关联的记录也被级联删除了。</p><p>2). SET NULL</p><pre><code>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id) on update set null on delete set null ;</code></pre><p><img src="/mysql-01/image-20230318162633853.png" alt="image-20230318162633853"></p><p>父表的记录是可以正常的删除的，父表的数据删除之后，再打开子表 emp，发现子表emp 的dept_id字段，原来dept_id为1的数据，现在都被置为NULL了。</p><p><img src="/mysql-01/image-20230318162649038.png" alt="image-20230318162649038"></p><h1 id="5-多表查询"><a href="#5-多表查询" class="headerlink" title="5.多表查询"></a>5.多表查询</h1><h2 id="5-1-多表关系"><a href="#5-1-多表关系" class="headerlink" title="5.1 多表关系"></a>5.1 多表关系</h2><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结 构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：</p><ul><li>一对多(多对一)</li><li>多对多</li><li>一对一</li></ul><h3 id="5-1-1-一对多"><a href="#5-1-1-一对多" class="headerlink" title="5.1.1 一对多"></a>5.1.1 一对多</h3><ul><li>案例: 部门 与 员工的关系</li><li>关系: 一个部门对应多个员工，一个员工对应一个部门 </li><li>实现: 在多的一方建立外键，指向一的一方的主键</li></ul><p><img src="/mysql-01/image-20230318163215620.png" alt="image-20230318163215620"></p><h3 id="5-1-2-多对多"><a href="#5-1-2-多对多" class="headerlink" title="5.1.2 多对多"></a>5.1.2 多对多</h3><ul><li>案例: 学生 与 课程的关系 </li><li>关系: 一个学生可以选修多门课程，一门课程也可以供多个学生选择 </li><li>实现: 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</li></ul><p><img src="/mysql-01/image-20230318163305957.png" alt="image-20230318163305957"></p><p>约束语句：</p><pre><code>constraint fk_courseid foreign key (courseid) references course (id),constraint fk_studentid foreign key (studentid) references student (id)</code></pre><h3 id="5-1-3-一对一"><a href="#5-1-3-一对一" class="headerlink" title="5.1.3 一对一"></a>5.1.3 一对一</h3><p>案例: 用户 与 用户详情的关系 关系:</p><p> 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另 一张表中，以提升操作效率 </p><p>实现: 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</p><p><img src="/mysql-01/image-20230318163537120.png" alt="image-20230318163537120"></p><h2 id="5-2-多表查询"><a href="#5-2-多表查询" class="headerlink" title="5.2 多表查询"></a>5.2 多表查询</h2><h3 id="5-2-2-概述"><a href="#5-2-2-概述" class="headerlink" title="5.2.2 概述"></a>5.2.2 概述</h3><p>多表查询就是指从多张表中查询数据。</p><p>原来查询单表数据，执行的SQL形式为：select * from emp;</p><p>那么我们要执行多表查询，就只需要使用逗号分隔多张表即可，如： select * from emp , dept ; 具体的执行结果如下:</p><p><img src="/mysql-01/image-20230318163656019.png" alt="image-20230318163656019"></p><p>此时,查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录 (17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。</p><p>笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况。</p><p><img src="/mysql-01/image-20230318163727372.png" alt="image-20230318163727372"></p><p>而在多表查询中，是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。</p><p><img src="/mysql-01/image-20230318163744086.png" alt="image-20230318163744086"></p><p>给多表查询加上连接查询的条件，消除笛卡尔集。</p><pre><code>select * from emp , dept where emp.dept_id = dept.id;</code></pre><p><img src="/mysql-01/image-20230318163821696.png" alt="image-20230318163821696"></p><p>而由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询 到。</p><h3 id="5-2-3-分类"><a href="#5-2-3-分类" class="headerlink" title="5.2.3 分类"></a>5.2.3 分类</h3><p>连接查询 </p><p>​    内连接：相当于查询A、B交集部分数据     </p><p>​    外连接：     </p><p>​        左外连接：查询左表所有数据，以及两张表交集部分数据     </p><p>​        右外连接：查询右表所有数据，以及两张表交集部分数据     </p><p>​    自连接：当前表与自身的连接查询，自连接必须使用表别名</p><ul><li>子查询</li></ul><p><img src="/mysql-01/image-20230318164141106.png" alt="image-20230318164141106"></p><h2 id="5-3-内连接"><a href="#5-3-内连接" class="headerlink" title="5.3 内连接"></a>5.3 内连接</h2><p><img src="/mysql-01/image-20230318164353496.png" alt="image-20230318164353496"></p><p>内连接查询的是两张表交集部分的数 据。(也就是绿色部分的数据) 内连接的语法分为两种: 隐式内连接、显式内连接。</p><p>1). 隐式内连接</p><pre><code>SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;</code></pre><p>2). 显式内连接</p><pre><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;</code></pre><p>案例: </p><p>A. 查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现) </p><p>表结构: emp , dept </p><p>连接条件: emp.dept_id = dept.id</p><pre><code>select emp.name , dept.name from emp , dept where emp.dept_id = dept.id ;-- 为每一张表起别名,简化SQL编写select e.name,d.name from emp e , dept d where e.dept_id = d.id;</code></pre><p>B. 查询每一个员工的姓名 , 及关联的部门的名称 (显式内连接实现) — INNER JOIN … ON …</p><p>​    表结构: emp , dept </p><p>​    连接条件: emp.dept_id = dept.id</p><pre><code>select e.name, d.name from emp e inner join dept d on e.dept_id = d.id;-- 为每一张表起别名,简化SQL编写select e.name, d.name from emp e join dept d on e.dept_id = d.id;</code></pre><p>注意事项:一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字 段。</p><h2 id="5-4-外连接"><a href="#5-4-外连接" class="headerlink" title="5.4 外连接"></a>5.4 外连接</h2><p><img src="/mysql-01/image-20230318165025944.png" alt="image-20230318165025944"></p><p>外连接分为两种，分别是：左外连接 和 右外连接。具体的语法结构为：</p><p>1). 左外连接</p><pre><code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;</code></pre><p>左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。</p><p>2). 右外连接</p><pre><code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ... ;</code></pre><p>右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。</p><p>案例:</p><p>A.     查询emp表的所有数据, 和对应的部门信息 </p><p>​        由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。         表结构: emp, dept 连接条件: emp.dept_id = dept.id</p><p>​        连接条件: emp.dept_id = dept.id</p><pre><code>select e.*, d.name from emp e left outer join dept d on e.dept_id = d.id;select e.*, d.name from emp e left join dept d on e.dept_id = d.id;</code></pre><p>​    B. 查询dept表的所有数据, 和对应的员工信息(右外连接)</p><p>由于需求中提到，要查询dept表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查 询。 </p><p>​    表结构: emp, dept </p><p>​    连接条件: emp.dept_id = dept.id</p><pre><code>select d.*, e.* from emp e right outer join dept d on e.dept_id = d.id;select d.*, e.* from dept d left outer join emp e on e.dept_id = d.id;</code></pre><p>注意事项： 左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺 序就可以了。日常开发使用时，更偏向于左外连接。</p><h2 id="5-5-自连接"><a href="#5-5-自连接" class="headerlink" title="5.5 自连接"></a>5.5 自连接</h2><h3 id="5-5-1-自连接查询"><a href="#5-5-1-自连接查询" class="headerlink" title="5.5.1 自连接查询"></a>5.5.1 自连接查询</h3><p>自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。</p><pre><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ... ;</code></pre><p>而对于自连接查询，可以是内连接查询，也可以是外连接查询。</p><p>案例： </p><p>A. 查询员工 及其 所属领导的名字 </p><p>表结构: emp</p><pre><code>select a.name , b.name from emp a , emp b where a.managerid = b.id;</code></pre><p>B. 查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来 </p><p>表结构: emp a , emp b</p><p>注意事项: 在自连接查询中，必须要为表起别名，要不然不清楚所指定的条件、返回的字段，到底 是哪一张表的字段</p><h3 id="5-5-2-联合查询"><a href="#5-5-2-联合查询" class="headerlink" title="5.5.2 联合查询"></a>5.5.2 联合查询</h3><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p><pre><code>SELECT 字段列表 FROM 表A ...UNION [ ALL ]SELECT 字段列表 FROM 表B ....;</code></pre><ul><li>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</li><li>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。</li></ul><p>案例: A. 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来. </p><p>当前对于这个需求，可以直接使用多条件查询，使用逻辑运算符 or 连接即可。 也可以通过union/union all来联合查询.</p><p><img src="/mysql-01/image-20230318171722519.png" alt="image-20230318171722519"></p><p>union all查询出来的结果，仅仅进行简单的合并，并未去重</p><pre><code>select * from emp where salary &lt; 5000unionselect * from emp where age &gt; 50;</code></pre><p><img src="/mysql-01/image-20230318171749423.png" alt="image-20230318171749423"></p><p>union 联合查询，会对查询出来的结果进行去重处理。</p><p>注意： 如果多条查询语句查询出来的结果，字段数量不一致，在进行union/union all联合查询时，将会报错。如：</p><p><img src="/mysql-01/image-20230318171808521.png" alt="image-20230318171808521"></p><h2 id="5-6-子查询"><a href="#5-6-子查询" class="headerlink" title="5.6 子查询"></a>5.6 子查询</h2><h3 id="5-6-1-概述"><a href="#5-6-1-概述" class="headerlink" title="5.6.1 概述"></a>5.6.1 概述</h3><p>1). 概念</p><p>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p><pre><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 );</code></pre><p>子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。</p><p>2). 分类</p><p>根据子查询结果不同，分为：</p><p>A. 标量子查询（子查询结果为单个值）</p><p>B. 列子查询(子查询结果为一列) </p><p>C. 行子查询(子查询结果为一行) </p><p>D. 表子查询(子查询结果为多行多列)</p><p>根据子查询位置，分为： </p><p>A. WHERE之后 </p><p>B. FROM之后 </p><p>C. SELECT之后</p><h3 id="5-6-2-标量子查询"><a href="#5-6-2-标量子查询" class="headerlink" title="5.6.2 标量子查询"></a>5.6.2 标量子查询</h3><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。 常用的操作符：= &lt;&gt; &gt; &gt;= &lt; &lt;= </p><p>案例: </p><p>A. 查询 “销售部” 的所有员工信息 </p><p>完成这个需求时，可以将需求分解为两步：</p><p>①. 查询 “销售部” 部门ID</p><pre><code>select id from dept where name = &#39;销售部&#39;;</code></pre><p>②. 根据 “销售部” 部门ID, 查询员工信息</p><pre><code>select * from emp where dept_id = (select id from dept where name = &#39;销售部&#39;);</code></pre><p>B. 查询在 “方东白” 入职之后的员工信息 </p><p>完成这个需求时，可以将需求分解为两步：</p><p>①. 查询 方东白 的入职日期</p><pre><code>select entrydate from emp where name = &#39;方东白&#39;;</code></pre><p>②. 查询指定入职日期之后入职的员工信息</p><pre><code>select * from emp where entrydate &gt; (select entrydate from emp where name = &#39;方东白&#39;);</code></pre><h3 id="5-6-3-列子查询"><a href="#5-6-3-列子查询" class="headerlink" title="5.6.3 列子查询"></a>5.6.3 列子查询</h3><p>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。</p><p>常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围之内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围之内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><p>案例: </p><p>A. 查询 “销售部” 和 “市场部” 的所有员工信息</p><p>分解为以下两步:</p><p> ①. 查询 “销售部” 和 “市场部” 的部门ID</p><pre><code>select id from dept where name = &#39;销售部&#39; or name = &#39;市场部&#39;;</code></pre><p>②. 根据部门ID, 查询员工信息</p><pre><code>select * from emp where dept_id in (select id from dept where name = &#39;销售部&#39; orname = &#39;市场部&#39;);</code></pre><p>B. 查询比 财务部 所有人工资都高的员工信息</p><p>分解为以下两步: ①. 查询所有 财务部 人员工资</p><pre><code>select id from dept where name = &#39;财务部&#39;;select salary from emp where dept_id = (select id from dept where name = &#39;财务部&#39;);</code></pre><p>②. 比 财务部 所有人工资都高的员工信息</p><pre><code>select * from emp where salary &gt; all ( select salary from emp where dept_id =(select id from dept where name = &#39;财务部&#39;) );</code></pre><p>C. 查询比研发部其中任意一人工资高的员工信息</p><p>分解为以下两步:</p><p>①. 查询研发部所有人工资</p><pre><code>select salary from emp where dept_id = (select id from dept where name = &#39;研发部&#39;);</code></pre><p>②. 比研发部其中任意一人工资高的员工信息</p><pre><code>select * from emp where salary &gt; any ( select salary from emp where dept_id =(select id from dept where name = &#39;研发部&#39;) );</code></pre><h3 id="5-6-4-行子查询"><a href="#5-6-4-行子查询" class="headerlink" title="5.6.4 行子查询"></a>5.6.4 行子查询</h3><p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。</p><p> 常用的操作符：= 、&lt;&gt; 、IN 、NOT IN</p><p>案例: </p><p>A. 查询与 “张无忌” 的薪资及直属领导相同的员工信息 ; </p><p>这个需求同样可以拆解为两步进行: </p><p>①. 查询 “张无忌” 的薪资及直属领导</p><pre><code> select salary, managerid from emp where name = &#39;张无忌&#39;;</code></pre><p>②. 查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;</p><pre><code>select * from emp where (salary,managerid) = (select salary, managerid from empwhere name = &#39;张无忌&#39;);</code></pre><h3 id="5-6-5-表子查询"><a href="#5-6-5-表子查询" class="headerlink" title="5.6.5 表子查询"></a>5.6.5 表子查询</h3><p>子查询返回的结果是多行多列，这种子查询称为表子查询。 </p><p>常用的操作符：IN</p><p>案例: </p><p>A. 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><p> 分解为两步执行:</p><p>①. 查询 “鹿杖客” , “宋远桥” 的职位和薪资</p><pre><code>select job, salary from emp where name = &#39;鹿杖客&#39; or name = &#39;宋远桥&#39;;</code></pre><p>②. 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><pre><code>select * from emp where (job,salary) in ( select job, salary from emp where name =&#39;鹿杖客&#39; or name = &#39;宋远桥&#39; );</code></pre><p>B. 查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息</p><p>分解为两步执行:</p><p>①. 入职日期是 “2006-01-01” 之后的员工信息</p><pre><code>select * from emp where entrydate &gt; &#39;2006-01-01&#39;;</code></pre><p>②. 查询这部分员工, 对应的部门信息;</p><pre><code>select e.*, d.* from (select * from emp where entrydate &gt; &#39;2006-01-01&#39;) e leftjoin dept d on e.dept_id = d.id ;</code></pre><h1 id="6-事务"><a href="#6-事务" class="headerlink" title="6.事务"></a>6.事务</h1><h2 id="6-1-事务简介"><a href="#6-1-事务简介" class="headerlink" title="6.1 事务简介"></a>6.1 事务简介</h2><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>就比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加 1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。</p><p><img src="/mysql-01/image-20230318175145463.png" alt="image-20230318175145463"></p><p>正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四 增加1000, 转账成功 :</p><p><img src="/mysql-01/image-20230318175413465.png" alt="image-20230318175413465"></p><p>异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张 三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了。</p><p><img src="/mysql-01/image-20230318175427146.png" alt="image-20230318175427146"></p><p>为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行 完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。</p><p><img src="/mysql-01/image-20230318175441174.png" alt="image-20230318175441174"></p><p>注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐 式的提交事务。</p><h2 id="6-2-事务操作"><a href="#6-2-事务操作" class="headerlink" title="6.2 事务操作"></a>6.2 事务操作</h2><h3 id="6-2-1-未控制事务"><a href="#6-2-1-未控制事务" class="headerlink" title="6.2.1 未控制事务"></a>6.2.1 未控制事务</h3><p>正常执行</p><p><img src="/mysql-01/image-20230318175558427.png" alt="image-20230318175558427"></p><p> 测试异常情况</p><pre><code>-- 1. 查询张三余额select * from account where name = &#39;张三&#39;;-- 2. 张三的余额减少1000update account set money = money - 1000 where name = &#39;张三&#39;;出错了....-- 3. 李四的余额增加1000update account set money = money + 1000 where name = &#39;李四&#39;;</code></pre><p><img src="/mysql-01/image-20230318175542807.png" alt="image-20230318175542807"></p><p>检查最终的数据情况, 发现数据在操作前后不一致了。</p><h3 id="6-2-2-控制事务一"><a href="#6-2-2-控制事务一" class="headerlink" title="6.2.2 控制事务一"></a>6.2.2 控制事务一</h3><p>1). 查看/设置事务提交方式</p><pre><code>SELECT @@autocommit ;SET @@autocommit = 0 ;</code></pre><p>2). 提交事务</p><pre><code>COMMIT;</code></pre><p>3). 回滚事务</p><pre><code>ROLLBACK;</code></pre><p>注意：上述的这种方式，是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提 交, 此时执行的DML语句都不会提交, 需要手动的执行commit进行提交。</p><h3 id="6-2-3-控制事务二"><a href="#6-2-3-控制事务二" class="headerlink" title="6.2.3 控制事务二"></a>6.2.3 控制事务二</h3><p>1). 开启事务</p><pre><code>START TRANSACTION 或 BEGIN ;</code></pre><p>2). 提交事务</p><pre><code>COMMIT;</code></pre><p>3). 回滚事务</p><pre><code>ROLLBACK;</code></pre><p>转账案例：</p><pre><code>-- 开启事务start transaction-- 1. 查询张三余额select * from account where name = &#39;张三&#39;;-- 2. 张三的余额减少1000update account set money = money - 1000 where name = &#39;张三&#39;;-- 3. 李四的余额增加1000update account set money = money + 1000 where name = &#39;李四&#39;;-- 如果正常执行完毕, 则提交事务commit;-- 如果执行过程中报错, 则回滚事务-- rollback;</code></pre><h3 id="6-3-事务四大特性"><a href="#6-3-事务四大特性" class="headerlink" title="6.3 事务四大特性"></a>6.3 事务四大特性</h3><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 </li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><p><img src="/mysql-01/image-20230318180214740.png" alt="image-20230318180214740"></p><h3 id="6-4-并发事务问题"><a href="#6-4-并发事务问题" class="headerlink" title="6.4 并发事务问题"></a>6.4 并发事务问题</h3><p>1). 赃读：一个事务读到另外一个事务还没有提交的数据。</p><p><img src="/mysql-01/image-20230318180237160.png" alt="image-20230318180237160"></p><p>比如B读取到了A未提交的数据。</p><p>2). 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p><p><img src="/mysql-01/image-20230318180253685.png" alt="image-20230318180253685"></p><p> 事务A两次读取同一条记录，但是读取到的数据却是不一样的。</p><p>3). 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 “幻影”。</p><p><img src="/mysql-01/image-20230318180423731.png" alt="image-20230318180423731"></p><h3 id="6-5-事务隔离级别"><a href="#6-5-事务隔离级别" class="headerlink" title="6.5 事务隔离级别"></a>6.5 事务隔离级别</h3><p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>1). 查看事务隔离级别</p><pre><code>SELECT @@TRANSACTION_ISOLATION;</code></pre><p>2). 设置事务隔离级别</p><pre><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED |READ COMMITTED | REPEATABLE READ | SERIALIZABLE }</code></pre><p>注意：事务隔离级别越高，数据越安全，但是性能越低。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
