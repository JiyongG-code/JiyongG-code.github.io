<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/rabbitmq.html"/>
      <url>/rabbitmq.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-初识MQ"><a href="#1-初识MQ" class="headerlink" title="1.初识MQ"></a>1.初识MQ</h1><h2 id="1-1-同步和异步通讯"><a href="#1-1-同步和异步通讯" class="headerlink" title="1.1.同步和异步通讯"></a>1.1.同步和异步通讯</h2><p>微服务间通讯有同步和异步两种方式：</p><p>同步通讯：就像打电话，需要实时响应。</p><p>异步通讯：就像发邮件，不需要马上回复。</p><p><img src="/rabbitmq/image-20210717161939695.png" alt="image-20210717161939695"></p><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发送邮件可以同时与多个人收发邮件，但是往往响应会有延迟。</p><h3 id="1-1-1-同步通讯"><a href="#1-1-1-同步通讯" class="headerlink" title="1.1.1.同步通讯"></a>1.1.1.同步通讯</h3><p><img src="/rabbitmq/image-20210717162004285.png" alt="image-20210717162004285"></p><p>总结：</p><p>同步调用的优点：</p><ul><li>时效性较强，可以立即得到结果</li></ul><p>同步调用的问题：</p><ul><li>耦合度高</li><li>性能和吞吐能力下降</li><li>有额外的资源消耗</li><li>有级联失败问题</li></ul><h3 id="1-1-2-异步通讯"><a href="#1-1-2-异步通讯" class="headerlink" title="1.1.2.异步通讯"></a>1.1.2.异步通讯</h3><p>异步调用则可以避免上述问题：</p><p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p><p>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单id。</p><p>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</p><p>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</p><p><img src="/rabbitmq/image-20210422095356088.png" alt="image-20210422095356088"></p><p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p><p>好处：</p><ul><li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p></li><li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p></li><li><p>调用间没有阻塞，不会造成无效的资源占用</p></li><li><p>耦合度极低，每个服务都可以灵活插拔，可替换</p></li><li><p>流量削峰：不管发布事件的流量波动多大，都由Broker接收，订阅者可以按照自己的速度去处理事件</p></li></ul><p>缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于Broker的可靠、安全、性能</li></ul><h2 id="1-2-技术对比："><a href="#1-2-技术对比：" class="headerlink" title="1.2.技术对比："></a>1.2.技术对比：</h2><p>MQ，中文是消息队列（MessageQueue），字面来看就是存放消息的队列。也就是事件驱动架构中的Broker。</p><p>比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司/社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><p>MQ的基本结构：</p><p><img src="/rabbitmq/image-20210717162752376.png" alt="image-20210717162752376"></p><p>RabbitMQ中的一些角色：</p><ul><li>publisher：生产者</li><li>consumer：消费者</li><li>exchange个：交换机，负责消息路由</li><li>queue：队列，存储消息</li><li>virtualHost：虚拟主机，隔离不同租户的exchange、queue、消息的隔离</li></ul><h2 id="2-2-RabbitMQ消息模型"><a href="#2-2-RabbitMQ消息模型" class="headerlink" title="2.2.RabbitMQ消息模型"></a>2.2.RabbitMQ消息模型</h2><p>RabbitMQ官方提供了5个不同的Demo示例，对应了不同的消息模型：</p><p><img src="/rabbitmq/image-20210717163332646.png" alt="image-20210717163332646"></p><p>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><h2 id="2-4-入门案例"><a href="#2-4-入门案例" class="headerlink" title="2.4.入门案例"></a>2.4.入门案例</h2><p>简单队列模式的模型图：</p><p> <img src="/rabbitmq/image-20210717163434647.png" alt="image-20210717163434647"></p><p>官方的HelloWorld是基于最基础的消息队列模型来实现的，只包括三个角色：</p><ul><li>publisher：消息发布者，将消息发送到队列queue</li><li>queue：消息队列，负责接受并缓存消息</li><li>consumer：订阅队列，处理队列中的消息</li></ul><h3 id="2-4-1-publisher实现"><a href="#2-4-1-publisher实现" class="headerlink" title="2.4.1.publisher实现"></a>2.4.1.publisher实现</h3><p>思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>发送消息</li><li>关闭连接和channel</li></ul><p>代码实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>helloworld<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Channel<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>Connection<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>ConnectionFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeoutException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PublisherTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1.建立连接</span>        ConnectionFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span>        factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"192.168.150.101"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"itcast"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123321"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1.2.建立连接</span>        Connection connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2.创建通道Channel</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.创建队列</span>        String queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 4.发送消息</span>        String message <span class="token operator">=</span> <span class="token string">"hello, rabbitmq!"</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">basicPublish</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> queueName<span class="token punctuation">,</span> null<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送消息成功：【"</span> <span class="token operator">+</span> message <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 5.关闭通道和连接</span>        channel<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-2-consumer实现"><a href="#2-4-2-consumer实现" class="headerlink" title="2.4.2.consumer实现"></a>2.4.2.consumer实现</h3><p>代码思路：</p><ul><li>建立连接</li><li>创建Channel</li><li>声明队列</li><li>订阅消息</li></ul><p>代码实现：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>helloworld<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rabbitmq<span class="token punctuation">.</span>client<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeoutException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsumerTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1.建立连接</span>        ConnectionFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span>        factory<span class="token punctuation">.</span><span class="token function">setHost</span><span class="token punctuation">(</span><span class="token string">"192.168.150.101"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">5672</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setVirtualHost</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"itcast"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        factory<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123321"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1.2.建立连接</span>        Connection connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2.创建通道Channel</span>        Channel channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">createChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.创建队列</span>        String queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>        channel<span class="token punctuation">.</span><span class="token function">queueDeclare</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 4.订阅消息</span>        channel<span class="token punctuation">.</span><span class="token function">basicConsume</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleDelivery</span><span class="token punctuation">(</span>String consumerTag<span class="token punctuation">,</span> Envelope envelope<span class="token punctuation">,</span>                                       AMQP<span class="token punctuation">.</span>BasicProperties properties<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> body<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 5.处理消息</span>                String message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到消息：【"</span> <span class="token operator">+</span> message <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等待接收消息。。。。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5.总结"></a>2.5.总结</h2><p>基本消息队列的消息发送流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>利用channel向队列发送消息</p></li></ol><p>基本消息队列的消息接收流程：</p><ol><li><p>建立connection</p></li><li><p>创建channel</p></li><li><p>利用channel声明队列</p></li><li><p>定义consumer的消费行为handleDelivery()</p></li><li><p>利用channel将消费者与队列绑定</p></li></ol><h1 id="3-SpringAMQP"><a href="#3-SpringAMQP" class="headerlink" title="3.SpringAMQP"></a>3.SpringAMQP</h1><p>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>SpringAmqp的官方地址：<a href="https://spring.io/projects/spring-amqp" target="_blank" rel="noopener">https://spring.io/projects/spring-amqp</a></p><p><img src="/rabbitmq/image-20210717164024967.png" alt="image-20210717164024967"></p><p><img src="/rabbitmq/image-20210717164038678.png" alt="image-20210717164038678"></p><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息 </li></ul><h2 id="3-1-Basic-Queue-简单队列模型"><a href="#3-1-Basic-Queue-简单队列模型" class="headerlink" title="3.1.Basic Queue 简单队列模型"></a>3.1.Basic Queue 简单队列模型</h2><p>在父工程mq-demo中引入依赖</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--AMQP依赖，包含RabbitMQ--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-1-消息发送"><a href="#3-1-1-消息发送" class="headerlink" title="3.1.1.消息发送"></a>3.1.1.消息发送</h3><p>首先配置MQ地址，在publisher服务的application.yml中添加配置：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 主机名</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672 </span><span class="token comment" spellcheck="true"># 端口</span>    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> / <span class="token comment" spellcheck="true"># 虚拟主机</span>    <span class="token key atrule">username</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 用户名</span>    <span class="token key atrule">password</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p><p>然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>spring<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>RunWith<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>core<span class="token punctuation">.</span>RabbitTemplate<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>SpringBootTest<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>junit4<span class="token punctuation">.</span>SpringRunner<span class="token punctuation">;</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringAmqpTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> RabbitTemplate rabbitTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSimpleQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 队列名称</span>        String queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 消息</span>        String message <span class="token operator">=</span> <span class="token string">"hello, spring amqp!"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 发送消息</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-2-消息接收"><a href="#3-1-2-消息接收" class="headerlink" title="3.1.2.消息接收"></a>3.1.2.消息接收</h3><p>首先配置MQ地址，在consumer服务的application.yml中添加配置：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 主机名</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672 </span><span class="token comment" spellcheck="true"># 端口</span>    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> / <span class="token comment" spellcheck="true"># 虚拟主机</span>    <span class="token key atrule">username</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 用户名</span>    <span class="token key atrule">password</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在consumer服务的<code>cn.itcast.mq.listener</code>包中新建一个类SpringRabbitListener，代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>listener<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RabbitListener<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Component<span class="token punctuation">;</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringRabbitListener</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenSimpleQueueMessage</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"spring 消费者接收到消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-3-测试"><a href="#3-1-3-测试" class="headerlink" title="3.1.3.测试"></a>3.1.3.测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息</p><h2 id="3-2-WorkQueue"><a href="#3-2-WorkQueue" class="headerlink" title="3.2.WorkQueue"></a>3.2.WorkQueue</h2><p>Work queues，也被称为（Task queues），任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。</p><p><img src="/rabbitmq/image-20210717164238910.png" alt="image-20210717164238910"></p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p><p>此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p><h3 id="3-2-1-消息发送"><a href="#3-2-1-消息发送" class="headerlink" title="3.2.1.消息发送"></a>3.2.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。</p><p>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * workQueue     * 向队列中不停发送消息，模拟消息堆积。     */</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 队列名称</span>    String queueName <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 消息</span>    String message <span class="token operator">=</span> <span class="token string">"hello, message_"</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 发送消息</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>queueName<span class="token punctuation">,</span> message <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-2-消息接收"><a href="#3-2-2-消息接收" class="headerlink" title="3.2.2.消息接收"></a>3.2.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenWorkQueue1</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者1接收到消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span> <span class="token operator">+</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenWorkQueue2</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者2........接收到消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span> <span class="token operator">+</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意到这个消费者sleep了1000秒，模拟任务耗时。</p><h3 id="3-2-3-测试"><a href="#3-2-3-测试" class="headerlink" title="3.2.3.测试"></a>3.2.3.测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。</p><p>可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。</p><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。</p><h3 id="3-2-4-能者多劳"><a href="#3-2-4-能者多劳" class="headerlink" title="3.2.4.能者多劳"></a>3.2.4.能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">listener</span><span class="token punctuation">:</span>      <span class="token key atrule">simple</span><span class="token punctuation">:</span>        <span class="token key atrule">prefetch</span><span class="token punctuation">:</span> <span class="token number">1 </span><span class="token comment" spellcheck="true"># 每次只能获取一条消息，处理完成才能获取下一个消息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-5-总结"><a href="#3-2-5-总结" class="headerlink" title="3.2.5.总结"></a>3.2.5.总结</h3><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="3-3-发布-订阅"><a href="#3-3-发布-订阅" class="headerlink" title="3.3.发布/订阅"></a>3.3.发布/订阅</h2><p>发布订阅的模型如图：</p><p><img src="/rabbitmq/image-20210717165309625.png" alt="image-20210717165309625"></p><p>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li>Publisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）</li><li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定routing key 的队列</li><li>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</li></ul></li><li>Consumer：消费者，与以前一样，订阅队列，没有变化</li><li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><h2 id="3-4-Fanout"><a href="#3-4-Fanout" class="headerlink" title="3.4.Fanout"></a>3.4.Fanout</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。</p><p><img src="/rabbitmq/image-20210717165438225.png" alt="image-20210717165438225"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><ul><li>创建一个交换机 ，类型是广播</li><li>创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout</li></ul><p><img src="/rabbitmq/image-20210717165509466.png" alt="image-20210717165509466"></p><h3 id="3-4-1-声明队列和交换机"><a href="#3-4-1-声明队列和交换机" class="headerlink" title="3.4.1.声明队列和交换机"></a>3.4.1.声明队列和交换机</h3><p>Spring提供了一个接口Exchange，来表示所有不同类型的交换机：</p><p><img src="/rabbitmq/image-20210717165552676.png" alt="image-20210717165552676"></p><p>在consumer中创建一个类，声明队列和交换机：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>config<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span>Binding<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span>BindingBuilder<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span>FanoutExchange<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span>Queue<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Bean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FanoutConfig</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 声明交换机     * @return Fanout类型交换机     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> FanoutExchange <span class="token function">fanoutExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FanoutExchange</span><span class="token punctuation">(</span><span class="token string">"itcast.fanout"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 第1个队列     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Queue <span class="token function">fanoutQueue1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">"fanout.queue1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 绑定队列和交换机     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Binding <span class="token function">bindingQueue1</span><span class="token punctuation">(</span>Queue fanoutQueue1<span class="token punctuation">,</span> FanoutExchange fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> BindingBuilder<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>fanoutQueue1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span>fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 第2个队列     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Queue <span class="token function">fanoutQueue2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">"fanout.queue2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 绑定队列和交换机     */</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Binding <span class="token function">bindingQueue2</span><span class="token punctuation">(</span>Queue fanoutQueue2<span class="token punctuation">,</span> FanoutExchange fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> BindingBuilder<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>fanoutQueue2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span>fanoutExchange<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-2-消息发送"><a href="#3-4-2-消息发送" class="headerlink" title="3.4.2.消息发送"></a>3.4.2.消息发送</h3><h3 id="3-4-2-消息发送-1"><a href="#3-4-2-消息发送-1" class="headerlink" title="3.4.2.消息发送"></a>3.4.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFanoutExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 队列名称</span>    String exchangeName <span class="token operator">=</span> <span class="token string">"itcast.fanout"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 消息</span>    String message <span class="token operator">=</span> <span class="token string">"hello, everyone!"</span><span class="token punctuation">;</span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-3-消息接收"><a href="#3-4-3-消息接收" class="headerlink" title="3.4.3.消息接收"></a>3.4.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"fanout.queue1"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenFanoutQueue1</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者1接收到Fanout消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"fanout.queue2"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenFanoutQueue2</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者2接收到Fanout消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><p>声明队列、交换机、绑定关系的Bean是什么？</p><ul><li>Queue</li><li>FanoutExchange</li><li>Binding</li></ul><h2 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p><img src="/rabbitmq/image-20210717170041447.png" alt="image-20210717170041447"></p><p> 在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><strong>案例需求如下</strong>：</p><ol><li><p>利用@RabbitListener声明Exchange、Queue、RoutingKey</p></li><li><p>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</p></li><li><p>在publisher中编写测试方法，向itcast. direct发送消息</p></li></ol><p><img src="/rabbitmq/image-20210717170223317.png" alt="image-20210717170223317"></p><h3 id="3-5-1-基于注解声明队列和交换机"><a href="#3-5-1-基于注解声明队列和交换机" class="headerlink" title="3.5.1.基于注解声明队列和交换机"></a>3.5.1.基于注解声明队列和交换机</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>    value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"direct.queue1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"itcast.direct"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> ExchangeTypes<span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span><span class="token punctuation">,</span>    key <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenDirectQueue1</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到direct.queue1的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>    value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"direct.queue2"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"itcast.direct"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> ExchangeTypes<span class="token punctuation">.</span>DIRECT<span class="token punctuation">)</span><span class="token punctuation">,</span>    key <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"yellow"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenDirectQueue2</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到direct.queue2的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-2-消息发送"><a href="#3-5-2-消息发送" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><h3 id="3-5-2-消息发送-1"><a href="#3-5-2-消息发送-1" class="headerlink" title="3.5.2.消息发送"></a>3.5.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendDirectExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 交换机名称</span>    String exchangeName <span class="token operator">=</span> <span class="token string">"itcast.direct"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 消息</span>    String message <span class="token operator">=</span> <span class="token string">"红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 发送消息</span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-3-总结"><a href="#3-5-3-总结" class="headerlink" title="3.5.3.总结"></a>3.5.3.总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p><ul><li>@Queue</li><li>@Exchange</li></ul><h2 id="3-6-Topic"><a href="#3-6-Topic" class="headerlink" title="3.6.Topic"></a>3.6.Topic</h2><h3 id="3-6-1-说明"><a href="#3-6-1-说明" class="headerlink" title="3.6.1.说明"></a>3.6.1.说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p><p><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p><p> 通配符规则：</p><p><code>#</code>：匹配一个或多个词</p><p><code>*</code>：匹配不多不少恰好1个词</p><p>举例：</p><p><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></p><p><code>item.*</code>：只能匹配<code>item.spu</code></p><p>​     </p><p>图示：</p><p> <img src="/rabbitmq/image-20210717170705380.png" alt="image-20210717170705380"></p><p>解释：</p><ul><li>Queue1：绑定的是<code>china.#</code> ，因此凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到。包括china.news和china.weather</li><li>Queue2：绑定的是<code>#.news</code> ，因此凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括china.news和japan.news</li></ul><p>案例需求：</p><p>实现思路如下：</p><ol><li><p>并利用@RabbitListener声明Exchange、Queue、RoutingKey</p></li><li><p>在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</p></li><li><p>在publisher中编写测试方法，向itcast. topic发送消息</p></li></ol><p><img src="/rabbitmq/image-20210717170829229.png" alt="image-20210717170829229"></p><h3 id="3-6-2-消息发送"><a href="#3-6-2-消息发送" class="headerlink" title="3.6.2.消息发送"></a>3.6.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * topicExchange     */</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendTopicExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 交换机名称</span>    String exchangeName <span class="token operator">=</span> <span class="token string">"itcast.topic"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 消息</span>    String message <span class="token operator">=</span> <span class="token string">"喜报！孙悟空大战哥斯拉，胜!"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 发送消息</span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>exchangeName<span class="token punctuation">,</span> <span class="token string">"china.news"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-3-消息接收"><a href="#3-6-3-消息接收" class="headerlink" title="3.6.3.消息接收"></a>3.6.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>    value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"topic.queue1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"itcast.topic"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> ExchangeTypes<span class="token punctuation">.</span>TOPIC<span class="token punctuation">)</span><span class="token punctuation">,</span>    key <span class="token operator">=</span> <span class="token string">"china.#"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenTopicQueue1</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到topic.queue1的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>    value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"topic.queue2"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"itcast.topic"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> ExchangeTypes<span class="token punctuation">.</span>TOPIC<span class="token punctuation">)</span><span class="token punctuation">,</span>    key <span class="token operator">=</span> <span class="token string">"#.news"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenTopicQueue2</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费者接收到topic.queue2的消息：【"</span> <span class="token operator">+</span> msg <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-4-总结"><a href="#3-6-4-总结" class="headerlink" title="3.6.4.总结"></a>3.6.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="3-7-消息转换器"><a href="#3-7-消息转换器" class="headerlink" title="3.7.消息转换器"></a>3.7.消息转换器</h2><p>之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p><img src="/rabbitmq/image-20200525170410401.png" alt="image-20200525170410401"></p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>修改消息发送的代码，发送一个Map对象：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 准备消息</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Jack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 发送消息</span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"simple.queue"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>停止consumer服务</p><p>发送消息后查看控制台：</p><p><img src="/rabbitmq/image-20210422232835363.png" alt="image-20210422232835363"></p><h3 id="3-7-2-配置JSON转换器"><a href="#3-7-2-配置JSON转换器" class="headerlink" title="3.7.2.配置JSON转换器"></a>3.7.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><p>在publisher和consumer两个服务中都引入依赖：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.dataformat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-dataformat-xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.9.10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置消息转换器。</p><p>在启动类中添加一个Bean即可：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> MessageConverter <span class="token function">jsonMessageConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonMessageConverter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>消息队列在使用过程中，面临着很多实际问题需要思考：</p><p><img src="/rabbitmq/image-20210718155003157.png" alt="image-20210718155003157"></p><h1 id="1-消息可靠性"><a href="#1-消息可靠性" class="headerlink" title="1.消息可靠性"></a>1.消息可靠性</h1><p>消息从发送，到消费者接收，会经理多个过程：</p><p><img src="/rabbitmq/image-20210718155059371.png" alt="image-20210718155059371"></p><p>其中的每一步都可能导致消息丢失，常见的丢失原因包括：</p><ul><li>发送时丢失：<ul><li>生产者发送的消息未送达exchange</li><li>消息到达exchange后未到达queue</li></ul></li><li>MQ宕机，queue将消息丢失</li><li>consumer接收到消息后未消费就宕机</li></ul><p>针对这些问题，RabbitMQ分别给出了解决方案：</p><ul><li>生产者确认机制</li><li>mq持久化</li><li>消费者确认机制</li><li>失败重试机制</li></ul><h2 id="1-1-生产者消息确认"><a href="#1-1-生产者消息确认" class="headerlink" title="1.1.生产者消息确认"></a>1.1.生产者消息确认</h2><p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。这种机制必须给每个消息指定一个唯一ID。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功。</p><p>返回结果有两种方式：</p><ul><li>publisher-confirm，发送者确认<ul><li>消息成功投递到交换机，返回ack</li><li>消息未投递到交换机，返回nack</li></ul></li><li>publisher-return，发送者回执<ul><li>消息投递到交换机了，但是没有路由到队列。返回ACK，及路由失败原因。</li></ul></li></ul><p><img src="/rabbitmq/image-20210718160907166.png" alt="image-20210718160907166"></p><p>注意：</p><p><img src="/rabbitmq/image-20210718161707992.png" alt="image-20210718161707992"></p><h3 id="1-1-1-修改配置"><a href="#1-1-1-修改配置" class="headerlink" title="1.1.1.修改配置"></a>1.1.1.修改配置</h3><p>首先，修改publisher服务中的application.yml文件，添加下面的内容：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">publisher-confirm-type</span><span class="token punctuation">:</span> correlated    <span class="token key atrule">publisher-returns</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">template</span><span class="token punctuation">:</span>      <span class="token key atrule">mandatory</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li><code>publish-confirm-type</code>：开启publisher-confirm，这里支持两种类型：<ul><li><code>simple</code>：同步等待confirm结果，直到超时</li><li><code>correlated</code>：异步回调，定义ConfirmCallback，MQ返回结果时会回调这个ConfirmCallback</li></ul></li><li><code>publish-returns</code>：开启publish-return功能，同样是基于callback机制，不过是定义ReturnCallback</li><li><code>template.mandatory</code>：定义消息路由失败时的策略。true，则调用ReturnCallback；false：则直接丢弃消息</li></ul><h3 id="1-1-2-定义Return回调"><a href="#1-1-2-定义Return回调" class="headerlink" title="1.1.2.定义Return回调"></a>1.1.2.定义Return回调</h3><p>每个RabbitTemplate只能配置一个ReturnCallback，因此需要在项目加载时配置：</p><p>修改publisher服务，添加一个：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>config<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Slf4j<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>core<span class="token punctuation">.</span>RabbitTemplate<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>BeansException<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ApplicationContext<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ApplicationContextAware<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommonConfig</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span>ApplicationContext applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取RabbitTemplate</span>        RabbitTemplate rabbitTemplate <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>RabbitTemplate<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置ReturnCallback</span>        rabbitTemplate<span class="token punctuation">.</span><span class="token function">setReturnCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> replyCode<span class="token punctuation">,</span> replyText<span class="token punctuation">,</span> exchange<span class="token punctuation">,</span> routingKey<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 投递失败，记录日志</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"消息发送失败，应答码{}，原因{}，交换机{}，路由键{},消息{}"</span><span class="token punctuation">,</span>                     replyCode<span class="token punctuation">,</span> replyText<span class="token punctuation">,</span> exchange<span class="token punctuation">,</span> routingKey<span class="token punctuation">,</span> message<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果有业务需要，可以重发消息</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-3-定义ConfirmCallback"><a href="#1-1-3-定义ConfirmCallback" class="headerlink" title="1.1.3.定义ConfirmCallback"></a>1.1.3.定义ConfirmCallback</h3><p>ConfirmCallback可以在发送消息时指定，因为每个业务处理confirm成功或失败的逻辑不一定相同。</p><p>在publisher服务的cn.itcast.mq.spring.SpringAmqpTest类中，定义一个单元测试方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSendMessage2SimpleQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.消息体</span>    String message <span class="token operator">=</span> <span class="token string">"hello, spring amqp!"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.全局唯一的消息ID，需要封装到CorrelationData中</span>    CorrelationData correlationData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CorrelationData</span><span class="token punctuation">(</span>UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3.添加callback</span>    correlationData<span class="token punctuation">.</span><span class="token function">getFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addCallback</span><span class="token punctuation">(</span>        result <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">isAck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 3.1.ack，消息成功</span>                log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"消息发送成功, ID:{}"</span><span class="token punctuation">,</span> correlationData<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 3.2.nack，消息失败</span>                log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"消息发送失败, ID:{}, 原因{}"</span><span class="token punctuation">,</span>correlationData<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getReason</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        ex <span class="token operator">-</span><span class="token operator">></span> log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"消息发送异常, ID:{}, 原因{}"</span><span class="token punctuation">,</span>correlationData<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 4.发送消息</span>    rabbitTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"task.direct"</span><span class="token punctuation">,</span> <span class="token string">"task"</span><span class="token punctuation">,</span> message<span class="token punctuation">,</span> correlationData<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 休眠一会儿，等待ack回执</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-消息持久化"><a href="#1-2-消息持久化" class="headerlink" title="1.2.消息持久化"></a>1.2.消息持久化</h2><p>生产者确认可以确保消息投递到RabbitMQ的队列中，但是消息发送到RabbitMQ以后，如果突然宕机，也可能导致消息丢失。</p><p>要想确保消息在RabbitMQ中安全保存，必须开启消息持久化机制。</p><ul><li>交换机持久化</li><li>队列持久化</li><li>消息持久化</li></ul><h3 id="1-2-1-交换机持久化"><a href="#1-2-1-交换机持久化" class="headerlink" title="1.2.1.交换机持久化"></a>1.2.1.交换机持久化</h3><p>RabbitMQ中交换机默认是非持久化的，mq重启后就丢失。</p><p>SpringAMQP中可以通过代码指定交换机持久化：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> DirectExchange <span class="token function">simpleExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span><span class="token string">"simple.direct"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上，默认情况下，由SpringAMQP声明的交换机都是持久化的。</p><p>可以在RabbitMQ控制台看到持久化的交换机都会带上<code>D</code>的标示：</p><p><img src="/rabbitmq/image-20210718164412450.png" alt="image-20210718164412450"></p><h3 id="1-2-2-队列持久化"><a href="#1-2-2-队列持久化" class="headerlink" title="1.2.2.队列持久化"></a>1.2.2.队列持久化</h3><p>RabbitMQ中队列默认是非持久化的，mq重启后就丢失。</p><p>SpringAMQP中可以通过代码指定交换机持久化：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> Queue <span class="token function">simpleQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用QueueBuilder构建队列，durable就是持久化的</span>    <span class="token keyword">return</span> QueueBuilder<span class="token punctuation">.</span><span class="token function">durable</span><span class="token punctuation">(</span><span class="token string">"simple.queue"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上，默认情况下，由SpringAMQP声明的队列都是持久化的。</p><p>可以在RabbitMQ控制台看到持久化的队列都会带上<code>D</code>的标示：</p><p><img src="/rabbitmq/image-20210718164729543.png" alt="image-20210718164729543"></p><h3 id="1-2-3-消息持久化"><a href="#1-2-3-消息持久化" class="headerlink" title="1.2.3.消息持久化"></a>1.2.3.消息持久化</h3><p>利用SpringAMQP发送消息时，可以设置消息的属性（MessageProperties），指定delivery-mode：</p><ul><li>1：非持久化</li><li>2：持久化</li></ul><p>用java代码指定：</p><p><img src="/rabbitmq/image-20210718165100016.png" alt="image-20210718165100016"></p><p>默认情况下，SpringAMQP发出的任何消息都是持久化的，不用特意指定。</p><h2 id="1-3-消费者消息确认"><a href="#1-3-消费者消息确认" class="headerlink" title="1.3.消费者消息确认"></a>1.3.消费者消息确认</h2><p>RabbitMQ是<strong>阅后即焚</strong>机制，RabbitMQ确认消息被消费者消费后会立刻删除。</p><p>而RabbitMQ是通过消费者回执来确认消费者是否成功处理消息的：消费者获取消息后，应该向RabbitMQ发送ACK回执，表明自己已经处理消息。</p><p>设想这样的场景：</p><ul><li>1）RabbitMQ投递消息给消费者</li><li>2）消费者获取消息后，返回ACK给RabbitMQ</li><li>3）RabbitMQ删除消息</li><li>4）消费者宕机，消息尚未处理</li></ul><p>这样，消息就丢失了。因此消费者返回ACK的时机非常重要。</p><p>而SpringAMQP则允许配置三种确认模式：</p><p>•manual：手动ack，需要在业务代码结束后，调用api发送ack。</p><p>•auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</p><p>•none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</p><p>由此可知：</p><ul><li>none模式下，消息投递是不可靠的，可能丢失</li><li>auto模式类似事务机制，出现异常时返回nack，消息回滚到mq；没有异常，返回ack</li><li>manual：自己根据业务情况，判断什么时候该ack</li></ul><p>一般，我们都是使用默认的auto即可。</p><h3 id="1-3-1-演示none模式"><a href="#1-3-1-演示none模式" class="headerlink" title="1.3.1.演示none模式"></a>1.3.1.演示none模式</h3><p>修改consumer服务的application.yml文件，添加下面内容：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">listener</span><span class="token punctuation">:</span>      <span class="token key atrule">simple</span><span class="token punctuation">:</span>        <span class="token key atrule">acknowledge-mode</span><span class="token punctuation">:</span> none <span class="token comment" spellcheck="true"># 关闭ack</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改consumer服务的SpringRabbitListener类中的方法，模拟一个消息处理异常：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>queues <span class="token operator">=</span> <span class="token string">"simple.queue"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listenSimpleQueue</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"消费者接收到simple.queue的消息：【{}】"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 模拟异常</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"消息处理完成！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试可以发现，当消息处理抛异常时，消息依然被RabbitMQ删除了。</p><h3 id="1-3-2-演示auto模式"><a href="#1-3-2-演示auto模式" class="headerlink" title="1.3.2.演示auto模式"></a>1.3.2.演示auto模式</h3><p>再次把确认机制修改为auto:</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">listener</span><span class="token punctuation">:</span>      <span class="token key atrule">simple</span><span class="token punctuation">:</span>        <span class="token key atrule">acknowledge-mode</span><span class="token punctuation">:</span> auto <span class="token comment" spellcheck="true"># 关闭ack</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在异常位置打断点，再次发送消息，程序卡在断点时，可以发现此时消息状态为unack（未确定状态）：</p><p><img src="/rabbitmq/image-20210718171705383.png" alt="image-20210718171705383"></p><p>抛出异常后，因为Spring会自动返回nack，所以消息恢复至Ready状态，并且没有被RabbitMQ删除：</p><p><img src="/rabbitmq/image-20210718171759179.png" alt="image-20210718171759179"></p><h2 id="1-4-消费失败重试机制"><a href="#1-4-消费失败重试机制" class="headerlink" title="1.4.消费失败重试机制"></a>1.4.消费失败重试机制</h2><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者，然后再次异常，再次requeue，无限循环，导致mq的消息处理飙升，带来不必要的压力：</p><p><img src="/rabbitmq/image-20210718172746378.png" alt="image-20210718172746378"></p><p>怎么办呢？</p><h3 id="1-4-1-本地重试"><a href="#1-4-1-本地重试" class="headerlink" title="1.4.1.本地重试"></a>1.4.1.本地重试</h3><p>我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。</p><p>修改consumer服务的application.yml文件，添加内容：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">listener</span><span class="token punctuation">:</span>      <span class="token key atrule">simple</span><span class="token punctuation">:</span>        <span class="token key atrule">retry</span><span class="token punctuation">:</span>          <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 开启消费者失败重试</span>          <span class="token key atrule">initial-interval</span><span class="token punctuation">:</span> <span class="token number">1000 </span><span class="token comment" spellcheck="true"># 初识的失败等待时长为1秒</span>          <span class="token key atrule">multiplier</span><span class="token punctuation">:</span> <span class="token number">1 </span><span class="token comment" spellcheck="true"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span>          <span class="token key atrule">max-attempts</span><span class="token punctuation">:</span> <span class="token number">3 </span><span class="token comment" spellcheck="true"># 最大重试次数</span>          <span class="token key atrule">stateless</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># true无状态；false有状态。如果业务中包含事务，这里改为false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启consumer服务，重复之前的测试。可以发现：</p><ul><li>在重试3次后，SpringAMQP会抛出异常AmqpRejectAndDontRequeueException，说明本地重试触发了</li><li>查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是ack，mq删除消息了</li></ul><p>结论：</p><ul><li>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</li><li>重试达到最大次数后，Spring会返回ack，消息会被丢弃</li></ul><h3 id="1-4-2-失败策略"><a href="#1-4-2-失败策略" class="headerlink" title="1.4.2.失败策略"></a>1.4.2.失败策略</h3><p>在之前的测试中，达到最大重试次数后，消息会被丢弃，这是由Spring内部机制决定的。</p><p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecovery接口来处理，它包含三种不同的实现：</p><ul><li><p>RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</p></li><li><p>ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队</p></li><li><p>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机</p></li></ul><p>比较优雅的一种处理方案是RepublishMessageRecoverer，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。</p><p>1）在consumer服务中定义处理失败消息的交换机和队列</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> DirectExchange <span class="token function">errorMessageExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span><span class="token string">"error.direct"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> Queue <span class="token function">errorQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">"error.queue"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> Binding <span class="token function">errorBinding</span><span class="token punctuation">(</span>Queue errorQueue<span class="token punctuation">,</span> DirectExchange errorMessageExchange<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> BindingBuilder<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>errorQueue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span>errorMessageExchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）定义一个RepublishMessageRecoverer，关联队列和交换机</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> MessageRecoverer <span class="token function">republishMessageRecoverer</span><span class="token punctuation">(</span>RabbitTemplate rabbitTemplate<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RepublishMessageRecoverer</span><span class="token punctuation">(</span>rabbitTemplate<span class="token punctuation">,</span> <span class="token string">"error.direct"</span><span class="token punctuation">,</span> <span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>完整代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>mq<span class="token punctuation">.</span>config<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span>Binding<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span>BindingBuilder<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span>DirectExchange<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>core<span class="token punctuation">.</span>Queue<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>core<span class="token punctuation">.</span>RabbitTemplate<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>retry<span class="token punctuation">.</span>MessageRecoverer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>rabbit<span class="token punctuation">.</span>retry<span class="token punctuation">.</span>RepublishMessageRecoverer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Bean<span class="token punctuation">;</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ErrorMessageConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> DirectExchange <span class="token function">errorMessageExchange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DirectExchange</span><span class="token punctuation">(</span><span class="token string">"error.direct"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Queue <span class="token function">errorQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token string">"error.queue"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Binding <span class="token function">errorBinding</span><span class="token punctuation">(</span>Queue errorQueue<span class="token punctuation">,</span> DirectExchange errorMessageExchange<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> BindingBuilder<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>errorQueue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">to</span><span class="token punctuation">(</span>errorMessageExchange<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> MessageRecoverer <span class="token function">republishMessageRecoverer</span><span class="token punctuation">(</span>RabbitTemplate rabbitTemplate<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RepublishMessageRecoverer</span><span class="token punctuation">(</span>rabbitTemplate<span class="token punctuation">,</span> <span class="token string">"error.direct"</span><span class="token punctuation">,</span> <span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5.总结"></a>1.5.总结</h2><p>如何确保RabbitMQ消息的可靠性？</p><ul><li>开启生产者确认机制，确保生产者的消息能到达队列</li><li>开启持久化功能，确保消息未消费前在队列中不会丢失</li><li>开启消费者确认机制为auto，由spring确认消息处理成功后完成ack</li><li>开启消费者失败重试机制，并设置MessageRecoverer，多次重试失败后将消息投递到异常交换机，交由人工处理</li></ul><h1 id="2-死信交换机"><a href="#2-死信交换机" class="headerlink" title="2.死信交换机"></a>2.死信交换机</h1><h2 id="2-1-初识死信交换机"><a href="#2-1-初识死信交换机" class="headerlink" title="2.1.初识死信交换机"></a>2.1.初识死信交换机</h2><h3 id="2-1-1-什么是死信交换机"><a href="#2-1-1-什么是死信交换机" class="headerlink" title="2.1.1.什么是死信交换机"></a>2.1.1.什么是死信交换机</h3><p>什么是死信？</p><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>basic.reject方法</p><pre><code>channel.basicReject(deliveryTag, true);</code></pre><p>拒绝deliveryTag对应的消息，第二个参数是否requeue，true则重新入队列，否则丢弃或者进入死信队列。</p><p>该方法reject后，该消费者还是会消费到该条被reject的消息。</p><p>basic.nack方法</p><pre><code>channel.basicNack(deliveryTag, false, true);</code></pre><p>为不确认deliveryTag对应的消息，第二个参数是否应用于多消息，第三个参数是否requeue<br>与basic.reject区别就是同时支持多个消息，可以nack该消费者先前接收未ack的所有消息。nack后的消息也会被自己消费到。</p><p>basic.recover</p><pre><code>channel.basicRecover(true);</code></pre><p>是否恢复消息到队列，参数是是否requeue，true则重新入队列，并且尽可能的将之前recover的消息投递给其他消费者消费，而不是自己再次消费。false则消息会重新被投递给自己。</p><p>如果这个包含死信的队列配置了<code>dead-letter-exchange</code>属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为<strong>死信交换机</strong>（Dead Letter Exchange，检查DLX）。</p><p>如图，一个消息被消费者拒绝了，变成了死信：</p><p><img src="/rabbitmq/image-20210718174328383.png" alt="image-20210718174328383"></p><p>因为simple.queue绑定了死信交换机 dl.direct，因此死信会投递给这个交换机：</p><p><img src="/rabbitmq/image-20210718174416160.png" alt="image-20210718174416160"></p><p>如果这个死信交换机也绑定了一个队列，则消息最终会进入这个存放死信的队列：</p><p><img src="/rabbitmq/image-20210718174506856.png" alt="image-20210718174506856"></p><p>另外，队列将死信投递给死信交换机时，必须知道两个信息：</p><ul><li>死信交换机名称</li><li>死信交换机与死信队列绑定的RoutingKey</li></ul><p>这样才能确保投递的消息能到达死信交换机，并且正确的路由到死信队列。</p><p><img src="/rabbitmq/image-20210821073801398.png" alt="image-20210821073801398"></p><h3 id="2-1-2-利用死信交换机接收死信（拓展）"><a href="#2-1-2-利用死信交换机接收死信（拓展）" class="headerlink" title="2.1.2.利用死信交换机接收死信（拓展）"></a>2.1.2.利用死信交换机接收死信（拓展）</h3><p>在失败重试策略中，默认的RejectAndDontRequeueRecoverer会在本地重试次数耗尽后，发送reject给RabbitMQ，消息变成死信，被丢弃。</p><p>可以给simple.queue添加一个死信交换机，给死信交换机绑定一个队列。这样消息变成死信后也不会丢弃，而是最终投递到死信交换机，路由到与死信交换机绑定的队列。</p><p><img src="/rabbitmq/image-20210718174506856-1680160654379.png" alt="image-20210718174506856"></p><p>在consumer服务中，定义一组死信交换机、死信队列：</p>]]></content>
      
      
      <categories>
          
          <category> Message Queue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xuecheng项目</title>
      <link href="/xuecheng.html"/>
      <url>/xuecheng.html</url>
      
        <content type="html"><![CDATA[<h1 id="学成在线"><a href="#学成在线" class="headerlink" title="学成在线"></a>学成在线</h1><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p>本项目包括了用户端、机构端、运营端。 核心模块包括：内容管理、媒资管理、课程搜索、订单支付、选课管理、认证授权等。</p><p><img src="/xuecheng/image-20230327170609556.png" alt="image-20230327170609556"></p><p>本项目采用前后端分离架构，后端采用SpringBoot、SpringCloud技术栈开发，数据库使用了MySQL， 还使用的Redis、消息队列、分布式文件系统、Elasticsearch等中间件系统。 划分的微服务包括：内容管理服务、媒资管理服务、搜索服务、订单支付服务、 学习中心服务、系统管 理服务、认证授权服务、网关服务、注册中心服务、配置中心服务等。</p><h1 id="项目的技术架构"><a href="#项目的技术架构" class="headerlink" title="项目的技术架构"></a>项目的技术架构</h1><h2 id="项目技术架构"><a href="#项目技术架构" class="headerlink" title="项目技术架构"></a>项目技术架构</h2><p>学成在线项目采用当前流行的前后端分离架构开发，由以下流程来构成：用户层、CDN内容分发和加 速、负载均衡、UI层、微服务层、数据层。</p><p><img src="/xuecheng/image-20230327170755746.png" alt="image-20230327170755746"></p><p>技术架构列表</p><table><thead><tr><th>序号</th><th>名称</th><th>功能描述</th></tr></thead><tbody><tr><td>1</td><td>用户层</td><td>用户层描述了本系统所支持的用户类型包括：pc用户、app用户、h5用户。pc用 户通过浏览器访问系统、app用户通过android、ios手机访问系统，H5用户通过 h5页面访问系统。</td></tr><tr><td>2</td><td>CDN</td><td>CDN全称Content Delivery Network，即内容分发网络，本系统所有静态资源全 部通过CDN加速来提高访问速度。系统静态资源包括：html页面、js文件、css文 件、image图片、pdf和ppt及doc教学文档、video视频等。</td></tr><tr><td>3</td><td>负载均衡</td><td>系统的CDN层、UI层、服务层及数据层均设置了负载均衡服务，上图仅在UI层前 边标注了负载均衡。 每一层的负载均衡会根据系统的需求来确定负载均衡器的类 型，系统支持4层负载均衡+7层负载均衡结合的方式，4层负载均衡是指在网络传 输层进行流程转发，根据IP和端口进行转发，7层负载均衡完成HTTP协议负载均 衡及反向代理的功能，根据url进行请求转发。</td></tr><tr><td>4</td><td>UI层</td><td>UI层描述了系统向pc用户、app用户、h5用户提供的产品界面。根据系统功能模 块特点确定了UI层包括如下产品界面类型： 1）面向pc用户的门户系统、学习中 心系统、教学管理系统、系统管理中心。 2）面向h5用户的门户系统、学习中心 系统。 3）面向app用户的门户系统、学习中心系统。</td></tr><tr><td>5</td><td>微服务层</td><td>微服务层将系统服务分类三类：业务服务、基础服务、第三方代理服务。 业务服 务：主要为学成在线核心业务提供服务，并与数据层进行交互获得数据。 基础服 务：主要管理学成在线系统运行所需的配置、日志、任务调度、短信等系统级别 的服务。 第三方代理服务：系统接入第三方服务完成业务的对接，例如认证、支 付、视频点播/直播、用户认证和授权。</td></tr><tr><td>6</td><td>数据层</td><td>数据层描述了系统的数据存储的内容类型，关系性数据库：持久化的业务数据使 用MySQL。 消息队列：存储系统服务间通信的消息，本身提供消息存取服务，与 微服务层的系统服务连接。 索引库：存储课程信息的索引信息，本身提供索引维 护及搜索的服务，与微服务层的系统服务连接。 缓存：作为系统的缓存服务，作 为微服务的缓存数据便于查询。 文件存储：提供系统静态资源文件的分布式存储 服务，文件存储服务器作为CDN服务器的数据来源，CDN上的静态资源将最终在 文件存储服务器上保存多份。</td></tr></tbody></table><ol><li>用户可以通过pc、手机等客户端访问系统进行在线学习。 </li><li>系统应用CDN技术，对一些图片、CSS、视频等资源从CDN调度访问。</li><li>所有的请求全部经过负载均衡器。 </li><li>对于PC、H5等客户端请求，首先请求UI层，渲染用户界面。 5</li><li>客户端UI请求服务层获取进行具体的业务操作。 6. 服务层将数据持久化到数据库。</li></ol><h2 id="项目技术栈"><a href="#项目技术栈" class="headerlink" title="项目技术栈"></a>项目技术栈</h2><p><img src="/xuecheng/image-20230327172852937.png" alt="image-20230327172852937"></p><h1 id="支付模块"><a href="#支付模块" class="headerlink" title="支付模块"></a>支付模块</h1><p><strong>需求分析</strong></p><p><strong>执行流程</strong></p><p><img src="/xuecheng/image-20230327182211044.png" alt="image-20230327182211044"></p><p>1，请求学习中心服务创建选课记录</p><p>2、请求订单服务创建商品订单、生成支付二维码。</p><p>3、用户扫码请求订单支付服务，订单支付服务请求第三方支付平台生成支付订单。</p><p>4、前端唤起支付客户端，用户输入密码完成支付。</p><p>5、第三方支付平台支付完成发起支付通知。</p><p>6、订单支付服务接收支付通知结果。</p><p>7、用户在前端查询支付结果，请求订单支付服务查询支付结果，如果订单支付服务还没有收到支付结果则请求学习中心查询支付结果。</p><p>8、订单支付服务向学习中心服务通知支付结果。</p><p>9、学习中心服务收到支付结果，如果支付成功则更新选课记录，并添加到我的课程表。</p><h2 id="通用订单服务设计"><a href="#通用订单服务设计" class="headerlink" title="通用订单服务设计"></a><strong>通用订单服务设计</strong></h2><p>在本项目中不仅选课需要下单、购买学习资料、老师一对一答疑等所以收费项目都需要下单支付。</p><p>所以本项目设计通用的订单服务，通用的订单服务承接各业务模块的收费支付需求，当用户需要交费时统一生成商品订单并进行支付。</p><p><img src="/xuecheng/image-20230327182419131.png" alt="image-20230327182419131"></p><p>所有收费业务最终转换为商品订单记录在订单服务的商品订单表。</p><p><img src="/xuecheng/image-20230327182429645.png" alt="image-20230327182429645">****</p><p>以选课为例，选课记录表的ID记录在商品订单表的out_business_id字段。</p><p><img src="/xuecheng/image-20230327182445545.png" alt="image-20230327182445545"></p><h2 id="支付接口调研"><a href="#支付接口调研" class="headerlink" title="支付接口调研"></a><strong>支付接口调研</strong></h2><p><strong>支付宝接口调研</strong></p><p>文档：<a href="https://b.alipay.com/signing/productSetV2.htm" target="_blank" rel="noopener">https://b.alipay.com/signing/productSetV2.htm</a></p><p>本项目选择的手机网站支付接口</p><p>手机网站支付</p><p>用户在商家手机网站消费，通过浏览器自动跳转支付宝APP或支付宝网页完成付款。 轻松实现和APP支付相同的支付体验。</p><p><img src="/xuecheng/image-20230327182641670.png" alt="image-20230327182641670"></p><p>对比两种支付方式：手机网站支付方式可以在H5网页唤起支付宝，手机扫码支付可以使用手机网站支付方式来完成，相比电脑网站支付形式更灵活。</p><p>本项目选择手机网站支付方式。</p><p>文档：<a href="https://opendocs.alipay.com/open/02ivbt" target="_blank" rel="noopener">https://opendocs.alipay.com/open/02ivbt</a></p><p>如何开通支付宝手机网站支付接口？</p><p>进入网址：</p><p><a href="https://b.alipay.com/signing/productDetailV2.htm?productId=I1011000290000001001" target="_blank" rel="noopener">https://b.alipay.com/signing/productDetailV2.htm?productId=I1011000290000001001</a></p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a><strong>开发环境</strong></h2><p>第三方支付接口流程大同小异，考虑开发及教学的方便性，支付宝提供支付宝沙箱环境开发支付接口，在教学中接入支付宝手机网站支付接口。</p><h3 id="配置沙箱环境"><a href="#配置沙箱环境" class="headerlink" title="配置沙箱环境"></a>配置沙箱环境</h3><p>沙箱环境是支付宝开放平台为开发者提供的与生产环境完全隔离的联调测试环境，开发者在沙箱环境中完成的接口调用不会对生产环境中的数据造成任何影响。</p><p>接入手机网站支付需要具备如下条件：</p><p>•    申请前必须拥有经过实名认证的支付宝账户；</p><p>•    企业或个体工商户可申请；</p><p>•    需提供真实有效的营业执照，且支付宝账户名称需与营业执照主体一致；</p><p>•    网站能正常访问且页面显示完整，网站需要明确经营内容且有完整的商品信息；</p><p>•    网站必须通过ICP备案。如为个体工商户，网站备案主体需要与支付宝账户主体名称一致；</p><p>•    如为个体工商户，则团购不开放，且古玩、珠宝等奢侈品、投资类行业无法申请本产品。</p><p>详细参见：<a href="https://docs.open.alipay.com/203" target="_blank" rel="noopener">https://docs.open.alipay.com/203</a></p><p>我是使用支付宝沙箱进行开发测试，这里主要介绍支付宝沙箱环境配置。</p><p>详细参见：<a href="https://docs.open.alipay.com/200/105311/" target="_blank" rel="noopener">https://docs.open.alipay.com/200/105311/</a></p><h3 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h3><p><a href="https://natapp.cn/" target="_blank" rel="noopener">NATAPP-内网穿透 基于ngrok的国内高速内网映射工具</a></p><p>因为我没有服务器所以用的是本地，需要用到内网穿透。</p><h3 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h3><p>用手机模拟器扫自己生成的二维码，访问自己本地的地址再下单发给支付宝，然后再请求模拟器上的支付宝。</p><p>在模拟器上登录沙盒应用的买家账号<a href="https://open.alipay.com/develop/sandbox/app" target="_blank" rel="noopener">支付宝开放平台 (alipay.com)</a></p><h2 id="订单服务"><a href="#订单服务" class="headerlink" title="订单服务"></a>订单服务</h2><p><img src="/xuecheng/image-20230327183903663.png" alt="image-20230327183903663"></p><h2 id="支付接口的测试"><a href="#支付接口的测试" class="headerlink" title="支付接口的测试"></a>支付接口的测试</h2><h2 id="阅读接口定义"><a href="#阅读接口定义" class="headerlink" title="阅读接口定义"></a>阅读接口定义</h2><p><a href="https://docs.open.alipay.com/203/105285/" target="_blank" rel="noopener">https://docs.open.alipay.com/203/105285/</a></p><h2 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h2><h2 id="系统交互流程"><a href="#系统交互流程" class="headerlink" title="系统交互流程"></a>系统交互流程</h2><p><img src="/xuecheng/1668414529588-da8c06d7-41da-49b2-a967-00d05d01ff33.png" alt="1667801727425_手机网站支付-支付及消息部分.png"></p><p><img src="/xuecheng/image-20230327194735434.png" alt="image-20230327194735434"></p><p>1）用户在商户的H5网站下单支付后，商户系统按照<a href="https://docs.open.alipay.com/203/107090" target="_blank" rel="noopener">手机网站支付接口alipay.trade.wap.pay</a>API的参数规范生成订单数据</p><p>2）前端页面通过Form表单的形式请求到支付宝。此时支付宝会自动将页面跳转至支付宝H5收银台页面，如果用户手机上安装了支付宝APP，则自动唤起支付宝APP。</p><p>3）输入支付密码完成支付。</p><p>4）用户在支付宝APP或H5收银台完成支付后，会根据商户在手机网站支付API中传入的前台回跳地址return_url自动跳转回商户页面，同时在URL请求中以Query String的形式附带上支付结果参数，详细回跳参数见“手机网站支付接口alipay.trade.wap.pay”<a href="https://docs.open.alipay.com/203/107090#s2" target="_blank" rel="noopener">前台回跳参数</a>。</p><p>5）支付宝还会根据原始支付API中传入的异步通知地址notify_url，通过POST请求的形式将支付结果作为参数通知到商户系统，详情见<a href="https://docs.open.alipay.com/203/105286" target="_blank" rel="noopener">支付结果异步通知</a>。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>2、接口定义</p><p>文档：<a href="https://opendocs.alipay.com/open/203/107090" target="_blank" rel="noopener">https://opendocs.alipay.com/open/203/107090</a></p><p>接口定义：外部商户请求支付宝创建订单并支付</p><p>公共参数</p><p><strong>请求地址</strong>：</p><p>开发中使用沙箱地址：<a href="https://openapi.alipaydev.com/gateway.do" target="_blank" rel="noopener">https://openapi.alipaydev.com/gateway.do</a></p><p>请求参数：</p><p>详细查阅<a href="https://opendocs.alipay.com/open/203/107090" target="_blank" rel="noopener">https://opendocs.alipay.com/open/203/107090</a></p><p>一部分由sdk设置，一部分需要编写程序时指定。</p><p><img src="/xuecheng/image-20230327195544696.png" alt="image-20230327195544696"></p><p><img src="/xuecheng/image-20230327195550516.png" alt="image-20230327195550516"></p><h3 id="支付宝的sdk"><a href="#支付宝的sdk" class="headerlink" title="支付宝的sdk"></a>支付宝的sdk</h3><pre><code>&lt;!-- 支付宝SDK --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt;    &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt;    &lt;version&gt;3.7.73.ALL&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 支付宝SDK依赖的日志 --&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-logging&lt;/groupId&gt;    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;    &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="创建订单并调用支付宝"><a href="#创建订单并调用支付宝" class="headerlink" title="创建订单并调用支付宝"></a>创建订单并调用支付宝</h3><p>就是用支付宝的sdk，在DefaultAlipayClient装支付宝的url,给的id，key,返回格式，字符类型，公钥，加密格式。</p><p>然后AlipayTradeWapPayRequest()中添加回调到自己访问的url和通知地址，和商品的信息也就是业务参数，</p><p>然后调用alipayClient.pageExecute()传入上面AlipayTradeWapPayRequest()生成表单。</p><p>然后用httpResponss江完整的表单html输出到页面。</p><pre><code>Javapublic void doPost(HttpServletRequest httpRequest,HttpServletResponse httpResponse) throws ServletException, IOException {    AlipayClient alipayClient = ... //获得初始化的AlipayClient    AlipayTradeWapPayRequest alipayRequest = new AlipayTradeWapPayRequest();//创建API对应的request    alipayRequest.setReturnUrl(&quot;http://domain.com/CallBack/return_url.jsp&quot;);    alipayRequest.setNotifyUrl(&quot;http://domain.com/CallBack/notify_url.jsp&quot;);//在公共参数中设置回跳和通知地址    alipayRequest.setBizContent(&quot;{&quot; +            &quot;    \&quot;out_trade_no\&quot;:\&quot;20150320010101002\&quot;,&quot; +            &quot;    \&quot;total_amount\&quot;:88.88,&quot; +            &quot;    \&quot;subject\&quot;:\&quot;Iphone6 16G\&quot;,&quot; +            &quot;    \&quot;product_code\&quot;:\&quot;QUICK_WAP_WAY\&quot;&quot; +            &quot;  }&quot;);//填充业务参数    String form = alipayClient.pageExecute(alipayRequest).getBody(); //调用SDK生成表单    httpResponse.setContentType(&quot;text/html;charset=&quot; + AlipayServiceEnvConstants.CHARSET);    httpResponse.getWriter().write(form);//直接将完整的表单html输出到页面    httpResponse.getWriter().flush();}</code></pre><h3 id="接受支付宝返回的信息"><a href="#接受支付宝返回的信息" class="headerlink" title="接受支付宝返回的信息"></a>接受支付宝返回的信息</h3><p>根据在 alipayRequest.setNotifyUrl中的通知地址，接受支付宝的的通知结果</p><pre><code> //支付结果通知    @PostMapping(&quot;/paynotifytest&quot;)    public void paynotify(HttpServletRequest request,HttpServletResponse response) throws IOException, AlipayApiException {        //获取支付宝POST过来反馈信息        Map&lt;String,String&gt; params = new HashMap&lt;String,String&gt;();        Map requestParams = request.getParameterMap();        for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext();) {            String name = (String) iter.next();            String[] values = (String[]) requestParams.get(name);            String valueStr = &quot;&quot;;            for (int i = 0; i &lt; values.length; i++) {                valueStr = (i == values.length - 1) ? valueStr + values[i]                        : valueStr + values[i] + &quot;,&quot;;            }            //乱码解决，这段代码在出现乱码时使用。如果mysign和sign不相等也可以使用这段代码转化            //valueStr = new String(valueStr.getBytes(&quot;ISO-8859-1&quot;), &quot;gbk&quot;);            params.put(name, valueStr);        }        //获取支付宝的通知返回参数，可参考技术文档中页面跳转同步通知参数列表(以下仅供参考)//        //获取支付宝的通知返回参数，可参考技术文档中页面跳转同步通知参数列表(以上仅供参考)//        //计算得出通知验证结果        //boolean AlipaySignature.rsaCheckV1(Map&lt;String, String&gt; params, String publicKey, String charset, String sign_type)        boolean verify_result = AlipaySignature.rsaCheckV1(params, ALIPAY_PUBLIC_KEY, AlipayConfig.CHARSET, &quot;RSA2&quot;);        if(verify_result){//验证成功            //////////////////////////////////////////////////////////////////////////////////////////            //请在这里加上商户的业务逻辑程序代码            //商户订单号            String out_trade_no = new String(request.getParameter(&quot;out_trade_no&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);            //支付宝交易号            String trade_no = new String(request.getParameter(&quot;trade_no&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);            //交易状态            String trade_status = new String(request.getParameter(&quot;trade_status&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);            //——请根据您的业务逻辑来编写程序（以下代码仅作参考）——            if(trade_status.equals(&quot;TRADE_FINISHED&quot;)){                //判断该笔订单是否在商户网站中已经做过处理                //如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细，并执行商户的业务程序                //请务必判断请求时的total_fee、seller_id与通知时获取的total_fee、seller_id为一致的                //如果有做过处理，不执行商户的业务程序                //注意：                //如果签约的是可退款协议，退款日期超过可退款期限后（如三个月可退款），支付宝系统发送该交易状态通知                //如果没有签约可退款协议，那么付款完成后，支付宝系统发送该交易状态通知。            } else if (trade_status.equals(&quot;TRADE_SUCCESS&quot;)){                //判断该笔订单是否在商户网站中已经做过处理                //如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细，并执行商户的业务程序                //请务必判断请求时的total_fee、seller_id与通知时获取的total_fee、seller_id为一致的                //如果有做过处理，不执行商户的业务程序                System.out.println(trade_status);                //注意：                //如果签约的是可退款协议，那么付款完成后，支付宝系统发送该交易状态通知。            }            //——请根据您的业务逻辑来编写程序（以上代码仅作参考）——            response.getWriter().write(&quot;success&quot;);            //////////////////////////////////////////////////////////////////////////////////////////        }else{//验证失败            response.getWriter().write(&quot;fail&quot;);        }    }</code></pre><h3 id="支付结果查询接口"><a href="#支付结果查询接口" class="headerlink" title="支付结果查询接口"></a>支付结果查询接口</h3><p>支付完成可以调用第三方支付平台的支付结果查询接口 查询支付结果。</p><p>文档：<a href="https://opendocs.alipay.com/open/02ivbt" target="_blank" rel="noopener">https://opendocs.alipay.com/open/02ivbt</a></p><p>刚才订单付款成功，可以使用out_trade_no商品订单号或支付宝的交易流水号trade_no去查询支付结果。</p><p>out_trade_no商品订单号: 是在下单请求时指定的商品订单号。</p><p>支付宝的交易流水号trade_no：是支付完成后支付宝通知支付结果时发送的trade_no</p><pre><code>JavaAlipayClient alipayClient = new DefaultAlipayClient(&quot;https://openapi.alipay.com/gateway.do&quot;,&quot;app_id&quot;,&quot;your private_key&quot;,&quot;json&quot;,&quot;GBK&quot;,&quot;alipay_public_key&quot;,&quot;RSA2&quot;);AlipayTradeQueryRequest request = new AlipayTradeQueryRequest();JSONObject bizContent = new JSONObject();bizContent.put(&quot;out_trade_no&quot;, &quot;20150320010101001&quot;);//订单号//bizContent.put(&quot;trade_no&quot;, &quot;2014112611001004680073956707&quot;);//支付宝流水号request.setBizContent(bizContent.toString());AlipayTradeQueryResponse response = alipayClient.execute(request);if(response.isSuccess()){    System.out.println(&quot;调用成功&quot;);} else {    System.out.println(&quot;调用失败&quot;);}</code></pre><h2 id="生成支付二维码"><a href="#生成支付二维码" class="headerlink" title="生成支付二维码"></a>生成支付二维码</h2><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>再次打开课程支付引导界面，点击“支付宝支付”按钮系统该如何处理？</p><p>点击“支付宝支付”此时打开支付二维码，用户扫码支付。</p><p>所以首先需要生成支付二维码，用户扫描二维码开始请求支付宝下单，在向支付宝下单前需要添加选课记录、创建商品订单、生成支付交易记录。</p><p>生成二维码执行流程如下：</p><p><img src="/xuecheng/image-20230328152932751.png" alt="image-20230328152932751"></p><p>用户扫码支付流程如下：</p><p>数据模型</p><p>订单支付模式的核心由三张表组成：订单表、订单明细表、支付交易记录表。</p><p><img src="/xuecheng/image-20230328153239142.png" alt="image-20230328153239142"></p><p>订单表：记录订单信息</p><p><img src="/xuecheng/clip_image002.gif" alt="img"></p><p>订单明细表记录订单的详细信息</p><p><img src="/xuecheng/clip_image004.gif" alt="img"></p><p>支付交易记录表记录与支付平台的交易明细</p><p><img src="/xuecheng/clip_image006.gif" alt="img"></p><p>订单号注意唯一性、安全性、尽量短等特点，生成方案常用的如下：</p><p>1、时间戳+随机数</p><p>年月日时分秒毫秒+随机数</p><p>2、高并发场景</p><p>年月日时分秒毫秒+随机数+redis自增序列</p><p>3、订单号中加上业务标识</p><p>订单号加上业务标识方便客服，比如：第10位是业务类型，第11位是用户类型等。</p><h4 id="使用雪花算法生成订单id"><a href="#使用雪花算法生成订单id" class="headerlink" title="使用雪花算法生成订单id"></a>使用雪花算法生成订单id</h4><p>雪花算法是推特内部使用的分布式环境下的唯一ID生成算法，它基于时间戳生成，保证有序递增，加以入计算机硬件等元素，可以满足高并发环境下ID不重复。</p><p>本项目订单号生成采用雪花算法。</p><h4 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h4><h5 id="生成支付二维码接口"><a href="#生成支付二维码接口" class="headerlink" title="生成支付二维码接口"></a>生成支付二维码接口</h5><p>生成的二维码url消息包括</p><p>在订单服务中定义生成支付二维码接口。</p><p>订单服务也需要获取用户的身份信息，需要在订单服务中集成认证授权</p><p>集成过程参考内容管理服务。</p><p>1、添加依赖</p><p>2、配置资源服务、令牌配置。</p><p>3、拷贝SecurityUtil，用来获取spring security中SecurityContextHolder的用户信息</p><p>保存商品订单</p><p>商品订单的数据来源于选课记录，在订单表需要存入选课记录的ID，这里需要作好幂等处理。</p><pre><code>public interface OrderService {   /** * @description 创建商品订单 * @param addOrderDto 订单信息 * @return PayRecordDto 支付交易记录(包括二维码)*/public PayRecordDto createOrder(String userId,AddOrderDto addOrderDto);</code></pre><p>在保存订单接口中需要做创建商品订单、创建支付交易记录</p><p>用前端传来的信息，构建订单信息。订单表的out_business_id就是选课的id</p><pre><code>Java@Transactional@Overridepublic PayRecordDto createOrder(String userId,AddOrderDto addOrderDto) {        //插入订单表,订单主表，订单明细表，保存订单信息        XcOrders xcOrders = saveXcOrders(userId, addOrderDto);        //插入支付记录        XcPayRecord payRecord = createPayRecord(xcOrders);        Long payNo = payRecord.getPayNo();        //生成二维码        QRCodeUtil qrCodeUtil = new QRCodeUtil();        //支付二维码的url        String url = String.format(qrcodeurl, payNo);        //二维码图片        String qrCode = null;        try {            qrCode = qrCodeUtil.createQRCode(url, 200, 200);        } catch (IOException e) {            XueChengPlusException.cast(&quot;生成二维码出错&quot;);        }        PayRecordDto payRecordDto = new PayRecordDto();        BeanUtils.copyProperties(payRecord,payRecordDto);        payRecordDto.setQrcode(qrCode);        return payRecordDto;}    //添加支付交易记录     /**     * 保存订单信息     * @param userId     * @param addOrderDto     * @return     */     //流程：用选课服务传给前端的选课id也就是添加订单实体类的outbusinessid，避免重复下单一个选课记录只能有一个订单，然后用雪花算法生成订单id,封装数据到订单实体，用订单实体的id，和addOrderDto中的订单详情信息添加到订单明细表。    public XcOrders saveXcOrders(String userId, AddOrderDto addOrderDto){        //插入订单表,订单主表，订单明细表        //进行幂等性判断，同一个选课记录只能有一个订单        //getOrderByBusinessId ,根据业务id查询订单 ,业务id是选课记录表中的主键        XcOrders xcOrders = getOrderByBusinessId(addOrderDto.getOutBusinessId());        if(xcOrders!=null){            return xcOrders;        }        //插入订单主表        xcOrders = new XcOrders();        //使用雪花算法生成订单号        xcOrders.setId(IdWorkerUtils.getInstance().nextId());        xcOrders.setTotalPrice(addOrderDto.getTotalPrice());        xcOrders.setCreateDate(LocalDateTime.now());        xcOrders.setStatus(&quot;600001&quot;);//未支付        xcOrders.setUserId(userId);        xcOrders.setOrderType(&quot;60201&quot;);//订单类型        xcOrders.setOrderName(addOrderDto.getOrderName());        xcOrders.setOrderDescrip(addOrderDto.getOrderDescrip());        xcOrders.setOrderDetail(addOrderDto.getOrderDetail());        xcOrders.setOutBusinessId(addOrderDto.getOutBusinessId());//如果是选课这里记录选课表的id        int insert = ordersMapper.insert(xcOrders);        if(insert&lt;=0){            XueChengPlusException.cast(&quot;添加订单失败&quot;);        }        //订单id        Long orderId = xcOrders.getId();        //插入订单明细表        //将前端传入的明细json串转成List        String orderDetailJson = addOrderDto.getOrderDetail();        List&lt;XcOrdersGoods&gt; xcOrdersGoods = JSON.parseArray(orderDetailJson, XcOrdersGoods.class);        //遍历xcOrdersGoods插入订单明细表        xcOrdersGoods.forEach(goods-&gt;{            goods.setOrderId(orderId);            //插入订单明细表            int insert1 = ordersGoodsMapper.insert(goods);        });        return xcOrders;    }      /**     * 保存支付记录     * @param orders     * @return     */     //用订单表的中订单的id    public XcPayRecord createPayRecord(XcOrders orders){        //订单id        Long orderId = orders.getId();        XcOrders xcOrders = ordersMapper.selectById(orderId);        //如果此订单不存在不能添加支付记录        if(xcOrders == null){            XueChengPlusException.cast(&quot;订单不存在&quot;);        }        //订单状态        String status = xcOrders.getStatus();        //如果此订单支付结果为成功，不再添加支付记录，避免重复支付        if(&quot;601002&quot;.equals(status)){//支付成功            XueChengPlusException.cast(&quot;此订单已支付&quot;);        }        //添加支付记录        XcPayRecord xcPayRecord = new XcPayRecord();        xcPayRecord.setPayNo(IdWorkerUtils.getInstance().nextId());//支付记录号，将来要传给支付宝        xcPayRecord.setOrderId(orderId);        xcPayRecord.setOrderName(xcOrders.getOrderName());        xcPayRecord.setTotalPrice(xcOrders.getTotalPrice());        xcPayRecord.setCurrency(&quot;CNY&quot;);        xcPayRecord.setCreateDate(LocalDateTime.now());        xcPayRecord.setStatus(&quot;601001&quot;);//未支付        xcPayRecord.setUserId(xcOrders.getUserId());        int insert = payRecordMapper.insert(xcPayRecord);        if(insert&lt;=0){            XueChengPlusException.cast(&quot;插入支付记录失败&quot;);        }        return xcPayRecord;    }}</code></pre><h5 id="扫码下单接口"><a href="#扫码下单接口" class="headerlink" title="扫码下单接口"></a>扫码下单接口</h5><p>生的支付二维码中地址的转跳就是这个接口的网址，</p><p>用户扫码请求第三方支付平台下单、支付。</p><p>定义查询支付交易记录的Service接口与实现方法</p><pre><code>public XcPayRecord getPayRecordByPayno(String payNo);</code></pre><p>接口实现</p><p>用本系统的支付记录号判断支付记录是否存在，查看支付结果的状体，然后就是用支付宝的sdk把需要的参数装进去，和填充业务参数。然后用alipayClient.pageExecute(填入业务信息的那个类).getbody获得表单信息，</p><p>设置返回前端的表头的编码，然后返回表单给前端。</p><pre><code>  @ApiOperation(&quot;扫码下单接口&quot;)    @GetMapping(&quot;/requestpay&quot;)    public void requestpay(String payNo, HttpServletResponse httpResponse) throws IOException, AlipayApiException {        //传入本系统支付记录号，判断支付记录号是否存在        XcPayRecord payRecordByPayno = orderService.getPayRecordByPayno(payNo);        if (payRecordByPayno==null){            XueChengPlusException.cast(&quot;支付记录不存在&quot;);        }        //支付结果        String status = payRecordByPayno.getStatus();        if (&quot;601002&quot;.equals(status)){            XueChengPlusException.cast(&quot;已支付,无需重复支付&quot;);        }        DefaultAlipayClient alipayClient = new DefaultAlipayClient(AlipayConfig.URL, APP_ID, APP_PRIVATE_KEY, AlipayConfig.FORMAT, AlipayConfig.CHARSET, ALIPAY_PUBLIC_KEY, AlipayConfig.SIGNTYPE);        AlipayTradeWapPayRequest alipayRequest = new AlipayTradeWapPayRequest();//创建API对对应的request        //        alipayRequest.setReturnUrl(&quot;http://domain.com/CallBack/return_url.jsp&quot;);        alipayRequest.setNotifyUrl(&quot;http://funeeu.natappfree.cc/orders/paynotify&quot;);//在公共参数中设置回跳和通知地址//        alipayRequest.setNotifyUrl(&quot;http://7ig2hh.natappfree.cc/xuecheng/orders/paynotify&quot;);//在公共参数中设置回跳和通知地址        alipayRequest.setBizContent(&quot;{&quot; +                &quot;    \&quot;out_trade_no\&quot;:\&quot;&quot;+payNo+&quot;\&quot;,&quot; +                &quot;    \&quot;total_amount\&quot;:&quot;+payRecordByPayno.getTotalPrice()+&quot;,&quot; +                &quot;    \&quot;subject\&quot;:\&quot;&quot;+payRecordByPayno.getOrderName()+&quot;\&quot;,&quot; +                &quot;    \&quot;product_code\&quot;:\&quot;QUICK_WAP_WAY\&quot;&quot; +                &quot;  }&quot;);//填充业务参数        String form = alipayClient.pageExecute(alipayRequest).getBody();        httpResponse.setContentType(&quot;text/html;charset=&quot; + AlipayConfig.CHARSET);        httpResponse.getWriter().write(form);//直接将完整的表单html输出到页面        httpResponse.getWriter().flush();    }</code></pre><h2 id="主动查询支付结果"><a href="#主动查询支付结果" class="headerlink" title="主动查询支付结果"></a>主动查询支付结果</h2><p>就是用本系统的订单号调用支付宝的sdk去支付宝查询。</p><p>接收生成支付二维码接口给前端的本项目的<strong>商户网站唯一订单号</strong>，<strong>在商户端唯一，每个商户订单号会对应一个支付宝订单号</strong>。去支付宝查询（还是调用支付宝的sdk拼接url,appid 之类的），用AlipayTradeQueryRequest() 设置商户网站唯一订单号，用alipayClient.execute（设置了商户网站唯一订单号的那个类）去支付宝查。然后支付宝返回一个AlipayTradeQueryResponse 用支付宝自带的isSuccess判断是不是成功，并且里面会带有订单详细信息，然后封装到PayStatusDto.用支付宝查到的结果也就是PayStatusDto去更新支付记录表和订单表的支付状态。</p><p>也就是用商户网站唯一订单号去支付记录表查是否有相关的支付记录表。拿到相关联的订单id去（订单表）查有没有相关的订单。查询支付状态，从支付宝查询到的支付结果更新支付记录表支付宝编号，支付时间之列的信息和订单表的订单状态</p><h3 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h3><p>前端传入本系统的订单号</p><pre><code>   @ApiOperation(&quot;查询支付结果&quot;)    @GetMapping(&quot;/payresult&quot;)    @ResponseBody    public PayRecordDto payresult(String payNo) {        //查询支付结果        PayRecordDto payRecordDto = orderService.queryPayResult(payNo);        return payRecordDto;    }</code></pre><h3 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h3><pre><code> /**  * 请求支付宝查询支付结果  * @param payNo 支付记录id  * @return 支付记录信息  */ public PayRecordDto queryPayResult(String payNo);</code></pre><pre><code>  @Override    public PayRecordDto queryPayResult(String payNo) {        //调用支付宝的接口查询支付结果        PayStatusDto payStatusDto = queryPayResultFromAlipay(payNo);        System.out.println(payStatusDto);        //拿到支付结果更新支付记录表和订单表的支付状态        currentProxy.saveAliPayStatus(payStatusDto);        //要返回最新的支付记录信息        XcPayRecord payRecordByPayno = getPayRecordByPayno(payNo);        PayRecordDto payRecordDto = new PayRecordDto();        BeanUtils.copyProperties(payRecordByPayno,payRecordDto);        return payRecordDto;    }    /**     * 请求支付宝查询支付结果     * @param payNo 支付交易号     * @return 支付结果     */    public PayStatusDto queryPayResultFromAlipay(String payNo){        DefaultAlipayClient defaultAlipayClient = new DefaultAlipayClient(AlipayConfig.URL, APP_ID, APP_PRIVATE_KEY, AlipayConfig.FORMAT, AlipayConfig.CHARSET, ALIPAY_PUBLIC_KEY, AlipayConfig.SIGNTYPE);        AlipayTradeQueryRequest alipayTradeQueryRequest = new AlipayTradeQueryRequest();        JSONObject bizContent = new JSONObject();        bizContent.put(&quot;out_trade_no&quot;,payNo);        alipayTradeQueryRequest.setBizContent(bizContent.toString());        //支付宝返回的信息        String body =null;        try {            AlipayTradeQueryResponse execute = defaultAlipayClient.execute(alipayTradeQueryRequest);//通过alipayClient调用API，获取对应的responsel类            if (!execute.isSuccess()){                XueChengPlusException.cast(&quot;请求支付宝查询支付结果失败&quot;);            }            body =execute.getBody();        }catch (AlipayApiException e){            e.printStackTrace();            XueChengPlusException.cast(&quot;请求支付查询支付结果异常&quot;);        }        Map bodyMap = JSON.parseObject(body, Map.class);        Map alipay_trade_query_response = (Map) bodyMap.get(&quot;alipay_trade_query_response&quot;);        String trade_no= (String) alipay_trade_query_response.get(&quot;trade_no&quot;);        String trade_status = (String) alipay_trade_query_response.get(&quot;trade_status&quot;);        String total_amount = (String) alipay_trade_query_response.get(&quot;total_amount&quot;);        PayStatusDto payStatusDto = new PayStatusDto();        payStatusDto.setOut_trade_no(payNo);        payStatusDto.setTrade_no(trade_no);//支付宝的交易号        payStatusDto.setTrade_status(trade_status);//交易状态        payStatusDto.setApp_id(APP_ID);        payStatusDto.setTotal_amount(total_amount);//总金额        return payStatusDto;    }    /**     * @description 保存支付宝支付结果     * @param payStatusDto  支付结果信息 从支付宝查询到的信息     * @return void     * @author Mr.M     * @date 2022/10/4 16:52     */    @Transactional    @Override    public void saveAliPayStatus(PayStatusDto payStatusDto){        String payNo = payStatusDto.getOut_trade_no();        XcPayRecord payRecordByPayno = getPayRecordByPayno(payNo);        if(payRecordByPayno == null){            XueChengPlusException.cast(&quot;找不到相关的支付记录&quot;);        }        //拿到相关联的订单id        Long orderId = payRecordByPayno.getOrderId();        XcOrders xcOrders = ordersMapper.selectById(orderId);        if(xcOrders == null){            XueChengPlusException.cast(&quot;找不到相关联的订单&quot;);        }        //支付状态        String statusFromDb = payRecordByPayno.getStatus();        //如果数据库支付的状态已经是成功了，不再处理了        if(&quot;601002&quot;.equals(statusFromDb)){            return ;        }        //如果支付成功        String trade_status = payStatusDto.getTrade_status();//从支付宝查询到的支付结果        if (trade_status.equals(&quot;TRADE_SUCCESS&quot;)){//支付宝返回的信息为支付成功            //更新支付纪律表的状态为支付成功            payRecordByPayno.setStatus(&quot;601002&quot;);            //支付宝的订单号            payRecordByPayno.setOutPayNo(payStatusDto.getTrade_no());            //第三方支付渠道编号            payRecordByPayno.setOutPayChannel(&quot;Alipay&quot;);            //支付成功时间            payRecordByPayno.setPaySuccessTime(LocalDateTime.now());            payRecordMapper.updateById(payRecordByPayno);            //更新订单表的状态和支付成功            xcOrders.setStatus(&quot;600002&quot;);//订单状态为交易成功            ordersMapper.updateById(xcOrders);            //将消息写道数据库            MqMessage mqMessage = mqMessageService.addMessage(&quot;payresult_notify&quot;, xcOrders.getOutBusinessId(), xcOrders.getOrderType(), null);            //发送消息            notifyPayResult(mqMessage);        }</code></pre><h4 id="PayStatusDto-实体类"><a href="#PayStatusDto-实体类" class="headerlink" title="PayStatusDto 实体类"></a>PayStatusDto 实体类</h4><pre><code>public class PayStatusDto {    //商户订单号    String out_trade_no;    //支付宝交易号    String trade_no;    //交易状态    String trade_status;    //appid    String app_id;    //total_amount    String total_amount;}</code></pre><h2 id="被动接受支付通知"><a href="#被动接受支付通知" class="headerlink" title="被动接受支付通知"></a>被动接受支付通知</h2><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>支付完成第三方支付系统会主动通知支付结果，要实现主动通知需要在请求支付系统下单时传入NotifyUrl，这里有两个url：NotifyUrl和ReturnUrl，ReturnUrl是支付完成后支付系统携带支付结果重定向到ReturnUrl地址，NotifyUrl是支付完成后支付系统在后台定时去通知，使用NotifyUrl比使用ReturnUrl有保证。</p><p>根据接口描述：<a href="https://opendocs.alipay.com/open/203/105286的内容下边在订单服务定义接收支付结果通知的接口。" target="_blank" rel="noopener">https://opendocs.alipay.com/open/203/105286的内容下边在订单服务定义接收支付结果通知的接口。</a></p><p>支付宝回调是用的post</p><p>首先在下单时指定NotifyUrl:</p><p>就是弄内网穿透的时候的地址+接口</p><pre><code> alipayRequest.setNotifyUrl(&quot;http://funeeu.natappfree.cc/orders/paynotify&quot;);//在公共参数中设置回跳和通知地址</code></pre><h3 id="Controller层-1"><a href="#Controller层-1" class="headerlink" title="Controller层"></a>Controller层</h3><pre><code> @PostMapping(&quot;/paynotify&quot;)    public void paynotify(HttpServletRequest request,HttpServletResponse response) throws AlipayApiException, IOException {        //获取支付宝post过来反馈信息        HashMap&lt;String, String&gt; params = new HashMap&lt;&gt;();        Map requestParams = request.getParameterMap();        //for循环每个参数都可以省略但是分号不能省略        for (Iterator iter =requestParams.keySet().iterator(); iter.hasNext(); ){            String name = (String) iter.next();            String valueStr = &quot;&quot;;            String[] values = (String[]) requestParams.get(name);            for (int i = 0; i &lt; values.length; i++) {                valueStr=(i== values.length-1)?valueStr+values[i]                :valueStr+values[i]+&quot;,&quot;;            }            params.put(name,valueStr);        }        boolean verify_result = AlipaySignature.rsaCheckV1(params, ALIPAY_PUBLIC_KEY, AlipayConfig.CHARSET, &quot;RSA2&quot;);        if (verify_result){//验证成功            //商户订单号            String out_trade_no = new String(request.getParameter(&quot;out_trade_no&quot;).getBytes(&quot;ISO-8859-1&quot;));            //支付宝交易号            String trade_no = new String(request.getParameter(&quot;trade_no&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);            //交易金额            String total_amount = new String(request.getParameter(&quot;total_amount&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);            //交易状态            String trade_status = new String(request.getParameter(&quot;trade_status&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);            if (trade_status.equals(&quot;TRADE_SUCCESS&quot;)){                //更新支付记录表的支付状态为成功，订单表的状态为成功                PayStatusDto payStatusDto = new PayStatusDto();                payStatusDto.setTrade_status(trade_status);                payStatusDto.setTrade_no(trade_no);                payStatusDto.setOut_trade_no(out_trade_no);                payStatusDto.setTotal_amount(total_amount);                payStatusDto.setApp_id(APP_ID);                orderService.saveAliPayStatus(payStatusDto);            }            response.getWriter().write(&quot;success&quot;);        }else {            response.getWriter().write(&quot;fail&quot;);        }    }</code></pre><h2 id="通知支付结果"><a href="#通知支付结果" class="headerlink" title="通知支付结果"></a>通知支付结果</h2><h3 id="消息通知方式"><a href="#消息通知方式" class="headerlink" title="消息通知方式"></a><strong>消息通知方式</strong></h3><p>订单服务作为通用服务在订单支付成功后需要将支付结果通知给与订单服务对接的其它微服务。</p><p>为了保证通知过程的简便还要保证消息全部到达消费服务，采用发布订阅的方式通知支付结果。</p><p><img src="/xuecheng/image-20230328220611686.png" alt="image-20230328220611686"></p><p>学习中心服务：对收费课程选课需要支付，与订单服务对接完成支付。</p><p>学习资源服务：对收费的学习资料需要购买后下载，与订单服务对接完成支付。</p><p>订单服务完成支付后将支付结果发给每一个与订单服务对接的微服务，订单服务将消息发给交换机，由交换机广播消息，每个订阅消息的微服务都可以接收到支付结果，根据支付结果的内容去更新自己的业务数据。</p><p>学习中心等微服务收到消息并处理完成通过消息队列回复订单服务。</p><h3 id="分布式事务问题"><a href="#分布式事务问题" class="headerlink" title="分布式事务问题"></a>分布式事务问题</h3><p>订单服务收到第三方支付系统的通知更新支付结果，订单服务将支付结果通知给其它微服务，订单服务需要保证更新支付结果成功并且向其它微服务通知支付结果也成功，两件事跨多个微服务并且需要保证一致性，存在分布式事务控制的需求。</p><p>针对该业务场景如何控制分布式事务？</p><p>根据需求可知，订单服务先将支付结果更新成功后再将支付结果通知给其它微服务，只要保证最终将支付结果通知到微服务保证最终一致性即可，可以采用课程发布模块的技术方案，先通过本地事务更新支付结果的同时添加一条消息表记录，再由任务调度去定时调度将支付结果通知给其它微服务。</p><p><img src="/xuecheng/image-20230328221153237.png" alt="image-20230328221153237"></p><h3 id="集成消息队列"><a href="#集成消息队列" class="headerlink" title="集成消息队列"></a>集成消息队列</h3><h4 id="支付结果通知队列"><a href="#支付结果通知队列" class="headerlink" title="支付结果通知队列"></a>支付结果通知队列</h4><p>订单服务通过消息队列将支付结果发给学习中心服务，消息队列采用发布订阅模式。</p><p>1、订单服务创建支付结果通知交换机。</p><p>2、学习中心服务绑定队列到交换机。</p><p>项目使用RabbitMQ作为消息队列，在课前下发的虚拟上已经安装了RabbitMQ.</p><p>执行docker start rabbitmq 启动RabbitMQ。访问：<a href="http://192.168.101.65:15672/" target="_blank" rel="noopener">http://192.168.101.65:15672/</a> </p><p>账户密码：guest/guest</p><p>交换机Fanout广播模式。</p><p>首先在订单服务添加消息队列依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>在nacos配置rabbitmq-dev.yaml为通用配置文件</p><pre><code>spring:  rabbitmq:    host: 192.168.101.65    port: 5672    username: guest    password: guest    virtual-host: /    publisher-confirm-type: correlated #correlated 异步回调，定义ConfirmCallback，MQ返回结果时会回调这个ConfirmCallback    publisher-returns: false #开启publish-return功能，同样是基于callback机制，需要定义ReturnCallback    template:      mandatory: false #定义消息路由失败时的策略。true，则调用ReturnCallback；false：则直接丢弃消息    listener:      simple:        acknowledge-mode: none #出现异常时返回unack，消息回滚到mq；没有异常，返回ack ,manual:手动控制,none:丢弃消息，不回滚到mq        retry:          enabled: true #开启消费者失败重试          initial-interval: 1000ms #初识的失败等待时长为1秒          multiplier: 1 #失败的等待时长倍数，下次等待时长 = multiplier * last-interval          max-attempts: 3 #最大重试次数          stateless: true #true无状态；false有状态。如果业务中包含事务，这里改为false</code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学成在线项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity-OAuth2</title>
      <link href="/springsecurity-oauth2.html"/>
      <url>/springsecurity-oauth2.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java反射</title>
      <link href="/java-reflection.html"/>
      <url>/java-reflection.html</url>
      
        <content type="html"><![CDATA[<h2 id="反射机制是什么"><a href="#反射机制是什么" class="headerlink" title="反射机制是什么"></a>反射机制是什么</h2><p>1、Java反射机制的核心是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。本质是JVM得到class对象之后，<strong>再通过class对象进行反编译，从而获取对象的各种信息。</strong><br>2、Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，<strong>不需要提前在编译期知道运行的对象是谁。</strong></p><p>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例：</p><pre><code>// Main.javaimport com.itranswarp.learnjava.Person;public class Main {    String getFullName(Person p) {        return p.getFirstName() + &quot; &quot; + p.getLastName();    }}</code></pre><p>但是，如果不能获得<code>Person</code>类，只有一个<code>Object</code>实例，比如这样：</p><pre><code>String getFullName(Object obj) {    return ???}</code></pre><p>怎么办？</p><pre><code>tring getFullName(Object obj) {    Person p = (Person) obj;    return p.getFirstName() + &quot; &quot; + p.getLastName();}</code></pre><p>强制转型的时候，你会发现一个问题：编译上面的代码，仍然需要引用<code>Person</code>类。不然，去掉<code>import</code>语句，你看能不能编译通过？</p><p>所以，反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p><p>除了<code>int</code>等基本类型外，Java的其他类型全部都是<code>class</code>（包括<code>interface</code>）。例如：</p><ul><li><code>String</code></li><li><code>Object</code></li><li><code>Runnable</code></li><li><code>Exception</code></li><li>…</li></ul><p>仔细思考，我们可以得出结论：<code>class</code>（包括<code>interface</code>）的本质是数据类型（<code>Type</code>）。无继承关系的数据类型无法赋值：</p><pre><code>Number n = new Double(123.456); // OKString s = new Double(123.456); // compile error!</code></pre><p>除了<code>int</code>等基本类型外，Java的其他类型全部都是<code>class</code>（包括<code>interface</code>）。例如：</p><ul><li><code>String</code></li><li><code>Object</code></li><li><code>Runnable</code></li><li><code>Exception</code></li><li>…</li></ul><p>仔细思考，我们可以得出结论：<code>class</code>（包括<code>interface</code>）的本质是数据类型（<code>Type</code>）。无继承关系的数据类型无法赋值：</p><pre><code>Number n = new Double(123.456); // OKString s = new Double(123.456); // compile error!</code></pre><p>而<code>class</code>是由JVM在执行过程中动态加载的。JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存。</p><p>每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类型的实例，并关联起来。注意：这里的<code>Class</code>类型是一个名叫<code>Class</code>的<code>class</code>。它长这样：</p><pre><code>public final class Class {    private Class() {}}</code></pre><p>以<code>String</code>类为例，当JVM加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，为<code>String</code>类创建一个<code>Class</code>实例并关联起来：</p><pre><code>Class cls = new Class(String);</code></pre><p>这个<code>Class</code>实例是JVM内部创建的，如果我们查看JDK源码，可以发现<code>Class</code>类的构造方法是<code>private</code>，只有JVM能创建<code>Class</code>实例，我们自己的Java程序是无法创建<code>Class</code>实例的。</p><p>所以，JVM持有的每个<code>Class</code>实例都指向一个数据类型（<code>class</code>或<code>interface</code>）：</p><pre class="line-numbers language-ascii"><code class="language-ascii">┌───────────────────────────┐│      Class Instance       │──────> String├───────────────────────────┤│name = "java.lang.String"  │└───────────────────────────┘┌───────────────────────────┐│      Class Instance       │──────> Random├───────────────────────────┤│name = "java.util.Random"  │└───────────────────────────┘┌───────────────────────────┐│      Class Instance       │──────> Runnable├───────────────────────────┤│name = "java.lang.Runnable"│└───────────────────────────┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个<code>Class</code>实例包含了该<code>class</code>的所有完整信息：</p><pre class="line-numbers language-ascii"><code class="language-ascii">┌───────────────────────────┐│      Class Instance       │──────> String├───────────────────────────┤│name = "java.lang.String"  │├───────────────────────────┤│package = "java.lang"      │├───────────────────────────┤│super = "java.lang.Object" │├───────────────────────────┤│interface = CharSequence...│├───────────────────────────┤│field = value[],hash,...   │├───────────────────────────┤│method = indexOf()...      │└───────────────────────────┘<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。</p><p>这种通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射（Reflection）。</p><h1 id="如何获取一个class的Class实例？有三个方法："><a href="#如何获取一个class的Class实例？有三个方法：" class="headerlink" title="如何获取一个class的Class实例？有三个方法："></a>如何获取一个<code>class</code>的<code>Class</code>实例？有三个方法：</h1><p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p><pre><code>Class cls = String.class;</code></pre><p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p><pre><code>String s = &quot;Hello&quot;;Class cls = s.getClass();</code></pre><p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p><pre><code>Class cls = Class.forName(&quot;java.lang.String&quot;);</code></pre><p>因为<code>Class</code>实例在JVM中是唯一的，所以，上述方法获取的<code>Class</code>实例是同一个实例。可以用<code>==</code>比较两个<code>Class</code>实例：</p><pre><code>Class cls1 = String.class;String s = &quot;Hello&quot;;Class cls2 = s.getClass();boolean sameClass = cls1 == cls2; // true</code></pre><p>注意一下<code>Class</code>实例比较和<code>instanceof</code>的差别：</p><pre><code>Integer n = new Integer(123);boolean b1 = n instanceof Integer; // true，因为n是Integer类型boolean b2 = n instanceof Number; // true，因为n是Number类型的子类boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.classboolean b4 = n.getClass() == Number.class; // false，因为Integer.class!=Number.class</code></pre><p>用<code>instanceof</code>不但匹配指定类型，还匹配指定类型的子类。而用<code>==</code>判断<code>class</code>实例可以精确地判断数据类型，但不能作子类型比较。</p><p>通常情况下，我们应该用<code>instanceof</code>判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个<code>class</code>的时候，我们才使用<code>==</code>判断<code>class</code>实例。</p><p>因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个<code>Object</code>实例时，我们可以通过反射获取该<code>Object</code>的<code>class</code>信息：</p><pre><code>void printObjectInfo(Object obj) {    Class cls = obj.getClass();}</code></pre><h1 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h1><p>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。例如：</p><pre><code>// Main.javapublic class Main {    public static void main(String[] args) {        if (args.length &gt; 0) {            create(args[0]);        }    }    static void create(String name) {        Person p = new Person(name);    }}</code></pre><p>当执行<code>Main.java</code>时，由于用到了<code>Main</code>，因此，JVM首先会把<code>Main.class</code>加载到内存。然而，并不会加载<code>Person.class</code>，除非程序执行到<code>create()</code>方法，JVM发现需要加载<code>Person</code>类时，才会首次加载<code>Person.class</code>。如果没有执行<code>create()</code>方法，那么<code>Person.class</code>根本就不会被加载。</p><p>这就是JVM动态加载<code>class</code>的特性。</p><p>动态加载<code>class</code>的特性对于Java程序非常重要。利用JVM动态加载<code>class</code>的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下：</p><pre><code>// Commons Logging优先使用Log4j:LogFactory factory = null;if (isClassPresent(&quot;org.apache.logging.log4j.Logger&quot;)) {    factory = createLog4j();} else {    factory = createJdkLog();}boolean isClassPresent(String name) {    try {        Class.forName(name);        return true;    } catch (Exception e) {        return false;    }}</code></pre><p>这就是为什么我们只需要把Log4j的jar包放到classpath中，Commons Logging就会自动使用Log4j的原因。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>JVM为每个加载的<code>class</code>及<code>interface</code>创建了对应的<code>Class</code>实例来保存<code>class</code>及<code>interface</code>的所有信息；</p><p>获取一个<code>class</code>对应的<code>Class</code>实例后，就可以获取该<code>class</code>的所有信息；</p><p>通过Class实例获取<code>class</code>信息的方法称为反射（Reflection）；</p><p>JVM总是动态加载<code>class</code>，可以在运行期根据条件来控制加载class。</p><p>对任意的一个<code>Object</code>实例，只要我们获取了它的<code>Class</code>，就可以获取它的一切信息。</p><p>我们先看看如何通过<code>Class</code>实例获取字段信息。<code>Class</code>类提供了以下几个方法来获取字段：</p><ul><li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li><li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li><li>Field[] getFields()：获取所有public的field（包括父类）</li><li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li></ul><p>一个<code>Field</code>对象包含了一个字段的所有信息：</p><ul><li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li><li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li><li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><h1 id="获取字段值"><a href="#获取字段值" class="headerlink" title="获取字段值"></a>获取字段值</h1><p>利用反射拿到字段的一个<code>Field</code>实例只是第一步，我们还可以拿到一个实例对应的该字段的值。</p><p>例如，对于一个<code>Person</code>实例，我们可以先拿到<code>name</code>字段对应的<code>Field</code>，再获取这个实例的<code>name</code>字段的值：</p><pre><code>public class Main {    public static void main(String[] args) throws Exception {        Object p = new Person(&quot;Xiao Ming&quot;);        Class c = p.getClass();        Field f = c.getDeclaredField(&quot;name&quot;);        Object value = f.get(p);        System.out.println(value); // &quot;Xiao Ming&quot;    }}class Person {    private String name;    public Person(String name) {        this.name = name;    }}</code></pre><p>上述代码先获取<code>Class</code>实例，再获取<code>Field</code>实例，然后，用<code>Field.get(Object)</code>获取指定实例的指定字段的值。</p><p>运行代码，如果不出意外，会得到一个<code>IllegalAccessException</code>，这是因为<code>name</code>被定义为一个<code>private</code>字段，正常情况下，<code>Main</code>类无法访问<code>Person</code>类的<code>private</code>字段。要修复错误，可以将<code>private</code>改为<code>public</code>，或者，在调用<code>Object value = f.get(p);</code>前，先写一句：</p><pre><code>f.setAccessible(true);</code></pre><p>调用<code>Field.setAccessible(true)</code>的意思是，别管这个字段是不是<code>public</code>，一律允许访问。</p><p>可以试着加上上述语句，再运行代码，就可以打印出<code>private</code>字段的值。</p><p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p><h3 id="设置字段值"><a href="#设置字段值" class="headerlink" title="设置字段值"></a>设置字段值</h3><p>通过Field实例既然可以获取到指定实例的字段值，自然也可以设置字段的值。</p><p>设置字段值是通过<code>Field.set(Object, Object)</code>实现的，其中第一个<code>Object</code>参数是指定的实例，第二个<code>Object</code>参数是待修改的值</p><pre><code>public class Main {    public static void main(String[] args) throws Exception {        Person p = new Person(&quot;Xiao Ming&quot;);        System.out.println(p.getName()); // &quot;Xiao Ming&quot;        Class c = p.getClass();        Field f = c.getDeclaredField(&quot;name&quot;);        f.setAccessible(true);        f.set(p, &quot;Xiao Hong&quot;);        System.out.println(p.getName()); // &quot;Xiao Hong&quot;    }}class Person {    private String name;    public Person(String name) {        this.name = name;    }    public String getName() {        return this.name;    }}</code></pre><h1 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h1><p>可以通过<code>Class</code>实例获取所有<code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul><p>一个<code>Method</code>对象包含一个方法的所有信息：</p><ul><li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li><li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li><li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>{String.class, int.class}</code>；</li><li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><h3 id="调用方法-1"><a href="#调用方法-1" class="headerlink" title="调用方法"></a>调用方法</h3><p>当我们获取到一个<code>Method</code>对象时，就可以对它进行调用。我们以下面的代码为例：</p><pre><code>String s = &quot;Hello world&quot;;String r = s.substring(6); // &quot;world&quot;</code></pre><p>如果用反射来调用<code>substring</code>方法，需要以下代码：</p><pre><code>public class Main {    public static void main(String[] args) throws Exception {        // String对象:        String s = &quot;Hello world&quot;;        // 获取String substring(int)方法，参数为int:        Method m = String.class.getMethod(&quot;substring&quot;, int.class);        // 在s对象上调用该方法并获取结果:        String r = (String) m.invoke(s, 6);        // 打印调用结果:        System.out.println(r);    }}</code></pre><p>注意到<code>substring()</code>有两个重载方法，我们获取的是<code>String substring(int)</code>这个方法。思考一下如何获取<code>String substring(int, int)</code>方法。</p><p>对<code>Method</code>实例调用<code>invoke</code>就相当于调用该方法，<code>invoke</code>的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。</p><h3 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a>调用静态方法</h3><p>如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以<code>invoke</code>方法传入的第一个参数永远为null</p><pre><code>public class Main {    public static void main(String[] args) throws Exception {        // 获取Integer.parseInt(String)方法，参数为String:        Method m = Integer.class.getMethod(&quot;parseInt&quot;, String.class);        // 调用该静态方法并获取结果:        Integer n = (Integer) m.invoke(null, &quot;12345&quot;);        // 打印调用结果:        System.out.println(n);    }}</code></pre><h3 id="调用非public方法"><a href="#调用非public方法" class="headerlink" title="调用非public方法"></a>调用非public方法</h3><p>和Field类似，对于非public方法，虽然可以通过<code>Class.getDeclaredMethod()</code>获取该方法实例，但直接对其调用将得到一个<code>IllegalAccessException</code>。为了调用非public方法，我们通过<code>Method.setAccessible(true)</code>允许其调用：</p><pre><code>public class Main {    public static void main(String[] args) throws Exception {        Person p = new Person();        Method m = p.getClass().getDeclaredMethod(&quot;setName&quot;, String.class);        m.setAccessible(true);        m.invoke(p, &quot;Bob&quot;);        System.out.println(p.name);    }}class Person {    String name;    private void setName(String name) {        this.name = name;    }}</code></pre><p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>一个<code>Person</code>类定义了<code>hello()</code>方法，并且它的子类<code>Student</code>也覆写了<code>hello()</code>方法，那么，从<code>Person.class</code>获取的<code>Method</code>，作用于<code>Student</code>实例时，调用的方法到底是哪个？</p><p>使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）</p><pre><code>Method m = Person.class.getMethod(&quot;hello&quot;);m.invoke(new Student());</code></pre><p>实际上相当于：</p><pre><code>Person p = new Student();p.hello();</code></pre><h1 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h1><p>### </p><p>Java的反射API提供的Method对象封装了方法的所有信息：</p><p>通过<code>Class</code>实例的方法可以获取<code>Method</code>实例：<code>getMethod()</code>，<code>getMethods()</code>，<code>getDeclaredMethod()</code>，<code>getDeclaredMethods()</code>；</p><p>通过<code>Method</code>实例可以获取方法信息：<code>getName()</code>，<code>getReturnType()</code>，<code>getParameterTypes()</code>，<code>getModifiers()</code>；</p><p>通过<code>Method</code>实例可以调用某个对象的方法：<code>Object invoke(Object instance, Object... parameters)</code>；</p><p>通过设置<code>setAccessible(true)</code>来访问非<code>public</code>方法；</p><p>通过反射调用方法时，仍然遵循多态原则。</p><h1 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h1><p>通常使用<code>new</code>操作符创建新的实例：</p><pre><code>Person p = new Person();</code></pre><p>如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</p><pre><code>Person p = Person.class.newInstance();</code></pre><p>调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。</p><p>为了调用任意的构造方法，Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例：</p><pre><code>public class Main {    public static void main(String[] args) throws Exception {        // 获取构造方法Integer(int):        Constructor cons1 = Integer.class.getConstructor(int.class);        // 调用构造方法:        Integer n1 = (Integer) cons1.newInstance(123);        System.out.println(n1);        // 获取构造方法Integer(String)        Constructor cons2 = Integer.class.getConstructor(String.class);        Integer n2 = (Integer) cons2.newInstance(&quot;456&quot;);        System.out.println(n2);    }}</code></pre><p>通过Class实例获取Constructor的方法如下：</p><ul><li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li><li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li></ul><p>注意<code>Constructor</code>总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p><p>调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p><h1 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h1><p><code>Constructor</code>对象封装了构造方法的所有信息；</p><p>通过<code>Class</code>实例的方法可以获取<code>Constructor</code>实例：<code>getConstructor()</code>，<code>getConstructors()</code>，<code>getDeclaredConstructor()</code>，<code>getDeclaredConstructors()</code>；</p><p>通过<code>Constructor</code>实例可以创建一个实例对象：<code>newInstance(Object... parameters)</code>； 通过设置<code>setAccessible(true)</code>来访问非<code>public</code>构造方法。</p><h1 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h1><p>当获取到某个<code>Class</code>对象时，实际上就获取到了一个类的类型：</p><pre><code>Class cls = String.class; // 获取到String的Class</code></pre><p>还可以用实例的<code>getClass()</code>方法获取：</p><pre><code>String s = &quot;&quot;;Class cls = s.getClass(); // s是String，因此获取到String的Class</code></pre><p>最后一种获取<code>Class</code>的方法是通过<code>Class.forName(&quot;&quot;)</code>，传入<code>Class</code>的完整类名获取：</p><pre><code>Class s = Class.forName(&quot;java.lang.String&quot;);</code></pre><p>这三种方式获取的<code>Class</code>实例都是同一个实例，因为JVM对每个加载的<code>Class</code>只创建一个<code>Class</code>实例来表示它的类型。</p><h3 id="获取父类的Class"><a href="#获取父类的Class" class="headerlink" title="获取父类的Class"></a>获取父类的Class</h3><p>有了<code>Class</code>实例，我们还可以获取它的父类的<code>Class</code>：</p><pre><code>public class Main {    public static void main(String[] args) throws Exception {        Class i = Integer.class;        Class n = i.getSuperclass();        System.out.println(n);        Class o = n.getSuperclass();        System.out.println(o);        System.out.println(o.getSuperclass());    }}</code></pre><p>运行上述代码，可以看到，<code>Integer</code>的父类类型是<code>Number</code>，<code>Number</code>的父类是<code>Object</code>，<code>Object</code>的父类是<code>null</code>。除<code>Object</code>外，其他任何非<code>interface</code>的<code>Class</code>都必定存在一个父类类型。</p><h3 id="获取interface"><a href="#获取interface" class="headerlink" title="获取interface"></a>获取interface</h3><p>由于一个类可能实现一个或多个接口，通过<code>Class</code>我们就可以查询到实现的接口类型。例如，查询<code>Integer</code>实现的接口</p><pre><code>public class Main {    public static void main(String[] args) throws Exception {        Class s = Integer.class;        Class[] is = s.getInterfaces();        for (Class i : is) {            System.out.println(i);        }    }}</code></pre><p>运行上述代码可知，<code>Integer</code>实现的接口有：</p><ul><li>java.lang.Comparable</li><li>java.lang.constant.Constable</li><li>java.lang.constant.ConstantDesc</li></ul><p>要特别注意：<code>getInterfaces()</code>只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型：</p><p><code>// reflection import java.lang.reflect.Method;</code> Run</p><p><code>Integer</code>的父类是<code>Number</code>，<code>Number</code>实现的接口是<code>java.io.Serializable</code>。</p><p>此外，对所有<code>interface</code>的<code>Class</code>调用<code>getSuperclass()</code>返回的是<code>null</code>，获取接口的父接口要用<code>getInterfaces()</code>：</p><pre><code>System.out.println(java.io.DataInputStream.class.getSuperclass()); // java.io.FilterInputStream，因为DataInputStream继承自FilterInputStreamSystem.out.println(java.io.Closeable.class.getSuperclass()); // null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces()</code></pre><p>如果一个类没有实现任何<code>interface</code>，那么<code>getInterfaces()</code>返回空数组。</p><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p>当我们判断一个实例是否是某个类型时，正常情况下，使用<code>instanceof</code>操作符：</p><pre><code>Object n = Integer.valueOf(123);boolean isDouble = n instanceof Double; // falseboolean isInteger = n instanceof Integer; // trueboolean isNumber = n instanceof Number; // trueboolean isSerializable = n instanceof java.io.Serializable; // true</code></pre><p>如果是两个<code>Class</code>实例，要判断一个向上转型是否成立，可以调用<code>isAssignableFrom()</code>：</p><pre><code>// Integer i = ?Integer.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Integer// Number n = ?Number.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Number// Object o = ?Object.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Object// Integer i = ?Integer.class.isAssignableFrom(Number.class); // false，因为Number不能赋值给Integer</code></pre><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>通过<code>Class</code>对象可以获取继承关系：</p><ul><li><code>Class getSuperclass()</code>：获取父类类型；</li><li><code>Class[] getInterfaces()</code>：获取当前类实现的所有接口。</li></ul><p>通过<code>Class</code>对象的<code>isAssignableFrom()</code>方法可以判断一个向上转型是否可以实现。</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>来比较Java的<code>class</code>和<code>interface</code>的区别：</p><ul><li>可以实例化<code>class</code>（非<code>abstract</code>）；</li><li>不能实例化<code>interface</code>。</li></ul><p>所有<code>interface</code>类型的变量总是通过某个实例向上转型并赋值给接口类型变量的：</p><pre><code>CharSequence cs = new StringBuilder();</code></pre><p>有没有可能不编写实现类，直接在运行期创建某个<code>interface</code>的实例呢？</p><p>这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</p><p>什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。</p><p>来看静态代码怎么写：</p><p>定义接口：</p><pre><code>public interface Hello {    void morning(String name);}</code></pre><p>编写实现类：</p><pre><code>public class HelloWorld implements Hello {    public void morning(String name) {        System.out.println(&quot;Good morning, &quot; + name);    }}</code></pre><p>创建实例，转型为接口并调用：</p><pre><code>Hello hello = new HelloWorld();hello.morning(&quot;Bob&quot;);</code></pre><p>这种方式就是我们通常编写代码的方式。</p><p>还有一种方式是动态代码，仍然先定义了接口<code>Hello</code>，但是我们并不去编写实现类，而是直接通过JDK提供的一个<code>Proxy.newProxyInstance()</code>创建了一个<code>Hello</code>接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。</p><p>一个最简单的动态代理实现如下：</p><pre><code>public class Main {    public static void main(String[] args) {        InvocationHandler handler = new InvocationHandler() {            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                System.out.println(method);                if (method.getName().equals(&quot;morning&quot;)) {                    System.out.println(&quot;Good morning, &quot; + args[0]);                }                return null;            }        };        Hello hello = (Hello) Proxy.newProxyInstance(            Hello.class.getClassLoader(), // 传入ClassLoader            new Class[] { Hello.class }, // 传入要实现的接口            handler); // 传入处理调用方法的InvocationHandler        hello.morning(&quot;Bob&quot;);    }}interface Hello {    void morning(String name);}</code></pre><p>在运行期动态创建一个<code>interface</code>实例的方法如下：</p><ol><li><p>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</p></li><li><p>通过</p><pre><code>Proxy.newProxyInstance()</code></pre><p>创建</p><pre><code>interface</code></pre><p>实例，它需要3个参数：</p><ol><li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li></ol></li><li><p>将返回的<code>Object</code>强制转型为接口。</p></li></ol><p>动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：</p><pre><code>public class HelloDynamicProxy implements Hello {    InvocationHandler handler;    public HelloDynamicProxy(InvocationHandler handler) {        this.handler = handler;    }    public void morning(String name) {        handler.invoke(           this,           Hello.class.getMethod(&quot;morning&quot;, String.class),           new Object[] { name });    }}</code></pre><p>其实就是JVM帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>Java标准库提供了动态代理功能，允许在运行期动态创建一个接口的实例；</p><p>动态代理是通过<code>Proxy</code>创建代理对象，然后将接口方法“代理”给<code>InvocationHandler</code>完成的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis02分布式缓存</title>
      <link href="/redis02-distributed-caching.html"/>
      <url>/redis02-distributed-caching.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><p>– 基于Redis集群解决单机Redis存在的问题</p><p>单机的Redis存在四大问题：</p><p><img src="/redis02-distributed-caching/image-20210725144240631.png" alt="image-20210725144240631"></p><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>Redis有两种持久化方案：</p><ul><li>RDB持久化</li><li>AOF持久化</li></ul><h2 id="1-1-RDB持久化"><a href="#1-1-RDB持久化" class="headerlink" title="1.1.RDB持久化"></a>1.1.RDB持久化</h2><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p><h3 id="1-1-1-执行时机"><a href="#1-1-1-执行时机" class="headerlink" title="1.1.1.执行时机"></a>1.1.1.执行时机</h3><p>RDB持久化在四种情况下会执行：</p><ul><li>执行save命令</li><li>执行bgsave命令</li><li>Redis停机时</li><li>触发RDB条件时</li></ul><p><strong>1）save命令</strong></p><p>执行下面的命令，可以立即执行一次RDB：</p><p><img src="/redis02-distributed-caching/image-20210725144536958.png" alt="image-20210725144536958"></p><p>save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p><p><strong>2）bgsave命令</strong></p><p>下面的命令可以异步执行RDB：</p><p><img src="/redis02-distributed-caching/image-20210725144725943.png" alt="image-20210725144725943"></p><p>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p><p><strong>3）停机时</strong></p><p>Redis停机时会执行一次save命令，实现RDB持久化。</p><p><strong>4）触发RDB条件</strong></p><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save "" 则表示禁用RDB</span><span class="token attr-name">save</span> <span class="token attr-value">900 1  </span><span class="token attr-name">save</span> <span class="token attr-value">300 10  </span><span class="token attr-name">save</span> <span class="token attr-value">60 10000 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>RDB的其它配置也可以在redis.conf文件中设置：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span><span class="token attr-name">rdbcompression</span> <span class="token attr-value">yes</span><span class="token comment" spellcheck="true"># RDB文件名称</span><span class="token attr-name">dbfilename</span> <span class="token attr-value">dump.rdb  </span><span class="token comment" spellcheck="true"># 文件保存的路径目录</span><span class="token attr-name">dir</span> <span class="token attr-value">./ </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-2-RDB原理"><a href="#1-1-2-RDB原理" class="headerlink" title="1.1.2.RDB原理"></a>1.1.2.RDB原理</h3><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p><p>fork采用的是copy-on-write技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><p><img src="/redis02-distributed-caching/image-20210725151319695.png" alt="image-20210725151319695"></p><h3 id="1-1-3-小结"><a href="#1-1-3-小结" class="headerlink" title="1.1.3.小结"></a>1.1.3.小结</h3><p>RDB方式bgsave的基本流程？</p><ul><li>fork主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的RDB文件</li><li>用新RDB文件替换旧的RDB文件</li></ul><p>RDB会在什么时候执行？save 60 1000代表什么含义？</p><ul><li>默认是服务停止时</li><li>代表60秒内至少执行1000次修改则触发RDB</li></ul><p>RDB的缺点？</p><ul><li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li><li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul><h2 id="1-2AOF持久化"><a href="#1-2AOF持久化" class="headerlink" title="1.2AOF持久化"></a>1.2AOF持久化</h2><h3 id="1-2-1-AOF原理"><a href="#1-2-1-AOF原理" class="headerlink" title="1.2.1.AOF原理"></a>1.2.1.AOF原理</h3><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><p><img src="/redis02-distributed-caching/image-20210725151543640.png" alt="image-20210725151543640"></p><h3 id="1-2-2-AOF配置"><a href="#1-2-2-AOF配置" class="headerlink" title="1.2.2.AOF配置"></a>1.2.2.AOF配置</h3><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 是否开启AOF功能，默认是no</span><span class="token attr-name">appendonly</span> <span class="token attr-value">yes</span><span class="token comment" spellcheck="true"># AOF文件的名称</span><span class="token attr-name">appendfilename</span> <span class="token attr-value">"appendonly.aof"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 表示每执行一次写命令，立即记录到AOF文件</span><span class="token attr-name">appendfsync</span> <span class="token attr-value">always </span><span class="token comment" spellcheck="true"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span><span class="token attr-name">appendfsync</span> <span class="token attr-value">everysec </span><span class="token comment" spellcheck="true"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span><span class="token attr-name">appendfsync</span> <span class="token attr-value">no</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三种策略对比：</p><p><img src="/redis02-distributed-caching/image-20210725151654046.png" alt="image-20210725151654046"></p><h3 id="1-2-3-AOF文件重写"><a href="#1-2-3-AOF文件重写" class="headerlink" title="1.2.3.AOF文件重写"></a>1.2.3.AOF文件重写</h3><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p><img src="/redis02-distributed-caching/image-20210725151729118.png" alt="image-20210725151729118"></p><p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p><p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># AOF文件比上次文件 增长超过多少百分比则触发重写</span><span class="token attr-name">auto-aof-rewrite-percentage</span> <span class="token attr-value">100</span><span class="token comment" spellcheck="true"># AOF文件体积最小多大以上才触发重写 </span><span class="token attr-name">auto-aof-rewrite-min-size</span> <span class="token attr-value">64mb </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-RDB与AOF对比"><a href="#1-3-RDB与AOF对比" class="headerlink" title="1.3.RDB与AOF对比"></a>1.3.RDB与AOF对比</h2><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><p><img src="/redis02-distributed-caching/image-20210725151940515.png" alt="image-20210725151940515"></p><h1 id="Redis主从"><a href="#Redis主从" class="headerlink" title="Redis主从"></a>Redis主从</h1><h2 id="主从数据同步原理"><a href="#主从数据同步原理" class="headerlink" title="主从数据同步原理"></a>主从数据同步原理</h2><p>开启主从关系</p><p>有临时和永久两种模式：</p><ul><li><p>修改配置文件（永久生效）</p><ul><li>在redis.conf中添加一行配置：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></li></ul></li><li><p>使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：</p><pre class="line-numbers language-sh"><code class="language-sh">slaveof <masterip> <masterport><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong><font color="red">注意</font></strong>：在5.0以后新增命令replicaof，与salveof效果一致。</p><h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：</p><p><img src="/redis02-distributed-caching/image-20210725152222497.png" alt="image-20210725152222497"></p><p>这里有一个问题，master如何得知salve是第一次来连接呢？？</p><p>有几个概念，可以作为判断依据：</p><ul><li><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li><li><strong>offset</strong>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li></ul><p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。</p><p>因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。</p><p>master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p><p>master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</p><p>因此，<strong>master判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。</p><p>如图：</p><p><img src="/redis02-distributed-caching/image-20210725152700914.png" alt="image-20210725152700914"></p><p>完整流程描述：</p><ul><li>slave节点请求增量同步</li><li>master节点判断replid，发现不一致，拒绝增量同步</li><li>master将完整内存数据生成RDB，发送RDB到slave</li><li>slave清空本地数据，加载master的RDB</li><li>master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</li><li>slave执行接收到的命令，保持与master之间的同步</li></ul><h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3><p>全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong>。</p><p>什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：</p><p><img src="/redis02-distributed-caching/image-20210725153201086.png" alt="image-20210725153201086"></p><p>那么master怎么知道slave与自己的数据差异在哪里呢?</p><h3 id="repl-backlog原理"><a href="#repl-backlog原理" class="headerlink" title="repl_backlog原理"></a>repl_backlog原理</h3><p>master怎么知道slave与自己的数据差异在哪里呢?</p><p>这就要说到全量同步时的repl_baklog文件了。</p><p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p><p>repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：</p><p><img src="/redis02-distributed-caching/image-20210725153359022.png" alt="image-20210725153359022"> </p><p>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。</p><p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p><p><img src="/redis02-distributed-caching/image-20210725153524190.png" alt="image-20210725153524190"> </p><p>直到数组被填满：</p><p><img src="/redis02-distributed-caching/image-20210725153715910.png" alt="image-20210725153715910"> </p><p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</p><p>但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset： </p><p><img src="/redis02-distributed-caching/image-20210725153937031.png" alt="image-20210725153937031"> </p><p>如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：</p><p><img src="/redis02-distributed-caching/image-20210725154155984.png" alt="image-20210725154155984"> </p><p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。</p><p><img src="/redis02-distributed-caching/image-20210725154216392.png" alt="image-20210725154216392"></p><h2 id="主从同步优化"><a href="#主从同步优化" class="headerlink" title="主从同步优化"></a>主从同步优化</h2><p>主从同步可以保证主从数据的一致性，非常重要。</p><p>可以从以下几个方面来优化Redis主从就集群：</p><ul><li>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</li></ul><p>主从从架构图：</p><p><img src="/redis02-distributed-caching/image-20210725154405899.png" alt="image-20210725154405899"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>简述全量同步和增量同步区别？</p><ul><li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</li><li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li></ul><p>什么时候执行全量同步？</p><ul><li>slave节点第一次连接master节点时</li><li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li></ul><p>什么时候执行增量同步？</p><ul><li>slave节点断开又恢复，并且在repl_baklog中能找到offset时</li></ul><h1 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h1><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。</p><h2 id="哨兵原理"><a href="#哨兵原理" class="headerlink" title="哨兵原理"></a>哨兵原理</h2><h3 id="集群结构和作用"><a href="#集群结构和作用" class="headerlink" title="集群结构和作用"></a>集群结构和作用</h3><h1 id="搭建哨兵集群"><a href="#搭建哨兵集群" class="headerlink" title="搭建哨兵集群"></a>搭建哨兵集群</h1><h2 id="集群结构"><a href="#集群结构" class="headerlink" title="集群结构"></a>集群结构</h2><p>这里我们搭建一个三节点形成的Sentinel集群，来监管之前的Redis主从集群。如图：</p><p><img src="/redis02-distributed-caching/image-20210701215227018.png" alt="image-20210701215227018"></p><p>三个sentinel实例信息如下：</p><table><thead><tr><th>节点</th><th align="center">IP</th><th align="center">PORT</th></tr></thead><tbody><tr><td>s1</td><td align="center">192.168.150.101</td><td align="center">27001</td></tr><tr><td>s2</td><td align="center">192.168.150.101</td><td align="center">27002</td></tr><tr><td>s3</td><td align="center">192.168.150.101</td><td align="center">27003</td></tr></tbody></table><h2 id="准备实例和配置"><a href="#准备实例和配置" class="headerlink" title="准备实例和配置"></a>准备实例和配置</h2><p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p><p>创建三个文件夹，名字分别叫s1、s2、s3：</p><pre class="line-numbers language-sh"><code class="language-sh"># 进入/tmp目录cd /tmp# 创建目录mkdir s1 s2 s3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如图：</p><p><img src="/redis02-distributed-caching/image-20210701215534714.png" alt="image-20210701215534714"></p><p>然后在s1目录创建一个sentinel.conf文件，添加下面的内容：</p><pre class="line-numbers language-ini"><code class="language-ini">port 27001sentinel announce-ip 192.168.150.101sentinel monitor mymaster 192.168.150.101 7001 2sentinel down-after-milliseconds mymaster 5000sentinel failover-timeout mymaster 60000dir "/tmp/s1"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解读：</p><ul><li><code>port 27001</code>：是当前sentinel实例的端口</li><li><code>sentinel monitor mymaster 192.168.150.101 7001 2</code>：指定主节点信息<ul><li><code>mymaster</code>：主节点名称，自定义，任意写</li><li><code>192.168.150.101 7001</code>：主节点的ip和端口</li><li><code>2</code>：选举master时的quorum值</li></ul></li></ul><p>然后将s1/sentinel.conf文件拷贝到s2、s3两个目录中（在/tmp目录执行下列命令）：</p><pre class="line-numbers language-sh"><code class="language-sh"># 方式一：逐个拷贝cp s1/sentinel.conf s2cp s1/sentinel.conf s3# 方式二：管道组合命令，一键拷贝echo s2 s3 | xargs -t -n 1 cp s1/sentinel.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003：</p><pre class="line-numbers language-sh"><code class="language-sh">sed -i -e 's/27001/27002/g' -e 's/s1/s2/g' s2/sentinel.confsed -i -e 's/27001/27003/g' -e 's/s1/s3/g' s3/sentinel.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p><pre class="line-numbers language-sh"><code class="language-sh"># 第1个redis-sentinel s1/sentinel.conf# 第2个redis-sentinel s2/sentinel.conf# 第3个redis-sentinel s3/sentinel.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动后：</p><p><img src="/redis02-distributed-caching/image-20210701220714104.png" alt="image-20210701220714104"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>尝试让master节点7001宕机，查看sentinel日志：</p><p><img src="/redis02-distributed-caching/image-20210701222857997.png" alt="image-20210701222857997"></p><p>查看7003的日志：</p><p><img src="/redis02-distributed-caching/image-20210701223025709.png" alt="image-20210701223025709"></p><p>查看7002的日志：</p><p><img src="/redis02-distributed-caching/image-20210701223131264.png" alt="image-20210701223131264"></p>]]></content>
      
      
      <categories>
          
          <category> NoSql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis入门</title>
      <link href="/redis01-getting-started.html"/>
      <url>/redis01-getting-started.html</url>
      
        <content type="html"><![CDATA[<h1 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h1><p>Redis是一种键值型的NoSql数据库，这里有两个关键字：</p><ul><li><p>键值型</p></li><li><p>NoSql</p></li></ul><p>其中<strong>键值型</strong>，是指Redis中存储的数据都是以key、value对的形式存储，而value的形式多种多样，可以是字符串、数值、甚至json：</p><p><img src="/redis01-getting-started/6U1Rhxo.png" alt="image-20220502190959608"></p><p>而NoSql则是相对于传统关系型数据库而言，有很大差异的一种数据库。</p><h2 id="1-1-认识NoSQL"><a href="#1-1-认识NoSQL" class="headerlink" title="1.1.认识NoSQL"></a>1.1.认识NoSQL</h2><p><strong>NoSql</strong>可以翻译做Not Only Sql（不仅仅是SQL），或者是No Sql（非Sql的）数据库。是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为<strong>非关系型数据库</strong>。</p><h3 id="1-1-1-结构化与非结构化"><a href="#1-1-1-结构化与非结构化" class="headerlink" title="1.1.1.结构化与非结构化"></a>1.1.1.结构化与非结构化</h3><p>传统关系型数据库是结构化数据，每一张表都有严格的约束信息：字段名、字段数据类型、字段约束等等信息，插入的数据必须遵守这些约束：</p><p><img src="/redis01-getting-started/4tUgFo6.png" alt></p><p>而NoSql则对数据库格式没有严格约束，往往形式松散，自由。</p><p>可以是键值型：</p><p><img src="/redis01-getting-started/GdqOSsj.png" alt></p><p>也可以是文档型：</p><p><img src="/redis01-getting-started/zBBQfcc.png" alt></p><p>甚至可以是图格式：</p><p><img src="/redis01-getting-started/zBnKxWf.png" alt></p><h3 id="1-1-2-关联和非关联"><a href="#1-1-2-关联和非关联" class="headerlink" title="1.1.2.关联和非关联"></a>1.1.2.关联和非关联</h3><p>传统数据库的表与表之间往往存在关联，例如外键：</p><p><img src="/redis01-getting-started/tXYSl5x.png" alt></p><p>而非关系型数据库不存在关联关系，要维护关系要么靠代码中的业务逻辑，要么靠数据之间的耦合：</p><pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>  id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>  name<span class="token operator">:</span> <span class="token string">"张三"</span><span class="token punctuation">,</span>  orders<span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>       id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>       item<span class="token operator">:</span> <span class="token punctuation">{</span>     id<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">"荣耀6"</span><span class="token punctuation">,</span> price<span class="token operator">:</span> <span class="token number">4999</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>       id<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>       item<span class="token operator">:</span> <span class="token punctuation">{</span>     id<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> title<span class="token operator">:</span> <span class="token string">"小米11"</span><span class="token punctuation">,</span> price<span class="token operator">:</span> <span class="token number">3999</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处要维护“张三”的订单与商品“荣耀”和“小米11”的关系，不得不冗余的将这两个商品保存在张三的订单文档中，不够优雅。还是建议用业务来维护关联关系。</p><h3 id="1-1-3-查询方式"><a href="#1-1-3-查询方式" class="headerlink" title="1.1.3.查询方式"></a>1.1.3.查询方式</h3><p>传统关系型数据库会基于Sql语句做查询，语法有统一标准；</p><p>而不同的非关系数据库查询语法差异极大，五花八门各种各样。</p><p><img src="/redis01-getting-started/AzaHOTF.png" alt></p><h3 id="1-1-4-事务"><a href="#1-1-4-事务" class="headerlink" title="1.1.4.事务"></a>1.1.4.事务</h3><p>传统关系型数据库能满足事务ACID的原则。</p><p><img src="/redis01-getting-started/J1MqOJM.png" alt></p><p>而非关系型数据库往往不支持事务，或者不能严格保证ACID的特性，只能实现基本的一致性。</p><h3 id="1-1-5-总结"><a href="#1-1-5-总结" class="headerlink" title="1.1.5.总结"></a>1.1.5.总结</h3><p>除了上述四点以外，在存储方式、扩展性、查询性能上关系型与非关系型也都有着显著差异，总结如下：</p><p><img src="/redis01-getting-started/kZP40dQ.png" alt></p><ul><li>存储方式<ul><li>关系型数据库基于磁盘进行存储，会有大量的磁盘IO，对性能有一定影响</li><li>非关系型数据库，他们的操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些</li></ul></li></ul><ul><li>扩展性<ul><li>关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。</li><li>非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。</li><li>关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦</li></ul></li></ul><h2 id="1-2-认识Redis"><a href="#1-2-认识Redis" class="headerlink" title="1.2.认识Redis"></a>1.2.认识Redis</h2><p>Redis诞生于2009年全称是<strong>Re</strong>mote  <strong>D</strong>ictionary <strong>S</strong>erver 远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p><strong>特征</strong>：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><p><strong>作者</strong>：Antirez</p><p>Redis的官方网站地址：<a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></p><h2 id="1-3-安装Redis"><a href="#1-3-安装Redis" class="headerlink" title="1.3.安装Redis"></a>1.3.安装Redis</h2><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此课程中我们会基于Linux系统来安装Redis.</p><p>此处选择的Linux版本为CentOS 7.</p><h3 id="1-3-1-依赖库"><a href="#1-3-1-依赖库" class="headerlink" title="1.3.1.依赖库"></a>1.3.1.依赖库</h3><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p><pre class="line-numbers language-sh"><code class="language-sh">yum install -y gcc tcl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-3-2-上传安装包并解压"><a href="#1-3-2-上传安装包并解压" class="headerlink" title="1.3.2.上传安装包并解压"></a>1.3.2.上传安装包并解压</h3><p>例如，我放到了/usr/local/src 目录：</p><p><img src="/redis01-getting-started/01DTNCf.png" alt></p><p>解压缩：</p><pre class="line-numbers language-sh"><code class="language-sh">tar -xzf redis-6.2.6.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压后：</p><p><img src="/redis01-getting-started/8V6zvCD.png" alt="image-20211211080339076"></p><p>进入redis目录：</p><pre class="line-numbers language-sh"><code class="language-sh">cd redis-6.2.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行编译命令：</p><pre class="line-numbers language-sh"><code class="language-sh">make && make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果没有出错，应该就安装成功了。</p><p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p><p>该目录已经默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><h3 id="1-3-3-启动"><a href="#1-3-3-启动" class="headerlink" title="1.3.3.启动"></a>1.3.3.启动</h3><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h3 id="1-3-4-默认启动"><a href="#1-3-4-默认启动" class="headerlink" title="1.3.4.默认启动"></a>1.3.4.默认启动</h3><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><pre><code>redis-server</code></pre><p>如图：</p><p><img src="/redis01-getting-started/v7xWsqC.png" alt></p><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h3 id="1-3-5-指定配置启动"><a href="#1-3-5-指定配置启动" class="headerlink" title="1.3.5.指定配置启动"></a>1.3.5.指定配置启动</h3><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p><img src="/redis01-getting-started/image-20211211082225509.png" alt="image-20211211082225509"></p><p>我们先将这个配置文件备份一份：</p><pre><code>cp redis.conf redis.conf.bck</code></pre><p>然后修改redis.conf文件中的一些配置：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span><span class="token attr-name">bind</span> <span class="token attr-value">0.0.0.0</span><span class="token comment" spellcheck="true"># 守护进程，修改为yes后即可后台运行</span><span class="token attr-name">daemonize</span> <span class="token attr-value">yes </span><span class="token comment" spellcheck="true"># 密码，设置后访问Redis必须输入密码</span><span class="token attr-name">requirepass</span> <span class="token attr-value">123321</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Redis的其它常见配置：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 监听的端口</span><span class="token attr-name">port</span> <span class="token attr-value">6379</span><span class="token comment" spellcheck="true"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span><span class="token attr-name">dir</span> <span class="token attr-value">.</span><span class="token comment" spellcheck="true"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span><span class="token attr-name">databases</span> <span class="token attr-value">1</span><span class="token comment" spellcheck="true"># 设置redis能够使用的最大内存</span><span class="token attr-name">maxmemory</span> <span class="token attr-value">512mb</span><span class="token comment" spellcheck="true"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span><span class="token attr-name">logfile</span> <span class="token attr-value">"redis.log"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动Redis：</p><pre class="line-numbers language-sh"><code class="language-sh"># 进入redis安装目录 cd /usr/local/src/redis-6.2.6# 启动redis-server redis.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>停止服务：</p><pre class="line-numbers language-sh"><code class="language-sh"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，# 因为之前配置了密码，因此需要通过 -u 来指定密码redis-cli -u 123321 shutdown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>1320159539</p><h3 id="1-3-6-开机自启"><a href="#1-3-6-开机自启" class="headerlink" title="1.3.6.开机自启"></a>1.3.6.开机自启</h3><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><pre class="line-numbers language-sh"><code class="language-sh">vi /etc/systemd/system/redis.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>内容如下：</p><pre class="line-numbers language-conf"><code class="language-conf">[Unit]Description=redis-serverAfter=network.target[Service]Type=forkingExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.confPrivateTmp=true[Install]WantedBy=multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后重载系统服务：</p><pre class="line-numbers language-sh"><code class="language-sh">systemctl daemon-reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，我们可以用下面这组命令来操作redis了：</p><pre class="line-numbers language-sh"><code class="language-sh"># 启动systemctl start redis# 停止systemctl stop redis# 重启systemctl restart redis# 查看状态systemctl status redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行下面的命令，可以让redis开机自启：</p><pre class="line-numbers language-sh"><code class="language-sh">systemctl enable redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-4-Redis桌面客户端"><a href="#1-4-Redis桌面客户端" class="headerlink" title="1.4.Redis桌面客户端"></a>1.4.Redis桌面客户端</h2><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编程客户端</li></ul><h3 id="1-4-1-Redis命令行客户端"><a href="#1-4-1-Redis命令行客户端" class="headerlink" title="1.4.1.Redis命令行客户端"></a>1.4.1.Redis命令行客户端</h3><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><pre class="line-numbers language-sh"><code class="language-sh">redis-cli [options] [commonds]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码  (1320159539)</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p><p><img src="/redis01-getting-started/OYYWPNo.png" alt></p><h3 id="1-4-2-图形化桌面客户端"><a href="#1-4-2-图形化桌面客户端" class="headerlink" title="1.4.2.图形化桌面客户端"></a>1.4.2.图形化桌面客户端</h3><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a href="https://github.com/uglide/RedisDesktopManager" target="_blank" rel="noopener">https://github.com/uglide/RedisDesktopManager</a></p><p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p><p>在下面这个仓库可以找到安装包：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases" target="_blank" rel="noopener">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p><h3 id="1-4-3-安装"><a href="#1-4-3-安装" class="headerlink" title="1.4.3.安装"></a>1.4.3.安装</h3><p><img src="/redis01-getting-started/hwK5LQ8.png" alt></p><p>双击即可运行：</p><p><img src="/redis01-getting-started/6hUqslY.png" alt></p><h3 id="1-4-4-建立连接"><a href="#1-4-4-建立连接" class="headerlink" title="1.4.4.建立连接"></a>1.4.4.建立连接</h3><p>点击左上角的<code>连接到Redis服务器</code>按钮：</p><p><img src="/redis01-getting-started/9qTGyoN.png" alt></p><p>在弹出的窗口中填写Redis服务信息：</p><p><img src="/redis01-getting-started/DshNnKC.png" alt></p><p>点击确定后，在左侧菜单会出现这个链接：</p><p><img src="/redis01-getting-started/A2cOm7Q.png" alt></p><p>点击即可建立连接了。</p><p><img src="/redis01-getting-started/ja8Fd9s.png" alt></p><p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p><p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p><pre class="line-numbers language-sh"><code class="language-sh"># 选择 0号库select 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h1><p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：</p><p><img src="/redis01-getting-started/8tli2o9.png" alt></p><p>在官网（ <a href="https://redis.io/commands" target="_blank" rel="noopener">https://redis.io/commands </a>）可以查看到不同的命令：</p><p><img src="/redis01-getting-started/5Lcr3BE.png" alt></p><p>不同类型的命令称为一个group，我们也可以通过help命令来查看各种不同group的命令：</p><p><img src="/redis01-getting-started/suevOIR.png" alt></p><h2 id="2-1-Redis通用命令"><a href="#2-1-Redis通用命令" class="headerlink" title="2.1.Redis通用命令"></a>2.1.Redis通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li><p>KEYS：查看符合模板的所有key</p></li><li><p>在 Redis 中是支持模糊查询的，它有 3 个通配符，分别是：*、 ? 和 []</p><ul><li>*：通配任意多个字符</li><li>?：通配单个字符</li><li>[]：通配括号内的某 1 个字符</li></ul></li><li><p>DEL：删除一个指定的key</p></li><li><p>EXISTS：判断key是否存在</p></li><li><p>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</p></li><li><p>与 <strong>expire</strong> 命令相关的命令有三个，分别是：</p><ul><li><strong>expireat</strong> 命令用来 设置一个 UNIX 时间戳的过期时间，这个命令就不举例了</li><li><strong>pexpire</strong> 命令用来 设置 key 的有效时间以毫秒为单位</li><li><strong>pexpireat</strong> 命令用来 设置 key 的到期 UNIX 时间戳以毫秒为单位</li></ul></li><li><p>TTL：查看一个KEY的剩余有效期</p></li><li><p><strong>randomkey</strong> 命令用来 返回一个随机的key</p></li><li><p><strong>rename</strong> 命令用来 将一个 key 重命名</p></li><li><p><strong>type</strong> 命令用来 获取 key 的存储类型</p></li></ul><p>通过help [command] 可以查看一个命令的具体用法，例如：</p><pre class="line-numbers language-sh"><code class="language-sh"># 查看keys命令的帮助信息：127.0.0.1:6379> help keysKEYS patternsummary: Find all keys matching the given patternsince: 1.0.0group: generic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-String类型"><a href="#2-2-String类型" class="headerlink" title="2.2.String类型"></a>2.2.String类型</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增、自减操作</li><li>float：浮点类型，可以做自增、自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p><p><img src="/redis01-getting-started/VZqpv73.png" alt></p><h3 id="2-2-1-String的常见命令"><a href="#2-2-1-String的常见命令" class="headerlink" title="2.2.1.String的常见命令"></a>2.2.1.String的常见命令</h3><p>String的常见命令有：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><h3 id="2-2-2-Key结构"><a href="#2-2-2-Key结构" class="headerlink" title="2.2.2.Key结构"></a>2.2.2.Key结构</h3><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p><p>例如，需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用’:’隔开，格式如下：</p><pre><code>    项目名:业务名:类型:id</code></pre><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样以来，我们就可以把不同类型的数据区分开了。从而避免了key的冲突问题。</p><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>heima:user:1</td><td>{“id”:1,  “name”: “Jack”, “age”: 21}</td></tr><tr><td>heima:product:1</td><td>{“id”:1,  “name”: “小米11”, “price”: 4999}</td></tr></tbody></table><p>并且，在Redis的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰：</p><p><img src="/redis01-getting-started/InWMfeD.png" alt></p><h2 id="2-3-Hash类型"><a href="#2-3-Hash类型" class="headerlink" title="2.3.Hash类型"></a>2.3.Hash类型</h2><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便：</p><p><img src="/redis01-getting-started/x2zDBjf.png" alt></p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><p><img src="/redis01-getting-started/VF2EPt0.png" alt></p><p>Hash的常见命令有：</p><ul><li><p>HSET key field value：添加或者修改hash类型key的field的值</p></li><li><p>HGET key field：获取一个hash类型key的field的值</p></li><li><p>HMSET：批量添加多个hash类型key的field的值</p></li><li><p>HMGET：批量获取多个hash类型key的field的值</p></li><li><p>HGETALL：获取一个hash类型的key中的所有的field和value</p></li><li><p>HKEYS：获取一个hash类型的key中的所有的field</p></li><li><p>HINCRBY:让一个hash类型key的字段值自增并指定步长</p></li><li><p>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</p></li></ul><h2 id="2-4-List类型"><a href="#2-4-List类型" class="headerlink" title="2.4.List类型"></a>2.4.List类型</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p>List的常见命令有：</p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><h2 id="2-5-Set类型"><a href="#2-5-Set类型" class="headerlink" title="2.5.Set类型"></a>2.5.Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li><p>无序</p></li><li><p>元素不可重复</p></li><li><p>查找快</p></li><li><p>支持交集、并集、差集等功能</p></li></ul><p>Set的常见命令有：</p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li></ul><p>例如两个集合：s1和s2:</p><p><img src="/redis01-getting-started/ha8x86R.png" alt></p><p>求交集：SINTER s1 s2</p><p>求s1与s2的不同：SDIFF s1 s2</p><p><img src="/redis01-getting-started/L9vTv2X.png" alt></p><h2 id="2-6-SortedSet类型"><a href="#2-6-SortedSet类型" class="headerlink" title="2.6.SortedSet类型"></a>2.6.SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</p></li><li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</p></li></ul><p>练习题：</p><p>将班级的下列学生得分存入Redis的SortedSet中：</p><p>Jack 85, Lucy 89, Rose 82, Tom 95, Jerry 78, Amy 92, Miles 76</p><p>并实现下列功能：</p><ul><li>删除Tom同学</li><li>获取Amy同学的分数</li><li>获取Rose同学的排名</li><li>查询80分以下有几个学生</li><li>给Amy同学加2分</li><li>查出成绩前3名的同学</li><li>查出成绩80分以下的所有同学</li></ul><h1 id="3-Redis的Java客户端"><a href="#3-Redis的Java客户端" class="headerlink" title="3.Redis的Java客户端"></a>3.Redis的Java客户端</h1><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/docs/clients/" target="_blank" rel="noopener">https://redis.io/docs/clients/</a></p><p><img src="/redis01-getting-started/9f68ivq.png" alt></p><p>其中Java客户端也包含很多：</p><p><img src="/redis01-getting-started/image-20220609102817435-165735883948534.png" alt="image-20220609102817435"></p><p>标记为*的就是推荐使用的java客户端，包括：</p><ul><li>Jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装，因此我们后期会直接以SpringDataRedis来学习。</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map、Queue等，而且支持跨进程的同步机制：Lock、Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><h2 id="3-1-Jedis客户端"><a href="#3-1-Jedis客户端" class="headerlink" title="3.1.Jedis客户端"></a>3.1.Jedis客户端</h2><p>Jedis的官网地址： <a href="https://github.com/redis/jedis" target="_blank" rel="noopener">https://github.com/redis/jedis</a></p><h3 id="3-1-1-快速入门"><a href="#3-1-1-快速入门" class="headerlink" title="3.1.1.快速入门"></a>3.1.1.快速入门</h3><p>1）引入依赖：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--jedis--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--单元测试--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.junit.jupiter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit-jupiter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）建立连接</p><p>新建一个单元测试类，内容如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> Jedis jedis<span class="token punctuation">;</span><span class="token annotation punctuation">@BeforeEach</span><span class="token keyword">void</span> <span class="token function">setUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1.建立连接</span>    <span class="token comment" spellcheck="true">// jedis = new Jedis("192.168.150.101", 6379);</span>    jedis <span class="token operator">=</span> JedisConnectionFactory<span class="token punctuation">.</span><span class="token function">getJedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.设置密码</span>    jedis<span class="token punctuation">.</span><span class="token function">auth</span><span class="token punctuation">(</span><span class="token string">"123321"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3.选择库</span>    jedis<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3）测试：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 存入数据</span>    String result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"虎哥"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"result = "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取数据</span>    String name <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 插入hash数据</span>    jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"user:1"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Jack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"user:1"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token string">"21"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">hgetAll</span><span class="token punctuation">(</span><span class="token string">"user:1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4）释放资源</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@AfterEach</span><span class="token keyword">void</span> <span class="token function">tearDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>jedis <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-2-连接池"><a href="#3-1-2-连接池" class="headerlink" title="3.1.2.连接池"></a>3.1.2.连接池</h3><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的直连方式。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>heima<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span>util<span class="token punctuation">;</span><span class="token keyword">import</span> redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisConnectionFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> JedisPool jedisPool<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 配置连接池</span>        JedisPoolConfig poolConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolConfig<span class="token punctuation">.</span><span class="token function">setMaxTotal</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolConfig<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolConfig<span class="token punctuation">.</span><span class="token function">setMinIdle</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        poolConfig<span class="token punctuation">.</span><span class="token function">setMaxWaitMillis</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码</span>        jedisPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPool</span><span class="token punctuation">(</span>poolConfig<span class="token punctuation">,</span> <span class="token string">"192.168.150.101"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token string">"123321"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Jedis <span class="token function">getJedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> jedisPool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-SpringDataRedis客户端"><a href="#3-2-SpringDataRedis客户端" class="headerlink" title="3.2.SpringDataRedis客户端"></a>3.2.SpringDataRedis客户端</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，官网地址：<a href="https://spring.io/projects/spring-data-redis" target="_blank" rel="noopener">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><p><img src="/redis01-getting-started/UFlNIV0.png" alt></p><h3 id="3-2-1-快速入门"><a href="#3-2-1-快速入门" class="headerlink" title="3.2.1.快速入门"></a>3.2.1.快速入门</h3><p>SpringBoot已经提供了对SpringDataRedis的支持，使用非常简单。</p><p>首先，新建一个maven项目，然后按照下面步骤执行：</p><h4 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h4><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.5.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment" spellcheck="true">&lt;!-- lookup parent from repository --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.heima<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>redis-demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>redis-demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--redis依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--common-pool--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--Jackson依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.fasterxml.jackson.core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jackson-databind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>excludes</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclude</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclude</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>excludes</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2）配置Redis"><a href="#2）配置Redis" class="headerlink" title="2）配置Redis"></a>2）配置Redis</h4><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.150.101    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123321</span>    <span class="token key atrule">lettuce</span><span class="token punctuation">:</span>      <span class="token key atrule">pool</span><span class="token punctuation">:</span>        <span class="token key atrule">max-active</span><span class="token punctuation">:</span> <span class="token number">8</span>        <span class="token key atrule">max-idle</span><span class="token punctuation">:</span> <span class="token number">8</span>        <span class="token key atrule">min-idle</span><span class="token punctuation">:</span> <span class="token number">0</span>        <span class="token key atrule">max-wait</span><span class="token punctuation">:</span> 100ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3）注入RedisTemplate"><a href="#3）注入RedisTemplate" class="headerlink" title="3）注入RedisTemplate"></a>3）注入RedisTemplate</h4><p>因为有了SpringBoot的自动装配，我们可以拿来就用：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">RedisStringTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> RedisTemplate redisTemplate<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4）编写测试"><a href="#4）编写测试" class="headerlink" title="4）编写测试"></a>4）编写测试</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">RedisStringTests</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> RedisTemplate edisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 写入一条String数据</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"虎哥"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取string数据</span>        Object name <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name = "</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-2-自定义序列化"><a href="#3-2-2-自定义序列化" class="headerlink" title="3.2.2.自定义序列化"></a>3.2.2.自定义序列化</h3><p>RedisTemplate可以接收任意Object作为值写入Redis：</p><p><img src="/redis01-getting-started/OEMcbuu.png" alt></p><p>只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：</p><p><img src="/redis01-getting-started/5FjtWk5.png" alt></p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>可以自定义RedisTemplate的序列化方式，代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> RedisTemplate<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span>RedisConnectionFactory connectionFactory<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建RedisTemplate对象</span>        RedisTemplate<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置连接工厂</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>connectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建JSON序列化工具</span>        GenericJackson2JsonRedisSerializer jsonRedisSerializer <span class="token operator">=</span>                                         <span class="token keyword">new</span> <span class="token class-name">GenericJackson2JsonRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置Key的序列化</span>        template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span>RedisSerializer<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span>RedisSerializer<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 设置Value的序列化</span>        template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span>jsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span>jsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 返回</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p><p><img src="/redis01-getting-started/XOAq3cN.png" alt></p><p>整体可读性有了很大提升，并且能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p><h3 id="3-2-3-StringRedisTemplate"><a href="#3-2-3-StringRedisTemplate" class="headerlink" title="3.2.3.StringRedisTemplate"></a>3.2.3.StringRedisTemplate</h3><p>为了节省内存空间，可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</p><p><img src="/redis01-getting-started/Ip9TKSY.png" alt></p><p>因为存入和读取时的序列化及反序列化都是我们自己实现的，SpringDataRedis就不会将class信息写入Redis了。</p><p>这种用法比较普遍，因此SpringDataRedis就提供了RedisTemplate的子类：StringRedisTemplate，它的key和value的序列化方式默认就是String方式。</p><p><img src="/redis01-getting-started/zXH6Qn6.png" alt></p><p>省去了自定义RedisTemplate的序列化方式的步骤，而是直接使用：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> StringRedisTemplate stringRedisTemplate<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// JSON序列化工具</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ObjectMapper mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testSaveUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> JsonProcessingException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建对象</span>    User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"虎哥"</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 手动序列化</span>    String json <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 写入数据</span>    stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"user:200"</span><span class="token punctuation">,</span> json<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取数据</span>    String jsonUser <span class="token operator">=</span> stringRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"user:200"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 手动反序列化</span>    User user1 <span class="token operator">=</span> mapper<span class="token punctuation">.</span><span class="token function">readValue</span><span class="token punctuation">(</span>jsonUser<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user1 = "</span> <span class="token operator">+</span> user1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> NoSql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka架构</title>
      <link href="/kafka02-architecture.html"/>
      <url>/kafka02-architecture.html</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka架构"><a href="#Kafka架构" class="headerlink" title="Kafka架构"></a>Kafka架构</h1><p><img src="/kafka02-architecture/image-20230324181732316.png" alt="image-20230324181732316"></p><p>整体来看，kafka架构中包含四大组件：生产者、消费者、kafka集群、zookeeper集群</p><h2 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h2><p>kafka 集群包含一个或多个服务器，每个服务器节点称为一个broker。</p><h2 id="topic"><a href="#topic" class="headerlink" title="topic"></a>topic</h2><p>每条发布到kafka集群的消息都有一个类别，这个类别称为topic，其实就是将消息按照topic来分类，topic就是逻辑上的分类，同一个topic的数据既可以在同一个broker上也可以在不同的broker结点上。</p><h2 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h2><p>分区，每个topic被物理划分为一个或多个分区，每个分区在物理上对应一个文件夹，该文件夹里面存储了这个分区的所有消息和索引文件。在创建topic时可指定parition数量，生产者将消息发送到topic时，消息会根据 分区策略 追加到分区文件的末尾，属于顺序写磁盘，因此效率非常高（经验证，顺序写磁盘效率比随机写内存还要高，这是Kafka高吞吐率的一个很重要的保证）</p><p><img src="/kafka02-architecture/image-20230324182513317.png" alt="image-20230324182513317"></p><p>上面提到了分区策略，所谓分区策略就是决定生产者将消息发送到哪个分区的算法。Kafka 为我们提供了默认的分区策略，同时它也支持自定义分区策略。kafka允许为每条消息设置一个key，一旦消息被定义了 Key，那么就可以保证同一个 Key 的所有消息都进入到相同的分区，这种策略属于自定义策略的一种，被称作”按消息key保存策略”，或Key-ordering 策略。</p><p>同一主题的多个分区可以部署在多个机器上，以此来实现 kafka 的伸缩性。同一partition中的数据是有序的，但topic下的多个partition之间在消费数据时不能保证有序性，在需要严格保证消息顺序消费的场景下，可以将partition数设为1，但这种做法的缺点是降低了吞吐，一般来说，只需要保证每个分区的有序性，再对消息设置key来保证相同key的消息落入同一分区，就可以满足绝大多数的应用。</p><h2 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h2><p>partition中的每条消息都被标记了一个序号，这个序号表示消息在partition中的偏移量，称为offset，每一条消息在partition都有唯一的offset，消息者通过指定offset来指定要消费的消息。</p><p>正常情况下，消费者在消费完一条消息后会递增offset，准备去消费下一条消息，但也可以将offset设成一个较小的值，重新消费一些消费过的消息，可见offset是由consumer控制的，consumer想消费哪一条消息就消费哪一条消息，所以kafka broker是无状态的，它不需要标记哪些消息被消费过。</p><h2 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h2><p>生产者，生产者发送消息到指定的topic下，消息再根据分配规则append到某个partition的末尾。</p><h2 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h2><p>消费者，消费者从topic中消费数据。</p><h2 id="consumer-group"><a href="#consumer-group" class="headerlink" title="consumer group"></a>consumer group</h2><p>消费者组，每个consumer属于一个特定的consumer group，可为每个consumer指定consumer group，若不指定则属于默认的group。</p><p>同一topic的一条消息只能被同一个consumer group内的一个consumer消费，但多个consumer group可同时消费这一消息。这也是kafka用来实现一个topic消息的广播和单播的手段，如果需要实现广播，一个consumer group内只放一个消费者即可，要实现单播，将所有的消费者放到同一个consumer group即可。</p><p>用consumer group还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。</p><h2 id="leader"><a href="#leader" class="headerlink" title="leader"></a>leader</h2><p>每个partition有多个副本，其中有且仅有一个作为leader，leader会负责所有的客户端读写操作。</p><h2 id="follower"><a href="#follower" class="headerlink" title="follower"></a>follower</h2><p>follower不对外提供服务，只与leader保持数据同步，如果leader失效，则选举一个follower来充当新的leader。当follower与leader挂掉、卡住或者同步太慢，leader会把这个follower从ISR列表中删除，重新创建一个follower。</p><h2 id="rebalance"><a href="#rebalance" class="headerlink" title="rebalance"></a>rebalance</h2><p>同一个consumer group下的多个消费者互相协调消费工作，，一个topic分为多个分区，一个consumer group里面的所有消费者合作，一起去消费所订阅的某个topic下的所有分区(每个消费者消费部分分区)，kafka会将该topic下的所有分区均匀的分配给consumer group下的每个消费者，如下图，</p><p><img src="/kafka02-architecture/image-20230324183946328.png" alt="image-20230324183946328"></p><p>rebalance表示”重平衡”，consumer group内某个消费者挂掉后，其他消费者自动重新分配订阅主题分区的过程，是 Kafka 消费者端实现高可用的重要手段。如下图Consumer Group A中的C2挂掉，C1会接收P1和P2，以达到重新平衡。同样的，当有新消费者加入consumer group，也会触发重平衡操作。</p><h1 id="对kafka架构的几点解释"><a href="#对kafka架构的几点解释" class="headerlink" title="对kafka架构的几点解释"></a>对kafka架构的几点解释</h1><ul><li><p>一个典型的kafka集群中包含若干producer，若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干consumer group，以及一个zookeeper集群。kafka通过zookeeper协调管理kafka集群，选举分区leader，以及在consumer group发生变化时进行rebalance。</p></li><li><p>kafka的topic被划分为一个或多个分区，多个分区可以分布在一个或多个broker节点上，同时为了故障容错，每个分区都会复制多个副本，分别位于不同的broker节点，这些分区副本中（不管是leader还是follower都称为分区副本），一个分区副本会作为leader，其余的分区副本作为follower。其中leader负责所有的客户端读写操作，follower不对外提供服务，仅仅从leader上同步数据，当leader出现故障时，其中的一个follower会顶替成为leader，继续对外提供服务。</p></li><li><p>对于传统的MQ而言，已经被消费的消息会从队列中删除，但在Kafka中被消费的消息也不会立马删除，在kafka的server.propertise配置文件中定义了数据的保存时间，当文件到设定的保存时间时才会删除，</p><p># 数据的保存时间(单位:小时，默认为7天)</p><p>log.retention.hours=168</p><p>因为Kafka读取消息的时间复杂度为O(1)，与文件大小无关，所以这里删除过期文件与提高Kafka性能并没有关系，所以选择怎样的删除策略应该考虑磁盘以及具体的需求。</p></li><li><p>点对点模式 VS 发布订阅模式</p><p>传统的消息系统中，有两种主要的消息传递模式：点对点模式、发布订阅模式。</p><p>①点对点模式 </p><p>生产者发送消息到queue中，queue支持存在多个消费者，但是对一个消息而言，只可以被一个消费者消费，并且在点对点模式中，已经消费过的消息会从queue中删除不再存储。</p><p>②发布订阅模式</p><p>生产者将消息发布到topic中，topic可以被多个消费者订阅，且发布到topic的消息会被所有订阅者消费。而kafka就是一种发布订阅模式。</p></li><li><p>消费端 pull 和 push</p><p>① push方式：由消息中间件主动地将消息推送给消费者；</p><p>优点：优点是不需要消费者额外开启线程监控中间件，节省开销。</p><p>缺点：无法适应消费速率不相同的消费者。因为消息的发送速率是broker决定的，而消</p><p>费者的处理速度又不尽相同，所以容易造成部分消费者空闲，部分消费者堆积，造成缓</p><p>冲区溢出。</p><p>② pull方式：由消费者主动向消息中间件拉取消息；</p><p>优点：消费端可以按处理能力进行拉取；</p><p>缺点：消费端需要另开线程监控中间件，有性能开销；</p><p>对于Kafka而言，pull模式更合适。pull模式可简化broker的设计，Consumer可自主控制消费消息的速率，同时Consumer可以自己控制消费方式，既可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Message Queue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka介绍</title>
      <link href="/kafka01-introductory.html"/>
      <url>/kafka01-introductory.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是消息系统？"><a href="#什么是消息系统？" class="headerlink" title="什么是消息系统？"></a>什么是消息系统？</h1><p>消息系统负责将数据从一个应用程序传输到另一个应用程序，因此应用程序可以专注于数据，但不担心如何共享它。 分布式消息传递基于可靠消息队列的概念。 消息在客户端应用程序和消息传递系统之间异步排队。 有两种类型的消息模式可用 - 一种是点对点，另一种是发布 - 订阅(pub-sub)消息系统。 大多数消息模式遵循 <strong>pub-sub</strong> 。</p><h1 id="为什么有消息系统"><a href="#为什么有消息系统" class="headerlink" title="为什么有消息系统"></a>为什么有消息系统</h1><ol><li>解耦合</li><li>异步处理 例如电商平台，秒杀活动。一般流程会分为：1: <code>风险控制</code>、2：<code>库存锁定</code>、3：<code>生成订单</code>、4：<code>短信通知</code>、5：<code>更新数据</code></li><li>通过消息系统将秒杀活动业务拆分开，将不急需处理的业务放在后面慢慢处理；流程改为：1：<code>风险控制</code>、2：<code>库存锁定</code>、3:<code>消息系统</code>、4:<code>生成订单</code>、5：<code>短信通知</code>、6：<code>更新数据</code></li><li>流量的控制 ：1. 网关在接受到请求后，就把请求放入到消息队列里面 2.后端的服务从消息队列里面获取到请求，完成后续的秒杀处理流程。然后再给用户返回结果。优点：控制了流量 缺点：会让流程变慢</li></ol><h3 id="点对点消息系统"><a href="#点对点消息系统" class="headerlink" title="点对点消息系统"></a>点对点消息系统</h3><p>在点对点系统中，消息被保留在队列中。 一个或多个消费者可以消耗队列中的消息，但是特定消息只能由最多一个消费者消费。 一旦消费者读取队列中的消息，它就从该队列中消失。 该系统的典型示例是订单处理系统，其中每个订单将由一个订单处理器处理，但多个订单处理器也可以同时工作。 下图描述了结构。</p><p><img src="/kafka01-introductory/image-20230323222505712.png" alt="image-20230323222505712"></p><h3 id="发布-订阅消息系统"><a href="#发布-订阅消息系统" class="headerlink" title="发布 - 订阅消息系统"></a>发布 - 订阅消息系统</h3><p><img src="/kafka01-introductory/image-20230323222903155.png" alt="image-20230323222903155"></p><p>### </p><p>在发布 - 订阅系统中，消息被保留在主题中。 与点对点系统不同，消费者可以订阅一个或多个主题并使用该主题中的所有消息。 在发布 - 订阅系统中，消息生产者称为发布者，消息使用者称为订阅者。 一个现实生活的例子是Dish电视，它发布不同的渠道，如运动，电影，音乐等，任何人都可以订阅自己的频道集，并获得他们订阅的频道时可用。</p><h1 id="Kafka核心概念"><a href="#Kafka核心概念" class="headerlink" title="Kafka核心概念"></a>Kafka核心概念</h1><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a><strong>生产者</strong></h2><p><strong>生产者</strong>：Producer 往Kafka集群生成数据</p><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a><strong>消费者</strong></h2><p><strong>消费者</strong>：Consumer 往Kafka里面去获取数据，处理数据、消费数据Kafka的数据是由消费者自己去拉去Kafka里面的数据</p><h2 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a><strong>消费者</strong></h2><p><strong>消费者</strong>: topic</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a><strong>分区</strong></h2><p><strong>分区</strong>:partition 默认一个topic有一个分区（partition），自己可设置多个分区（分区分散存储在服务器不同节点上）</p><h1 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h1><ol><li>将下载好的安装包上传到 Linux 服务器。（我这里使用的是 kafka_2.11-0.11.0.0.tgz）</li><li>解压安装包到指定目录。</li></ol><pre><code>tar -zxvf kafka_2.11-0.11.0.0.tgz -C /opt/module/</code></pre><p>修改解压后的文件名称</p><pre><code>mv kafka_2.11-0.11.0.0/ kafka</code></pre><p>在 /opt/module/kafka 目录下创建 logs 文件夹。</p><pre><code>mkdir logs</code></pre><p>修改 config 目录下的配置文件 server.properties。</p><pre><code>#broker 的全局唯一编号，不能重复broker.id=0#删除 topic 功能使能delete.topic.enable=true#处理网络请求的线程数量num.network.threads=3#用来处理磁盘 IO 的现成数量num.io.threads=8#发送套接字的缓冲区大小socket.send.buffer.bytes=102400#接收套接字的缓冲区大小socket.receive.buffer.bytes=102400#请求套接字的缓冲区大小socket.request.max.bytes=104857600#kafka 运行日志存放的路径log.dirs=/opt/module/kafka/data#topic 在当前 broker 上的分区个数num.partitions=1#用来恢复和清理 data 下数据的线程数量num.recovery.threads.per.data.dir=1#segment 文件保留的最长时间，超时将被删除log.retention.hours=168#配置连接 Zookeeper 集群地址zookeeper.connect=master:2181,slave1:2181,slave2:2181</code></pre><p>将 kafka 目录分发到另外两台机器上。</p><pre><code>scp kafka/ master:/opt/module/</code></pre><pre><code>scp kafka/ slave2:/opt/module/</code></pre><p>在另外两台机器上修改配置文件 /opt/module/kafka/config/server.properties 中的 broker.id=1、broker.id=2（broker.id 不得重复）</p><p>配置环境变量。</p><pre><code>vim /etc/profile</code></pre><p>添加下面内容</p><pre><code>#KAFKA_HOMEexport KAFKA_HOME=/opt/module/kafkaexport PATH=$PATH:$KAFKA_HOME/bin</code></pre><p>让配置文件生效：</p><pre><code> source /etc/profile</code></pre><p>在另外两台机器做以上操作</p><pre><code>在 /opt/module/kafka/bin 目录下编写群起群关脚本 kk.sh，方便以后使用。</code></pre><pre><code>vim kk.sh</code></pre><pre><code>#!/bin/bashcase $1 in&quot;start&quot;){  for i in master slave1 slave2    do      echo &quot;****************** $i *********************&quot;      ssh $i &quot;source /etc/profile &amp;&amp; /opt/module/kafka/bin/kafka-server-start.sh -daemon /opt/module/kafka/config/server.properties&quot;    done};;&quot;stop&quot;){  for i in master slave1 slave2    do      echo &quot;****************** $i *********************&quot;      ssh $i &quot;/opt/module/kafka/bin/kafka-server-stop.sh&quot;    done};;esac</code></pre><pre><code>chmod 777 kk.sh</code></pre><h1 id="Kafka-命令行操作"><a href="#Kafka-命令行操作" class="headerlink" title="Kafka 命令行操作"></a>Kafka 命令行操作</h1><p>创建 topic</p><pre><code>kafka-topics.sh --zookeeper slave1:2181 --create --replication-factor 3 --partitions 2 --topic demo</code></pre><p>查看当前服务器中所有的 topic。</p><pre><code>kafka-topics.sh --zookeeper slave1:2181 --list</code></pre><p>查看某个 topic 的详情</p><pre><code>kafka-topics.sh --zookeeper slave1:2181 --describe --topic demo</code></pre><p>删除 topic</p><pre><code>kafka-topics.sh --zookeeper slave1:2181 --delete --topic first</code></pre><p>发送消息</p><pre><code>kafka-console-producer.sh --broker-list slave1:9092 --topic demo</code></pre><p>消费消息</p><p>方法一过时</p><pre><code> kafka-console-consumer.sh --zookeeper slave1:2181 --topic demo</code></pre><p>方法二</p><pre><code>kafka-console-consumer.sh --bootstrap-server slave1:9092 --topic demo</code></pre><p>在以上两种方法的命令上添加 <strong>–from-beginning</strong> 参数会把主题中以往所有的数据都读取出来。</p><p>Kafka整合Spring Boot</p><p>在项目中连接kafka，因为是外网，首先要开放kafka配置文件中的如下配置（其中IP为公网IP），</p><pre><code>advertised.listeners=PLAINTEXT://112.126.74.249:9092</code></pre><p>在开始前我们先创建两个topic：topic1、topic2，其分区和副本数都设置为2，用来测试，</p><pre><code>[root@iZ2zegzlkedbo3e64vkbefZ ~]#  cd /usr/local/kafka-cluster/kafka1/bin/[root@iZ2zegzlkedbo3e64vkbefZ bin]# ./kafka-topics.sh --create --zookeeper 172.17.80.219:2181 --replication-factor 2 --partitions 2 --topic topic1Created topic topic1.[root@iZ2zegzlkedbo3e64vkbefZ bin]# ./kafka-topics.sh --create --zookeeper 172.17.80.219:2181 --replication-factor 2 --partitions 2 --topic topic2Created topic topic2.</code></pre><p>当然也可以不手动创建topic，在执行代码kafkaTemplate.send(“topic1”, normalMessage)发送消息时，kafka会帮我们自动完成topic的创建工作，但这种情况下创建的topic默认只有一个分区，分区也没有副本。所以，我们可以在项目中新建一个配置类专门用来初始化topic，如下，</p><pre><code>@Configurationpublic class KafkaInitialConfiguration {    // 创建一个名为testtopic的Topic并设置分区数为8，分区副本数为2    @Bean    public NewTopic initialTopic() {        return new NewTopic(&quot;testtopic&quot;,8, (short) 2 );    }     // 如果要修改分区数，只需修改配置值重启项目即可    // 修改分区数并不会导致数据的丢失，但是分区数只能增大不能减小    @Bean    public NewTopic updateTopic() {        return new NewTopic(&quot;testtopic&quot;,10, (short) 2 );    }}</code></pre><h1 id="Kafka整合Spring-Boot"><a href="#Kafka整合Spring-Boot" class="headerlink" title="Kafka整合Spring Boot"></a>Kafka整合Spring Boot</h1><h2 id="新建Spring-Boot项目"><a href="#新建Spring-Boot项目" class="headerlink" title="新建Spring Boot项目"></a>新建Spring Boot项目</h2><p>引入pom依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>application.properties配置</p><pre><code>###########【Kafka集群】###########spring.kafka.bootstrap-servers=112.126.74.249:9092,112.126.74.249:9093###########【初始化生产者配置】############ 重试次数spring.kafka.producer.retries=0# 应答级别:多少个分区副本备份完成时向生产者发送ack确认(可选0、1、all/-1)spring.kafka.producer.acks=1# 批量大小spring.kafka.producer.batch-size=16384# 提交延时spring.kafka.producer.properties.linger.ms=0# 当生产端积累的消息达到batch-size或接收到消息linger.ms后,生产者就会将消息提交给kafka# linger.ms为0表示每接收到一条消息就提交给kafka,这时候batch-size其实就没用了​# 生产端缓冲区大小spring.kafka.producer.buffer-memory = 33554432# Kafka提供的序列化和反序列化类spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializerspring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer# 自定义分区器# spring.kafka.producer.properties.partitioner.class=com.felix.kafka.producer.CustomizePartitioner​###########【初始化消费者配置】############ 默认的消费组IDspring.kafka.consumer.properties.group.id=defaultConsumerGroup# 是否自动提交offsetspring.kafka.consumer.enable-auto-commit=true# 提交offset延时(接收到消息后多久提交offset)spring.kafka.consumer.auto.commit.interval.ms=1000# 当kafka中没有初始offset或offset超出范围时将自动重置offset# earliest:重置为分区中最小的offset;# latest:重置为分区中最新的offset(消费分区中新产生的数据);# none:只要有一个分区不存在已提交的offset,就抛出异常;spring.kafka.consumer.auto-offset-reset=latest# 消费会话超时时间(超过这个时间consumer没有发送心跳,就会触发rebalance操作)spring.kafka.consumer.properties.session.timeout.ms=120000# 消费请求超时时间spring.kafka.consumer.properties.request.timeout.ms=180000# Kafka提供的序列化和反序列化类spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializerspring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer# 消费端监听的topic不存在时，项目启动会报错(关掉)spring.kafka.listener.missing-topics-fatal=false# 设置批量消费# spring.kafka.listener.type=batch# 批量消费每次最多消费多少条消息# spring.kafka.consumer.max-poll-records=50</code></pre><h3 id="Hello-Kafka"><a href="#Hello-Kafka" class="headerlink" title="Hello Kafka"></a>Hello Kafka</h3><p>简单生产者</p><pre><code>@RestControllerpublic class KafkaProducer {    @Autowired    private KafkaTemplate&lt;String, Object&gt; kafkaTemplate;    // 发送消息    @GetMapping(&quot;/kafka/normal/{message}&quot;)    public void sendMessage1(@PathVariable(&quot;message&quot;) String normalMessage) {        kafkaTemplate.send(&quot;topic1&quot;, normalMessage);    }}</code></pre><p>简单消费</p><pre><code>@Componentpublic class KafkaConsumer {    // 消费监听    @KafkaListener(topics = {&quot;topic1&quot;})    public void onMessage1(ConsumerRecord&lt;?, ?&gt; record){        // 消费的哪个topic、partition的消息,打印出消息内容        System.out.println(&quot;简单消费：&quot;+record.topic()+&quot;-&quot;+record.partition()+&quot;-&quot;+record.value());    }}</code></pre><p>上面示例创建了一个生产者，发送消息到topic1，消费者监听topic1消费消息。监听器用@KafkaListener注解，topics表示监听的topic，支持同时监听多个，用英文逗号分隔。启动项目，postman调接口触发生产者发送消息，</p><p><img src="/kafka01-introductory/image-20230324144409141.png" alt="image-20230324144409141"></p><p><img src="/kafka01-introductory/image-20230324144529390.png" alt="image-20230324144529390"></p><h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h3><p>带回调的生产者</p><p>kafkaTemplate提供了一个回调方法addCallback，我们可以在回调方法中监控消息是否发送成功 或 失败时做补偿处理，有两种写法</p><pre><code>@GetMapping(&quot;/kafka/callbackOne/{message}&quot;)public void sendMessage2(@PathVariable(&quot;message&quot;) String callbackMessage) {    kafkaTemplate.send(&quot;topic1&quot;, callbackMessage).addCallback(success -&gt; {        // 消息发送到的topic        String topic = success.getRecordMetadata().topic();        // 消息发送到的分区        int partition = success.getRecordMetadata().partition();        // 消息在分区内的offset        long offset = success.getRecordMetadata().offset();        System.out.println(&quot;发送消息成功:&quot; + topic + &quot;-&quot; + partition + &quot;-&quot; + offset);    }, failure -&gt; {        System.out.println(&quot;发送消息失败:&quot; + failure.getMessage());    });}</code></pre><pre><code>@GetMapping(&quot;/kafka/callbackTwo/{message}&quot;)public void sendMessage3(@PathVariable(&quot;message&quot;) String callbackMessage) {    kafkaTemplate.send(&quot;topic1&quot;, callbackMessage).addCallback(new ListenableFutureCallback&lt;SendResult&lt;String, Object&gt;&gt;() {        @Override        public void onFailure(Throwable ex) {            System.out.println(&quot;发送消息失败：&quot;+ex.getMessage());        }        @Override        public void onSuccess(SendResult&lt;String, Object&gt; result) {            System.out.println(&quot;发送消息成功：&quot; + result.getRecordMetadata().topic() + &quot;-&quot;                    + result.getRecordMetadata().partition() + &quot;-&quot; + result.getRecordMetadata().offset());        }    });}</code></pre><p>自定义分区器</p><p>kafka中每个topic被划分为多个分区，那么生产者将消息发送到topic时，具体追加到哪个分区呢？这就是所谓的分区策略，Kafka 为我们提供了默认的分区策略，同时它也支持自定义分区策略。其路由机制为：</p><p>① <strong>若发送消息时指定了分区（即自定义分区策略），则直接将消息append到指定分区；</strong></p><p>② 若发送消息时未指定 patition，但指定了 key（kafka允许为每条消息设置一个key），则对key值进行hash计算，根据计算结果路由到指定分区，这种情况下可以保证同一个 Key 的所有消息都进入到相同的分区；</p><p>③  patition 和 key 都未指定，则使用kafka默认的分区策略，轮询选出一个 patition；</p><p>※ 我们来自定义一个分区策略，将消息发送到我们指定的partition，首先新建一个分区器类实现Partitioner接口，重写方法，其中partition方法的返回值就表示将消息发送到几号分区，</p><pre><code>public class CustomizePartitioner implements Partitioner {    @Override    public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) {        // 自定义分区规则(这里假设全部发到0号分区)        // ......        return 0;    }    @Override    public void close() {    }    @Override    public void configure(Map&lt;String, ?&gt; configs) {    }}</code></pre><p>在application.propertise中配置自定义分区器，配置的值就是分区器类的全路径名，</p><pre><code># 自定义分区器spring.kafka.producer.properties.partitioner.class=com.felix.kafka.producer.CustomizePartitioner</code></pre><p>kafka事务提交</p><pre><code>如果在发送消息时需要创建事务，可以使用 KafkaTemplate 的 executeInTransaction 方法来声明事务</code></pre><pre><code>@GetMapping(&quot;/kafka/transaction&quot;)public void sendMessage7(){    // 声明事务：后面报错消息不会发出去    kafkaTemplate.executeInTransaction(operations -&gt; {        operations.send(&quot;topic1&quot;,&quot;test executeInTransaction&quot;);        throw new RuntimeException(&quot;fail&quot;);    });    // 不声明事务：后面报错但前面消息已经发送成功了   kafkaTemplate.send(&quot;topic1&quot;,&quot;test executeInTransaction&quot;);   throw new RuntimeException(&quot;fail&quot;);}</code></pre><h3 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h3><p>指定topic、partition、offset消费</p><p>前面在监听消费topic1的时候，监听的是topic1上所有的消息，如果我们想指定topic、指定partition、指定offset来消费呢？也很简单，@KafkaListener注解已全部为我们提供</p><pre><code>/** * @Title 指定topic、partition、offset消费 * @Description 同时监听topic1和topic2，监听topic1的0号分区、topic2的 &quot;0号和1号&quot; 分区，指向1号分区的offset初始值为8 * @Author long.yuan * @Date 2020/3/22 13:38 * @Param [record] * @return void **/@KafkaListener(id = &quot;consumer1&quot;,groupId = &quot;felix-group&quot;,topicPartitions = {        @TopicPartition(topic = &quot;topic1&quot;, partitions = { &quot;0&quot; }),        @TopicPartition(topic = &quot;topic2&quot;, partitions = &quot;0&quot;, partitionOffsets = @PartitionOffset(partition = &quot;1&quot;, initialOffset = &quot;8&quot;))})public void onMessage2(ConsumerRecord&lt;?, ?&gt; record) {    System.out.println(&quot;topic:&quot;+record.topic()+&quot;|partition:&quot;+record.partition()+&quot;|offset:&quot;+record.offset()+&quot;|value:&quot;+record.value());}</code></pre><p>属性解释：</p><p>① id：消费者ID；</p><p>② groupId：消费组ID；</p><p>③ topics：监听的topic，可监听多个；</p><p>④ topicPartitions：可配置更加详细的监听信息，可指定topic、parition、offset监听。</p><p>上面onMessage2监听的含义：监听topic1的0号分区，同时监听topic2的0号分区和topic2的1号分区里面offset从8开始的消息。</p><p>注意：topics和topicPartitions不能同时使用；</p><h4 id="批量消费"><a href="#批量消费" class="headerlink" title="批量消费"></a>批量消费</h4><p>设置application.prpertise开启批量消费即可，</p><pre><code># 设置批量消费spring.kafka.listener.type=batch# 批量消费每次最多消费多少条消息spring.kafka.consumer.max-poll-records=50</code></pre><p>接收消息时用List来接收，监听代码如下，</p><pre><code>@KafkaListener(id = &quot;consumer2&quot;,groupId = &quot;felix-group&quot;, topics = &quot;topic1&quot;)public void onMessage3(List&lt;ConsumerRecord&lt;?, ?&gt;&gt; records) {    System.out.println(&quot;&gt;&gt;&gt;批量消费一次，records.size()=&quot;+records.size());    for (ConsumerRecord&lt;?, ?&gt; record : records) {        System.out.println(record.value());    }}</code></pre><h4 id="ConsumerAwareListenerErrorHandler-异常处理器"><a href="#ConsumerAwareListenerErrorHandler-异常处理器" class="headerlink" title="ConsumerAwareListenerErrorHandler 异常处理器"></a>ConsumerAwareListenerErrorHandler 异常处理器</h4><p>通过异常处理器，我们可以处理consumer在消费时发生的异常。</p><p>新建一个 ConsumerAwareListenerErrorHandler 类型的异常处理方法，用@Bean注入，BeanName默认就是方法名，然后我们将这个异常处理器的BeanName放到@KafkaListener注解的errorHandler属性里面，当监听抛出异常的时候，则会自动调用异常处理器，</p><pre><code>// 新建一个异常处理器，用@Bean注入@Beanpublic ConsumerAwareListenerErrorHandler consumerAwareErrorHandler() {    return (message, exception, consumer) -&gt; {        System.out.println(&quot;消费异常：&quot;+message.getPayload());        return null;    };}​// 将这个异常处理器的BeanName放到@KafkaListener注解的errorHandler属性里面@KafkaListener(topics = {&quot;topic1&quot;},errorHandler = &quot;consumerAwareErrorHandler&quot;)public void onMessage4(ConsumerRecord&lt;?, ?&gt; record) throws Exception {    throw new Exception(&quot;简单消费-模拟异常&quot;);}​// 批量消费也一样，异常处理器的message.getPayload()也可以拿到各条消息的信息@KafkaListener(topics = &quot;topic1&quot;,errorHandler=&quot;consumerAwareErrorHandler&quot;)public void onMessage5(List&lt;ConsumerRecord&lt;?, ?&gt;&gt; records) throws Exception {    System.out.println(&quot;批量消费一次...&quot;);    throw new Exception(&quot;批量消费-模拟异常&quot;);}</code></pre><p><img src="/kafka01-introductory/image-20230324174523424.png" alt="image-20230324174523424"></p><h4 id="消息过滤器"><a href="#消息过滤器" class="headerlink" title="消息过滤器"></a>消息过滤器</h4><p>消息过滤器可以在消息抵达consumer之前被拦截，在实际应用中，我们可以根据自己的业务逻辑，筛选出需要的信息再交由KafkaListener处理，不需要的消息则过滤掉。</p><p>配置消息过滤只需要为 监听器工厂 配置一个RecordFilterStrategy（消息过滤策略），返回true的时候消息将会被抛弃，返回false时，消息能正常抵达监听容器。</p><pre><code>@Componentpublic class KafkaConsumer {    @Autowired    ConsumerFactory consumerFactory;​    // 消息过滤器    @Bean    public ConcurrentKafkaListenerContainerFactory filterContainerFactory() {        ConcurrentKafkaListenerContainerFactory factory = new ConcurrentKafkaListenerContainerFactory();        factory.setConsumerFactory(consumerFactory);        // 被过滤的消息将被丢弃        factory.setAckDiscarded(true);        // 消息过滤策略        factory.setRecordFilterStrategy(consumerRecord -&gt; {            if (Integer.parseInt(consumerRecord.value().toString()) % 2 == 0) {                return false;            }            //返回true消息则被过滤            return true;        });        return factory;    }​    // 消息过滤监听    @KafkaListener(topics = {&quot;topic1&quot;},containerFactory = &quot;filterContainerFactory&quot;)    public void onMessage6(ConsumerRecord&lt;?, ?&gt; record) {        System.out.println(record.value());    }}</code></pre><p>上面实现了一个”过滤奇数、接收偶数”的过滤策略，向topic1发送0-99总共100条消息，看一下监听器的消费情况，可以看到监听器只消费了偶数，</p><p><img src="/kafka01-introductory/image-20230324175223429.png" alt="image-20230324175223429"></p><h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>在实际开发中，可能有这样的需求，应用A从TopicA获取到消息，经过处理后转发到TopicB，再由应用B监听处理消息，即一个应用处理完成后将该消息转发至其他应用，完成消息的转发。</p><p>在SpringBoot集成Kafka实现消息的转发也很简单，只需要通过一个@SendTo注解，被注解方法的return值即转发的消息内容，如下，</p><pre><code>/** * @Title 消息转发 * @Description 从topic1接收到的消息经过处理后转发到topic2 * @Author long.yuan * @Date 2020/3/23 22:15 * @Param [record] * @return void **/@KafkaListener(topics = {&quot;topic1&quot;})@SendTo(&quot;topic2&quot;)public String onMessage7(ConsumerRecord&lt;?, ?&gt; record) {    return record.value()+&quot;-forward message&quot;;}</code></pre><h4 id="定时启动、停止监听器"><a href="#定时启动、停止监听器" class="headerlink" title="定时启动、停止监听器"></a>定时启动、停止监听器</h4><p>默认情况下，当消费者项目启动的时候，监听器就开始工作，监听消费发送到指定topic的消息，那如果我们不想让监听器立即工作，想让它在我们指定的时间点开始工作，或者在我们指定的时间点停止工作，该怎么处理呢——使用KafkaListenerEndpointRegistry，下面我们就来实现：</p><p>① 禁止监听器自启动；</p><p>② 创建两个定时任务，一个用来在指定时间点启动定时器，另一个在指定时间点停止定时器；</p><p>新建一个定时任务类，用注解@EnableScheduling声明，KafkaListenerEndpointRegistry 在SpringIO中已经被注册为Bean，直接注入，设置禁止KafkaListener自启动，</p><pre><code>@EnableScheduling@Componentpublic class CronTimer {​    /**     * @KafkaListener注解所标注的方法并不会在IOC容器中被注册为Bean，     * 而是会被注册在KafkaListenerEndpointRegistry中，     * 而KafkaListenerEndpointRegistry在SpringIOC中已经被注册为Bean     **/    @Autowired    private KafkaListenerEndpointRegistry registry;​    @Autowired    private ConsumerFactory consumerFactory;​    // 监听器容器工厂(设置禁止KafkaListener自启动)    @Bean    public ConcurrentKafkaListenerContainerFactory delayContainerFactory() {        ConcurrentKafkaListenerContainerFactory container = new ConcurrentKafkaListenerContainerFactory();        container.setConsumerFactory(consumerFactory);        //禁止KafkaListener自启动        container.setAutoStartup(false);        return container;    }​    // 监听器    @KafkaListener(id=&quot;timingConsumer&quot;,topics = &quot;topic1&quot;,containerFactory = &quot;delayContainerFactory&quot;)    public void onMessage1(ConsumerRecord&lt;?, ?&gt; record){        System.out.println(&quot;消费成功：&quot;+record.topic()+&quot;-&quot;+record.partition()+&quot;-&quot;+record.value());    }​    // 定时启动监听器    //{秒数} {分钟} {小时} {日期} {月份} {星期} {年份(可为空)}    @Scheduled(cron = &quot;0 42 11 * * ? &quot;)    public void startListener() {        System.out.println(&quot;启动监听器...&quot;);        // &quot;timingConsumer&quot;是@KafkaListener注解后面设置的监听器ID,标识这个监听器        if (!registry.getListenerContainer(&quot;timingConsumer&quot;).isRunning()) {            registry.getListenerContainer(&quot;timingConsumer&quot;).start();        }        //registry.getListenerContainer(&quot;timingConsumer&quot;).resume();    }​    // 定时停止监听器    @Scheduled(cron = &quot;0 45 11 * * ? &quot;)    public void shutDownListener() {        System.out.println(&quot;关闭监听器...&quot;);        registry.getListenerContainer(&quot;timingConsumer&quot;).pause();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Message Queue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Feign</title>
      <link href="/feign.html"/>
      <url>/feign.html</url>
      
        <content type="html"><![CDATA[<h1 id="Feign远程调用"><a href="#Feign远程调用" class="headerlink" title="Feign远程调用"></a>Feign远程调用</h1><p>以前利用RestTemplate发起远程调用的代码：</p><p><img src="/feign/image-20210714174814204.png" alt="image-20210714174814204"></p><p>存在下面的问题：</p><p>•代码可读性差，编程体验不统一</p><p>•参数复杂URL难以维护</p><p>Feign是一个声明式的http客户端，官方地址：<a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">https://github.com/OpenFeign/feign</a></p><p>其作用就是帮助我们的实现http请求的发送，解决上面提到的问题。</p><p><img src="/feign/image-20210714174918088.png" alt="image-20210714174918088"></p><h2 id="Feign替代RestTemplate"><a href="#Feign替代RestTemplate" class="headerlink" title="Feign替代RestTemplate"></a>Feign替代RestTemplate</h2><p>Fegin的使用步骤如下：</p><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>我们在order-service服务的pom文件中引入feign的依赖：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2）添加注解"><a href="#2）添加注解" class="headerlink" title="2）添加注解"></a>2）添加注解</h3><p>在order-service的启动类添加注解开启Feign的功能：</p><p><img src="/feign/image-20210714175102524.png" alt="image-20210714175102524"></p><h3 id="3）编写Feign的客户端"><a href="#3）编写Feign的客户端" class="headerlink" title="3）编写Feign的客户端"></a>3）编写Feign的客户端</h3><p>在order-service中新建一个接口，内容如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>order<span class="token punctuation">.</span>client<span class="token punctuation">;</span><span class="token keyword">import</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>order<span class="token punctuation">.</span>pojo<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>openfeign<span class="token punctuation">.</span>FeignClient<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>GetMapping<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>PathVariable<span class="token punctuation">;</span><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span><span class="token string">"userservice"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserClient</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/user/{id}"</span><span class="token punctuation">)</span>    User <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> Long id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p><ul><li>服务名称：userservice</li><li>请求方式：GET</li><li>请求路径：/user/{id}</li><li>请求参数：Long id</li><li>返回值类型：User</li></ul><p>这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</p><h3 id="4）测试"><a href="#4）测试" class="headerlink" title="4）测试"></a>4）测试</h3><p>修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：</p><p><img src="/feign/image-20210714175415087.png" alt="image-20210714175415087"></p><h3 id="5）总结"><a href="#5）总结" class="headerlink" title="5）总结"></a>5）总结</h3><p>使用Feign的步骤：</p><p>① 引入依赖</p><p>② 添加@EnableFeignClients注解</p><p>③ 编写FeignClient接口</p><p>④ 使用FeignClient中定义的方法代替RestTemplate</p><h2 id="2-2-自定义配置"><a href="#2-2-自定义配置" class="headerlink" title="2.2.自定义配置"></a>2.2.自定义配置</h2><p>Feign可以支持很多的自定义配置，如下表所示：</p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.Logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign. Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign. Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。</p><p>下面以日志为例来演示如何自定义配置。</p><h3 id="2-2-1-配置文件方式"><a href="#2-2-1-配置文件方式" class="headerlink" title="2.2.1.配置文件方式"></a>2.2.1.配置文件方式</h3><p>基于配置文件修改feign的日志级别可以针对单个服务：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>    <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>       <span class="token key atrule">userservice</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 针对某个微服务的配置</span>        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> FULL <span class="token comment" spellcheck="true">#  日志级别 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以针对所有服务：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>    <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>       <span class="token key atrule">default</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span>        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> FULL <span class="token comment" spellcheck="true">#  日志级别 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><h3 id="2-2-2-Java代码方式"><a href="#2-2-2-Java代码方式" class="headerlink" title="2.2.2.Java代码方式"></a>2.2.2.Java代码方式</h3><p>也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultFeignConfiguration</span>  <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Logger<span class="token punctuation">.</span>Level <span class="token function">feignLogLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> Logger<span class="token punctuation">.</span>Level<span class="token punctuation">.</span>BASIC<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 日志级别为BASIC</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>defaultConfiguration <span class="token operator">=</span> DefaultFeignConfiguration <span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"userservice"</span><span class="token punctuation">,</span> configuration <span class="token operator">=</span> DefaultFeignConfiguration <span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-3-Feign使用优化"><a href="#2-3-Feign使用优化" class="headerlink" title="2.3.Feign使用优化"></a>2.3.Feign使用优化</h2><p>Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：</p><p>•URLConnection：默认实现，不支持连接池</p><p>•Apache HttpClient ：支持连接池</p><p>•OKHttp：支持连接池</p><p>因此提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。</p><p>这里我们用Apache的HttpClient来演示。</p><p>1）引入依赖</p><p>在order-service的pom文件中引入Apache的HttpClient依赖：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--httpClient的依赖 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.github.openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>feign-httpclient<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）配置连接池</p><p>在order-service的application.yml中添加配置：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>      <span class="token key atrule">default</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># default全局的配置</span>        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> BASIC <span class="token comment" spellcheck="true"># 日志级别，BASIC就是基本的请求和响应信息</span>  <span class="token key atrule">httpclient</span><span class="token punctuation">:</span>    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 开启feign对HttpClient的支持</span>    <span class="token key atrule">max-connections</span><span class="token punctuation">:</span> <span class="token number">200 </span><span class="token comment" spellcheck="true"># 最大的连接数</span>    <span class="token key atrule">max-connections-per-route</span><span class="token punctuation">:</span> <span class="token number">50 </span><span class="token comment" spellcheck="true"># 每个路径的最大连接数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，在FeignClientFactoryBean中的loadBalance方法中打断点：</p><p><img src="/feign/image-20210714185925910.png" alt="image-20210714185925910"></p><p>Debug方式启动order-service服务，可以看到这里的client，底层就是Apache HttpClient：</p><p><img src="/feign/image-20210714190041542.png" alt="image-20210714190041542"></p><p>总结，Feign的优化：</p><p>1.日志级别尽量用basic</p><p>2.使用HttpClient或OKHttp代替URLConnection</p><p>①  引入feign-httpClient依赖</p><p>②  配置文件开启httpClient功能，设置连接池参数</p><h2 id="2-4-最佳实践"><a href="#2-4-最佳实践" class="headerlink" title="2.4.最佳实践"></a>2.4.最佳实践</h2><p>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。</p><p>自习观察可以发现，Feign的客户端与服务提供者的controller代码非常相似：</p><p>feign客户端：</p><p><img src="/feign/image-20210714190542730.png" alt="image-20210714190542730"></p><p>UserController：</p><p><img src="/feign/image-20210714190528450.png" alt="image-20210714190528450"></p><h3 id="2-4-1-继承方式"><a href="#2-4-1-继承方式" class="headerlink" title="2.4.1.继承方式"></a>2.4.1.继承方式</h3><p>一样的代码可以通过继承来共享：</p><p>1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。</p><p>2）Feign客户端和Controller都集成改接口</p><p><img src="/feign/image-20210714190640857.png" alt="image-20210714190640857"></p><p>优点：</p><ul><li>简单</li><li>实现了代码共享</li></ul><p>缺点：</p><ul><li><p>服务提供方、服务消费方紧耦合</p></li><li><p>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解</p></li></ul><h3 id="2-4-2-抽取方式"><a href="#2-4-2-抽取方式" class="headerlink" title="2.4.2.抽取方式"></a>2.4.2.抽取方式</h3><p>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。</p><p>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。</p><p><img src="/feign/image-20210714214041796.png" alt="image-20210714214041796"></p><h3 id="2-4-3-实现基于抽取的最佳实践"><a href="#2-4-3-实现基于抽取的最佳实践" class="headerlink" title="2.4.3.实现基于抽取的最佳实践"></a>2.4.3.实现基于抽取的最佳实践</h3><h4 id="1）抽取"><a href="#1）抽取" class="headerlink" title="1）抽取"></a>1）抽取</h4><p>首先创建一个module，命名为feign-api：</p><p><img src="/feign/image-20210714204557771.png" alt="image-20210714204557771"></p><p>项目结构：</p><p><img src="/feign/image-20210714204656214.png" alt="image-20210714204656214"></p><p>在feign-api中然后引入feign的starter依赖</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中</p><p><img src="/feign/image-20210714205221970.png" alt="image-20210714205221970"></p><h4 id="2）在order-service中使用feign-api"><a href="#2）在order-service中使用feign-api" class="headerlink" title="2）在order-service中使用feign-api"></a>2）在order-service中使用feign-api</h4><p>首先，删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口。</p><p>在order-service的pom文件中中引入feign-api的依赖：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>cn.itcast.demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>feign-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包</p><h4 id="3）重启测试"><a href="#3）重启测试" class="headerlink" title="3）重启测试"></a>3）重启测试</h4><p>重启后，发现服务报错了：</p><p><img src="/feign/image-20210714205623048.png" alt="image-20210714205623048"></p><p>这是因为UserClient现在在cn.itcast.feign.clients包下，</p><p>而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。</p><h4 id="4）解决扫描包问题"><a href="#4）解决扫描包问题" class="headerlink" title="4）解决扫描包问题"></a>4）解决扫描包问题</h4><p>方式一：</p><p>指定Feign应该扫描的包：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token string">"cn.itcast.feign.clients"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方式二：</p><p>指定需要加载的Client接口：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>clients <span class="token operator">=</span> <span class="token punctuation">{</span>UserClient<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Feign调用被保护的资源"><a href="#Feign调用被保护的资源" class="headerlink" title="Feign调用被保护的资源"></a>Feign调用被保护的资源</h1><p>Feign调用被Spring Security保护的资源的时候，需要加上token之类的规定的验证条件</p><p>@Headers注解添加Authorization头信息，以便通过Spring Security的认证。</p><pre><code>@FeignClient(name = &quot;service-provider&quot;)public interface UserFeignClient {    @RequestLine(&quot;GET /api/users/{id}&quot;)    @Headers(&quot;Authorization: {token}&quot;)    User getUserById(@Param(&quot;id&quot;) Long id, @Param(&quot;token&quot;) String token);}</code></pre><h1 id="OpenFeign——拦截器"><a href="#OpenFeign——拦截器" class="headerlink" title="OpenFeign——拦截器"></a>OpenFeign——拦截器</h1><pre><code>package feign;/** * 可以配置零个或多个请求拦截器，可以用于例如给所有请求添加请求头信息.但是不能保证拦截器的应用顺  * 序。一旦拦截器被应用，就会调用Target类中的apply(RequestTemplate)方法去创建不可变的http请  * 求，该请求通过Client类中的execute(Request, feign.Request.Options)发送。 * * 拦截器是在设置rest模板参数后才被应用的，因此不能再拦截器中添加参数，比如不能再     * apply(RequestTemplate)方法中给/path/{foo}/bar中的foo设置参数。 * 这个类类似于RequestInterceptor.intercept()方法，可以实现读取、删除或以其他方式改变请求模板  * 的任何部分。 */public interface RequestInterceptor {  /**   * 可以被每个请求调用。使用RequestTemplate提供的这个方法可以添加数据。   */  void apply(RequestTemplate template);}</code></pre><p>通过对该类及方法的注释可以了解到RequestInterceptor接口的apply方法可以对请求进行拦截，可以在该方法中添加请求头信息。</p><pre><code>package com.example.rtbootconsumer.config.interceptor;import com.example.rtbootconsumer.common.utils.TraceIdUtil;import feign.Request;import feign.RequestInterceptor;import feign.RequestTemplate;import org.apache.commons.lang3.StringUtils;import org.springframework.context.annotation.Configuration;/** * @Description Feign接口请求拦截器 **/@Configurationpublic class FeignRequestInterceptor implements RequestInterceptor {    /**     * @description: 将traceId设置到请求头     */    @Override    public void apply(RequestTemplate template) {        String traceId = TraceIdUtil.getTraceId();        if (StringUtils.isNotEmpty(traceId)) {            template.header(&quot;traceId&quot;, traceId);        }    }}</code></pre><p>创建自定义拦截器+配置@FeignClient注解的configuration属性</p><pre><code>package com.example.rtbootconsumer.config.interceptor;import com.example.rtbootconsumer.common.utils.TraceIdUtil;import feign.Request;import feign.RequestInterceptor;import feign.RequestTemplate;import org.apache.commons.lang3.StringUtils;import org.springframework.context.annotation.Configuration;/** * @Description Feign接口请求拦截器 **/public class FeignRequestInterceptor implements RequestInterceptor {    /**     * @description: 将traceId设置到请求头     */    @Override    public void apply(RequestTemplate template) {        String traceId = TraceIdUtil.getTraceId();        if (StringUtils.isNotEmpty(traceId)) {            template.header(&quot;traceId&quot;, traceId);        }    }}</code></pre><pre><code>package com.example.rtbootconsumer.feignservice;import com.example.rtbootconsumer.pojo.User;import com.example.rtbootconsumer.vo.ResultBody;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.*;import java.util.List;@FeignClient(name = &quot;service-provider&quot;, path = &quot;/testComm&quot;, url = &quot;${addr.url}&quot;,configuration = FeignRequestInterceptor.class)public interface UserFeignService {    @PostMapping(value = &quot;/getUser&quot;)    public ResultBody&lt;User&gt; getUser(@RequestBody User user);}</code></pre><h2 id="创建两个拦截器"><a href="#创建两个拦截器" class="headerlink" title="创建两个拦截器"></a>创建两个拦截器</h2><p>也可以同时创建多个拦截器实现拦截器链的功能。</p><p>此时再创建一个拦截器FeignRequestInterceptor2，用于在请求头中设置属性名为test，值为lalala信息。</p><p>方式一：同上</p><pre><code>package com.example.rtbootconsumer.config.interceptor;import com.example.rtbootconsumer.common.utils.TraceIdUtil;import feign.Request;import feign.RequestInterceptor;import feign.RequestTemplate;import org.apache.commons.lang3.StringUtils;import org.springframework.context.annotation.Configuration;/** * @Description Feign接口请求拦截器 **/@Configurationpublic class FeignRequestInterceptor2 implements RequestInterceptor {    /**     * @description: 将test设置到请求头     */    @Override    public void apply(RequestTemplate template) {        String traceId = TraceIdUtil.getTraceId();        if (StringUtils.isNotEmpty(traceId)) {            template.header(&quot;test&quot;, &quot;lalala&quot;);        }    }}</code></pre><p>方式二：同上，注意这里设置的@FeignClient注解的configuration属性值是两个拦截器的class数组。</p><pre><code>package com.example.rtbootconsumer.feignservice;import com.example.rtbootconsumer.pojo.User;import com.example.rtbootconsumer.vo.ResultBody;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.*;import java.util.List;@FeignClient(name = &quot;service-provider&quot;, path = &quot;/testComm&quot;, url = &quot;${addr.url}&quot;,configuration = {FeignRequestInterceptor.class,FeignRequestInterceptor2.class})public interface UserFeignService {    @PostMapping(value = &quot;/getUser&quot;)    public ResultBody&lt;User&gt; getUser(@RequestBody User user);    @PostMapping(value = &quot;/testList&quot;)    public ResultBody&lt;List&lt;User&gt;&gt; testList(@RequestBody List&lt;User&gt; list);}</code></pre><p>三、注意<br>在创建并配置拦截器时有两点需要特别注意。</p><p>在使用方式一去创建拦截器时，会拦截所有请求。用方式二时若@FeignClient注解的configuration属性未设置拦截器，那么并不会拦截该接口下所有方法的请求。拦截器只会拦截所有configuration属性值设置了拦截器的接口下所有方法的请求。因此使用方式二更灵活。<br>拦截器执行顺序。若使用方式一去创建多个拦截器时，正如前面注释所讲，不能保证拦截器的执行顺序。但是使用方式二则可以控制拦截器的执行顺序，拦截器的执行顺序和@FeignClient注解中configuration属性中拦截器的配置顺序有关。若配置为 {FeignRequestInterceptor.class,FeignRequestInterceptor2.class})，则会先执行FeignRequestInterceptor中的拦截，再执行FeignRequestInterceptor2中的拦截。若配置为 {FeignRequestInterceptor2.class,FeignRequestInterceptor.class})，则会先执行FeignRequestInterceptor2中的拦截，再执行FeignRequestInterceptor中的拦截。</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gateway</title>
      <link href="/gateway.html"/>
      <url>/gateway.html</url>
      
        <content type="html"><![CDATA[<h1 id="Gateway服务网关"><a href="#Gateway服务网关" class="headerlink" title="Gateway服务网关"></a>Gateway服务网关</h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><h2 id="为什么需要网关"><a href="#为什么需要网关" class="headerlink" title="为什么需要网关"></a>为什么需要网关</h2><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。</p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p>架构图：</p><p><img src="/gateway/image-20210714210131152.png" alt="image-20210714210131152"></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="gateway快速入门"><a href="#gateway快速入门" class="headerlink" title="gateway快速入门"></a>gateway快速入门</h2><p>下面，我们就演示下网关的基本路由功能。基本步骤如下：</p><ol><li>创建SpringBoot工程gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><h3 id="1）创建gateway服务，引入依赖"><a href="#1）创建gateway服务，引入依赖" class="headerlink" title="1）创建gateway服务，引入依赖"></a>1）创建gateway服务，引入依赖</h3><p>创建服务：</p><p><img src="/gateway/image-20210714210919458.png" alt="image-20210714210919458"></p><p>引入依赖：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--网关--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-gateway<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--nacos服务发现依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2）编写启动类"><a href="#2）编写启动类" class="headerlink" title="2）编写启动类"></a>2）编写启动类</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>gateway<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>SpringBootApplication<span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GatewayApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>GatewayApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3）编写基础配置和路由规则"><a href="#3）编写基础配置和路由规则" class="headerlink" title="3）编写基础配置和路由规则"></a>3）编写基础配置和路由规则</h3><p>创建application.yml文件，内容如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10010 </span><span class="token comment" spellcheck="true"># 网关端口</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> gateway <span class="token comment" spellcheck="true"># 服务名称</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848 </span><span class="token comment" spellcheck="true"># nacos地址</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 网关路由配置</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> user<span class="token punctuation">-</span>service <span class="token comment" spellcheck="true"># 路由id，自定义，只要唯一即可</span>          <span class="token comment" spellcheck="true"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span>          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//userservice <span class="token comment" spellcheck="true"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span>          <span class="token key atrule">predicates</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 路由断言，也就是判断请求是否符合路由规则的条件</span>            <span class="token punctuation">-</span> Path=/user/** <span class="token comment" spellcheck="true"># 这个是按照路径匹配，只要以/user/开头就符合要求</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>本例中，将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p><h3 id="4）重启测试"><a href="#4）重启测试" class="headerlink" title="4）重启测试"></a>4）重启测试</h3><p>重启网关，访问<a href="http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：" target="_blank" rel="noopener">http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：</a></p><p><img src="/gateway/image-20210714211908341.png" alt="image-20210714211908341"></p><h3 id="5）网关路由的流程图"><a href="#5）网关路由的流程图" class="headerlink" title="5）网关路由的流程图"></a>5）网关路由的流程图</h3><p>整个访问的流程如下：</p><p><img src="/gateway/image-20210714211742956.png" alt="image-20210714211742956"></p><p>总结：</p><p>网关搭建步骤：</p><ol><li><p>创建项目，引入nacos服务发现和gateway依赖</p></li><li><p>配置application.yml，包括服务基本信息、nacos地址、路由</p></li></ol><p>路由配置包括：</p><ol><li><p>路由id：路由的唯一标示</p></li><li><p>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</p></li><li><p>路由断言（predicates）：判断路由的规则，</p></li><li><p>路由过滤器（filters）：对请求或响应做处理</p></li></ol><h2 id="断言工厂"><a href="#断言工厂" class="headerlink" title="断言工厂"></a>断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p><p>例如Path=/user/**是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来</p><p>处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>-  After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>-  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>-  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie=chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header=X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>-  Host=<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method=GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path=/red/{segment},/blue/**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query=name, Jack或者-  Query=name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr=192.168.1.1/24</td></tr><tr><td>Weight</td><td>权重处理</td><td></td></tr></tbody></table><h2 id="过滤器工厂"><a href="#过滤器工厂" class="headerlink" title="过滤器工厂"></a>过滤器工厂</h2><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p><p><img src="/gateway/image-20210714212312871.png" alt="image-20210714212312871"></p><h3 id="3-4-1-路由过滤器的种类"><a href="#3-4-1-路由过滤器的种类" class="headerlink" title="3.4.1.路由过滤器的种类"></a>3.4.1.路由过滤器的种类</h3><p>Spring提供了31种不同的路由过滤器工厂。例如：</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr><tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr></tbody></table><h3 id="3-4-2-请求头过滤器"><a href="#3-4-2-请求头过滤器" class="headerlink" title="3.4.2.请求头过滤器"></a>3.4.2.请求头过滤器</h3><p>下面以AddRequestHeader 为例。</p><blockquote><p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!</p></blockquote><p>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> user<span class="token punctuation">-</span>service         <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//userservice         <span class="token key atrule">predicates</span><span class="token punctuation">:</span>         <span class="token punctuation">-</span> Path=/user/**         <span class="token key atrule">filters</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 过滤器</span>        <span class="token punctuation">-</span> AddRequestHeader=Truth<span class="token punctuation">,</span> Itcast is freaking awesome! <span class="token comment" spellcheck="true"># 添加请求头</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。</p><h3 id="3-4-3-默认过滤器"><a href="#3-4-3-默认过滤器" class="headerlink" title="3.4.3.默认过滤器"></a>3.4.3.默认过滤器</h3><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> user<span class="token punctuation">-</span>service         <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//userservice         <span class="token key atrule">predicates</span><span class="token punctuation">:</span>         <span class="token punctuation">-</span> Path=/user/**      <span class="token key atrule">default-filters</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 默认过滤项</span>      <span class="token punctuation">-</span> AddRequestHeader=Truth<span class="token punctuation">,</span> Itcast is freaking awesome! <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>过滤器的作用是什么？</p><p>① 对路由的请求或响应做加工处理，比如添加请求头</p><p>② 配置在路由下的过滤器只对当前路由的请求生效</p><p>defaultFilters的作用是什么？</p><p>① 对所有路由都生效的过滤器</p><h2 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h2><p>上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</p><h3 id="3-5-1-全局过滤器作用"><a href="#3-5-1-全局过滤器作用" class="headerlink" title="3.5.1.全局过滤器作用"></a>3.5.1.全局过滤器作用</h3><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</p><p>定义方式是实现GlobalFilter接口。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">GlobalFilter</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     *  处理当前请求，有必要的话通过{@link GatewayFilterChain}将请求交给下一个过滤器处理     *     * @param exchange 请求上下文，里面可以获取Request、Response等信息     * @param chain 用来把请求委托给下一个过滤器      * @return {@code Mono&lt;Void>} 返回标示当前过滤器业务结束     */</span>    Mono<span class="token operator">&lt;</span>Void<span class="token operator">></span> <span class="token function">filter</span><span class="token punctuation">(</span>ServerWebExchange exchange<span class="token punctuation">,</span> GatewayFilterChain chain<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在filter中编写自定义逻辑，可以实现下列功能：</p><ul><li>登录状态判断</li><li>权限校验</li><li>请求限流等</li></ul><h3 id="3-5-2-自定义全局过滤器"><a href="#3-5-2-自定义全局过滤器" class="headerlink" title="3.5.2.自定义全局过滤器"></a>3.5.2.自定义全局过滤器</h3><p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p><ul><li><p>参数中是否有authorization，</p></li><li><p>authorization参数值是否为admin</p></li></ul><p>如果同时满足则放行，否则拦截</p><p>实现：</p><p>在gateway中定义一个过滤器：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>gateway<span class="token punctuation">.</span>filters<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>gateway<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>GatewayFilterChain<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>gateway<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>GlobalFilter<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Order<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpStatus<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Component<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>server<span class="token punctuation">.</span>ServerWebExchange<span class="token punctuation">;</span><span class="token keyword">import</span> reactor<span class="token punctuation">.</span>core<span class="token punctuation">.</span>publisher<span class="token punctuation">.</span>Mono<span class="token punctuation">;</span><span class="token annotation punctuation">@Order</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AuthorizeFilter</span> <span class="token keyword">implements</span> <span class="token class-name">GlobalFilter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Mono<span class="token operator">&lt;</span>Void<span class="token operator">></span> <span class="token function">filter</span><span class="token punctuation">(</span>ServerWebExchange exchange<span class="token punctuation">,</span> GatewayFilterChain chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1.获取请求参数</span>        MultiValueMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> params <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQueryParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2.获取authorization参数</span>        String auth <span class="token operator">=</span> params<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token string">"authorization"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.校验</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>auth<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 放行</span>            <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 4.拦截</span>        <span class="token comment" spellcheck="true">// 4.1.禁止访问，设置状态码</span>        exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setStatusCode</span><span class="token punctuation">(</span>HttpStatus<span class="token punctuation">.</span>FORBIDDEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 4.2.结束处理</span>        <span class="token keyword">return</span> exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-3-过滤器执行顺序"><a href="#3-5-3-过滤器执行顺序" class="headerlink" title="3.5.3.过滤器执行顺序"></a>3.5.3.过滤器执行顺序</h3><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p><p><img src="/gateway/image-20210714214228409.png" alt="image-20210714214228409"></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li><li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li></ul><p>详细内容，可以查看源码：</p><p><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code>方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。</p><p><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code>方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链</p><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><h3 id="3-6-1-什么是跨域问题"><a href="#3-6-1-什么是跨域问题" class="headerlink" title="3.6.1.什么是跨域问题"></a>3.6.1.什么是跨域问题</h3><p>跨域：域名不一致就是跨域，主要包括：</p><ul><li><p>域名不同： <a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a> 和 <a href="http://www.taobao.org" target="_blank" rel="noopener">www.taobao.org</a> 和 <a href="http://www.jd.com" target="_blank" rel="noopener">www.jd.com</a> 和 miaosha.jd.com</p></li><li><p>域名相同，端口不同：localhost:8080和localhost8081</p></li></ul><p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</p><p>解决方案：CORS可以查看<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><h3 id="3-6-3-解决跨域问题"><a href="#3-6-3-解决跨域问题" class="headerlink" title="3.6.3.解决跨域问题"></a>3.6.3.解决跨域问题</h3><p>在gateway服务的application.yml文件中，添加下面的配置：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 。。。</span>      <span class="token key atrule">globalcors</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 全局的跨域处理</span>        <span class="token key atrule">add-to-simple-url-handler-mapping</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 解决options请求被拦截问题</span>        <span class="token key atrule">corsConfigurations</span><span class="token punctuation">:</span>          '<span class="token punctuation">[</span>/**<span class="token punctuation">]</span>'<span class="token punctuation">:</span>            <span class="token key atrule">allowedOrigins</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 允许哪些网站的跨域请求 </span>              <span class="token punctuation">-</span> <span class="token string">"http://localhost:8090"</span>            <span class="token key atrule">allowedMethods</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 允许的跨域ajax的请求方式</span>              <span class="token punctuation">-</span> <span class="token string">"GET"</span>              <span class="token punctuation">-</span> <span class="token string">"POST"</span>              <span class="token punctuation">-</span> <span class="token string">"DELETE"</span>              <span class="token punctuation">-</span> <span class="token string">"PUT"</span>              <span class="token punctuation">-</span> <span class="token string">"OPTIONS"</span>            <span class="token key atrule">allowedHeaders</span><span class="token punctuation">:</span> <span class="token string">"*"</span> <span class="token comment" spellcheck="true"># 允许在请求中携带的头信息</span>            <span class="token key atrule">allowCredentials</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 是否允许携带cookie</span>            <span class="token key atrule">maxAge</span><span class="token punctuation">:</span> <span class="token number">360000 </span><span class="token comment" spellcheck="true"># 这次跨域检测的有效期</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos</title>
      <link href="/nacos.html"/>
      <url>/nacos.html</url>
      
        <content type="html"><![CDATA[<h1 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h1><h2 id="认识和安装Nacos"><a href="#认识和安装Nacos" class="headerlink" title="认识和安装Nacos"></a>认识和安装Nacos</h2><p><a href="https://nacos.io/" target="_blank" rel="noopener">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener">SpringCloud</a>中的一个组件。相比<a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">Eureka</a>功能更加丰富，在国内受欢迎程度较高。</p><p><img src="/nacos/image-20210713230444308.png" alt="image-20210713230444308"></p><h3 id="安装Nacos"><a href="#安装Nacos" class="headerlink" title="安装Nacos"></a>安装Nacos</h3><p>GitHub主页：<a href="https://github.com/alibaba/nacos" target="_blank" rel="noopener">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">https://github.com/alibaba/nacos/releases</a></p><p>解压</p><p><img src="/nacos/image-20210402161843337.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><h4 id="端口配置"><a href="#端口配置" class="headerlink" title="端口配置"></a>端口配置</h4><p>Nacos的默认端口是8848，如果电脑上的其它进程占用了8848端口，请先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p><p><img src="/nacos/image-20210402162008280.png" alt="image-20210402162008280"></p><p>修改其中的内容：</p><p><img src="/nacos/image-20210402162251093.png" alt="image-20210402162251093"></p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>启动非常简单，进入bin目录，结构如下：</p><p><img src="/nacos/image-20210402162350977.png" alt="image-20210402162350977"></p><p>然后执行命令即可：</p><ul><li><p>windows命令：</p><pre><code>startup.cmd -m standalone</code></pre></li></ul><p>执行后的效果如图：</p><p><img src="/nacos/image-20210402162526774.png" alt="image-20210402162526774"></p><h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos即可：" target="_blank" rel="noopener">http://127.0.0.1:8848/nacos即可：</a></p><p><img src="/nacos/image-20210402162630427.png" alt="image-20210402162630427"></p><p>默认的账号和密码都是nacos，进入后：</p><p><img src="/nacos/image-20210402162709515.png" alt="image-20210402162709515"></p><p>Linux和Windows差不多</p><p>就是下载安装包解压</p><p>Nacos依赖于JDK运行所以Linux上也需要安装JDK才行。</p><p>tar -xvf nacos-server-1.4.1.tar.gz</p><p><img src="/nacos/image-20210402164414827.png" alt="image-20210402164414827"></p><p>在nacos/bin目录中，输入命令启动Nacos：</p><pre class="line-numbers language-sh"><code class="language-sh">sh startup.sh -m standalone<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Nacos的依赖"><a href="#Nacos的依赖" class="headerlink" title="Nacos的依赖"></a>Nacos的依赖</h2><p>父工程：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-alibaba-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- nacos客户端依赖包 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="服务注册到nacos"><a href="#服务注册到nacos" class="headerlink" title="服务注册到nacos"></a>服务注册到nacos</h2><p>Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。</p><p>主要差异在于：</p><ul><li>依赖不同</li><li>服务地址不同</li></ul><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-alibaba-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：不要忘了注释掉eureka的依赖。</p><h3 id="配置nacos地址"><a href="#配置nacos地址" class="headerlink" title="配置nacos地址"></a>配置nacos地址</h3><p>在user-service和order-service的application.yml中添加nacos地址：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的地址</p></blockquote><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>重启微服务后，登录nacos管理页面，可以看到微服务信息：</p><p><img src="/nacos/image-20210713231439607.png" alt="image-20210713231439607"></p><h2 id="服务分级存储模型"><a href="#服务分级存储模型" class="headerlink" title="服务分级存储模型"></a>服务分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p><p>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p><p><img src="/nacos/image-20210713232522531.png" alt="image-20210713232522531"></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p><p><img src="/nacos/image-20210713232658928.png" alt="image-20210713232658928"></p><p>杭州机房内的order-service应该优先访问同机房的user-service。</p><h3 id="5-3-1-给user-service配置集群"><a href="#5-3-1-给user-service配置集群" class="headerlink" title="5.3.1.给user-service配置集群"></a>5.3.1.给user-service配置集群</h3><p>修改user-service的application.yml文件，添加集群配置：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>        <span class="token key atrule">cluster-name</span><span class="token punctuation">:</span> HZ <span class="token comment" spellcheck="true"># 集群名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启两个user-service实例后，我们可以在nacos控制台看到下面结果：</p><p><img src="/nacos/image-20210713232916215.png" alt="image-20210713232916215"></p><p>我们再次复制一个user-service启动配置，添加属性：</p><pre class="line-numbers language-sh"><code class="language-sh">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置如图所示：</p><p><img src="/nacos/image-20210713233528982.png" alt="image-20210713233528982"></p><p>启动UserApplication3后再次查看nacos控制台：</p><p><img src="/nacos/image-20210713233727923.png" alt="image-20210713233727923"></p><h3 id="同集群优先的负载均衡"><a href="#同集群优先的负载均衡" class="headerlink" title="同集群优先的负载均衡"></a>同集群优先的负载均衡</h3><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p><p>因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p><p>1）给order-service配置集群信息</p><p>修改order-service的application.yml文件，添加集群配置：</p><pre class="line-numbers language-sh"><code class="language-sh">spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        cluster-name: HZ # 集群名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）修改负载均衡规则</p><p>修改order-service的application.yml文件，修改负载均衡规则：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">userservice</span><span class="token punctuation">:</span>  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.alibaba.cloud.nacos.ribbon.NacosRule <span class="token comment" spellcheck="true"># 负载均衡规则 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="权重配置"><a href="#权重配置" class="headerlink" title="权重配置"></a>权重配置</h2><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p><p>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</p><p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</p><p><img src="/nacos/image-20210713235133225.png" alt="image-20210713235133225"></p><p>在弹出的编辑窗口，修改权重：</p><p><img src="/nacos/image-20210713235235219.png" alt="image-20210713235235219"></p><blockquote><p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p></blockquote><h2 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h2><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><p><img src="/nacos/image-20210714000101516.png" alt="image-20210714000101516"></p><h3 id="5-5-1-创建namespace"><a href="#5-5-1-创建namespace" class="headerlink" title="5.5.1.创建namespace"></a>5.5.1.创建namespace</h3><p>默认情况下，所有service、data、group都在同一个namespace，名为public：</p><p><img src="/nacos/image-20210714000414781.png" alt="image-20210714000414781"></p><p>我们可以点击页面新增按钮，添加一个namespace：</p><p><img src="/nacos/image-20210714000440143.png" alt="image-20210714000440143"></p><p>然后，填写表单：</p><p><img src="/nacos/image-20210714000505928.png" alt="image-20210714000505928"></p><p>就能在页面看到一个新的namespace：</p><p><img src="/nacos/image-20210714000522913.png" alt="image-20210714000522913"></p><h3 id="给微服务配置namespace"><a href="#给微服务配置namespace" class="headerlink" title="给微服务配置namespace"></a>给微服务配置namespace</h3><p>给微服务配置namespace只能通过修改配置来实现。</p><p>例如，修改order-service的application.yml文件：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>        <span class="token key atrule">cluster-name</span><span class="token punctuation">:</span> HZ        <span class="token key atrule">namespace</span><span class="token punctuation">:</span> 492a7d5d<span class="token punctuation">-</span>237b<span class="token punctuation">-</span>46a1<span class="token punctuation">-</span>a99a<span class="token punctuation">-</span>fa8e98e4b0f9 <span class="token comment" spellcheck="true"># 命名空间，填ID</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启order-service后，访问控制台，可以看到下面的结果：</p><p><img src="/nacos/image-20210714000830703.png" alt="image-20210714000830703"></p><p><img src="/nacos/image-20210714000837140.png" alt="image-20210714000837140"></p><p>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：</p><p><img src="/nacos/image-20210714000941256.png" alt="image-20210714000941256"></p><h2 id="Nacos与Eureka的区别"><a href="#Nacos与Eureka的区别" class="headerlink" title="Nacos与Eureka的区别"></a>Nacos与Eureka的区别</h2><p>Nacos的服务实例分为两种l类型：</p><ul><li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p>配置一个服务实例为永久实例：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>        <span class="token key atrule">ephemeral</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 设置为非临时实例</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p><p><img src="/nacos/image-20210714001728017.png" alt="image-20210714001728017"></p><ul><li><p>Nacos与eureka的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p>Nacos与Eureka的区别</p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul><h2 id="Nacos的服务注册表结构"><a href="#Nacos的服务注册表结构" class="headerlink" title="Nacos的服务注册表结构"></a>Nacos的服务注册表结构</h2><p>Nacos采用了数据的分级存储模型，最外层是Namespace，用来隔离环境。然后是Group，用来对服务分组。接下来就是服务（Service）了，一个服务包含多个实例，但是可能处于不同机房，因此Service下有多个集群（Cluster），Cluster下是不同的实例（Instance）。</p><p>对应到Java代码中，Nacos采用了一个多层的Map来表示。结构为Map&lt;String, Map&lt;String, Service&gt;&gt;，其中最外层Map的key就是namespaceId，值是一个Map。内层Map的key是group拼接serviceName，值是Service对象。Service对象内部又是一个Map，key是集群名称，值是Cluster对象。而Cluster对象内部维护了Instance的集合。</p><p><img src="/nacos/image-20210925215305446.png" alt="image-20210925215305446"></p><h2 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h2><h2 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h2><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</p><p><img src="/nacos/image-20210714164426792.png" alt="image-20210714164426792"></p><p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p><h3 id="在nacos中添加配置文件"><a href="#在nacos中添加配置文件" class="headerlink" title="在nacos中添加配置文件"></a>在nacos中添加配置文件</h3><p>如何在nacos中管理配置呢？</p><p><img src="/nacos/image-20210714164742924.png" alt="image-20210714164742924"></p><p>然后在弹出的表单中，填写配置信息：</p><p><img src="/nacos/image-20210714164856664.png" alt="image-20210714164856664"></p><blockquote><p>注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p></blockquote><h3 id="从微服务拉取配置"><a href="#从微服务拉取配置" class="headerlink" title="从微服务拉取配置"></a>从微服务拉取配置</h3><p>微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。</p><p>但如果尚未读取application.yml，又如何得知nacos地址呢？</p><p>因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取，流程如下：</p><p><img src="/nacos/L0iFYNF.png" alt="img"></p><p>1）引入nacos-config依赖</p><p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--nacos配置管理依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）添加bootstrap.yaml</p><p>然后，在user-service中添加一个bootstrap.yaml文件，内容如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> userservice <span class="token comment" spellcheck="true"># 服务名称</span>  <span class="token key atrule">profiles</span><span class="token punctuation">:</span>    <span class="token key atrule">active</span><span class="token punctuation">:</span> dev <span class="token comment" spellcheck="true">#开发环境，这里是dev </span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848 </span><span class="token comment" spellcheck="true"># Nacos地址</span>      <span class="token key atrule">config</span><span class="token punctuation">:</span>        <span class="token key atrule">file-extension</span><span class="token punctuation">:</span> yaml <span class="token comment" spellcheck="true"># 文件后缀名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>spring:  application:    name: media-api //服务名  cloud:    nacos:      server-addr: 192.168.101.65:8848 //nacos的地址      discovery:         namespace: devXueCheng //服务发现的命名空间        group: xuecheng-plus-project //服务发现的组      config:        namespace: devXueCheng         group: xuecheng-plus-project        file-extension: yaml        refresh-enabled: true        extension-configs: //扩展的配置          - data-id: media-service-${spring.profiles.active}.yaml            group: xuecheng-plus-project            refresh: true        shared-configs:          - data-id: swagger-${spring.profiles.active}.yaml            group: xuecheng-plus-common            refresh: true          - data-id: logging-${spring.profiles.active}.yaml            group: xuecheng-plus-common            refresh: true  profiles:    active: dev  //开发</code></pre><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="/nacos/image-20210714174623557.png" alt="image-20210714174623557"></p><p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据</p><p><code>${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}</code>作为文件id，来读取配置。</p><p>本例中，就是去读取<code>userservice-dev.yaml</code>：</p><p><img src="/nacos/image-20210714170845901.png" alt="image-20210714170845901"></p><p>3）读取nacos配置</p><p>在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置：</p><p><img src="/nacos/image-20210714170337448.png" alt="image-20210714170337448"></p><p>完整代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>user<span class="token punctuation">.</span>web<span class="token punctuation">;</span><span class="token keyword">import</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>user<span class="token punctuation">.</span>pojo<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>user<span class="token punctuation">.</span>service<span class="token punctuation">.</span>UserService<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Slf4j<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Value<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>LocalDateTime<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>format<span class="token punctuation">.</span>DateTimeFormatter<span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${pattern.dateformat}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String dateformat<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"now"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>DateTimeFormatter<span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span>dateformat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// ...略</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在页面访问，可以看到效果：</p><p><img src="/nacos/image-20210714170449612.png" alt="image-20210714170449612"></p><h2 id="1-2-配置热更新"><a href="#1-2-配置热更新" class="headerlink" title="1.2.配置热更新"></a>1.2.配置热更新</h2><p>最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p><p>要实现配置热更新，可以使用两种方式：</p><h3 id="1-2-1-方式一"><a href="#1-2-1-方式一" class="headerlink" title="1.2.1.方式一"></a>1.2.1.方式一</h3><p>在@Value注入的变量所在类上添加注解@RefreshScope：</p><p><img src="/nacos/image-20210714171036335.png" alt="image-20210714171036335"></p><h3 id="1-2-2-方式二"><a href="#1-2-2-方式二" class="headerlink" title="1.2.2.方式二"></a>1.2.2.方式二</h3><p>使用@ConfigurationProperties注解代替@Value注解。</p><p>在user-service服务中，添加一个类，读取patterrn.dateformat属性：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>user<span class="token punctuation">.</span>config<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>Data<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>context<span class="token punctuation">.</span>properties<span class="token punctuation">.</span>ConfigurationProperties<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Component<span class="token punctuation">;</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"pattern"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PatternProperties</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String dateformat<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在UserController中使用这个类代替@Value：</p><p><img src="/nacos/image-20210714171316124.png" alt="image-20210714171316124"></p><p>完整代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>user<span class="token punctuation">.</span>web<span class="token punctuation">;</span><span class="token keyword">import</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>user<span class="token punctuation">.</span>config<span class="token punctuation">.</span>PatternProperties<span class="token punctuation">;</span><span class="token keyword">import</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>user<span class="token punctuation">.</span>pojo<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>user<span class="token punctuation">.</span>service<span class="token punctuation">.</span>UserService<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Slf4j<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>GetMapping<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>PathVariable<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RequestMapping<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RestController<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>LocalDateTime<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>format<span class="token punctuation">.</span>DateTimeFormatter<span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> PatternProperties patternProperties<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"now"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>DateTimeFormatter<span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span>patternProperties<span class="token punctuation">.</span><span class="token function">getDateformat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 略</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-配置共享"><a href="#1-3-配置共享" class="headerlink" title="1.3.配置共享"></a>1.3.配置共享</h2><p>其实微服务启动时，会去nacos读取多个配置文件，例如：</p><ul><li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</p></li><li><p><code>[spring.application.name].yaml</code>，例如：userservice.yaml</p></li></ul><p>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。</p><p>下面我们通过案例来测试配置共享</p><h3 id="1）添加一个环境共享配置"><a href="#1）添加一个环境共享配置" class="headerlink" title="1）添加一个环境共享配置"></a>1）添加一个环境共享配置</h3><p>我们在nacos中添加一个userservice.yaml文件：</p><p><img src="/nacos/image-20210714173233650.png" alt="image-20210714173233650"></p><h3 id="2）在user-service中读取共享配置"><a href="#2）在user-service中读取共享配置" class="headerlink" title="2）在user-service中读取共享配置"></a>2）在user-service中读取共享配置</h3><p>在user-service服务中，修改PatternProperties类，读取新添加的属性：</p><p><img src="/nacos/image-20210714173324231.png" alt="image-20210714173324231"></p><p>在user-service服务中，修改UserController，添加一个方法：</p><p><img src="/nacos/image-20210714173721309.png" alt="image-20210714173721309"></p><h3 id="3）运行两个UserApplication，使用不同的profile"><a href="#3）运行两个UserApplication，使用不同的profile" class="headerlink" title="3）运行两个UserApplication，使用不同的profile"></a>3）运行两个UserApplication，使用不同的profile</h3><p>修改UserApplication2这个启动项，改变其profile值：</p><p><img src="/nacos/image-20210714173538538.png" alt="image-20210714173538538"></p><p><img src="/nacos/image-20210714173519963.png" alt="image-20210714173519963"></p><p>这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。</p><p>启动UserApplication和UserApplication2</p><p>访问<a href="http://localhost:8081/user/prop，结果：" target="_blank" rel="noopener">http://localhost:8081/user/prop，结果：</a></p><p><img src="/nacos/image-20210714174313344.png" alt="image-20210714174313344"></p><p>访问<a href="http://localhost:8082/user/prop，结果：" target="_blank" rel="noopener">http://localhost:8082/user/prop，结果：</a></p><p><img src="/nacos/image-20210714174424818.png" alt="image-20210714174424818"></p><p>可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。</p><h3 id="4）配置共享的优先级"><a href="#4）配置共享的优先级" class="headerlink" title="4）配置共享的优先级"></a>4）配置共享的优先级</h3><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="/nacos/image-20210714174623557.png" alt="image-20210714174623557"></p><h2 id="Nacos的服务注册表结构-1"><a href="#Nacos的服务注册表结构-1" class="headerlink" title="Nacos的服务注册表结构"></a>Nacos的服务注册表结构</h2><p>Nacos采用了数据的分级存储模型，最外层是Namespace，用来隔离环境。然后是Group，用来对服务分组。接下来就是服务（Service）了，一个服务包含多个实例，但是可能处于不同机房，因此Service下有多个集群（Cluster），Cluster下是不同的实例（Instance）。</p><p>对应到Java代码中，Nacos采用了一个多层的Map来表示。结构为Map&lt;String, Map&lt;String, Service&gt;&gt;，其中最外层Map的key就是namespaceId，值是一个Map。内层Map的key是group拼接serviceName，值是Service对象。Service对象内部又是一个Map，key是集群名称，值是Cluster对象。而Cluster对象内部维护了Instance的集合。</p><p>如图：</p><p><img src="/nacos/image-20210925215305446-1679578574632.png" alt="image-20210925215305446"></p><h2 id="Nacos如何支撑阿里内部数十万服务注册压力"><a href="#Nacos如何支撑阿里内部数十万服务注册压力" class="headerlink" title="Nacos如何支撑阿里内部数十万服务注册压力"></a>Nacos如何支撑阿里内部数十万服务注册压力</h2><p>Nacos内部接收到注册的请求时，不会立即写数据，而是将服务注册的任务放入一个阻塞队列就立即响应给客户端。然后利用线程池读取阻塞队列中的任务，异步来完成实例更新，从而提高并发写能力。</p><h2 id="Nacos如何避免并发读写冲突问题"><a href="#Nacos如何避免并发读写冲突问题" class="headerlink" title="Nacos如何避免并发读写冲突问题"></a>Nacos如何避免并发读写冲突问题</h2><p>Nacos在更新实例列表时，会采用CopyOnWrite技术，首先将旧的实例列表拷贝一份，然后更新拷贝的实例列表，再用更新后的实例列表来覆盖旧的实例列表。</p><p>这样在更新的过程中，就不会对读实例列表的请求产生影响，也不会出现脏读问题了。</p><h2 id="Nacos与Eureka的区别有哪些？"><a href="#Nacos与Eureka的区别有哪些？" class="headerlink" title="Nacos与Eureka的区别有哪些？"></a>Nacos与Eureka的区别有哪些？</h2>]]></content>
      
      
      <categories>
          
          <category> Springcloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon-LoadBalance</title>
      <link href="/ribbon-loadbalance.html"/>
      <url>/ribbon-loadbalance.html</url>
      
        <content type="html"><![CDATA[<h1 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h1><h2 id="负载均衡原理"><a href="#负载均衡原理" class="headerlink" title="负载均衡原理"></a>负载均衡原理</h2><p>SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。</p><p><img src="/ribbon-loadbalance/image-20210713224517686.png" alt="image-20210713224517686"></p><h2 id="源码跟踪"><a href="#源码跟踪" class="headerlink" title="源码跟踪"></a>源码跟踪</h2><p>为什么只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p><p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p><h3 id="1-LoadBalancerIntercepor"><a href="#1-LoadBalancerIntercepor" class="headerlink" title="1,LoadBalancerIntercepor"></a>1,LoadBalancerIntercepor</h3><p><img src="/ribbon-loadbalance/1525620483637.png" alt="1525620483637"></p><p>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求uri，本例中就是 <a href="http://user-service/user/8" target="_blank" rel="noopener">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id，<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求。</li></ul><p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型。</p><h3 id="2-LoadBalancerClient"><a href="#2-LoadBalancerClient" class="headerlink" title="2,LoadBalancerClient"></a>2,LoadBalancerClient</h3><p><img src="/ribbon-loadbalance/1525620787090.png" alt="1525620787090"></p><ul><li>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</li><li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</li></ul><p>放行后，再次访问并跟踪，发现获取的是8081</p><p><img src="/ribbon-loadbalance/1525620835911.png" alt="1525620835911"></p><p>果然实现了负载均衡。</p><h3 id="3-负载均衡策略IRule"><a href="#3-负载均衡策略IRule" class="headerlink" title="3,负载均衡策略IRule"></a>3,负载均衡策略IRule</h3><p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p><p><img src="/ribbon-loadbalance/1525620835911-1679574717984.png" alt="1525620835911"></p><p>继续跟踪</p><p><img src="/ribbon-loadbalance/1544361421671.png" alt="1544361421671"></p><p>继续跟踪源码chooseServer方法，发现这么一段代码：</p><p><img src="/ribbon-loadbalance/1525622652849.png" alt="1525622652849"></p><p>看看这个rule是谁：</p><p><img src="/ribbon-loadbalance/1525622699666.png" alt="1525622699666"></p><p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍</p><p><img src="/ribbon-loadbalance/1525622754316.png" alt="1525622754316"></p><p>轮询的意思</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：</p><p><img src="/ribbon-loadbalance/image-20210713224724673.png" alt="image-20210713224724673"></p><p>基本流程如下：</p><ul><li>拦截我们的RestTemplate请求<a href="http://userservice/user/1" target="_blank" rel="noopener">http://userservice/user/1</a></li><li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li><li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li><li>eureka返回列表，localhost:8081、localhost:8082</li><li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li><li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a href="http://localhost:8081/user/1，发起真实请求" target="_blank" rel="noopener">http://localhost:8081/user/1，发起真实请求</a></li></ul><h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><h3 id="负载均衡策略-1"><a href="#负载均衡策略-1" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</p><p><img src="/ribbon-loadbalance/image-20210713225653000.png" alt="image-20210713225653000"></p><p>不同规则的含义如下：</p><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientname>.<clientconfignamespace>.ActiveConnectionsLimit属性进行配置。</clientconfignamespace></clientname></td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><p>默认的实现就是ZoneAvoidanceRule，是一种轮询方案</p><h3 id="自定义负载均衡策略"><a href="#自定义负载均衡策略" class="headerlink" title="自定义负载均衡策略"></a>自定义负载均衡策略</h3><p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p><p>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</p><pre><code>@Beanpublic IRule randomRule(){    return new RandomRule();}</code></pre><p>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</p><pre><code>userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务  ribbon:    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 </code></pre><p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改</p><h2 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h2><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><pre><code>ribbon:  eager-load:    enabled: true    clients: userservice</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eureka注册中心</title>
      <link href="/eureka.html"/>
      <url>/eureka.html</url>
      
        <content type="html"><![CDATA[<h1 id="Eureka的结构和作用"><a href="#Eureka的结构和作用" class="headerlink" title="Eureka的结构和作用"></a>Eureka的结构和作用</h1><p><img src="/eureka/image-20210713220104956.png" alt="image-20210713220104956"></p><p>order-service如何得知user-service实例地址？</p><p>获取地址信息的流程如下：</p><ul><li>user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</li><li>eureka-server保存服务名称到服务实例地址列表的映射关系</li><li>order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li></ul><p>order-service如何从多个user-service实例中选择具体的实例？</p><ul><li>order-service从实例列表中利用负载均衡算法选中一个实例地址</li><li>向该实例地址发起远程调用</li></ul><p>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</p><ul><li>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳</li><li>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service拉取服务时，就能将故障实例排除了</li></ul><p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端</p><h1 id="搭建eureka-server"><a href="#搭建eureka-server" class="headerlink" title="搭建eureka-server"></a>搭建eureka-server</h1><p>首先注册中心服务端：eureka-server，这必须是一个独立的微服务</p><h2 id="创建eureka-server服务"><a href="#创建eureka-server服务" class="headerlink" title="创建eureka-server服务"></a>创建eureka-server服务</h2><p>在cloud-d<img src="/eureka/image-20210713220605881.png" alt="image-20210713220605881">emo父工程下，创建一个子模块：</p><h2 id="引入eureka依赖"><a href="#引入eureka依赖" class="headerlink" title="引入eureka依赖"></a>引入eureka依赖</h2><p>引入SpringCloud为eureka提供的starter依赖：</p><p>注意这里引入的依赖是server,注册的才是client</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="编写启动类"><a href="#编写启动类" class="headerlink" title="编写启动类"></a>编写启动类</h2><p>给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：</p><pre><code>package cn.itcast.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication {    public static void main(String[] args) {        SpringApplication.run(EurekaApplication.class, args);    }}</code></pre><h2 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h2><p>编写一个application.yml文件，内容如下</p><pre><code>server:  port: 10086spring:  application:    name: eureka-servereureka:  client:    service-url:       defaultZone: http://127.0.0.1:10086/eureka</code></pre><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>启动微服务，然后在浏览器访问：<a href="http://127.0.0.1:10086" target="_blank" rel="noopener">http://127.0.0.1:10086</a></p><p>看到下面结果应该是成功了：</p><p><img src="/eureka/image-20210713222157190.png" alt="image-20210713222157190"></p><h1 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h1><p>将user-service注册到eureka-server中去。</p><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>注意这里引入的依赖是Client,服务是server</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>文件，添加服务名称、eureka地址：</p><pre><code>spring:  application:    name: userserviceeureka:  client:    service-url:      defaultZone: http://127.0.0.1:10086/eureka</code></pre><h3 id="启动多个user-service实例"><a href="#启动多个user-service实例" class="headerlink" title="启动多个user-service实例"></a>启动多个user-service实例</h3><p>![image-20210713222656562](Eureka/image-20210713222656562.png</p><p><img src="/eureka/image-20210713222841951.png" alt="image-20210713222841951"></p><p><img src="/eureka/image-20210713223041491.png" alt="image-20210713223041491"></p><p>查看eureka-server管理页面：</p><p><img src="/eureka/image-20210713223150650.png" alt="image-20210713223150650"></p><h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p>将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。</p><h2 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。</p><p>在order-service的pom文件中，引入下面的eureka-client依赖：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h2><p>服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：</p><p>在order-service中，修改application.yml文件，添加服务名称、eureka地址：</p><pre><code>spring:  application:    name: orderserviceeureka:  client:    service-url:      defaultZone: http://127.0.0.1:10086/eureka</code></pre><h2 id="服务拉取和负载均衡"><a href="#服务拉取和负载均衡" class="headerlink" title="服务拉取和负载均衡"></a>服务拉取和负载均衡</h2><p>最后要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。</p><p>只需要添加一些注解即可。</p><p>在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：</p><p><img src="/eureka/image-20210713224049419.png" alt="image-20210713224049419"></p><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：</p><p><img src="/eureka/image-20210713224245731.png" alt="image-20210713224245731"></p><p>spring会自动从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。</p><p>如果使用Feign调用的话就不用@LoadBalanced了，因为Feign是自带负载均衡的。</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity</title>
      <link href="/springsecurity.html"/>
      <url>/springsecurity.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h1><p>Spring Security 是 Spring 家族中的一个安全管理框架，应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。Spring Security是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型</p><p>Spring Security 采用的是责任链的设计模式，它有一条很长的过滤器链。</p><p>Spring Security对Web资源的保护是靠Filter实现的</p><p>当初始化Spring Security时，会创建一个名为SpringSecurityFilterChain的Servlet过滤器，类型为 org.springframework.security.web.FilterChainProxy，它实现了javax.servlet.Filter，因此外部的请求会经过此类，<img src="/springsecurity/image-20230325122446975.png" alt="image-20230325122446975"></p><p>FilterChainProxy是一个代理，真正起作用的是FilterChainProxy中SecurityFilterChain所包含的各个Filter，同时这些Filter作为Bean被Spring管理，它们是Spring Security核心，各有各的职责，但他们并不直接处理用户的<strong>认证</strong>，也不直接处理用户的<strong>授权</strong>，而是把它们交给了认证管理器（AuthenticationManager）和决策管理器（AccessDecisionManager）进行处理。</p><p>spring Security功能的实现主要是由一系列过滤器链相互配合完成。</p><h1 id="SpringSecurity执行流程图"><a href="#SpringSecurity执行流程图" class="headerlink" title="SpringSecurity执行流程图"></a>SpringSecurity执行流程图</h1><p><img src="/springsecurity/d359fe34bc7860c11a1b6e50bfd0e086.png" alt="img"></p><ol><li><p>WebAsyncManagerIntegrationFilter：将 Security 上下文与 Spring Web 中用于处理异步请求映射的 WebAsyncManager 进行集成。</p></li><li><p>SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到 SecurityContextHolder 中，然后在该次请求处理完成之后，将 SecurityContextHolder 中关于这次请求的信息存储到一个“仓储”中，然后将 SecurityContextHolder 中的信息清除，例如在Session中维护一个用户的安全信息就是这个过滤器处理的。默认是将SecurityContext存储在threadlocal中，可能是spring考虑到目前大多数为BS应用，一个应用同时可能有多个使用者，每个使用者又对应不同的安全上下，Security Context Holder为了保存这些安全上下文。</p></li><li><p>HeaderWriterFilter：用于将头信息加入响应中。</p></li><li><p>CsrfFilter：用于处理跨站请求伪造。</p></li><li><p>LogoutFilter：用于处理退出登录。</p></li><li><p>UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自 /login 的请求。从表单中获取用户名和密码时，默认使用的表单 name 值为 username 和 password，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。</p></li><li><p>DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。</p></li><li><p>BasicAuthenticationFilter：检测和处理 http basic 认证。</p></li><li><p>RequestCacheAwareFilter：用来处理请求的缓存。</p></li><li><p>SecurityContextHolderAwareRequestFilter：主要是包装请求对象request。</p></li><li><p>AnonymousAuthenticationFilter：检测 SecurityContextHolder 中是否存在 Authentication 对象，如果不存在为其提供一个匿名 Authentication。</p></li><li><p>SessionManagementFilter：管理 session 的过滤器</p></li><li><p>ExceptionTranslationFilter：处理 AccessDeniedException 和 AuthenticationException 异常。</p></li><li><p>FilterSecurityInterceptor：可以看做过滤器链的出口。</p></li><li><p>RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从 cookie 里找出用户的信息, 如果 Spring Security 能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。</p></li></ol><h1 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h1><p>客户端发起一个请求，进入 Security 过滤器链。</p><p>当到 LogoutFilter 的时候判断是否是登出路径，如果是登出路径则到 logoutHandler ，如果登出成功则到 logoutSuccessHandler 登出成功处理，如果登出失败则由 ExceptionTranslationFilter ；如果不是登出路径则直接进入下一个过滤器。</p><p>当到 UsernamePasswordAuthenticationFilter 的时候判断是否为登录路径，如果是，则进入该过滤器进行登录操作，如果登录失败则到 AuthenticationFailureHandler 登录失败处理器处理，如果登录成功则到 AuthenticationSuccessHandler 登录成功处理器处理，如果不是登录请求则不进入该过滤器。</p><p>当到 FilterSecurityInterceptor 的时候会拿到 uri ，根据 uri 去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到 Controller 层否则到 AccessDeniedHandler 鉴权失败处理器处理。</p><h1 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h1><p>WebSecurityConfigurerAdapte 这个类将在5.7版本被<code>@Deprecated</code>所标记了，未来这个类将被移除。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>    <span class="token annotation punctuation">@EnableWebSecurity</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SecurityConfig</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>AuthenticationManagerBuilder auth<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        auth<span class="token punctuation">.</span><span class="token function">userDetailsService</span><span class="token punctuation">(</span>userDetailService<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">passwordEncoder</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BCryptPasswordEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//认证提供者</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>WebSecurity web<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>            web<span class="token punctuation">.</span><span class="token function">ignoring</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">antMatchers</span><span class="token punctuation">(</span><span class="token string">"/resources/**/*.html"</span><span class="token punctuation">,</span> <span class="token string">"/resources/**/*.js"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>HttpSecurity http<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>           http           <span class="token punctuation">.</span><span class="token function">formLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token punctuation">.</span><span class="token function">loginPage</span><span class="token punctuation">(</span><span class="token string">"/login_page"</span><span class="token punctuation">)</span>           <span class="token punctuation">.</span><span class="token function">passwordParameter</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span>           <span class="token punctuation">.</span><span class="token function">passwordParameter</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span>           <span class="token punctuation">.</span><span class="token function">loginProcessingUrl</span><span class="token punctuation">(</span><span class="token string">"/sign_in"</span><span class="token punctuation">)</span>           <span class="token punctuation">.</span><span class="token function">permitAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authorizeRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">antMatchers</span><span class="token punctuation">(</span><span class="token string">"/test"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasRole</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//权限设置</span>       <span class="token punctuation">.</span><span class="token function">anyRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">accessDecisionManager</span><span class="token punctuation">(</span><span class="token function">accessDecisionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">logout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">logoutUrl</span><span class="token punctuation">(</span><span class="token string">"/logout"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">logoutSuccessHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyLogoutSuccessHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">csrf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           http<span class="token punctuation">.</span><span class="token function">addFilterAt</span><span class="token punctuation">(</span><span class="token function">getAuthenticationFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>UsernamePasswordAuthenticationFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           http<span class="token punctuation">.</span><span class="token function">exceptionHandling</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">accessDeniedHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyAccessDeniedHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           http<span class="token punctuation">.</span><span class="token function">addFilterAfter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyFittler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> LogoutFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置介绍</p><p>@EnableWebSecurity</p><p> 加载了WebSecurityConfiguration配置类, 配置安全认证策略。2: 加载了AuthenticationConfiguration, 配置了认证信息。</p><p>configure(AuthenticationManagerBuilder auth)</p><p>AuthenticationManager 的建造器，配置 AuthenticationManagerBuilder 会让Security 自动构建一个 AuthenticationManager（该类的功能参考流程图）；</p><p>该接口的作用是对用户的未授信凭据进行认证，认证通过则返回授信状态的凭据，否则将抛出认证异常。</p><p>如果想要使用该功能需要配置一个 UserDetailService 和 PasswordEncoder。UserDetailsService 用于在认证器中根据用户传过来的用户名查找一个用户， PasswordEncoder 用于密码的加密与比对，我们存储用户密码的时候用PasswordEncoder.encode() 加密存储，在认证器里会调用 PasswordEncoder.matches() 方法进行密码比对。</p><p>如果重写了该方法，Security 会启用 DaoAuthenticationProvider 这个认证器，该认证就是先调用 UserDetailsService.loadUserByUsername 然后使用 PasswordEncoder.matches() 进行密码比对，如果认证成功成功则返回一个 Authentication 对象。</p><p>DaoAuthenticationProvider  实现了 AuthenticationProvider（鉴定提供者）</p><p>configure(WebSecurity web)</p><p>这个配置方法用于配置静态资源的处理方式，可使用 Ant 匹配规则。</p><p>configure(HttpSecurity http)</p><pre><code>http    .formLogin()    .loginPage(&quot;/login_page&quot;)    .passwordParameter(&quot;username&quot;)    .passwordParameter(&quot;password&quot;)    .loginProcessingUrl(&quot;/sign_in&quot;)    .permitAll()</code></pre><p>这是配置登录相关的操作从方法名可知，</p><p>配置了登录页请求路径.loginPage(“/login_page”)，</p><p>密码属性名，.passwordParameter(“username”)    </p><p>用户名属性名， .passwordParameter(“username”)    </p><p>登录请求路径，.loginProcessingUrl(“/sign_in”)     //就是验证成功后转跳的页面</p><p>permitAll()代表任意用户可访问。</p><pre><code>http    .authorizeRequests()    .antMatchers(&quot;/test&quot;).hasRole(&quot;test&quot;)    .anyRequest().authenticated()    .accessDecisionManager(accessDecisionManager());</code></pre><p>以上配置是权限相关的配置，</p><p>配置了一个 <code>/test</code> url 该有什么权限才能访问， </p><p>anyRequest() 表示所有请求，</p><p>authenticated() 表示已登录用户才能访问， </p><p>accessDecisionManager() 表示绑定在 url 上的鉴权管理器</p><pre><code>http    .logout()    .logoutUrl(&quot;/logout&quot;)    .logoutSuccessHandler(new MyLogoutSuccessHandler())</code></pre><p>登出相关配置，这里配置了登出 url 和登出成功处理器</p><pre><code>http    .exceptionHandling()    .accessDeniedHandler(new MyAccessDeniedHandler());</code></pre><p>代码是配置鉴权失败的处理器</p><pre><code>http.addFilterAfter(new MyFittler(), LogoutFilter.class);    http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</code></pre><p>上面代码展示如何在过滤器链中插入自己的过滤器，addFilterBefore 加在对应的过滤器之前，addFilterAfter 加在对应的过滤器之后，addFilterAt 加在过滤器同一位置，事实上框架原有的 Filter 在启动 HttpSecurity 配置的过程中，都由框架完成了其一定程度上固定的配置，是不允许更改替换的。根据测试结果来看，调用 addFilterAt 方法插入的 Filter ，会在这个位置上的原有 Filter 之前执行。</p><p>注：关于 HttpSecurity 使用的是链式编程，其中 http.xxxx.and.yyyyy 这种写法和 http.xxxx;http.yyyy 写法意义一样。</p><ul><li>自定义 AuthenticationManager 认证管理器 和 AccessDecisionManager 访问决策管理器</li></ul><p>重写 authenticationManagerBean() 方法，并构造一个 authenticationManager：</p><pre><code>@Override    public AuthenticationManager authenticationManagerBean() throws Exception {        ProviderManager authenticationManager = new ProviderManager(Arrays.asLis(getMyAuthenticationProvider(),daoAuthenticationProvider()));        return authenticationManager;    }</code></pre><p>authenticationManager 配置了两个认证器</p><pre><code>public AccessDecisionManager accessDecisionManager(){        List&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt; decisionVoters                = Arrays.asList(                new MyExpressionVoter(),                new WebExpressionVoter(),                new RoleVoter(),                new AuthenticatedVoter());        return new UnanimousBased(decisionVoters);    }</code></pre><p>投票管理器会收集投票器投票结果做统计，最终结果大于等于0代表通过；每个投票器会返回三个结果：-1（反对），0（通过），1（赞成）。</p><h1 id="Security-权限系统"><a href="#Security-权限系统" class="headerlink" title="Security 权限系统"></a>Security 权限系统</h1><h2 id="UserDetails"><a href="#UserDetails" class="headerlink" title="UserDetails"></a>UserDetails</h2><p>该接口是提供用户<strong>信息</strong>的核心接口。该接口实现仅仅存储用户的信息。后续会将该接口提供的用户信息封装到认证对象<code>Authentication</code>中去。</p><p><code>UserDetails</code> 默认提供了：</p><ul><li>用户的权限集， 默认需要添加<code>ROLE_</code> 前缀</li><li>用户的加密后的密码， 不加密会使用<code>{noop}</code>前缀</li><li>应用内唯一的用户名</li><li>账户是否过期</li><li>账户是否锁定</li><li>凭证是否过期</li><li>用户是否可用</li></ul><p>如果以上的信息满足不了使用，可以自行实现扩展以存储更多的用户信息。比如用户的邮箱、手机号等等。通常使用其实现类</p><pre><code>org.springframework.security.core.userdetails.User</code></pre><p>该类内置一个建造器<code>UserBuilder</code> 会很方便地构建<code>UserDetails</code> 对象。</p><h2 id="GrantedAuthority"><a href="#GrantedAuthority" class="headerlink" title="GrantedAuthority"></a>GrantedAuthority</h2><pre><code>public interface GrantedAuthority extends Serializable {    String getAuthority();}</code></pre><p><img src="/springsecurity/image-20230323174655629.png" alt="image-20230323174655629"></p><p>自带了三个实现类</p><p>Security 中的用户权限接口，自定义权限需要实现该接口:</p><pre><code>public class MyGrantedAuthority implements GrantedAuthority {        private String authority;    }</code></pre><p>authority 表示权限字段，需要注意的是在 config 中配置的权限会被加上 ROLE_ 前缀，比如我们的配置 authorizeRequests().antMatchers(“/test”).hasRole(“test”)，配置了一个 test 权限但我们存储的权限字段（authority）应该是 ROLE_test 。</p><p>GrantedAuthority代表的就是一种权限对象，而一个 UserDetails 对象具备一个或多个 GrantedAuthority 对象。通过这种关联关系，实际上我们就可以对用户的权限做一些限制</p><p>Authentication 的 getAuthorities() 可以返回当前 Authentication 对象拥有的权限，即当前用户拥有的权限。其返回值是一个 GrantedAuthority 类型的数组，每一个 GrantedAuthority 对象代表赋予给当前用户的一种权限。GrantedAuthority 是一个接口，其通常是通过 UserDetailsService 进行加载，然后赋予给 UserDetails 的。</p><p>GrantedAuthority 中只定义了一个 getAuthority() 方法，该方法返回一个字符串，表示对应权限的字符串表示，如果对应权限不能用字符串表示，则应当返回 null。</p><p>Spring Security 针对 GrantedAuthority 有一个简单实现 SimpleGrantedAuthority。该类只是简单的接收一个表示权限的字符串。Spring Security 内部的所有 AuthenticationProvider 都是使用 SimpleGrantedAuthority 来封装 Authentication 对象。</p><h2 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h2><p><code>UserDetailsService</code>接口。该接口只提供了一个方法：</p><pre><code>public interface UserDetailsService {    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;}</code></pre><p>根据用户名来定位用户。在实际执行中，搜索可能是区分大小写的，也可能是不区分大小写的，这取决于执行实例是如何配置的。在这种情况下，返回的UserDetails对象可能有一个与实际请求的不同大小写的用户名。</p><p>loadUserByUsername的作用，就是根据用户名查询用户对象。</p><h2 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h2><p>用户在完成登录后 Security 会将用户信息存储到这个类中，之后其他流程需要得到用户信息时都是从这个类中获得，用户信息被封装成 SecurityContext ，而实际存储的类是 SecurityContextHolderStrategy ，默认的SecurityContextHolderStrategy 实现类是 ThreadLocalSecurityContextHolderStrategy 它使用了ThreadLocal来存储了用户信息。</p><h2 id="使用注解在方法上进行权限认"><a href="#使用注解在方法上进行权限认" class="headerlink" title="使用注解在方法上进行权限认"></a>使用注解在方法上进行权限认</h2><p>Spring Security<code>默认是禁用注解的，要想开启注解，要在继承</code>WebSecurityConfigurerAdapter<code>的类加</code>@EnableMethodSecurity<code>注解，并在该类中将</code>AuthenticationManager<code>定义为</code>Bean。</p><pre><code>@EnableWebSecurity@Configuration@EnableGlobalMethodSecurity(  prePostEnabled = true,   securedEnabled = true,   jsr250Enabled = true)public class SecurityConfig extends WebSecurityConfigurerAdapter {    @Bean    @Override    public AuthenticationManager authenticationManagerBean() throws Exception {        return super.authenticationManagerBean();    }}</code></pre><p>分别有prePostEnabled 、securedEnabled、jsr250Enabled三个字段，其中每个字段代码一种注解支持，默认为false，true为开启。那么我们就一一来说一下这三总注解支持。</p><p>prePostEnabled = true 的作用的是启用Spring Security的@PreAuthorize 以及@PostAuthorize 注解。</p><p>securedEnabled = true 的作用是启用Spring Security的@Secured 注解。</p><p>jsr250Enabled = true 的作用是启用@RoleAllowed 注解</p><h3 id="JSR-250注解"><a href="#JSR-250注解" class="headerlink" title="JSR-250注解"></a>JSR-250注解</h3><p>遵守了JSR-250标准注解</p><p>主要注解</p><ol><li>@DenyAll</li><li>@RolesAllowed</li><li>@PermitAll</li></ol><p>这里面<code>@DenyAll</code> 和 <code>@PermitAll</code> 相信就不用多说了 代表拒绝和通过。</p><p><code>@RolesAllowed</code> 使用示例</p><pre><code>@RolesAllowed(&quot;ROLE_VIEWER&quot;)public String getUsername2() {    //...}@RolesAllowed({ &quot;USER&quot;, &quot;ADMIN&quot; })public boolean isValidUsername2(String username) {    //...}</code></pre><p>代表标注的方法只要具有USER, ADMIN任意一种权限就可以访问。这里可以省略前缀ROLE_，实际的权限可能是ROLE_ADMIN</p><p>在功能及使用方法上与 <code>@Secured</code> 完全相同</p><h3 id="securedEnabled注解"><a href="#securedEnabled注解" class="headerlink" title="securedEnabled注解"></a>securedEnabled注解</h3><p>主要注解</p><p>@Secured</p><p>Spring Security的@Secured注解。注解规定了访问访方法的角色列表，在列表中最少指定一种角色</p><p>@Secured在方法上指定安全性，要求 角色/权限等 只有对应 角色/权限 的用户才可以调用这些方法。 如果有人试图调用一个方法，但是不拥有所需的 角色/权限，那会将会拒绝访问将引发异常。</p><pre><code>@Secured(&quot;ROLE_VIEWER&quot;)public String getUsername() {    SecurityContext securityContext = SecurityContextHolder.getContext();    return securityContext.getAuthentication().getName();}@Secured({ &quot;ROLE_DBA&quot;, &quot;ROLE_ADMIN&quot; })public String getUsername2() {    //...}</code></pre><p>@Secured(“ROLE_VIEWER”) 表示只有拥有ROLE_VIEWER角色的用户，才能够访问getUsername()方法。</p><p>@Secured({ “ROLE_DBA”, “ROLE_ADMIN” }) 表示用户拥有”ROLE_DBA”, “ROLE_ADMIN” 两个角色中的任意一个角色，均可访问 getUsername2 方法。</p><p>还有一点就是@Secured,不支持Spring EL表达式</p><h3 id="prePostEnabled注解"><a href="#prePostEnabled注解" class="headerlink" title="prePostEnabled注解"></a>prePostEnabled注解</h3><p>这个开启后支持Spring EL表达式 算是蛮厉害的。如果没有访问方法的权限，会抛出AccessDeniedException。</p><p>主要注解</p><p>@PreAuthorize –适合进入方法之前验证授权</p><p>@PostAuthorize –检查授权方法之后才被执行并且可以影响执行方法的返回值</p><p>@PostFilter –在方法执行之后执行，而且这里可以调用方法的返回值，然后对返回值进行过滤或处理或修改并返回</p><p>@PreFilter –在方法执行之前执行，而且这里可以调用方法的参数，然后对参数值进行过滤或处理或修改</p><h3 id="PreAuthorize注解使用"><a href="#PreAuthorize注解使用" class="headerlink" title="PreAuthorize注解使用"></a>PreAuthorize注解使用</h3><pre><code>@PreAuthorize(&quot;hasRole(&#39;ROLE_VIEWER&#39;)&quot;)public String getUsernameInUpperCase() {    return getUsername().toUpperCase();}</code></pre><p>@PreAuthorize(“hasRole(‘ROLE_VIEWER’)”) 相当于@Secured(“ROLE_VIEWER”)。</p><p>同样的@Secured({“ROLE_VIEWER”,”ROLE_EDITOR”}) 也可以替换为：@PreAuthorize(“hasRole(‘ROLE_VIEWER’) or hasRole(‘ROLE_EDITOR’)”)。</p><p>在方法执行之前执行，这里可以调用方法的参数，也可以得到参数值，这里利用JAVA8的参数名反射特性，如果没有JAVA8，那么也可以利用Spring Secuirty的@P标注参数，或利用Spring Data的@Param标注参数</p><pre><code>//无java8@PreAuthorize(&quot;#userId == authentication.principal.userId or hasAuthority(‘ADMIN’)&quot;)void changePassword(@P(&quot;userId&quot;) long userId ){}//有java8@PreAuthorize(&quot;#userId == authentication.principal.userId or hasAuthority(‘ADMIN’)&quot;)void changePassword(long userId ){}</code></pre><p>这里表示在<code>changePassword</code>方法执行之前，判断方法参数userId的值是否等于principal中保存的当前用户的userId，或者当前用户是否具有ROLE_ADMIN权限，两种符合其一，就可以访问该 方法。</p><h3 id="PostAuthorize注解使用"><a href="#PostAuthorize注解使用" class="headerlink" title="@PostAuthorize注解使用"></a>@PostAuthorize注解使用</h3><p>在方法执行之后执行可,以获取到方法的返回值，并且可以根据该方法来决定最终的授权结果（是允许访问还是不允许访问):</p><pre><code>@PostAuthorize  (&quot;returnObject.username == authentication.principal.nickName&quot;)public CustomUser loadUserDetail(String username) {    return userRoleRepository.loadUserByUserName(username);}</code></pre><p>上述代码中，仅当<code>loadUserDetail</code>方法的返回值中的username与当前登录用户的username相同时才被允许访问</p><h3 id="PreFilter以及-PostFilter注解使用"><a href="#PreFilter以及-PostFilter注解使用" class="headerlink" title="@PreFilter以及@PostFilter注解使用"></a>@PreFilter以及@PostFilter注解使用</h3><p>Spring Security提供了一个<code>@PreFilter</code> 注解来对传入的参数进行过滤：</p><pre><code>@PreFilter(&quot;filterObject != authentication.principal.username&quot;)public String joinUsernames(List&lt;String&gt; usernames) {    return usernames.stream().collect(Collectors.joining(&quot;;&quot;));}</code></pre><p>当usernames中的子项与当前登录用户的用户名不同时，则保留；当usernames中的子项与当前登录用户的用户名相同时，则移除。比如当前使用用户的用户名为zhangsan，此时usernames的值为{“zhangsan”, “lisi”, “wangwu”}，则经@PreFilter过滤后，实际传入的usernames的值为{“lisi”, “wangwu”}</p><p>如果执行方法中包含有多个类型为Collection的参数，filterObject 就不太清楚是对哪个Collection参数进行过滤了。此时，便需要加入 filterTarget 属性来指定具体的参数名称：</p><pre><code>@PreFilter  (value = &quot;filterObject != authentication.principal.username&quot;,  filterTarget = &quot;usernames&quot;)public String joinUsernamesAndRoles(  List&lt;String&gt; usernames, List&lt;String&gt; roles) {    return usernames.stream().collect(Collectors.joining(&quot;;&quot;))       + &quot;:&quot; + roles.stream().collect(Collectors.joining(&quot;;&quot;));}</code></pre><p>同样的我们还可以使用@PostFilter注解来过返回的Collection进行过滤：</p><pre><code>@PostFilter(&quot;filterObject != authentication.principal.username&quot;)public List&lt;String&gt; getAllUsernamesExceptCurrent() {    return userRoleRepository.getAllUsernames();}</code></pre><p>此时 filterObject 代表返回值。如果按照上述代码则实现了：移除掉返回值中与当前登录用户的用户名相同的子项。</p><p>手动填充 SecurityContextHolder 示例：</p><pre><code>UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(&quot;test&quot;,&quot;test&quot;,list);    SecurityContextHolder.getContext().setAuthentication(token);</code></pre><p>对于使用 token 鉴权的系统，就可以验证token后手动填充SecurityContextHolder，填充时机只要在执行投票器之前即可，或者干脆可以在投票器中填充，然后在登出操作中清空SecurityContextHolder。</p><h1 id="Authority、Role的区别"><a href="#Authority、Role的区别" class="headerlink" title="Authority、Role的区别"></a>Authority、Role的区别</h1><p>可以看到，hasRole 的处理逻辑和 hasAuthority 似乎一模一样，不同的是，hasRole 这里会自动给传入的字符串加上 ROLE_ 前缀，所以在数据库中的权限字符串需要加上 ROLE_ 前缀。即数据库中存储的用户角色如果是 ROLE_admin，这里就是 admin。</p><p>在调用 hasAuthority 方法时，如果数据是从数据库中查询出来的，这里的权限和数据库中保存一致即可，可以不加 ROLE_ 前缀。即数据库中存储的用户角色如果是 admin，这里就是 admin</p><p>。</p><p>也就是说，使用 hasAuthority 更具有一致性，你不用考虑要不要加 ROLE_ 前缀，数据库什么样这里就是什么样！而 hasRole 则不同，代码里如果写的是 admin，框架会自动加上 ROLE_ 前缀，所以数据库就必须是 ROLE_admin。</p><p><img src="/springsecurity/image-20230323195413928.png" alt="image-20230323195413928"></p><p>使用方法</p><h1 id="Security-扩展"><a href="#Security-扩展" class="headerlink" title="Security 扩展"></a>Security 扩展</h1><p>Security 可扩展的有</p><ol><li><p>鉴权失败处理器</p></li><li><p>验证器</p></li><li><p>登录成功处理器</p></li><li><p>投票器</p></li><li><p>自定义token处理过滤器</p></li><li><p>登出成功处理器</p></li><li><p>登录失败处理器</p></li><li><p>自定义 UsernamePasswordAuthenticationFilter</p></li></ol><p>鉴权失败处理器</p><p>Security 鉴权失败默认跳转登录页面，我们可以实现 AccessDeniedHandler 接口，重写 handle() 方法来自定义处理逻辑；然后参考配置类说明将处理器加入到配置当中。</p><p>验证器</p><p>实现 AuthenticationProvider 接口来实现自己验证逻辑。需要注意的是在这个类里面就算你抛出异常，也不会中断验证流程，而是算你验证失败，我们由流程图知道，只要有一个验证器验证成功，就算验证成功，所以你需要留意这一点。</p><p>登录成功处理器</p><p>在 Security 中验证成功默认跳转到上一次请求页面或者路径为 “/“ 的页面，我们同样可以自定义：继承 SimpleUrlAuthenticationSuccessHandler 这个类或者实现 AuthenticationSuccessHandler 接口。我这里建议采用继承的方式,SimpleUrlAuthenticationSuccessHandler 是默认的处理器，采用继承可以契合里氏替换原则，提高代码的复用性和避免不必要的错误。</p><p>投票器</p><p>投票器可继承 WebExpressionVoter 或者实现 AccessDecisionVoter接口；WebExpressionVoter 是 Security 默认的投票器；我这里同样建议采用继承的方式；添加到配置的方式参考 上文；</p><p>注意：投票器 vote 方法返回一个int值；-1代表反对，0代表弃权，1代表赞成；投票管理器收集投票结果，如果最终结果大于等于0则放行该请求。</p><p>自定义token处理过滤器</p><p>自定义 token 处理器继承自 OncePerRequestFilter 或者 GenericFilterBean 或者 Filter 都可以，在这个处理器里面需要完成的逻辑是：获取请求里的 token，验证 token 是否合法然后填充 SecurityContextHolder ，虽然说过滤器只要添加在投票器之前就可以，但我这里还是建议添加在 http.addFilterAfter(new MyFittler(), LogoutFilter.class);</p><p>登出成功处理器</p><p>实现LogoutSuccessHandler接口，添加到配置的方式参考上文。</p><p>登录失败处理器</p><p>登录失败默认跳转到登录页，我们同样可以自定义。继承 SimpleUrlAuthenticationFailureHandler 或者实现 AuthenticationFailureHandler，建议采用继承。</p><p>自定义UsernamePasswordAuthenticationFilter</p><p>我们自定义UsernamePasswordAuthenticationFilter可以极大提高我们 Security的灵活性（比如添加验证验证码是否正确的功能）。</p><p>我们直接继承 UsernamePasswordAuthenticationFilter ，然后在配置类中初始化这个过滤器，给这个过滤器添加登录失败处理器，登录成功处理器，登录管理器，登录请求 url 。</p><p>这里配置略微复杂，贴一下代码清单</p><p>初始化过滤器：</p><pre><code>MyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){        MyUsernamePasswordAuthenticationFilter myUsernamePasswordAuthenticationFilter = new MyUsernamePasswordAuthenticationFilter(redisService);        myUsernamePasswordAuthenticationFilter.setAuthenticationFailureHandler(new MyUrlAuthenticationFailureHandler());        myUsernamePasswordAuthenticationFilter.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler());        myUsernamePasswordAuthenticationFilter.setFilterProcessesUrl(&quot;/sign_in&quot;);        myUsernamePasswordAuthenticationFilter.setAuthenticationManager(getAuthenticationManager());        return myUsernamePasswordAuthenticationFilter;    }</code></pre><p>添加到配置：</p><pre><code>http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</code></pre><p>总结<br>对于 Security 的扩展配置关键在于 configure(HttpSecurityhttp) 方法；扩展认证方式可以自定义 authenticationManager 并加入自己验证器，在验证器中抛出异常不会终止验证流程；扩展鉴权方式可以自定义 accessDecisionManager 然后添加自己的投票器并绑定到对应的 url（url 匹配方式为 ant）上，投票器 vote(Authenticationauthentication,FilterInvocationfi,Collection<configattribute>attributes) 方法返回值为三种：-1 0 1，分别表示反对弃权赞成。</configattribute></p><p>对于 token 认证的校验方式，可以暴露一个获取的接口，或者重写 UsernamePasswordAuthenticationFilter 过滤器和扩展登录成功处理器来获取 token，然后在 LogoutFilter 之后添加一个自定义过滤器，用于校验和填充 SecurityContextHolder。</p><p>另外，Security 的处理器大部分都是重定向的，我们的项目如果是前后端分离的话，我们希望无论什么情况都返回 json ,那么就需要重写各个处理器了。</p>]]></content>
      
      
      <categories>
          
          <category> Auth </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecuritt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT</title>
      <link href="/jwt.html"/>
      <url>/jwt.html</url>
      
        <content type="html"><![CDATA[<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><h2 id="JWT介绍"><a href="#JWT介绍" class="headerlink" title="JWT介绍"></a>JWT介绍</h2><p>JWT(json web token)是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。<br> JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用户登录。在传统的用户登录认证中，因为http是无状态的，所以都是采用session方式。用户登录成功，服务端会保存一个session，服务端会返回给客户端一个sessionId，客户端会把sessionId保存在cookie中，每次请求都会携带这个sessionId。</p><p> cookie+session这种模式通常是保存在内存中，而且服务从单服务到多服务会面临的session共享问题。虽然目前存在使用Redis进行Session共享的机制，但是随着用户量和访问量的增加，Redis中保存的数据会越来越多，开销就会越来越大，多服务间的耦合性也会越来越大，Redis中的数据也很难进行管理，例如当Redis集群服务器出现Down机的情况下，整个业务系统随之将变为不可用的状态。而JWT不是这样的，只需要服务端生成token，客户端保存这个token，每次请求携带这个token，服务端认证解析就可。</p><h2 id="JWT的结构"><a href="#JWT的结构" class="headerlink" title="JWT的结构"></a>JWT的结构</h2><p><img src="/jwt/image-20230322191935818.png" alt="image-20230322191935818"></p><p> 第一部分称它为头部（header),第二部分称其为载荷（payload)，第三部分是签证（signature)</p><ul><li><strong>header</strong> jwt的头部承载两部分信息： 1.声明类型，这里是jwt 2.声明加密的算法 通常直接使用 HMAC SHA256</li></ul><p>完整的头部就像下面这样的JSON：</p><pre><code>{ &quot;typ&quot;: &quot;JWT&quot;,&quot;alg&quot;: &quot;HS256&quot;}</code></pre><p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分：</p><pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code></pre><ul><li><strong>playload</strong> 载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分：标准中注册的声明、公共的声明、私有的声明。</li></ul><ol><li>标准中注册的声明 (建议但不强制使用) ： iss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的. iat: jwt的签发时间 jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li><li>公共的声明 ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。</li><li>私有的声明 ： 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。 </li><li>此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。</li></ol><p>定义一个payload：</p><pre><code>{ &quot;uid&quot;:&quot;e12a34b56c78d9e0f&quot;,&quot;name&quot;:&quot;ramostear&quot;,&quot;role&quot;:&quot;admin&quot;}</code></pre><p>然后将其进行base64加密，得到Jwt的第二部分：</p><pre><code>eyJvcmciOiLku4rml6XlpLTmnaEiLCJuYW1lIjoiRnJlZeeggeWGnCIsImV4cCI6MTUxNDM1NjEwMywiaWF0IjoxNTE0MzU2MDQzLCJhZ2UiOiIyOCJ9</code></pre><ul><li><p><strong>signature</strong> jwt的第三部分是一个签证信息，这个签证信息由三部分组成：header (base64后的)、 payload (base64后的)、secret。</p><p>此部分用于防止jwt内容被篡改。这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明签名算法进行签名。然后就构成了jwt的第三部分：</p></li></ul><pre><code>49UF72vSkj-sA4aHHiYN5eoZ9Nb4w5Vb45PsLF7x_NY</code></pre><pre><code>  HMACSHA256(    base64UrlEncode(header) + &quot;.&quot; +    base64UrlEncode(payload),    secret)</code></pre><p>base64UrlEncode(header)：jwt令牌的第一部分。</p><p>base64UrlEncode(payload)：jwt令牌的第二部分。</p><p>secret：签名所使用的密钥。</p><h2 id="为什么JWT可以防止篡改？"><a href="#为什么JWT可以防止篡改？" class="headerlink" title="为什么JWT可以防止篡改？"></a>为什么JWT可以防止篡改？</h2><p>第三部分使用签名算法对第一部分和第二部分的内容进行签名，常用的签名算法是 HS256，常见的还有md5,sha 等，签名算法需要使用密钥进行签名，密钥不对外公开，并且签名是不可逆的，如果第三方更改了内容那么服务器验证签名就会失败，要想保证验证签名正确必须保证内容、密钥与签名前一致。</p><p><img src="/jwt/image-20230322194425426.png" alt="image-20230322194425426"></p><p>从上图可以看出认证服务和资源服务使用相同的密钥，这叫对称加密，对称加密效率高，如果一旦密钥泄露可以伪造jwt令牌。</p><p>JWT还可以使用非对称加密，认证服务自己保留私钥，将公钥下发给受信任的客户端、资源服务，公钥和私钥是配对的，成对的公钥和私钥才可以正常加密和解密，非对称加密效率低但相比对称加密非对称加密更安全一些。</p><h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><p>首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。<br>后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT（Token）。形成的JWT就是一个形同lll.zzz.xxx的字符串。<br>后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。<br>前端在每次请求时将JWT放入HTTP Header中的Authorization位。（解决XSS和XSRF问题）<br>后端检查是否存在，如存在验证JWT的有效性。例如：检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。<br>验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果</p><p>JWT解决了什么问题</p><p>用户认证通过后会得到一个JWT令牌，JWT令牌中已经包括了用户相关的信息，客户端只需要携带JWT访问资源服务，资源服务根据事先约定的算法自行完成令牌校验，无需每次都请求认证服务完成授权。</p><h2 id="使用jwt"><a href="#使用jwt" class="headerlink" title="使用jwt"></a>使用jwt</h2><p>1,导入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.auth0&lt;/groupId&gt;     &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;     &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt;</code></pre><p>2，生成Token</p><pre><code>Calendar instance = Calendar.getInstance();      instance.add(Calendar.SECOND,90); //设置过期时间      //生成令牌      String token = JWT.create()              .withClaim(&quot;username&quot;, &quot;张三&quot;)//设置自定义用户名              .withClaim(&quot;userid&quot;, 1)//设置自定义id              .withExpiresAt(instance.getTime())//设置过期时间              .sign(Algorithm.HMAC256(&quot;token!Q2W#E$RW&quot;));//设置签名 保密 复杂</code></pre><p>3.根据令牌解析数据</p><pre><code> //创建验证对象       JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(&quot;token!Q2W#E$RW&quot;)).build();       DecodedJWT decodedJWT = jwtVerifier.verify(&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2MDQ4ODU1NzAsInVzZXJJZCI6MSwidXNlcm5hbWUiOiLlvKDkuIkifQ.s4YAv6EWqZQA4eO2uTwJkAoR45AZUOGMDskjvzoaW-s&quot;);       System.out.println(&quot;用户名：&quot;+decodedJWT.getClaim(&quot;username&quot;).asString());</code></pre>]]></content>
      
      
      <categories>
          
          <category> Auth </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oauth</title>
      <link href="/oauth.html"/>
      <url>/oauth.html</url>
      
        <content type="html"><![CDATA[<h1 id="Oauth"><a href="#Oauth" class="headerlink" title="Oauth"></a>Oauth</h1><h2 id="什么是OAuth"><a href="#什么是OAuth" class="headerlink" title="什么是OAuth?"></a>什么是OAuth?</h2><p>一个验证授权(Authorization)的开放标准，所有人都有基于这个标准实现自己的OAuth。</p><p>更具体来说，OAuth是一个标准，app可以用来实现<code>secure delegated access</code>. OAuth基于HTTPS，以及APIs，Service应用使用<code>access token</code>来进行身份验证。</p><p>OAuth主要有OAuth 1.0a和OAuth 2.0两个版本，并且二者完全不同，且不兼容。OAuth2.0 是目前广泛使用的版本，</p><p><strong>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</strong></p><h2 id="令牌与密码"><a href="#令牌与密码" class="headerlink" title="令牌与密码"></a>令牌与密码</h2><p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p><p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p><p>（2）令牌可以被数据所有者撤销，会立即失效。</p><p>（3）令牌有权限范围（scope），对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p><p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。</p><p>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以<strong>令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。</strong> 这也是为什么令牌的有效期，一般都设置得很短的原因。</p><h2 id="OAuth四种获取令牌的模式"><a href="#OAuth四种获取令牌的模式" class="headerlink" title="OAuth四种获取令牌的模式"></a>OAuth四种获取令牌的模式</h2><p>不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p><ul><li>授权码（authorization-code）</li><li>隐藏式（implicit）</li><li>密码式（password）：</li><li>客户端凭证（client credentials</li></ul><h3 id="授权码"><a href="#授权码" class="headerlink" title="授权码"></a>授权码</h3><p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</strong></p><p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p><p><img src="/oauth/1571688-20190506180810029-1179611880.png" alt="img"></p><p>简单的流程</p><p>第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。</p><pre><code>https://b.com/oauth/authorize?  response_type=code&amp;  client_id=CLIENT_ID&amp;  redirect_uri=CALLBACK_URL&amp;  scope=read</code></pre><p>上面 URL 中，<code>response_type</code>参数表示要求返回授权码（<code>code</code>），<code>client_id</code>参数让 B 知道是谁在请求，<code>redirect_uri</code>参数是 B 接受或拒绝请求后的跳转网址，<code>scope</code>参数表示要求的授权范围（这里是只读）。</p><p><img src="/oauth/image-20230322002441924.png" alt="image-20230322002441924"></p><p>第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码，就像下面这样。</p><pre><code>https://a.com/callback?code=AUTHORIZATION_CODE</code></pre><p>上面 URL 中，<code>code</code>参数就是授权码。</p><p><img src="/oauth/image-20230322002815995.png" alt="image-20230322002815995"></p><p>第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌.</p><pre><code>https://b.com/oauth/token? client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; grant_type=authorization_code&amp; code=AUTHORIZATION_CODE&amp; redirect_uri=CALLBACK_URL</code></pre><p>上面 URL 中，<code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，<code>redirect_uri</code>参数是令牌颁发后的回调网址。</p><p><img src="/oauth/image-20230322003624932.png" alt="image-20230322003624932"></p><p>第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据。</p><pre><code>{      &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,  &quot;token_type&quot;:&quot;bearer&quot;,  &quot;expires_in&quot;:2592000,  &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,  &quot;scope&quot;:&quot;read&quot;,  &quot;uid&quot;:100101,  &quot;info&quot;:{...}}</code></pre><p>上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。</p><p><img src="/oauth/image-20230322003851943.png" alt="image-20230322003851943"></p><h3 id="隐藏式"><a href="#隐藏式" class="headerlink" title="隐藏式"></a>隐藏式</h3><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</p><p>第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。</p><pre class="line-numbers language-javascript"><code class="language-javascript">https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>b<span class="token punctuation">.</span>com<span class="token operator">/</span>oauth<span class="token operator">/</span>authorize<span class="token operator">?</span>  response_type<span class="token operator">=</span>token<span class="token operator">&amp;</span>  client_id<span class="token operator">=</span>CLIENT_ID<span class="token operator">&amp;</span>  redirect_uri<span class="token operator">=</span>CALLBACK_URL<span class="token operator">&amp;</span>  scope<span class="token operator">=</span>read<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> URL 中，<code>response_type</code>参数为<code>token</code>，表示要求直接返回令牌。</p><p>第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回<code>redirect_uri</code>参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</p><p><img src="/oauth/image-20230322173835499.png" alt="image-20230322173835499"></p><h3 id="密码式"><a href="#密码式" class="headerlink" title="密码式"></a>密码式</h3><p><strong>允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</strong></p><p>第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。</p><pre class="line-numbers language-javascript"><code class="language-javascript">https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>oauth<span class="token punctuation">.</span>b<span class="token punctuation">.</span>com<span class="token operator">/</span>token<span class="token operator">?</span>  grant_type<span class="token operator">=</span>password<span class="token operator">&amp;</span>  username<span class="token operator">=</span>USERNAME<span class="token operator">&amp;</span>  password<span class="token operator">=</span>PASSWORD<span class="token operator">&amp;</span>  client_id<span class="token operator">=</span>CLIENT_ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面 URL 中，<code>grant_type</code>参数是授权方式，这里的<code>password</code>表示”密码式”，<code>username</code>和<code>password</code>是 B 的用户名和密码。</p><p>第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</p><p>这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用</p><h3 id="凭证式"><a href="#凭证式" class="headerlink" title="凭证式"></a>凭证式</h3><p><strong>最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。</strong></p><p>第一步，A 应用在命令行向 B 发出请求。‘</p><pre><code>https://oauth.b.com/token?  grant_type=client_credentials&amp;  client_id=CLIENT_ID&amp;  client_secret=CLIENT_SECRET</code></pre><p>上面 URL 中，<code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式，<code>client_id</code>和<code>client_secret</code>用来让 B 确认 A 的身份。</p><p>第二步，B 网站验证通过以后，直接返回令牌。</p><p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p><h2 id="令牌的使用"><a href="#令牌的使用" class="headerlink" title="令牌的使用"></a>令牌的使用</h2><p>A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。</p><p>此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个<code>Authorization</code>字段，令牌就放在这个字段里面。</p><pre class="line-numbers language-bash"><code class="language-bash">curl -H <span class="token string">"Authorization: Bearer ACCESS_TOKEN"</span> \<span class="token string">"https://api.b.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h2><p>令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。</p><p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p><pre class="line-numbers language-javascript"><code class="language-javascript">https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>b<span class="token punctuation">.</span>com<span class="token operator">/</span>oauth<span class="token operator">/</span>token<span class="token operator">?</span>  grant_type<span class="token operator">=</span>refresh_token<span class="token operator">&amp;</span>  client_id<span class="token operator">=</span>CLIENT_ID<span class="token operator">&amp;</span>  client_secret<span class="token operator">=</span>CLIENT_SECRET<span class="token operator">&amp;</span>  refresh_token<span class="token operator">=</span>REFRESH_TOKEN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面 URL 中，<code>grant_type</code>参数为<code>refresh_token</code>表示要求更新令牌，<code>client_id</code>参数和<code>client_secret</code>参数用于确认身份，<code>refresh_token</code>参数就是用于更新令牌的令牌。</p><p>B 网站验证通过以后，就会颁发新的令牌。</p>]]></content>
      
      
      <categories>
          
          <category> Auth </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oauth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Controller实现Feign 简化代码</title>
      <link href="/feign-simplification.html"/>
      <url>/feign-simplification.html</url>
      
        <content type="html"><![CDATA[<h1 id="Feign简化-feign的接口抽取成公共的api"><a href="#Feign简化-feign的接口抽取成公共的api" class="headerlink" title="Feign简化  feign的接口抽取成公共的api"></a>Feign简化  feign的接口抽取成公共的api</h1><p>加@EnableFeignClients注解</p><p><img src="/feign-simplification/image-20230320211401433.png" alt="image-20230320211401433"></p><p><img src="/feign-simplification/image-20230320210509772.png" alt="image-20230320210509772"></p><p>先抽取出Feign</p><p>用Controller实现Feign类</p><p><img src="/feign-simplification/image-20230320210604423.png" alt="image-20230320210604423"></p><p>简单例子</p><p>项目结构与说明：<br>feign-provider-api（公用接口依赖模块）</p><p>feign-provider-service（feign-provider-api的接口实现模块）</p><p>feign-consumer-service（引用feign-provider-api依赖调用Feign）</p><p>Feign服务提供者</p><p>在feign-provider-api创建feign接口</p><pre><code>@FeignClient(name = &quot;feign-provider-service&quot;)public interface DemoFeign {    @RequestMapping(&quot;demo&quot;)    String demo();}</code></pre><p>在feign-provider-service创建Controller实现DemoFeign接口:</p><pre><code>@RestControllerpublic class DemoFeignController implements DemoFeign {    @Override    public String demo() {        return &quot;this demo feign.&quot;;    }}</code></pre><p>Feign服务消费者：</p><p>在feign-consumer-service单元测试引入feign-provider-api依赖直接调用DemoFeign接口:</p><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class FeignTest {    @Autowired    private DemoFeign demoFeign;    @Test    public void demo(){        System.out.println(demoFeign.demo());    }}</code></pre><p>启动报bean重复创建的错在配置文件加上</p><pre><code>spring.main.allow-bean-definition-overriding: true</code></pre><h1 id="通常的Feign调用"><a href="#通常的Feign调用" class="headerlink" title="通常的Feign调用"></a>通常的Feign调用</h1><p>引入依赖</p><p><img src="/feign-simplification/image-20230320212216979.png" alt="image-20230320212216979"></p><p>要在gulimall-member模块调用gulimall-coupon模块中的coupon/coupon/member/list接口</p><p><img src="/feign-simplification/image-20230320212241761.png" alt="image-20230320212241761"></p><p>在gulimall-member的启动类上加注解@EnableDiscoveryClient，告诉member是一个远程调用客户端</p><p><img src="/feign-simplification/image-20230320212301480.png" alt="image-20230320212301480"></p><p>将要调用的接口新建一个interface文件，在interface中写入要调用远程接口的函数体即可</p><p><img src="/feign-simplification/image-20230320212327191.png" alt="image-20230320212327191"></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>community项目</title>
      <link href="/community.html"/>
      <url>/community.html</url>
      
        <content type="html"><![CDATA[<h1 id="community项目"><a href="#community项目" class="headerlink" title="community项目"></a>community项目</h1><h1 id="用到的框架"><a href="#用到的框架" class="headerlink" title="用到的框架"></a>用到的框架</h1><ul><li><p><strong>SpringBoot2.3.x</strong>  <strong>SpringMVC + Mybatis</strong></p></li><li><p><strong>Maven3.6.X + Git</strong></p></li><li><p><strong>MySQL</strong> + <strong>文件存储阿里云OSS</strong></p></li><li><p><strong>Thymleaf3.x</strong></p></li><li><p><strong>网页长图生成工具Wkhtmltopdf</strong> + <strong>验证码生成工具kaptcha</strong></p></li><li><p><strong>分布式缓存Redis</strong> + <strong>全文检索ElasticSearch</strong> + <strong>Kafka</strong> + <strong>本地缓存Caffeine</strong></p></li><li><p><strong>Spring Securtiy + Spring Actuator</strong></p></li></ul><h1 id="数据库结构"><a href="#数据库结构" class="headerlink" title="数据库结构"></a>数据库结构</h1><p><img src="/community/image-20230325145448109.png" alt="image-20230325145448109"></p><h1 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h1><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment" spellcheck="true">&lt;!-- lookup parent from repository --></span><span class="token comment" spellcheck="true">&lt;!--把依赖交版本控制交给springboot控制        --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.nowcoder.community<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>community<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>community<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>nowcoder community<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--    jdk版本--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--        AOP依赖--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-aop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--thymeleaf依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-thymeleaf<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--Web依赖嵌入了MVC和Servlet--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-devtools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--Mysql连接依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>8.0.16<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--Mybatis依赖        --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.spring.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--邮件依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-mail<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.1.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--开源工具包--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-lang3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--验证码的图片依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.github.penggle<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>kaptcha<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--fastjson依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2.58<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--redis依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--Kafka的依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--Elasticsearch依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-elasticsearch<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--Srpingsecurity的依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-security<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--thyemleaf对spring security的依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.thymeleaf.extras<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>thymeleaf-extras-springsecurity5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--SrpingQuartz定时任务的依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-quartz<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--七牛云的sdk--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.qiniu<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>qiniu-java-sdk<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>7.2.23<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--caffeine的依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.github.ben-manes.caffeine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>caffeine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--Spring boot监控功能的依赖--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="properties文件"><a href="#properties文件" class="headerlink" title="properties文件"></a>properties文件</h1><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># ServerProperties</span><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8080</span><span class="token attr-name">server.servlet.context-path</span><span class="token punctuation">=</span><span class="token attr-value">/community</span><span class="token comment" spellcheck="true"># ThymeleafProperties</span><span class="token attr-name">spring.thymeleaf.cache</span><span class="token punctuation">=</span><span class="token attr-value">false</span><span class="token comment" spellcheck="true"># DataSourceProperties</span><span class="token attr-name">spring.datasource.driver-class-name</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.cj.jdbc.Driver</span><span class="token attr-name">spring.datasource.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/community?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span><span class="token attr-name">spring.datasource.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">spring.datasource.password</span><span class="token punctuation">=</span><span class="token attr-value">1320159539</span><span class="token attr-name">spring.datasource.type</span><span class="token punctuation">=</span><span class="token attr-value">com.zaxxer.hikari.HikariDataSource</span><span class="token attr-name">spring.datasource.hikari.maximum-pool-size</span><span class="token punctuation">=</span><span class="token attr-value">15</span><span class="token attr-name">spring.datasource.hikari.minimum-idle</span><span class="token punctuation">=</span><span class="token attr-value">5</span><span class="token attr-name">spring.datasource.hikari.idle-timeout</span><span class="token punctuation">=</span><span class="token attr-value">30000</span><span class="token comment" spellcheck="true"># MybatisProperties</span><span class="token attr-name">mybatis.mapper-locations</span><span class="token punctuation">=</span><span class="token attr-value">classpath:mapper/*.xml</span><span class="token attr-name">mybatis.type-aliases-package</span><span class="token punctuation">=</span><span class="token attr-value">com.community.entity</span><span class="token attr-name">mybatis.configuration.useGeneratedKeys</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">mybatis.configuration.mapUnderscoreToCamelCase</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token comment" spellcheck="true"># logger</span><span class="token attr-name">logging.level.com.community</span><span class="token punctuation">=</span><span class="token attr-value">debug</span><span class="token comment" spellcheck="true">#logging.file=d:/work/data/nowcoder/community.log</span><span class="token comment" spellcheck="true">#MailProperties</span><span class="token attr-name">spring.mail.host</span><span class="token punctuation">=</span><span class="token attr-value">smtp.qq.com</span><span class="token attr-name">spring.mail.port</span><span class="token punctuation">=</span><span class="token attr-value">465</span><span class="token attr-name">spring.mail.username</span><span class="token punctuation">=</span><span class="token attr-name">spring.mail.password</span><span class="token punctuation">=</span><span class="token attr-value">fjrkkagtxlwjbaad</span><span class="token attr-name">spring.mail.protocol</span><span class="token punctuation">=</span><span class="token attr-value">smtps</span><span class="token attr-name">spring.mail.properties.mail.smtp.ssl.enable</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token comment" spellcheck="true">#community</span><span class="token attr-name">community.path.domain</span><span class="token punctuation">=</span><span class="token attr-value">http://localhost:8080</span><span class="token attr-name">community.path.upload</span><span class="token punctuation">=</span><span class="token attr-value">d:/work/data/upload</span><span class="token comment" spellcheck="true">#RedisProperties</span><span class="token attr-name">spring.redis.database</span><span class="token punctuation">=</span><span class="token attr-value">11</span><span class="token attr-name">spring.redis.host</span><span class="token punctuation">=</span><span class="token attr-value">localhost</span><span class="token attr-name">spring.redis.port</span><span class="token punctuation">=</span><span class="token attr-value">6379</span><span class="token comment" spellcheck="true">#KafkaProperties</span><span class="token attr-name">spring.kafka.bootstrap-servers</span><span class="token punctuation">=</span><span class="token attr-value">localhost:9092</span><span class="token attr-name">spring.kafka.consumer.group-id</span><span class="token punctuation">=</span><span class="token attr-value">community-consumer-group</span><span class="token attr-name">spring.kafka.consumer.enable-auto-commit</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.kafka.consumer.auto-commit-interval</span><span class="token punctuation">=</span><span class="token attr-value">3000</span><span class="token comment" spellcheck="true">#ElasticsearchProperties</span><span class="token attr-name">spring.data.elasticsearch.cluster-name</span><span class="token punctuation">=</span><span class="token attr-value">nowcoder</span><span class="token attr-name">spring.data.elasticsearch.cluster-nodes</span><span class="token punctuation">=</span><span class="token attr-value">127.0.0.1:9300</span><span class="token attr-name">spring.task.execution.pool.core-size</span><span class="token punctuation">=</span><span class="token attr-value">8</span><span class="token attr-name">spring.task.execution.pool.max-size</span><span class="token punctuation">=</span><span class="token attr-value">15</span><span class="token comment" spellcheck="true">#?????,?????</span><span class="token attr-name">spring.task.execution.pool.queue-capacity</span><span class="token punctuation">=</span><span class="token attr-value">100</span><span class="token comment" spellcheck="true">#TaskSchedulingProperties ??????</span><span class="token attr-name">spring.task.scheduling.pool.size</span><span class="token punctuation">=</span><span class="token attr-value">5</span><span class="token comment" spellcheck="true"># QuartzProperties</span><span class="token attr-name">spring.quartz.job-store-type</span><span class="token punctuation">=</span><span class="token attr-value">jdbc</span><span class="token attr-name">spring.quartz.scheduler-name</span><span class="token punctuation">=</span><span class="token attr-value">communityScheduler</span><span class="token attr-name">spring.quartz.properties.org.quartz.scheduler.instanceId</span><span class="token punctuation">=</span><span class="token attr-value">AUTO</span><span class="token attr-name">spring.quartz.properties.org.quartz.jobStore.class</span><span class="token punctuation">=</span><span class="token attr-value">org.quartz.impl.jdbcjobstore.JobStoreTX</span><span class="token attr-name">spring.quartz.properties.org.quartz.jobStore.driverDelegateClass</span><span class="token punctuation">=</span><span class="token attr-value">org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span><span class="token comment" spellcheck="true">#?????</span><span class="token attr-name">spring.quartz.properties.org.quartz.jobStore.isClustered</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token comment" spellcheck="true">#?????</span><span class="token attr-name">spring.quartz.properties.org.quartz.threadPool.class</span><span class="token punctuation">=</span><span class="token attr-value">org.quartz.simpl.SimpleThreadPool</span><span class="token comment" spellcheck="true">#?????</span><span class="token attr-name">spring.quartz.properties.org.quartz.threadPool.threadCount</span><span class="token punctuation">=</span><span class="token attr-value">5</span><span class="token comment" spellcheck="true">#wk</span><span class="token attr-name">wk.image.command</span><span class="token punctuation">=</span><span class="token attr-value">D:/wkhtmltopdf/bin/wkhtmltoimage.exe</span><span class="token attr-name">wk.image.storage</span><span class="token punctuation">=</span><span class="token attr-value">D:/wkhtmltopdfData/wk-images</span><span class="token comment" spellcheck="true">#qiniu</span><span class="token attr-name">qiniu.key.access</span><span class="token punctuation">=</span><span class="token attr-value">rFsKmICqgda3kB8gyg3oWI5G9Q8JdTfNR5BaSiNj</span><span class="token attr-name">qiniu.key.secret</span><span class="token punctuation">=</span><span class="token attr-value">vD1HUlx-g-ZvR9p9txZABkv4B-FqTNi7aMXZiJr6</span><span class="token attr-name">qiniu.bucket.header.name</span><span class="token punctuation">=</span><span class="token attr-value">commu-header</span><span class="token attr-name">qiniu.bucket.header.url</span><span class="token punctuation">=</span><span class="token attr-value">http://rmu3dns5e.bkt.clouddn.com</span><span class="token attr-name">qiniu.bucket.share.name</span><span class="token punctuation">=</span><span class="token attr-value">commu-share</span><span class="token attr-name">qiniu.bucket.share.url</span><span class="token punctuation">=</span><span class="token attr-value">http://rmu33f1tu.hd-bkt.clouddn.com</span><span class="token comment" spellcheck="true"># caffeine</span><span class="token attr-name">caffeine.posts.max-size</span><span class="token punctuation">=</span><span class="token attr-value">15</span><span class="token attr-name">caffeine.posts.expire-seconds</span><span class="token punctuation">=</span><span class="token attr-value">180</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="邮件发送功能"><a href="#邮件发送功能" class="headerlink" title="邮件发送功能"></a>邮件发送功能</h1><h2 id="开启SMTP服务"><a href="#开启SMTP服务" class="headerlink" title="开启SMTP服务"></a>开启SMTP服务</h2><p>发送者有限打开SMTP服务</p><p><img src="/community/image-20230325154512911.png" alt="image-20230325154512911"></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># spring 相关配置</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 发送者邮箱相关配置</span>  <span class="token key atrule">mail</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># SMTP服务器域名</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> Smtp.qq.com    <span class="token comment" spellcheck="true"># 编码集</span>    <span class="token key atrule">default-encoding</span><span class="token punctuation">:</span> UTF<span class="token punctuation">-</span><span class="token number">8</span>    <span class="token comment" spellcheck="true"># 邮箱用户名</span>    <span class="token key atrule">username</span><span class="token punctuation">:</span>     <span class="token comment" spellcheck="true"># 授权码(注意不是邮箱密码！)</span>    <span class="token key atrule">password</span><span class="token punctuation">:</span>     <span class="token comment" spellcheck="true"># 协议：smtps</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> smtps    <span class="token comment" spellcheck="true"># 详细配置</span>    <span class="token key atrule">properties</span><span class="token punctuation">:</span>      <span class="token key atrule">mail</span><span class="token punctuation">:</span>        <span class="token key atrule">smtp</span><span class="token punctuation">:</span>          <span class="token comment" spellcheck="true"># 设置是否需要认证,如果为true,那么用户名和密码就必须的,</span>          <span class="token comment" spellcheck="true"># 如果设置false,可以不设置用户名和密码</span>          <span class="token comment" spellcheck="true"># (前提要知道对接的平台是否支持无密码进行访问的)</span>          <span class="token key atrule">auth</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>          <span class="token comment" spellcheck="true"># STARTTLS[1]  是对纯文本通信协议的扩展。</span>          <span class="token comment" spellcheck="true"># 它提供一种方式将纯文本连接升级为加密连接（TLS或SSL）</span>          <span class="token comment" spellcheck="true"># 而不是另外使用一个端口作加密通信。</span>          <span class="token key atrule">starttls</span><span class="token punctuation">:</span>            <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MailClient（邮件发送工具类）"><a href="#MailClient（邮件发送工具类）" class="headerlink" title="MailClient（邮件发送工具类）"></a>MailClient（邮件发送工具类）</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MailClient</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger logger <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>MailClient<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> JavaMailSender mailSender<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.mail.username}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String from<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMail</span><span class="token punctuation">(</span>String to<span class="token punctuation">,</span> String subject<span class="token punctuation">,</span> String content<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            MimeMessage message <span class="token operator">=</span> mailSender<span class="token punctuation">.</span><span class="token function">createMimeMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            MimeMessageHelper helper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MimeMessageHelper</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>            helper<span class="token punctuation">.</span><span class="token function">setFrom</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//发送者</span>            helper<span class="token punctuation">.</span><span class="token function">setTo</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//接收者</span>            helper<span class="token punctuation">.</span><span class="token function">setSubject</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span><span class="token punctuation">;</span>            helper<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//邮件主题</span>            mailSender<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>helper<span class="token punctuation">.</span><span class="token function">getMimeMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//邮件内容，第二个参数true表示支持html格式</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MessagingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"发送邮件失败:"</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="注册功能"><a href="#注册功能" class="headerlink" title="注册功能"></a>注册功能</h1><h2 id="entity"><a href="#entity" class="headerlink" title="entity"></a>entity</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span> <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String username<span class="token punctuation">;</span>    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>    <span class="token keyword">private</span> String salt<span class="token punctuation">;</span>    <span class="token keyword">private</span> String email<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> type<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> status<span class="token punctuation">;</span>    <span class="token keyword">private</span> String activationCode<span class="token punctuation">;</span>    <span class="token keyword">private</span> String headerUrl<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date createTime<span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h2><pre><code>public class UserService implements CommunityConstant {//注册页面     @RequestMapping(path = &quot;/register&quot;, method = RequestMethod.GET)    public String getRegisterPage() {        return &quot;/site/register&quot;;    }//注册功能    @RequestMapping(path = &quot;/register&quot;, method = RequestMethod.POST)    public String register(Model model, User user) {//springboot不会校验前端传过来的参数。        Map&lt;String, Object&gt; map = userService.register(user);//从数据库查用户是否注册过        if (map == null || map.isEmpty()) {//没有            model.addAttribute(&quot;msg&quot;, &quot;注册成功,我们已经向您的邮箱发送了一封激活邮件,请尽快激活!&quot;);            model.addAttribute(&quot;target&quot;, &quot;/index&quot;);//传给Thymelaf的属性            return &quot;/site/operate-result&quot;;        } else {//有            model.addAttribute(&quot;usernameMsg&quot;, map.get(&quot;usernameMsg&quot;));            model.addAttribute(&quot;passwordMsg&quot;, map.get(&quot;passwordMsg&quot;));            model.addAttribute(&quot;emailMsg&quot;, map.get(&quot;emailMsg&quot;));            return &quot;/site/register&quot;;        }    }</code></pre><h2 id="Thymelaf文件注册发送文件完成转跳到的页面"><a href="#Thymelaf文件注册发送文件完成转跳到的页面" class="headerlink" title="Thymelaf文件注册发送文件完成转跳到的页面"></a>Thymelaf文件注册发送文件完成转跳到的页面</h2><p>/site/operate-result</p><pre class="line-numbers language-xml"><code class="language-xml">.......        <span class="token comment" spellcheck="true">&lt;!-- 内容 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container mt-5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jumbotron<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lead<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${msg}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>您的账号已经激活成功,可以正常使用了!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>my-4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>                        系统会在 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>seconds<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text-danger<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span> 秒后自动跳转,                        您也可以点此 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>target<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{${target}}<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text-primary<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>链接<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>, 手动跳转!                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>.......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Thymelaf文件已经注册过时候的页面</p><p>/site/register</p><pre class="line-numbers language-xml"><code class="language-xml">                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-group row<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-sm-2 col-form-label text-right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>邮箱:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-sm-10<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span>                                   <span class="token attr-name"><span class="token namespace">th:</span>class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>|form-control ${emailMsg!<span class="token punctuation">=</span>null?<span class="token punctuation">'</span>is-invalid<span class="token punctuation">'</span>:<span class="token punctuation">'</span><span class="token punctuation">'</span>}|<span class="token punctuation">"</span></span>                                   <span class="token attr-name"><span class="token namespace">th:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${user!<span class="token punctuation">=</span>null?user.email:<span class="token punctuation">'</span><span class="token punctuation">'</span>}<span class="token punctuation">"</span></span>                                   <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>请输入您的邮箱!<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>invalid-feedback<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${emailMsg}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                该邮箱已注册!                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h2><pre><code>    @Autowired    private UserMapper userMapper;    @Autowired    private MailClient mailClient;    @Autowired    private TemplateEngine templateEngine;    @Value(&quot;${community.path.domain}&quot;)    private String domain;    @Value(&quot;${server.servlet.context-path}&quot;)    private String contextPath;   public Map&lt;String, Object&gt; register(User user) {  .....        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        // 空值处理        if (user == null) {            throw new IllegalArgumentException(&quot;参数不能为空!&quot;);        }        if (StringUtils.isBlank(user.getUsername())) {            map.put(&quot;usernameMsg&quot;, &quot;账号不能为空!&quot;);            return map;        }        if (StringUtils.isBlank(user.getPassword())) {            map.put(&quot;passwordMsg&quot;, &quot;密码不能为空!&quot;);            return map;        }        if (StringUtils.isBlank(user.getEmail())) {            map.put(&quot;emailMsg&quot;, &quot;邮箱不能为空!&quot;);            return map;        }        // 验证账号        User u = userMapper.selectByName(user.getUsername());        if (u != null) {            map.put(&quot;usernameMsg&quot;, &quot;该账号已存在!&quot;);            return map;        }        // 验证邮箱        u = userMapper.selectByEmail(user.getEmail());        if (u != null) {            map.put(&quot;emailMsg&quot;, &quot;该邮箱已被注册!&quot;);            return map;        }   // 注册用户        user.setSalt(CommunityUtil.generateUUID().substring(0, 5));        user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt()));        user.setType(0);        user.setStatus(0);        user.setActivationCode(&quot;null&quot;);//验证码存到redis里面，懒得改表就在表里面存个null        String activationCode = CommunityUtil.generateUUID();        user.setHeaderUrl(String.format(&quot;http://images.nowcoder.com/head/%dt.png&quot;, new Random().nextInt(1000)));        user.setCreateTime(new Date());        redisTemplate.opsForValue().set(&quot;ActivationCode:&quot;+user.getEmail(),activationCode,60*10,TimeUnit.MINUTES);        // 激活邮件        Context context = new Context();        context.setVariable(&quot;email&quot;, user.getEmail());        // http://localhost:8080/community/activation/用户名id/激活码        String url = domain + contextPath + &quot;/activation/&quot; + user.getId() + &quot;/&quot; + user.getActivationCode();        context.setVariable(&quot;url&quot;, url);        String content = templateEngine.process(&quot;/mail/activation&quot;, context);//Thymleaf模板文件地址。        mailClient.sendMail(user.getEmail(), &quot;激活账号&quot;, content);        return map;    }    ....}</code></pre><h2 id="Thymelaf文件-发送给邮箱的文件"><a href="#Thymelaf文件-发送给邮箱的文件" class="headerlink" title="Thymelaf文件-发送给邮箱的文件"></a>Thymelaf文件-发送给邮箱的文件</h2><pre><code>&lt;!doctype html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;link rel=&quot;icon&quot; href=&quot;https://static.nowcoder.com/images/logo_87_87.png&quot;/&gt;    &lt;title&gt;牛客网-激活账号&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;p&gt;            &lt;b th:text=&quot;${email}&quot;&gt;xxx@xxx.com&lt;/b&gt;, 您好!        &lt;/p&gt;        &lt;p&gt;            您正在注册牛客网, 这是一封激活邮件, 请点击             &lt;a th:href=&quot;${url}&quot;&gt;此链接&lt;/a&gt;,            激活您的牛客账号!        &lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h2><pre><code>@Mapperpublic interface UserMapper {.....    User selectByName(String username);    User selectByEmail(String email);     int insertUser(User user);    .....}</code></pre><h2 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h2><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span><span class="token doctype">&lt;!DOCTYPE mapper        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.nowcoder.community.dao.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sql</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>insertFields<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        username, password, salt, email, type, status, activation_code, header_url, create_time    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sql</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sql</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectFields<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        id, username, password, salt, email, type, status, activation_code, header_url, create_time    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sql</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectByName<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectFields<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>        from user        where username = #{username}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectByEmail<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectFields<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>        from user        where email = #{email}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>insertUser<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span> <span class="token attr-name">keyProperty</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        insert into user (<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>insertFields<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>)        values(#{username}, #{password}, #{salt}, #{email}, #{type}, #{status}, #{activationCode}, #{headerUrl}, #{createTime})    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="激活功能"><a href="#激活功能" class="headerlink" title="激活功能"></a>激活功能</h1><h2 id="Controller层-1"><a href="#Controller层-1" class="headerlink" title="Controller层"></a>Controller层</h2><pre><code>   // http://localhost:8080/community/activation/101/code    @RequestMapping(path = &quot;/activation/{userId}/{code}&quot;, method = RequestMethod.GET)    public String activation(Model model, @PathVariable(&quot;userId&quot;) int userId, @PathVariable(&quot;code&quot;) String code) {        int result = userService.activation(userId, code);        if (result == ACTIVATION_SUCCESS) {            model.addAttribute(&quot;msg&quot;, &quot;激活成功,您的账号已经可以正常使用了!&quot;);            model.addAttribute(&quot;target&quot;, &quot;/login&quot;);        } else if (result == ACTIVATION_REPEAT) {            model.addAttribute(&quot;msg&quot;, &quot;无效操作,该账号已经激活过了!&quot;);            model.addAttribute(&quot;target&quot;, &quot;/index&quot;);        } else {            model.addAttribute(&quot;msg&quot;, &quot;激活失败,您提供的激活码不正确!&quot;);            model.addAttribute(&quot;target&quot;, &quot;/index&quot;);        }        return &quot;/site/operate-result&quot;;    }</code></pre><h2 id="Thymelaf文件激活的时候转跳的文件"><a href="#Thymelaf文件激活的时候转跳的文件" class="headerlink" title="Thymelaf文件激活的时候转跳的文件"></a>Thymelaf文件激活的时候转跳的文件</h2><pre class="line-numbers language-xml"><code class="language-xml">    ......    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container mt-5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jumbotron<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lead<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${msg}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>您的账号已经激活成功,可以正常使用了!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>my-4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>                        系统会在 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>seconds<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text-danger<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span> 秒后自动跳转,                        您也可以点此 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>target<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{${target}}<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text-primary<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>链接<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>, 手动跳转!                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Service层-1"><a href="#Service层-1" class="headerlink" title="Service层"></a>Service层</h2><pre><code>   public int activation(int userId, String code) {        User user = userMapper.selectById(userId);        if (user.getStatus() == 1) {            return ACTIVATION_REPEAT;        } else if (redisTemplate.opsForValue().get(&quot;ActivationCode&quot;+user.getEmail()).equals(code)) {            redisTemplate.delete(&quot;ActivationCode&quot;+user.getEmail());//如果成功就把redis里面的删除            userMapper.updateStatus(userId, 1);            clearCache(userId);//后面会把一些基本信息放到redis里面，如果这个激活成功了会删除redis里面的            return ACTIVATION_SUCCESS;        } else {            return ACTIVATION_FAILURE;        }    }      // 3.数据变更时清除缓存数据    private void clearCache(int userId) {        String redisKey = RedisKeyUtil.getUserKey(userId);        redisTemplate.delete(redisKey);    }</code></pre><h2 id="dao"><a href="#dao" class="headerlink" title="dao"></a>dao</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Mapper</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">int</span> <span class="token function">insertUser</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mapper</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?></span><span class="token doctype">&lt;!DOCTYPE mapper        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.nowcoder.community.dao.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>insert</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>insertUser<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>User<span class="token punctuation">"</span></span> <span class="token attr-name">keyProperty</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        insert into user (<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">refid</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>insertFields<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>)        values(#{username}, #{password}, #{salt}, #{email}, #{type}, #{status}, #{activationCode}, #{headerUrl}, #{createTime})    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>insert</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="登录验证码"><a href="#登录验证码" class="headerlink" title="登录验证码"></a>登录验证码</h1><h2 id="Controller层-（LoginController"><a href="#Controller层-（LoginController" class="headerlink" title="Controller层 （LoginController)"></a>Controller层 （LoginController)</h2><pre><code>   @Autowired    private Producer kaptchaProducer; @RequestMapping(path = &quot;/kaptcha&quot;, method = RequestMethod.GET)    public void getKaptcha(HttpServletResponse response/*, HttpSession session*/) {        // 生成验证码        String text = kaptchaProducer.createText();        BufferedImage image = kaptchaProducer.createImage(text);        // 将验证码存入session        // session.setAttribute(&quot;kaptcha&quot;, text);        // 验证码的归属        String kaptchaOwner = CommunityUtil.generateUUID();        Cookie cookie = new Cookie(&quot;kaptchaOwner&quot;, kaptchaOwner);        cookie.setMaxAge(60);        cookie.setPath(contextPath);        response.addCookie(cookie);        // 将验证码存入Redis        String redisKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);        redisTemplate.opsForValue().set(redisKey, text, 60, TimeUnit.SECONDS);        // 将突图片输出给浏览器        response.setContentType(&quot;image/png&quot;);        try {            OutputStream os = response.getOutputStream();            ImageIO.write(image, &quot;png&quot;, os);        } catch (IOException e) {            logger.error(&quot;响应验证码失败:&quot; + e.getMessage());        }    }</code></pre><h1 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h1><h2 id="Controller层-LoginController"><a href="#Controller层-LoginController" class="headerlink" title="Controller层(LoginController)"></a>Controller层(LoginController)</h2><pre><code>  @RequestMapping(path = &quot;/login&quot;, method = RequestMethod.POST)    public String login(String username, String password, String code, boolean rememberme,                        Model model, /*HttpSession session, */HttpServletResponse response,                        @CookieValue(&quot;kaptchaOwner&quot;) String kaptchaOwner) {        // 检查验证码        // String kaptcha = (String) session.getAttribute(&quot;kaptcha&quot;);        String kaptcha = null;        if (StringUtils.isNotBlank(kaptchaOwner)) {            String redisKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);            kaptcha = (String) redisTemplate.opsForValue().get(redisKey);        }        if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) {            model.addAttribute(&quot;codeMsg&quot;, &quot;验证码不正确!&quot;);            return &quot;/site/login&quot;;        }        // 检查账号,密码        int expiredSeconds = rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;        Map&lt;String, Object&gt; map = userService.login(username, password, expiredSeconds);        if (map.containsKey(&quot;ticket&quot;)) {            Cookie cookie = new Cookie(&quot;ticket&quot;, map.get(&quot;ticket&quot;).toString());            cookie.setPath(contextPath);            cookie.setMaxAge(expiredSeconds);            response.addCookie(cookie);            return &quot;redirect:/index&quot;;        } else {            model.addAttribute(&quot;usernameMsg&quot;, map.get(&quot;usernameMsg&quot;));            model.addAttribute(&quot;passwordMsg&quot;, map.get(&quot;passwordMsg&quot;));            return &quot;/site/login&quot;;        }    }</code></pre><h2 id="Thymelaf登录页面"><a href="#Thymelaf登录页面" class="headerlink" title="Thymelaf登录页面"></a>Thymelaf登录页面</h2><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container pl-5 pr-5 pt-3 pb-3 mt-3 mb-3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text-center text-info border-bottom pb-3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>登<span class="token entity" title="&nbsp;">&amp;nbsp;</span><span class="token entity" title="&nbsp;">&amp;nbsp;</span>录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mt-5<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{/login}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-group row<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-sm-2 col-form-label text-right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>账号:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-sm-10<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>|form-control ${usernameMsg!<span class="token punctuation">=</span>null?<span class="token punctuation">'</span>is-invalid<span class="token punctuation">'</span>:<span class="token punctuation">'</span><span class="token punctuation">'</span>}|<span class="token punctuation">"</span></span>                                   <span class="token attr-name"><span class="token namespace">th:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${param.username}<span class="token punctuation">"</span></span>                                   <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>请输入您的账号!<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>invalid-feedback<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${usernameMsg}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                该账号不存在!                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-group row mt-4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-sm-2 col-form-label text-right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>密码:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-sm-10<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>|form-control ${passwordMsg!<span class="token punctuation">=</span>null?<span class="token punctuation">'</span>is-invalid<span class="token punctuation">'</span>:<span class="token punctuation">'</span><span class="token punctuation">'</span>}|<span class="token punctuation">"</span></span>                                   <span class="token attr-name"><span class="token namespace">th:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${param.password}<span class="token punctuation">"</span></span>                                   <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>请输入您的密码!<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>invalid-feedback<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${passwordMsg}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                密码长度不能小于8位!                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-group row mt-4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>verifycode<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-sm-2 col-form-label text-right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>验证码:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-sm-6<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>|form-control ${codeMsg!<span class="token punctuation">=</span>null?<span class="token punctuation">'</span>is-invalid<span class="token punctuation">'</span>:<span class="token punctuation">'</span><span class="token punctuation">'</span>}|<span class="token punctuation">"</span></span>                                   <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>verifycode<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>code<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>请输入验证码!<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>invalid-feedback<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${codeMsg}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                                验证码不正确!                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-sm-4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name"><span class="token namespace">th:</span>src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{/kaptcha}<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>kaptcha<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">width</span><span class="token punctuation">:</span><span class="token number">100</span>px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span><span class="token number">40</span>px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mr-2<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>javascript:refresh_kaptcha();<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>font-size-12 align-bottom<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>刷新验证码<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-group row mt-4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-sm-2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-sm-10<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>remember-me<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rememberme<span class="token punctuation">"</span></span>                                   <span class="token attr-name"><span class="token namespace">th:</span>checked</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${param.rememberme}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-check-label<span class="token punctuation">"</span></span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>remember-me<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>记住我<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>forget.html<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text-danger float-right<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>忘记密码?<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-group row mt-4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-sm-2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>col-sm-10 text-center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn btn-info text-white form-control<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>立即登录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Service层（UserService"><a href="#Service层（UserService" class="headerlink" title="Service层（UserService)"></a>Service层（UserService)</h2><pre><code> public Map&lt;String, Object&gt; login(String username, String password, long expiredSeconds) {        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        // 空值处理        if (StringUtils.isBlank(username)) {            map.put(&quot;usernameMsg&quot;, &quot;账号不能为空!&quot;);            return map;        }        if (StringUtils.isBlank(password)) {            map.put(&quot;passwordMsg&quot;, &quot;密码不能为空!&quot;);            return map;        }        // 验证账号        User user = userMapper.selectByName(username);        if (user == null) {            map.put(&quot;usernameMsg&quot;, &quot;该账号不存在!&quot;);            return map;        }        // 验证状态        if (user.getStatus() == 0) {            map.put(&quot;usernameMsg&quot;, &quot;该账号未激活!&quot;);            return map;        }        // 验证密码        password = CommunityUtil.md5(password + user.getSalt());        if (!user.getPassword().equals(password)) {            map.put(&quot;passwordMsg&quot;, &quot;密码不正确!&quot;);            return map;        }        // 生成登录凭证        LoginTicket loginTicket = new LoginTicket();        loginTicket.setUserId(user.getId());        loginTicket.setTicket(CommunityUtil.generateUUID());        loginTicket.setStatus(0);        loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000));//        loginTicketMapper.insertLoginTicket(loginTicket);        //rediskey=&quot;ticket&quot;+logiTicket.getTicket的值的字符串，用作redis查询的凭证        String redisKey = RedisKeyUtil.getTicketKey(loginTicket.getTicket());        redisTemplate.opsForValue().set(redisKey, loginTicket);//在redis里面记录登录状态        map.put(&quot;ticket&quot;, loginTicket.getTicket());        return map;    }</code></pre><h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h2><pre><code>public class LoginTicket {private int id;    private int userId; 用户id    private String ticket; 用户凭证    private int status; 用户状态    private Date expired; 过期时间    }</code></pre><h2 id="dao-1"><a href="#dao-1" class="headerlink" title="dao"></a>dao</h2><pre><code>    User selectByName(String username);</code></pre><h2 id="mapper-1"><a href="#mapper-1" class="headerlink" title="mapper"></a>mapper</h2><pre><code>  &lt;select id=&quot;selectById&quot; resultType=&quot;User&quot;&gt;        select &lt;include refid=&quot;selectFields&quot;&gt;&lt;/include&gt;        from user        where id = #{id}    &lt;/select&gt;</code></pre><h1 id="登出功能"><a href="#登出功能" class="headerlink" title="登出功能"></a>登出功能</h1><p>Controller(LoginController)</p><pre><code>  @RequestMapping(path = &quot;/logout&quot;, method = RequestMethod.GET)    public String logout(@CookieValue(&quot;ticket&quot;) String ticket) {        userService.logout(ticket);        SecurityContextHolder.clearContext();        return &quot;redirect:/login&quot;;    }</code></pre><p>Service层（UserService)</p><pre><code>  public void logout(String ticket) {//        loginTicketMapper.updateStatus(ticket, 1);        String redisKey = RedisKeyUtil.getTicketKey(ticket);        LoginTicket loginTicket = (LoginTicket) redisTemplate.opsForValue().get(redisKey);        loginTicket.setStatus(1);        redisTemplate.opsForValue().set(redisKey, loginTicket);//把redis里面的登录状态修改为登出    }</code></pre><h1 id="使用SpringMVC获取登录的凭证"><a href="#使用SpringMVC获取登录的凭证" class="headerlink" title="使用SpringMVC获取登录的凭证"></a>使用SpringMVC获取登录的凭证</h1><h2 id="创建拦截器（LoginTicketInterceptor）"><a href="#创建拦截器（LoginTicketInterceptor）" class="headerlink" title="创建拦截器（LoginTicketInterceptor）"></a>创建拦截器（LoginTicketInterceptor）</h2><pre><code>@Componentpublic class LoginTicketInterceptor implements HandlerInterceptor {    @Autowired    private UserService userService;    @Autowired    private HostHolder hostHolder;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        // 从cookie中获取凭证        String ticket = CookieUtil.getValue(request, &quot;ticket&quot;);        if (ticket != null) {            // 查询凭证            LoginTicket loginTicket = userService.findLoginTicket(ticket);            // 检查凭证是否有效            if (loginTicket != null &amp;&amp; loginTicket.getStatus() == 0 &amp;&amp; loginTicket.getExpired().after(new Date())) {                // 根据凭证查询用户                User user = userService.findUserById(loginTicket.getUserId());                // 在本次请求中持有用户                hostHolder.setUser(user);                // 构建用户认证的结果,并存入SecurityContext,以便于Security进行授权.                //UsernamePasswordAuthenticationToken((主体)user,(配置)user.getPassword(), (权限)userService.getAuthorities(user.getId()));                Authentication authentication = new UsernamePasswordAuthenticationToken(                        user, user.getPassword(), userService.getAuthorities(user.getId()));                SecurityContextHolder.setContext(new SecurityContextImpl(authentication));            }        }        return true;    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {        User user = hostHolder.getUser();           //把用户信息放到视图里面        if (user != null &amp;&amp; modelAndView != null) {            modelAndView.addObject(&quot;loginUser&quot;, user);        }    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {        hostHolder.clear();//结束后清除        SecurityContextHolder.clearContext();    }}</code></pre><p>这里就没有用spring security的认证流程，在拦截的时候就把权限和用户信息放到spring security里面了</p><h2 id="Service类（UserService）"><a href="#Service类（UserService）" class="headerlink" title="Service类（UserService）"></a>Service类（UserService）</h2><pre><code>    //获取权限    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities(int userId) {        User user = this.findUserById(userId);        List&lt;GrantedAuthority&gt; list = new ArrayList&lt;&gt;();        list.add(new GrantedAuthority() {            @Override            public String getAuthority() {                switch (user.getType()) {                    case 1:                        return AUTHORITY_ADMIN;                    case 2:                        return AUTHORITY_MODERATOR;                    default:                        return AUTHORITY_USER;                }            }        });        return list;    }</code></pre><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="HostHolder"><a href="#HostHolder" class="headerlink" title="HostHolder"></a>HostHolder</h3><pre><code>/** * 持有用户信息,用于代替session对象. */@Componentpublic class HostHolder {    private ThreadLocal&lt;User&gt; users = new ThreadLocal&lt;&gt;();    public void setUser(User user) {        users.set(user);    }    public User getUser() {        return users.get();    }    public void clear() {        users.remove();    }}</code></pre><h2 id="注册到Mvc当中"><a href="#注册到Mvc当中" class="headerlink" title="注册到Mvc当中"></a>注册到Mvc当中</h2><pre><code>@Configurationpublic class WebMvcConfig implements WebMvcConfigurer {    @Autowired    private LoginTicketInterceptor loginTicketInterceptor;     @Override    public void addInterceptors(InterceptorRegistry registry) {        registry.addInterceptor(loginTicketInterceptor)                .excludePathPatterns(&quot;/**/*.css&quot;, &quot;/**/*.js&quot;, &quot;/**/*.png&quot;, &quot;/**/*.jpg&quot;, &quot;/**/*.jpeg&quot;);                }</code></pre><h1 id="接入spring-security做权限管理"><a href="#接入spring-security做权限管理" class="headerlink" title="接入spring security做权限管理"></a>接入spring security做权限管理</h1><pre><code>@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter implements CommunityConstant {    @Override    public void configure(WebSecurity web) throws Exception {        web.ignoring().antMatchers(&quot;/resources/**&quot;);    }    @Override    protected void configure(HttpSecurity http) throws Exception {        // 授权        http.authorizeRequests()                .antMatchers(                        &quot;/user/setting&quot;,                        &quot;/user/upload&quot;,                        &quot;/discuss/add&quot;,                        &quot;/comment/add/**&quot;,                        &quot;/letter/**&quot;,                        &quot;/notice/**&quot;,                        &quot;/like&quot;,                        &quot;/follow&quot;,                        &quot;/unfollow&quot;                )                .hasAnyAuthority(                        AUTHORITY_USER,                        AUTHORITY_ADMIN,                        AUTHORITY_MODERATOR                )                .antMatchers(                        &quot;/discuss/top&quot;,                        &quot;/discuss/wonderful&quot;                )                .hasAnyAuthority(                        AUTHORITY_MODERATOR                )                .antMatchers(                        &quot;/discuss/delete&quot;,                        &quot;/data/**&quot;,                        &quot;/actuator/**&quot;                )                .hasAnyAuthority(                        AUTHORITY_ADMIN                )                .anyRequest().permitAll()                .and().csrf().disable();        // 权限不够时的处理        http.exceptionHandling()                .authenticationEntryPoint(new AuthenticationEntryPoint() {                    // 没有登录                    @Override                    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException {                        String xRequestedWith = request.getHeader(&quot;x-requested-with&quot;);                        if (&quot;XMLHttpRequest&quot;.equals(xRequestedWith)) {                            response.setContentType(&quot;application/plain;charset=utf-8&quot;);                            PrintWriter writer = response.getWriter();                            writer.write(CommunityUtil.getJSONString(403, &quot;你还没有登录哦!&quot;));                        } else {                            response.sendRedirect(request.getContextPath() + &quot;/login&quot;);                        }                    }                })                .accessDeniedHandler(new AccessDeniedHandler() {                    // 权限不足                    @Override                    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException e) throws IOException, ServletException {                        String xRequestedWith = request.getHeader(&quot;x-requested-with&quot;);                        if (&quot;XMLHttpRequest&quot;.equals(xRequestedWith)) {                            response.setContentType(&quot;application/plain;charset=utf-8&quot;);                            PrintWriter writer = response.getWriter();                            writer.write(CommunityUtil.getJSONString(403, &quot;你没有访问此功能的权限!&quot;));                        } else {                            response.sendRedirect(request.getContextPath() + &quot;/denied&quot;);                        }                    }                });        // Security底层默认会拦截/logout请求,进行退出处理.        // 覆盖它默认的逻辑,才能执行我们自己的退出代码.        http.logout().logoutUrl(&quot;/securitylogout&quot;);    }}</code></pre><pre><code>new AuthenticationEntryPoint()</code></pre><p>它的作用是在用户未登录或者登录失效时，处理该请求并返回相应的响应信息，通常是跳转到登录页面或返回未授权的错误信息。该接口的实现类可以自定义，以适应不同的业务需求。在 Spring Security 中，当用户请求需要身份认证的资源时，如果用户未登录或者登录失效，就会触发 AuthenticationEntryPoint() 的实现类的处理逻辑。</p><pre><code>new AccessDeniedHandler()</code></pre><p>用于处理权限不足的情况。当用户尝试访问没有权限的资源时，AccessDeniedHandler 将会被调用以处理这种情况。它可以根据自己的逻辑返回一个自定义的错误页面或者其他的错误信息。一般情况下，我们会自定义一个 AccessDeniedHandler 来实现自己的业务逻辑，以便更好地处理权限不足的情况。</p><h1 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h1><h2 id="advice-ExceptionAdvice"><a href="#advice-ExceptionAdvice" class="headerlink" title="advice(ExceptionAdvice)"></a>advice(ExceptionAdvice)</h2><pre><code>@ControllerAdvice(annotations = Controller.class)public class ExceptionAdvice {    private static final Logger logger = LoggerFactory.getLogger(ExceptionAdvice.class);    @ExceptionHandler({Exception.class})    public void handleException(Exception e, HttpServletRequest request, HttpServletResponse response) throws IOException {        logger.error(&quot;服务器发生异常: &quot; + e.getMessage());        for (StackTraceElement element : e.getStackTrace()) {            logger.error(element.toString());        }        String xRequestedWith = request.getHeader(&quot;x-requested-with&quot;);        if (&quot;XMLHttpRequest&quot;.equals(xRequestedWith)) {            response.setContentType(&quot;application/plain;charset=utf-8&quot;);            PrintWriter writer = response.getWriter();            writer.write(CommunityUtil.getJSONString(1, &quot;服务器异常!&quot;));        } else {            response.sendRedirect(request.getContextPath() + &quot;/error&quot;);        }    }}</code></pre><pre><code>@ControllerAdvice</code></pre><ul><li>用于<em>修饰类</em>，表示该类是<strong>Controller</strong> 的全局适配类。</li><li>在此类中，可以对<strong>Controller</strong> 进行如下三种全局配置：<ul><li>异常处理方案</li><li>绑定数据方案</li><li>绑定参数方案</li></ul></li></ul><p><code>@ExceptionHandler</code>(例中使用这个注解修饰方法)</p><ul><li>用于<em>修饰方法</em>，该方法会在<strong>Controller</strong> 出现异常后被调用，用于<em>处理捕获到的异常</em>。</li></ul><pre><code>@ModelAttribute</code></pre><ul><li>用于<em>修饰方法</em>，该方法回在<strong>Controller</strong> 方法执行前被调用，用于<em>为*</em>Model** 对象绑定参数*。</li></ul><pre><code>@DataBinder</code></pre><ul><li>用于<em>修饰方法</em>，该方法回在<strong>Controller</strong> 方法执行前被调用，用于<em>绑定参数的转换器</em>。</li></ul><h1 id="敏感词过滤"><a href="#敏感词过滤" class="headerlink" title="敏感词过滤"></a>敏感词过滤</h1><p>使用前缀树的数据结构，来进行敏感词过滤：</p><ul><li>第一步：在resource 目录下新建 sensitive-words.txt 敏感词文本文件</li><li>第二步：新建一个敏感词过滤组件 <strong>SensitiveFilter</strong> 类</li></ul><pre><code>@Componentpublic class SensitiveFilter {    private static final Logger logger= LoggerFactory.getLogger(SensitiveFilter.class);    //替换符    private static final String REPLACEMENT=&quot;***&quot;;    //根节点    private TrieNode rootNode = new TrieNode();    @PostConstruct//初始化方法。服务启动的时候就被调用    public void  init(){        try(                InputStream is = this.getClass().getClassLoader().getResourceAsStream(&quot;sensitive-words.txt&quot;);                BufferedReader reader=new BufferedReader(new InputStreamReader(is) );        )        {            String keyword;            while ( ( keyword= reader.readLine() ) !=null){                //添加到前缀树                this.addKeyword(keyword);            }        } catch (IOException e) {           logger.error(&quot;加载敏感文件失败:&quot;+e.getMessage());        }    }    //将敏感词添加到前缀树中    private void addKeyword(String keyword){        TrieNode tempNode=rootNode;        for (int i = 0; i &lt; keyword.length(); i++) {            char c =keyword.charAt(i);           TrieNode subNode = tempNode.getSubNode(c);           if (subNode ==null) {               //初始化子节点               subNode  =  new TrieNode();               tempNode.addSubNode(c,subNode);           }           //指向子节点，进入下一轮循环            tempNode =subNode;           //设置结束表示            if (i==keyword.length()-1){                tempNode.setKeywrodEnd(true);            }        }    }    /**     * 过路敏感词     * @param text 带过滤的文本     * @return 过滤后的文本     */    //    public String filter(String text){        if (StringUtils.isBlank(text)){            return null;        }        //指针1开始指向树的根        TrieNode tempNode=rootNode;        //指针2开始指字符串的首位        int begin=0;        //指针3        int position =0;        //结果        StringBuilder sb =new StringBuilder();        while (position &lt;text.length()){            char c =text.charAt(position);            //跳过符号            if (isSymbol(c)){                //若指针1处于根节点,就将此符号好计入结果，让指针2向下走一步                if (tempNode ==rootNode){                    sb.append(c);                    begin++;                }                //无论符号在开头或中间，指针3都向下走一步                position++;                continue;            }            //检查下级节点            tempNode= tempNode.getSubNode(c);            if (tempNode==null){                //以begin开头的字符不是敏感词                sb.append(text.charAt(begin));              position =  ++begin;              //指针重写指向根节点                tempNode=rootNode;            }else if (tempNode.isKeywrodEnd()){                //发现敏感词，将begin-position字符串替换掉                sb.append(REPLACEMENT);                //进入下一个位置               begin = ++position;            }else {                //检查下一个字符                position++;            }        }        //将最后一批字符计入结果        sb.append(text.substring(begin));        return sb.toString();    }    //判断上是否为符号    private boolean  isSymbol(Character c){        //判断是不是合法字符abc之类的，特殊字符返回false        //0x2E80  到 0x9FFF是东亚文字范围 。在这范围之外是特殊文字。         return  !CharUtils.isAsciiAlphanumeric(c) &amp;&amp;(c&lt;0x2E80 ||c&gt;0x9FFF);    }    //前缀树    private class TrieNode{        //关键词结束的标识        private boolean isKeywrodEnd =false;        //子节点(key是下级字符，value是下级节点)        private Map&lt;Character,TrieNode&gt; subNodes=new HashMap&lt;&gt;();        public boolean isKeywrodEnd() {            return isKeywrodEnd;        }        public void setKeywrodEnd(boolean keywrodEnd) {            isKeywrodEnd = keywrodEnd;        }        //添加子节点        public void addSubNode(Character c,TrieNode node){            subNodes.put(c,node);        }        //获取子节点        public TrieNode  getSubNode(Character  c){            return subNodes.get(c);        }    }}</code></pre><h1 id="帖子发布与帖子评论"><a href="#帖子发布与帖子评论" class="headerlink" title="帖子发布与帖子评论"></a>帖子发布与帖子评论</h1><h2 id="帖子发布"><a href="#帖子发布" class="headerlink" title="帖子发布"></a>帖子发布</h2><p>帖子存入数据库 ，Kafka生产者创建帖子事件，消费者发布帖子到elastic search，并且更新redis点赞之类的数据写入rides，rides中点赞之类的数据没有写到数据库，可以选择RDB持久化或者AOF持久化。</p><h3 id="Controller层-DiscussPostController"><a href="#Controller层-DiscussPostController" class="headerlink" title="Controller层(DiscussPostController)"></a>Controller层(DiscussPostController)</h3><pre><code>@Controller@RequestMapping(&quot;/discuss&quot;)public class DiscussPostController implements CommunityConstant {         @Autowired        private HostHolder hostHolder;          @Autowired    private RedisTemplate redisTemplate;        @Autowired    private EventProducer eventProducer;     @Autowired    private DiscussPostService discussPostService;    @RequestMapping(path = &quot;/add&quot;, method = RequestMethod.POST)    @ResponseBody    public String addDiscussPost(String title, String content) {        User user = hostHolder.getUser();        if (user == null) {            return CommunityUtil.getJSONString(403, &quot;你还没有登录哦!&quot;);        }        DiscussPost post = new DiscussPost();        post.setUserId(user.getId());        post.setTitle(title);        post.setContent(content);        post.setCreateTime(new Date());        discussPostService.addDiscussPost(post);        // 触发发帖事件        Event event = new Event()                .setTopic(TOPIC_PUBLISH)                .setUserId(user.getId())                .setEntityType(ENTITY_TYPE_POST)                .setEntityId(post.getId());        eventProducer.fireEvent(event);        // 计算帖子分数        String redisKey = RedisKeyUtil.getPostScoreKey();        redisTemplate.opsForSet().add(redisKey, post.getId());        // 报错的情况,将来统一处理.        return CommunityUtil.getJSONString(0, &quot;发布成功!&quot;);    }}</code></pre><h4 id="HostHolder-代替session获取用户信息"><a href="#HostHolder-代替session获取用户信息" class="headerlink" title="HostHolder 代替session获取用户信息"></a>HostHolder 代替session获取用户信息</h4><pre><code>/** * 持有用户信息,用于代替session对象. */@Componentpublic class HostHolder {    private ThreadLocal&lt;User&gt; users = new ThreadLocal&lt;&gt;();    public void setUser(User user) {        users.set(user);    }    public User getUser() {        return users.get();    }    public void clear() {        users.remove();    }}</code></pre><h3 id="entity层-DiscussPost"><a href="#entity层-DiscussPost" class="headerlink" title="entity层(DiscussPost)"></a>entity层(DiscussPost)</h3><p>DiscussPost</p><pre><code>@Document(indexName = &quot;discusspost&quot;, type = &quot;_doc&quot;, shards = 6, replicas = 3)public class DiscussPost {    @Id    private int id;    @Field(type = FieldType.Integer)    private int userId;    // 互联网校招    @Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_smart&quot;)    private String title;    @Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;, searchAnalyzer = &quot;ik_smart&quot;)    private String content;    @Field(type = FieldType.Integer)    private int type;    @Field(type = FieldType.Integer)    private int status;    @Field(type = FieldType.Date)    private Date createTime;    @Field(type = FieldType.Integer)    private int commentCount;    @Field(type = FieldType.Double)    private double score;</code></pre><h3 id="Service层-DiscussPostService"><a href="#Service层-DiscussPostService" class="headerlink" title="Service层(DiscussPostService)"></a>Service层(DiscussPostService)</h3><pre><code>@Servicepublic class DiscussPostService { @Autowired    private DiscussPostMapper discussPostMapper;    public int addDiscussPost(DiscussPost post) {        if (post == null) {            throw new IllegalArgumentException(&quot;参数不能为空!&quot;);        }        // 转义HTML标记        post.setTitle(HtmlUtils.htmlEscape(post.getTitle()));        post.setContent(HtmlUtils.htmlEscape(post.getContent()));        // 过滤敏感词        post.setTitle(sensitiveFilter.filter(post.getTitle()));        post.setContent(sensitiveFilter.filter(post.getContent()));        return discussPostMapper.insertDiscussPost(post);    }}</code></pre><h3 id="DAO-DiscussPostMapper"><a href="#DAO-DiscussPostMapper" class="headerlink" title="DAO(DiscussPostMapper)"></a>DAO(DiscussPostMapper)</h3><pre><code>@Mapperpublic interface DiscussPostMapper{   int insertDiscussPost(DiscussPost discussPost);}</code></pre><h3 id="Mapper-discusspost-mapper-xml"><a href="#Mapper-discusspost-mapper-xml" class="headerlink" title="Mapper(discusspost-mapper.xml)"></a>Mapper(discusspost-mapper.xml)</h3><pre><code>  &lt;insert id=&quot;insertDiscussPost&quot; parameterType=&quot;DiscussPost&quot; keyProperty=&quot;id&quot;&gt;        insert into discuss_post(&lt;include refid=&quot;insertFields&quot;&gt;&lt;/include&gt;)        values(#{userId},#{title},#{content},#{type},#{status},#{createTime},#{commentCount},#{score})    &lt;/insert&gt;</code></pre><h3 id="Event触发事件"><a href="#Event触发事件" class="headerlink" title="Event触发事件"></a>Event触发事件</h3><h3 id="kafka生产者"><a href="#kafka生产者" class="headerlink" title="kafka生产者"></a>kafka生产者</h3><pre><code>@Componentpublic class EventProducer {    @Autowired    private KafkaTemplate kafkaTemplate;    // 处理事件    public void fireEvent(Event event) {        // 将事件发布到指定的主题        kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));    }}</code></pre><h3 id="kafka消费者"><a href="#kafka消费者" class="headerlink" title="kafka消费者"></a>kafka消费者</h3><pre><code>@Componentpublic class EventConsumer implements CommunityConstant {  @Autowired    private ElasticsearchService elasticsearchService;.....    // 消费发帖事件    @KafkaListener(topics = {TOPIC_PUBLISH})    public void handlePublishMessage(ConsumerRecord record) {        if (record == null || record.value() == null) {            logger.error(&quot;消息的内容为空!&quot;);            return;        }        Event event = JSONObject.parseObject(record.value().toString(), Event.class);        if (event == null) {            logger.error(&quot;消息格式错误!&quot;);            return;        }        DiscussPost post = discussPostService.findDiscussPostById(event.getEntityId());        elasticsearchService.saveDiscussPost(post);    }    .....    }</code></pre><h3 id="把帖子存入elastic-search"><a href="#把帖子存入elastic-search" class="headerlink" title="把帖子存入elastic search"></a>把帖子存入elastic search</h3><h4 id="接口（DiscussPostRepository）"><a href="#接口（DiscussPostRepository）" class="headerlink" title="接口（DiscussPostRepository）"></a>接口（DiscussPostRepository）</h4><pre><code>@Repositorypublic interface DiscussPostRepository extends ElasticsearchRepository&lt;DiscussPost, Integer&gt; {}</code></pre><pre><code>@Servicepublic class ElasticsearchService {    @Autowired    private DiscussPostRepository discussRepository;    @Autowired    private ElasticsearchTemplate elasticTemplate;    public void saveDiscussPost(DiscussPost post) {        discussRepository.save(post);    }    public void deleteDiscussPost(int id) {        discussRepository.deleteById(id);    }    public Page&lt;DiscussPost&gt; searchDiscussPost(String keyword, int current, int limit) {        SearchQuery searchQuery = new NativeSearchQueryBuilder()                .withQuery(QueryBuilders.multiMatchQuery(keyword, &quot;title&quot;, &quot;content&quot;))                .withSort(SortBuilders.fieldSort(&quot;type&quot;).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(&quot;score&quot;).order(SortOrder.DESC))                .withSort(SortBuilders.fieldSort(&quot;createTime&quot;).order(SortOrder.DESC))                .withPageable(PageRequest.of(current, limit))                .withHighlightFields(                        new HighlightBuilder.Field(&quot;title&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;),                        new HighlightBuilder.Field(&quot;content&quot;).preTags(&quot;&lt;em&gt;&quot;).postTags(&quot;&lt;/em&gt;&quot;)                ).build();        return elasticTemplate.queryForPage(searchQuery, DiscussPost.class, new SearchResultMapper() {            @Override            public &lt;T&gt; AggregatedPage&lt;T&gt; mapResults(SearchResponse response, Class&lt;T&gt; aClass, Pageable pageable) {                SearchHits hits = response.getHits();                if (hits.getTotalHits() &lt;= 0) {                    return null;                }                List&lt;DiscussPost&gt; list = new ArrayList&lt;&gt;();                for (SearchHit hit : hits) {                    DiscussPost post = new DiscussPost();                    String id = hit.getSourceAsMap().get(&quot;id&quot;).toString();                    post.setId(Integer.valueOf(id));                    String userId = hit.getSourceAsMap().get(&quot;userId&quot;).toString();                    post.setUserId(Integer.valueOf(userId));                    String title = hit.getSourceAsMap().get(&quot;title&quot;).toString();                    post.setTitle(title);                    String content = hit.getSourceAsMap().get(&quot;content&quot;).toString();                    post.setContent(content);                    String status = hit.getSourceAsMap().get(&quot;status&quot;).toString();                    post.setStatus(Integer.valueOf(status));                    String createTime = hit.getSourceAsMap().get(&quot;createTime&quot;).toString();                    post.setCreateTime(new Date(Long.valueOf(createTime)));                    String commentCount = hit.getSourceAsMap().get(&quot;commentCount&quot;).toString();                    post.setCommentCount(Integer.valueOf(commentCount));                    // 处理高亮显示的结果                    HighlightField titleField = hit.getHighlightFields().get(&quot;title&quot;);                    if (titleField != null) {                        post.setTitle(titleField.getFragments()[0].toString());                    }                    HighlightField contentField = hit.getHighlightFields().get(&quot;content&quot;);                    if (contentField != null) {                        post.setContent(contentField.getFragments()[0].toString());                    }                    list.add(post);                }                return new AggregatedPageImpl(list, pageable,                        hits.getTotalHits(), response.getAggregations(), response.getScrollId(), hits.getMaxScore());            }        });    }}</code></pre><h2 id="帖子详情"><a href="#帖子详情" class="headerlink" title="帖子详情"></a>帖子详情</h2><h3 id="Controller层-2"><a href="#Controller层-2" class="headerlink" title="Controller层"></a>Controller层</h3><p>就是靠帖子id查数据库的帖子，靠redis查点赞的</p><pre><code>@Controller@RequestMapping(&quot;/discuss&quot;)public class DiscussPostController implements CommunityConstant {    @RequestMapping(path = &quot;/detail/{discussPostId}&quot;, method = RequestMethod.GET)    public String getDiscussPost(@PathVariable(&quot;discussPostId&quot;) int discussPostId, Model model, Page page) {        // 帖子        DiscussPost post = discussPostService.findDiscussPostById(discussPostId);        model.addAttribute(&quot;post&quot;, post);        // 作者        User user = userService.findUserById(post.getUserId());        model.addAttribute(&quot;user&quot;, user);        // 点赞数量        long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, discussPostId);        model.addAttribute(&quot;likeCount&quot;, likeCount);        // 点赞状态        int likeStatus = hostHolder.getUser() == null ? 0 :                likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_POST, discussPostId);        model.addAttribute(&quot;likeStatus&quot;, likeStatus);        // 评论分页信息        page.setLimit(5);        page.setPath(&quot;/discuss/detail/&quot; + discussPostId);        page.setRows(post.getCommentCount());        // 评论: 给帖子的评论        // 回复: 给评论的评论        // 评论列表        List&lt;Comment&gt; commentList = commentService.findCommentsByEntity(                ENTITY_TYPE_POST, post.getId(), page.getOffset(), page.getLimit());        // 评论VO列表        List&lt;Map&lt;String, Object&gt;&gt; commentVoList = new ArrayList&lt;&gt;();        if (commentList != null) {            for (Comment comment : commentList) {                // 评论VO                Map&lt;String, Object&gt; commentVo = new HashMap&lt;&gt;();                // 评论                commentVo.put(&quot;comment&quot;, comment);                // 作者                commentVo.put(&quot;user&quot;, userService.findUserById(comment.getUserId()));                // 点赞数量                likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, comment.getId());                commentVo.put(&quot;likeCount&quot;, likeCount);                // 点赞状态                likeStatus = hostHolder.getUser() == null ? 0 :                        likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, comment.getId());                commentVo.put(&quot;likeStatus&quot;, likeStatus);                // 回复列表                List&lt;Comment&gt; replyList = commentService.findCommentsByEntity(                        ENTITY_TYPE_COMMENT, comment.getId(), 0, Integer.MAX_VALUE);                // 回复VO列表                List&lt;Map&lt;String, Object&gt;&gt; replyVoList = new ArrayList&lt;&gt;();                if (replyList != null) {                    for (Comment reply : replyList) {                        Map&lt;String, Object&gt; replyVo = new HashMap&lt;&gt;();                        // 回复                        replyVo.put(&quot;reply&quot;, reply);                        // 作者                        replyVo.put(&quot;user&quot;, userService.findUserById(reply.getUserId()));                        // 回复目标                        User target = reply.getTargetId() == 0 ? null : userService.findUserById(reply.getTargetId());                        replyVo.put(&quot;target&quot;, target);                        // 点赞数量                        likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_COMMENT, reply.getId());                        replyVo.put(&quot;likeCount&quot;, likeCount);                        // 点赞状态                        likeStatus = hostHolder.getUser() == null ? 0 :                                likeService.findEntityLikeStatus(hostHolder.getUser().getId(), ENTITY_TYPE_COMMENT, reply.getId());                        replyVo.put(&quot;likeStatus&quot;, likeStatus);                        replyVoList.add(replyVo);                    }                }                commentVo.put(&quot;replys&quot;, replyVoList);                // 回复数量                int replyCount = commentService.findCommentCount(ENTITY_TYPE_COMMENT, comment.getId());                commentVo.put(&quot;replyCount&quot;, replyCount);                commentVoList.add(commentVo);            }        }        model.addAttribute(&quot;comments&quot;, commentVoList);        return &quot;/site/discuss-detail&quot;;    }}</code></pre><h2 id="帖子评论"><a href="#帖子评论" class="headerlink" title="帖子评论"></a>帖子评论</h2><pre><code>@Controller@RequestMapping(&quot;/comment&quot;)public class CommentController implements CommunityConstant {    @Autowired    private CommentService commentService;    @Autowired    private HostHolder hostHolder;    @Autowired    private EventProducer eventProducer;    @Autowired    private DiscussPostService discussPostService;    @Autowired    private RedisTemplate redisTemplate;    @RequestMapping(path = &quot;/add/{discussPostId}&quot;, method = RequestMethod.POST)    public String addComment(@PathVariable(&quot;discussPostId&quot;) int discussPostId, Comment comment) {        comment.setUserId(hostHolder.getUser().getId());        comment.setStatus(0);        comment.setCreateTime(new Date());        commentService.addComment(comment);        // 触发评论事件        Event event = new Event()                .setTopic(TOPIC_COMMENT)                .setUserId(hostHolder.getUser().getId())                .setEntityType(comment.getEntityType())                .setEntityId(comment.getEntityId())                .setData(&quot;postId&quot;, discussPostId);        if (comment.getEntityType() == ENTITY_TYPE_POST) {            DiscussPost target = discussPostService.findDiscussPostById(comment.getEntityId());            event.setEntityUserId(target.getUserId());        } else if (comment.getEntityType() == ENTITY_TYPE_COMMENT) {            Comment target = commentService.findCommentById(comment.getEntityId());            event.setEntityUserId(target.getUserId());        }        eventProducer.fireEvent(event);        if (comment.getEntityType() == ENTITY_TYPE_POST) {            // 触发发帖事件            event = new Event()                    .setTopic(TOPIC_PUBLISH)                    .setUserId(comment.getUserId())                    .setEntityType(ENTITY_TYPE_POST)                    .setEntityId(discussPostId);            eventProducer.fireEvent(event);            // 计算帖子分数            String redisKey = RedisKeyUtil.getPostScoreKey();            redisTemplate.opsForSet().add(redisKey, discussPostId);        }        return &quot;redirect:/discuss/detail/&quot; + discussPostId;    }}</code></pre><p>消费者</p><p>调用消息接口的的service，写入数据库</p><pre><code>    @KafkaListener(topics = {TOPIC_COMMENT, TOPIC_LIKE, TOPIC_FOLLOW})    public void handleCommentMessage(ConsumerRecord record) {        if (record == null || record.value() == null) {            logger.error(&quot;消息的内容为空!&quot;);            return;        }        Event event = JSONObject.parseObject(record.value().toString(), Event.class);        if (event == null) {            logger.error(&quot;消息格式错误!&quot;);            return;        }        // 发送站内通知        Message message = new Message();        message.setFromId(SYSTEM_USER_ID);        message.setToId(event.getEntityUserId());        message.setConversationId(event.getTopic());        message.setCreateTime(new Date());        Map&lt;String, Object&gt; content = new HashMap&lt;&gt;();        content.put(&quot;userId&quot;, event.getUserId());        content.put(&quot;entityType&quot;, event.getEntityType());        content.put(&quot;entityId&quot;, event.getEntityId());        if (!event.getData().isEmpty()) {            for (Map.Entry&lt;String, Object&gt; entry : event.getData().entrySet()) {                content.put(entry.getKey(), entry.getValue());            }        }        message.setContent(JSONObject.toJSONString(content));        messageService.addMessage(message);    }</code></pre><p>实体类</p><p>就是谁对谁评论了</p><pre><code>   public class Comment {   private int id;    private int userId;    private int entityType;    private int entityId;    private int targetId;    private String content;    private int status;    private Date createTime;    public class Comment {</code></pre><h1 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h1><p>Controller层</p><p>靠帖子中的一个类型查询置顶。</p><pre><code>@Controllerpublic class HomeController implements CommunityConstant {    @Autowired    private DiscussPostService discussPostService;    @Autowired    private UserService userService;    @Autowired    private LikeService likeService;    @RequestMapping(path = &quot;/index&quot;, method = RequestMethod.GET)    public String getIndexPage(Model model, Page page,                               @RequestParam(name = &quot;orderMode&quot;, defaultValue = &quot;0&quot;) int orderMode) {        // 方法调用钱,SpringMVC会自动实例化Model和Page,并将Page注入Model.        // 所以,在thymeleaf中可以直接访问Page对象中的数据.        page.setRows(discussPostService.findDiscussPostRows(0));        page.setPath(&quot;/index?orderMode=&quot; + orderMode);        List&lt;DiscussPost&gt; list = discussPostService                .findDiscussPosts(0, page.getOffset(), page.getLimit(), orderMode);        List&lt;Map&lt;String, Object&gt;&gt; discussPosts = new ArrayList&lt;&gt;();        if (list != null) {            for (DiscussPost post : list) {                Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();                map.put(&quot;post&quot;, post);                User user = userService.findUserById(post.getUserId());                map.put(&quot;user&quot;, user);                long likeCount = likeService.findEntityLikeCount(ENTITY_TYPE_POST, post.getId());                map.put(&quot;likeCount&quot;, likeCount);                discussPosts.add(map);            }        }        model.addAttribute(&quot;discussPosts&quot;, discussPosts);        model.addAttribute(&quot;orderMode&quot;, orderMode);        return &quot;/index&quot;;    }    @RequestMapping(path = &quot;/error&quot;, method = RequestMethod.GET)    public String getErrorPage() {        return &quot;/error/500&quot;;    }    @RequestMapping(path = &quot;/denied&quot;, method = RequestMethod.GET)    public String getDeniedPage() {        return &quot;/error/404&quot;;    }}</code></pre><h1 id="帖子置顶，加精，删除，"><a href="#帖子置顶，加精，删除，" class="headerlink" title="帖子置顶，加精，删除，"></a>帖子置顶，加精，删除，</h1><p>Controller层</p><p>靠帖子ID，更改帖子状态然后用Kafka发送消息队列</p><pre><code> @Controller@RequestMapping(&quot;/discuss&quot;)public class DiscussPostController implements CommunityConstant { // 置顶    @RequestMapping(path = &quot;/top&quot;, method = RequestMethod.POST)    @ResponseBody    public String setTop(int id) {        discussPostService.updateType(id, 1);        // 触发发帖事件        Event event = new Event()                .setTopic(TOPIC_PUBLISH)                .setUserId(hostHolder.getUser().getId())                .setEntityType(ENTITY_TYPE_POST)                .setEntityId(id);        eventProducer.fireEvent(event);        return CommunityUtil.getJSONString(0);    }    // 加精    @RequestMapping(path = &quot;/wonderful&quot;, method = RequestMethod.POST)    @ResponseBody    public String setWonderful(int id) {        discussPostService.updateStatus(id, 1);        // 触发发帖事件        Event event = new Event()                .setTopic(TOPIC_PUBLISH)                .setUserId(hostHolder.getUser().getId())                .setEntityType(ENTITY_TYPE_POST)                .setEntityId(id);        eventProducer.fireEvent(event);        // 计算帖子分数        String redisKey = RedisKeyUtil.getPostScoreKey();        redisTemplate.opsForSet().add(redisKey, id);        return CommunityUtil.getJSONString(0);    }    // 删除    @RequestMapping(path = &quot;/delete&quot;, method = RequestMethod.POST)    @ResponseBody    public String setDelete(int id) {        discussPostService.updateStatus(id, 2);        // 触发删帖事件        Event event = new Event()                .setTopic(TOPIC_DELETE)                .setUserId(hostHolder.getUser().getId())                .setEntityType(ENTITY_TYPE_POST)                .setEntityId(id);        eventProducer.fireEvent(event);        return CommunityUtil.getJSONString(0);    }}</code></pre><p>消费者，把帖子更新elasticasear</p><pre><code>    // 消费发帖事件    @KafkaListener(topics = {TOPIC_PUBLISH})    public void handlePublishMessage(ConsumerRecord record) {        if (record == null || record.value() == null) {            logger.error(&quot;消息的内容为空!&quot;);            return;        }        Event event = JSONObject.parseObject(record.value().toString(), Event.class);        if (event == null) {            logger.error(&quot;消息格式错误!&quot;);            return;        }        DiscussPost post = discussPostService.findDiscussPostById(event.getEntityId());        elasticsearchService.saveDiscussPost(post);    }</code></pre><pre><code>    // 消费删帖事件    @KafkaListener(topics = {TOPIC_DELETE})    public void handleDeleteMessage(ConsumerRecord record) {        if (record == null || record.value() == null) {            logger.error(&quot;消息的内容为空!&quot;);            return;        }        Event event = JSONObject.parseObject(record.value().toString(), Event.class);        if (event == null) {            logger.error(&quot;消息格式错误!&quot;);            return;        }        elasticsearchService.deleteDiscussPost(event.getEntityId());    }</code></pre><h1 id="私信列表与私信会话聊天的显示"><a href="#私信列表与私信会话聊天的显示" class="headerlink" title="私信列表与私信会话聊天的显示"></a>私信列表与私信会话聊天的显示</h1><p>没有什么其他中间件和逻辑都是把消息内容和私信的内容装进一个实体类里面，对内容进行敏感词过滤，然后存到数据库。</p><pre><code>@Controllerpublic class MessageController implements CommunityConstant {    @Autowired    private MessageService messageService;    @Autowired    private HostHolder hostHolder;    @Autowired    private UserService userService;    // 私信列表    @RequestMapping(path = &quot;/letter/list&quot;, method = RequestMethod.GET)    public String getLetterList(Model model, Page page) {        User user = hostHolder.getUser();        // 分页信息        page.setLimit(5);        page.setPath(&quot;/letter/list&quot;);        page.setRows(messageService.findConversationCount(user.getId()));        // 会话列表        List&lt;Message&gt; conversationList = messageService.findConversations(                user.getId(), page.getOffset(), page.getLimit());        List&lt;Map&lt;String, Object&gt;&gt; conversations = new ArrayList&lt;&gt;();        if (conversationList != null) {            for (Message message : conversationList) {                Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();                map.put(&quot;conversation&quot;, message);                map.put(&quot;letterCount&quot;, messageService.findLetterCount(message.getConversationId()));                map.put(&quot;unreadCount&quot;, messageService.findLetterUnreadCount(user.getId(), message.getConversationId()));                int targetId = user.getId() == message.getFromId() ? message.getToId() : message.getFromId();                map.put(&quot;target&quot;, userService.findUserById(targetId));                conversations.add(map);            }        }        model.addAttribute(&quot;conversations&quot;, conversations);        // 查询未读消息数量        int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);        model.addAttribute(&quot;letterUnreadCount&quot;, letterUnreadCount);        int noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), null);        model.addAttribute(&quot;noticeUnreadCount&quot;, noticeUnreadCount);        return &quot;/site/letter&quot;;    }    @RequestMapping(path = &quot;/letter/detail/{conversationId}&quot;, method = RequestMethod.GET)    public String getLetterDetail(@PathVariable(&quot;conversationId&quot;) String conversationId, Page page, Model model) {        // 分页信息        page.setLimit(5);        page.setPath(&quot;/letter/detail/&quot; + conversationId);        page.setRows(messageService.findLetterCount(conversationId));        // 私信列表        List&lt;Message&gt; letterList = messageService.findLetters(conversationId, page.getOffset(), page.getLimit());        List&lt;Map&lt;String, Object&gt;&gt; letters = new ArrayList&lt;&gt;();        if (letterList != null) {            for (Message message : letterList) {                Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();                map.put(&quot;letter&quot;, message);                map.put(&quot;fromUser&quot;, userService.findUserById(message.getFromId()));                letters.add(map);            }        }        model.addAttribute(&quot;letters&quot;, letters);        // 私信目标        model.addAttribute(&quot;target&quot;, getLetterTarget(conversationId));        // 设置已读        List&lt;Integer&gt; ids = getLetterIds(letterList);        if (!ids.isEmpty()) {            messageService.readMessage(ids);        }        return &quot;/site/letter-detail&quot;;    }    private User getLetterTarget(String conversationId) {        String[] ids = conversationId.split(&quot;_&quot;);        int id0 = Integer.parseInt(ids[0]);        int id1 = Integer.parseInt(ids[1]);        if (hostHolder.getUser().getId() == id0) {            return userService.findUserById(id1);        } else {            return userService.findUserById(id0);        }    }    private List&lt;Integer&gt; getLetterIds(List&lt;Message&gt; letterList) {        List&lt;Integer&gt; ids = new ArrayList&lt;&gt;();        if (letterList != null) {            for (Message message : letterList) {                if (hostHolder.getUser().getId() == message.getToId() &amp;&amp; message.getStatus() == 0) {                    ids.add(message.getId());                }            }        }        return ids;    }    @RequestMapping(path = &quot;/letter/send&quot;, method = RequestMethod.POST)    @ResponseBody    public String sendLetter(String toName, String content) {        User target = userService.findUserByName(toName);        if (target == null) {            return CommunityUtil.getJSONString(1, &quot;目标用户不存在!&quot;);        }        Message message = new Message();        message.setFromId(hostHolder.getUser().getId());        message.setToId(target.getId());        if (message.getFromId() &lt; message.getToId()) {            message.setConversationId(message.getFromId() + &quot;_&quot; + message.getToId());        } else {            message.setConversationId(message.getToId() + &quot;_&quot; + message.getFromId());        }        message.setContent(content);        message.setCreateTime(new Date());        messageService.addMessage(message);        return CommunityUtil.getJSONString(0);    }    @RequestMapping(path = &quot;/notice/list&quot;, method = RequestMethod.GET)    public String getNoticeList(Model model) {        User user = hostHolder.getUser();        // 查询评论类通知        Message message = messageService.findLatestNotice(user.getId(), TOPIC_COMMENT);        if (message != null) {            Map&lt;String, Object&gt; messageVO = new HashMap&lt;&gt;();            messageVO.put(&quot;message&quot;, message);            String content = HtmlUtils.htmlUnescape(message.getContent());            Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);            messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));            messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));            messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));            messageVO.put(&quot;postId&quot;, data.get(&quot;postId&quot;));            int count = messageService.findNoticeCount(user.getId(), TOPIC_COMMENT);            messageVO.put(&quot;count&quot;, count);            int unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_COMMENT);            messageVO.put(&quot;unread&quot;, unread);            model.addAttribute(&quot;commentNotice&quot;, messageVO);        }        // 查询点赞类通知        message = messageService.findLatestNotice(user.getId(), TOPIC_LIKE);        if (message != null) {            Map&lt;String, Object&gt; messageVO = new HashMap&lt;&gt;();            messageVO.put(&quot;message&quot;, message);            String content = HtmlUtils.htmlUnescape(message.getContent());            Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);            messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));            messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));            messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));            messageVO.put(&quot;postId&quot;, data.get(&quot;postId&quot;));            int count = messageService.findNoticeCount(user.getId(), TOPIC_LIKE);            messageVO.put(&quot;count&quot;, count);            int unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_LIKE);            messageVO.put(&quot;unread&quot;, unread);            model.addAttribute(&quot;likeNotice&quot;, messageVO);        }        // 查询关注类通知        message = messageService.findLatestNotice(user.getId(), TOPIC_FOLLOW);        if (message != null) {            Map&lt;String, Object&gt; messageVO = new HashMap&lt;&gt;();            messageVO.put(&quot;message&quot;, message);            String content = HtmlUtils.htmlUnescape(message.getContent());            Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);            messageVO.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));            messageVO.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));            messageVO.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));            int count = messageService.findNoticeCount(user.getId(), TOPIC_FOLLOW);            messageVO.put(&quot;count&quot;, count);            int unread = messageService.findNoticeUnreadCount(user.getId(), TOPIC_FOLLOW);            messageVO.put(&quot;unread&quot;, unread);            model.addAttribute(&quot;followNotice&quot;, messageVO);        }        // 查询未读消息数量        int letterUnreadCount = messageService.findLetterUnreadCount(user.getId(), null);        model.addAttribute(&quot;letterUnreadCount&quot;, letterUnreadCount);        int noticeUnreadCount = messageService.findNoticeUnreadCount(user.getId(), null);        model.addAttribute(&quot;noticeUnreadCount&quot;, noticeUnreadCount);        return &quot;/site/notice&quot;;    }    @RequestMapping(path = &quot;/notice/detail/{topic}&quot;, method = RequestMethod.GET)    public String getNoticeDetail(@PathVariable(&quot;topic&quot;) String topic, Page page, Model model) {        User user = hostHolder.getUser();        page.setLimit(5);        page.setPath(&quot;/notice/detail/&quot; + topic);        page.setRows(messageService.findNoticeCount(user.getId(), topic));        List&lt;Message&gt; noticeList = messageService.findNotices(user.getId(), topic, page.getOffset(), page.getLimit());        List&lt;Map&lt;String, Object&gt;&gt; noticeVoList = new ArrayList&lt;&gt;();        if (noticeList != null) {            for (Message notice : noticeList) {                Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();                // 通知                map.put(&quot;notice&quot;, notice);                // 内容                String content = HtmlUtils.htmlUnescape(notice.getContent());                Map&lt;String, Object&gt; data = JSONObject.parseObject(content, HashMap.class);                map.put(&quot;user&quot;, userService.findUserById((Integer) data.get(&quot;userId&quot;)));                map.put(&quot;entityType&quot;, data.get(&quot;entityType&quot;));                map.put(&quot;entityId&quot;, data.get(&quot;entityId&quot;));                map.put(&quot;postId&quot;, data.get(&quot;postId&quot;));                // 通知作者                map.put(&quot;fromUser&quot;, userService.findUserById(notice.getFromId()));                noticeVoList.add(map);            }        }        model.addAttribute(&quot;notices&quot;, noticeVoList);        // 设置已读        List&lt;Integer&gt; ids = getLetterIds(noticeList);        if (!ids.isEmpty()) {            messageService.readMessage(ids);        }        return &quot;/site/notice-detail&quot;;    }}</code></pre><h1 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h1><h2 id="Controller层（LikeController）"><a href="#Controller层（LikeController）" class="headerlink" title="Controller层（LikeController）"></a>Controller层（LikeController）</h2><p>调用service层的方法，判断查询某人对某实体的点赞状态，然后kafka触发点赞时间。</p><pre><code>@Controllerpublic class LikeController implements CommunityConstant {    @Autowired    private LikeService likeService;    @Autowired    private HostHolder hostHolder;    @Autowired    private EventProducer eventProducer;    @Autowired    private RedisTemplate redisTemplate;    @RequestMapping(path = &quot;/like&quot;, method = RequestMethod.POST)    @ResponseBody    public String like(int entityType, int entityId, int entityUserId, int postId) {        User user = hostHolder.getUser();        // 点赞        likeService.like(postId ,user.getId(), entityType, entityId, entityUserId);        // 数量        long likeCount = likeService.findEntityLikeCount(entityType, entityId);        // 状态        int likeStatus = likeService.findEntityLikeStatus(user.getId(), entityType, entityId);        // 返回的结果        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;likeCount&quot;, likeCount);        map.put(&quot;likeStatus&quot;, likeStatus);        // 触发点赞事件        if (likeStatus == 1) {            Event event = new Event()                    .setTopic(TOPIC_LIKE)                    .setUserId(hostHolder.getUser().getId())                    .setEntityType(entityType)                    .setEntityId(entityId)                    .setEntityUserId(entityUserId)                    .setData(&quot;postId&quot;, postId);            eventProducer.fireEvent(event);        }        //判断是不是帖子类型        if(entityType == ENTITY_TYPE_POST) {            // 计算帖子分数            String redisKey = RedisKeyUtil.getPostScoreKey();            redisTemplate.opsForSet().add(redisKey, postId);        }        return CommunityUtil.getJSONString(0, null, map);    }}</code></pre><h2 id="Service层-2"><a href="#Service层-2" class="headerlink" title="Service层"></a>Service层</h2><pre><code>@Servicepublic class LikeService {    @Autowired    DiscussPostService  discussPostService;    @Autowired    private RedisTemplate redisTemplate;    // 点赞    public void like(int postId , int userId, int entityType, int entityId, int entityUserId) {        redisTemplate.execute(new SessionCallback() {            @Override            public Object execute(RedisOperations operations) throws DataAccessException {                String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);                String userLikeKey = RedisKeyUtil.getUserLikeKey(entityUserId);                boolean isMember = operations.opsForSet().isMember(entityLikeKey, userId);                operations.multi();                if (isMember) {                    operations.opsForSet().remove(entityLikeKey, userId);                    operations.opsForValue().decrement(userLikeKey);                } else {                    operations.opsForSet().add(entityLikeKey, userId);                    operations.opsForValue().increment(userLikeKey);                }                return operations.exec();            }        });    }    // 查询某实体点赞的数量    public long findEntityLikeCount(int entityType, int entityId) {        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        Long size = redisTemplate.opsForSet().size(entityLikeKey);        return size;    }    // 查询某人对某实体的点赞状态    public int findEntityLikeStatus(int userId, int entityType, int entityId) {        String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);        return redisTemplate.opsForSet().isMember(entityLikeKey, userId) ? 1 : 0;    }    // 查询某个用户获得的赞    public int findUserLikeCount(int userId) {        String userLikeKey = RedisKeyUtil.getUserLikeKey(userId);        Integer count = (Integer) redisTemplate.opsForValue().get(userLikeKey);        return count == null ? 0 : count.intValue();    }}</code></pre><h2 id="Kafka消费事件"><a href="#Kafka消费事件" class="headerlink" title="Kafka消费事件"></a>Kafka消费事件</h2><p>监听评论和点赞和关注都是把消息装到Message里面然后去掉内容里面的html标签之类的。然后存入redis里面。</p><pre><code>    @KafkaListener(topics = {TOPIC_COMMENT, TOPIC_LIKE, TOPIC_FOLLOW})    public void handleCommentMessage(ConsumerRecord record) {        if (record == null || record.value() == null) {            logger.error(&quot;消息的内容为空!&quot;);            return;        }        Event event = JSONObject.parseObject(record.value().toString(), Event.class);        if (event == null) {            logger.error(&quot;消息格式错误!&quot;);            return;        }        // 发送站内通知        Message message = new Message();        message.setFromId(SYSTEM_USER_ID);        message.setToId(event.getEntityUserId());        message.setConversationId(event.getTopic());        message.setCreateTime(new Date());        Map&lt;String, Object&gt; content = new HashMap&lt;&gt;();        content.put(&quot;userId&quot;, event.getUserId());        content.put(&quot;entityType&quot;, event.getEntityType());        content.put(&quot;entityId&quot;, event.getEntityId());        if (!event.getData().isEmpty()) {            for (Map.Entry&lt;String, Object&gt; entry : event.getData().entrySet()) {                content.put(entry.getKey(), entry.getValue());            }        }        message.setContent(JSONObject.toJSONString(content));        messageService.addMessage(message);    }</code></pre><h1 id="网站数据统计（UV）-DAU"><a href="#网站数据统计（UV）-DAU" class="headerlink" title="网站数据统计（UV） (DAU)"></a>网站数据统计（UV） (DAU)</h1><p><strong>HyperLogLog</strong> 和 <strong>Bitmap</strong> 都是 Redis 中的高级数据类型！</p><p>HyperLogLog统计UV（独立访客）访问网站的一台电脑客户端为一个访客</p><p>Bitmap统计DAU（(page view）即页面浏览量，或点击量；用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计</p><h2 id="拦截器（DataInterceptor-）"><a href="#拦截器（DataInterceptor-）" class="headerlink" title="拦截器（DataInterceptor ）"></a>拦截器（DataInterceptor ）</h2><p>从请求头获取ip，从线程里面获取用户</p><pre><code>@Componentpublic class DataInterceptor implements HandlerInterceptor {    @Autowired    private DataService dataService;    @Autowired    private HostHolder hostHolder;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        // 统计UV        String ip = request.getRemoteHost();        dataService.recordUV(ip);        // 统计DAU        User user = hostHolder.getUser();        if (user != null) {            dataService.recordDAU(user.getId());        }        return true;    }}</code></pre><h2 id="Controller层-DataController"><a href="#Controller层-DataController" class="headerlink" title="Controller层(DataController)"></a>Controller层(DataController)</h2><pre><code>@Controllerpublic class DataController {    @Autowired    private DataService dataService;    // 统计页面    @RequestMapping(path = &quot;/data&quot;, method = {RequestMethod.GET, RequestMethod.POST})    public String getDataPage() {        return &quot;/site/admin/data&quot;;    }    // 统计网站UV    @RequestMapping(path = &quot;/data/uv&quot;, method = RequestMethod.POST)    public String getUV(@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date start,                        @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date end, Model model) {        long uv = dataService.calculateUV(start, end);        model.addAttribute(&quot;uvResult&quot;, uv);        model.addAttribute(&quot;uvStartDate&quot;, start);        model.addAttribute(&quot;uvEndDate&quot;, end);        return &quot;forward:/data&quot;;    }    // 统计活跃用户    @RequestMapping(path = &quot;/data/dau&quot;, method = RequestMethod.POST)    public String getDAU(@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date start,                         @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) Date end, Model model) {        long dau = dataService.calculateDAU(start, end);        model.addAttribute(&quot;dauResult&quot;, dau);        model.addAttribute(&quot;dauStartDate&quot;, start);        model.addAttribute(&quot;dauEndDate&quot;, end);        return &quot;forward:/data&quot;;    }}</code></pre><h2 id="Service层-3"><a href="#Service层-3" class="headerlink" title="Service层"></a>Service层</h2><p>统计UV就是从redis里面依靠日期查ip</p><pre><code>@Servicepublic class DataService {    @Autowired    private RedisTemplate redisTemplate;    private SimpleDateFormat df = new SimpleDateFormat(&quot;yyyyMMdd&quot;);    // 将指定的IP计入UV    public void recordUV(String ip) {        String redisKey = RedisKeyUtil.getUVKey(df.format(new Date()));        redisTemplate.opsForHyperLogLog().add(redisKey, ip);    }    // 统计指定日期范围内的UV    public long calculateUV(Date start, Date end) {        if (start == null || end == null) {            throw new IllegalArgumentException(&quot;参数不能为空!&quot;);        }        // 整理该日期范围内的key        List&lt;String&gt; keyList = new ArrayList&lt;&gt;();        Calendar calendar = Calendar.getInstance();//获取使用默认时区和区域设置的日历。返回的日历基于默认时区中的当前时间，具有默认格式区域设置        calendar.setTime(start);//开始时间        while (!calendar.getTime().after(end)) {            String key = RedisKeyUtil.getUVKey(df.format(calendar.getTime()));            keyList.add(key);            calendar.add(Calendar.DATE, 1);        }        // 合并这些数据        String redisKey = RedisKeyUtil.getUVKey(df.format(start), df.format(end));        redisTemplate.opsForHyperLogLog().union(redisKey, keyList.toArray());        // 返回统计的结果        return redisTemplate.opsForHyperLogLog().size(redisKey);    }    // 将指定用户计入DAU    public void recordDAU(int userId) {        String redisKey = RedisKeyUtil.getDAUKey(df.format(new Date()));        redisTemplate.opsForValue().setBit(redisKey, userId, true);    }    // 统计指定日期范围内的DAU    public long calculateDAU(Date start, Date end) {        if (start == null || end == null) {            throw new IllegalArgumentException(&quot;参数不能为空!&quot;);        }        // 整理该日期范围内的key        List&lt;byte[]&gt; keyList = new ArrayList&lt;&gt;();        Calendar calendar = Calendar.getInstance();        calendar.setTime(start);        while (!calendar.getTime().after(end)) {            String key = RedisKeyUtil.getDAUKey(df.format(calendar.getTime()));            keyList.add(key.getBytes());            calendar.add(Calendar.DATE, 1);        }        // 进行OR运算        return (long) redisTemplate.execute(new RedisCallback() {            @Override            public Object doInRedis(RedisConnection connection) throws DataAccessException {                String redisKey = RedisKeyUtil.getDAUKey(df.format(start), df.format(end));                connection.bitOp(RedisStringCommands.BitOperation.OR,                        redisKey.getBytes(), keyList.toArray(new byte[0][0]));//(做什么运算，存到redisKey这个变量，从KeyList里面取到)                return connection.bitCount(redisKey.getBytes()); //统计字符串被设置为1            }        });    }}</code></pre><h1 id="Quartz做热帖排行"><a href="#Quartz做热帖排行" class="headerlink" title="Quartz做热帖排行"></a>Quartz做热帖排行</h1><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><pre><code>// 配置 -&gt; 数据库 -&gt; 调用@Configurationpublic class QuartzConfig {    // FactoryBean可简化Bean的实例化过程:    // 1.通过FactoryBean封装Bean的实例化过程.    // 2.将FactoryBean装配到Spring容器里.    // 3.将FactoryBean注入给其他的Bean.    // 4.该Bean得到的是FactoryBean所管理的对象实例.    // 配置JobDetail    // @Bean    public JobDetailFactoryBean alphaJobDetail() {        JobDetailFactoryBean factoryBean = new JobDetailFactoryBean();        factoryBean.setJobClass(AlphaJob.class);        factoryBean.setName(&quot;alphaJob&quot;);        factoryBean.setGroup(&quot;alphaJobGroup&quot;);        factoryBean.setDurability(true);        factoryBean.setRequestsRecovery(true);        return factoryBean;    }    // 配置Trigger(SimpleTriggerFactoryBean, CronTriggerFactoryBean)    // @Bean    public SimpleTriggerFactoryBean alphaTrigger(JobDetail alphaJobDetail) {        SimpleTriggerFactoryBean factoryBean = new SimpleTriggerFactoryBean();        factoryBean.setJobDetail(alphaJobDetail);        factoryBean.setName(&quot;alphaTrigger&quot;);        factoryBean.setGroup(&quot;alphaTriggerGroup&quot;);        factoryBean.setRepeatInterval(3000);        factoryBean.setJobDataMap(new JobDataMap());        return factoryBean;    }    // 刷新帖子分数任务    @Bean    public JobDetailFactoryBean postScoreRefreshJobDetail() {        JobDetailFactoryBean factoryBean = new JobDetailFactoryBean();        factoryBean.setJobClass(PostScoreRefreshJob.class);        factoryBean.setName(&quot;postScoreRefreshJob&quot;);        factoryBean.setGroup(&quot;communityJobGroup&quot;);        factoryBean.setDurability(true);        factoryBean.setRequestsRecovery(true);        return factoryBean;    }    @Bean    public SimpleTriggerFactoryBean postScoreRefreshTrigger(JobDetail postScoreRefreshJobDetail) {        SimpleTriggerFactoryBean factoryBean = new SimpleTriggerFactoryBean();        factoryBean.setJobDetail(postScoreRefreshJobDetail);        factoryBean.setName(&quot;postScoreRefreshTrigger&quot;);        factoryBean.setGroup(&quot;communityTriggerGroup&quot;);        factoryBean.setRepeatInterval(1000 * 60 * 5);        factoryBean.setJobDataMap(new JobDataMap());        return factoryBean;    }}</code></pre><p>Quartz配置文件</p><pre><code>spring.quartz.job-store-type=jdbcspring.quartz.scheduler-name=communitySchedulerspring.quartz.properties.org.quartz.scheduler.instanceId=AUTOspring.quartz.properties.org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreTXspring.quartz.properties.org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegatespring.quartz.properties.org.quartz.jobStore.isClustered=truespring.quartz.properties.org.quartz.threadPool.class=org.quartz.simpl.SimpleThreadPoolspring.quartz.properties.org.quartz.threadPool.threadCount=5</code></pre><h1 id="使用Caffeine做缓存"><a href="#使用Caffeine做缓存" class="headerlink" title="使用Caffeine做缓存"></a>使用Caffeine做缓存</h1><p>@PostConstruct</p><p>被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。</p><h3 id="application-properties-配置文件中添加配置"><a href="#application-properties-配置文件中添加配置" class="headerlink" title="application.properties 配置文件中添加配置"></a>application.properties 配置文件中添加配置</h3><pre class="line-numbers language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># caffeine 本地缓存相关配置</span><span class="token comment" spellcheck="true"># 缓存的帖子列表(max-size:表示本地缓存空间内最多能缓存的数据条数 15条)</span><span class="token attr-name">caffeine.posts.max-size</span><span class="token punctuation">=</span><span class="token attr-value">15</span><span class="token comment" spellcheck="true"># 缓存的帖子列表(expire-seconds:表示本地缓存数据的过期时间 180s)</span><span class="token attr-name">caffeine.posts.expire-seconds</span><span class="token punctuation">=</span><span class="token attr-value">180</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>    @PostConstruct    public void init() {        // 初始化帖子列表缓存        postListCache = Caffeine.newBuilder()                .maximumSize(maxSize)                .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)                .build(new CacheLoader&lt;String, List&lt;DiscussPost&gt;&gt;() {                    @Nullable                    @Override                    public List&lt;DiscussPost&gt; load(@NonNull String key) throws Exception {                        if (key == null || key.length() == 0) {                            throw new IllegalArgumentException(&quot;参数错误!&quot;);                        }                        String[] params = key.split(&quot;:&quot;);                        if (params == null || params.length != 2) {                            throw new IllegalArgumentException(&quot;参数错误!&quot;);                        }                        int offset = Integer.valueOf(params[0]);                        int limit = Integer.valueOf(params[1]);                        // 二级缓存: Redis -&gt; mysql                        logger.debug(&quot;load post list from DB.&quot;);                        return discussPostMapper.selectDiscussPosts(0, offset, limit, 1);                    }                });        // 初始化帖子总数缓存        postRowsCache = Caffeine.newBuilder()                .maximumSize(maxSize)                .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)                .build(new CacheLoader&lt;Integer, Integer&gt;() {                    @Nullable                    @Override                    public Integer load(@NonNull Integer key) throws Exception {                        logger.debug(&quot;load post rows from DB.&quot;);                        return discussPostMapper.selectDiscussPostRows(key);                    }                });    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社区项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-03</title>
      <link href="/mysql-03.html"/>
      <url>/mysql-03.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-日志"><a href="#1-日志" class="headerlink" title="1.日志"></a>1.日志</h1><h2 id="1-1-错误日志"><a href="#1-1-错误日志" class="headerlink" title="1.1 错误日志"></a>1.1 错误日志</h2><p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过 程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，建议首先查看此日 志。 该日志是默认开启的，默认存放目录 /var/log/，默认的日志文件名为 mysqld.log 。查看日志 位置：</p><pre><code>show variables like &#39;%log_error%&#39;;</code></pre><p><img src="/mysql-03/image-20230320140656699.png" alt="image-20230320140656699"></p><h2 id="1-2-二进制日志"><a href="#1-2-二进制日志" class="headerlink" title="1.2 二进制日志"></a>1.2 二进制日志</h2><h3 id="1-2-1-介绍"><a href="#1-2-1-介绍" class="headerlink" title="1.2.1 介绍"></a>1.2.1 介绍</h3><p>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但 不包括数据查询（SELECT、SHOW）语句。</p><p> 作用：①. 灾难时的数据恢复；②. MySQL的主从复制。在MySQL8版本中，默认二进制日志是开启着 的，涉及到的参数如下：</p><pre><code> show variables like &#39;%log_bin%&#39;;</code></pre><p><img src="/mysql-03/image-20230320140852143.png" alt="image-20230320140852143"></p><p>参数说明：</p><ul><li>log_bin_basename：当前数据库服务器的binlog日志的基础名称(前缀)，具体的binlog文 件名需要再该basename的基础上加上编号(编号从000001开始)。</li><li>log_bin_index：binlog的索引文件，里面记录了当前服务器关联的binlog文件有哪些。</li></ul><h3 id="1-2-2-格式"><a href="#1-2-2-格式" class="headerlink" title="1.2.2 格式"></a>1.2.2 格式</h3><p>MySQL服务器中提供了多种格式来记录二进制日志，具体格式及特点如下：</p><table><thead><tr><th>日志格式</th><th>含义</th></tr></thead><tbody><tr><td>STATEMENT</td><td>基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在 日志文件中。</td></tr><tr><td>ROW</td><td>基于行的日志记录，记录的是每一行的数据变更。（默认）</td></tr><tr><td>MIXED</td><td>混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会 自动切换为ROW进行记录。</td></tr></tbody></table><pre><code>show variables like &#39;%binlog_format%&#39;;</code></pre><p><img src="/mysql-03/image-20230320141427815.png" alt="image-20230320141427815"></p><p>需要配置二进制日志的格式，只需要在 /etc/my.cnf 中配置 binlog_format 参数即 可。</p><h3 id="1-2-3-查看"><a href="#1-2-3-查看" class="headerlink" title="1.2.3 查看"></a>1.2.3 查看</h3><p>由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具 mysqlbinlog 来查 看，具体语法：</p><pre><code>mysqlbinlog [ 参数选项 ] logfilename参数选项：-d 指定数据库名称，只列出指定的数据库相关操作。-o 忽略掉日志中的前n行命令。-v 将行事件(数据变更)重构为SQL语句-vv 将行事件(数据变更)重构为SQL语句，并输出注释信息</code></pre><h3 id="1-2-4-删除"><a href="#1-2-4-删除" class="headerlink" title="1.2.4 删除"></a>1.2.4 删除</h3><p>对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空 间。可以通过以下几种方式清理日志：</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>reset master</td><td>删除全部 binlog 日志，删除之后，日志编号，将 从 binlog.000001重新开始</td></tr><tr><td>purge master logs to ‘binlog.*’</td><td>删除 * 编号之前的所有日志</td></tr><tr><td>purge master logs before ‘yyyy-mm-dd hh24:mi:ss’</td><td>删除日志为 “yyyy-mm-dd hh24:mi:ss” 之前 产生的所有日志</td></tr></tbody></table><p>也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除。</p><pre><code>show variables like &#39;%binlog_expire_logs_seconds%&#39;;</code></pre><h2 id="1-3-查询日志"><a href="#1-3-查询日志" class="headerlink" title="1.3 查询日志"></a>1.3 查询日志</h2><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下， 查询日志是未开启的。</p><p><img src="/mysql-03/image-20230320141813340.png" alt="image-20230320141813340"></p><p>如果需要开启查询日志，可以修改MySQL的配置文件 /etc/my.cnf 文件，添加如下内容：</p><pre><code>#该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启general_log=1#设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.loggeneral_log_file=mysql_query.log</code></pre><p>开启了查询日志之后，在MySQL的数据存放目录，也就是 /var/lib/mysql/ 目录下就会出现 mysql_query.log 文件。之后所有的客户端的增删改查操作都会记录在该日志文件之中，长时间运 行后，该日志文件将会非常大。</p><h2 id="1-4-慢查询日志"><a href="#1-4-慢查询日志" class="headerlink" title="1.4 慢查询日志"></a>1.4 慢查询日志</h2><p>慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的SQL语句的日志，默认未开启。long_query_time 默认为 10 秒，最小为 0， 精度可以到微秒。 如果需要开启慢查询日志，需要在MySQL的配置文件 /etc/my.cnf 中配置如下参数：</p><pre><code>#慢查询日志slow_query_log=1#执行时间参数long_query_time=2</code></pre><p>默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用 log_slow_admin_statements和 更改此行为 log_queries_not_using_indexes，如下所 述。</p><pre><code>#记录执行较慢的管理语句log_slow_admin_statements =1#记录执行较慢的未使用索引的语句log_queries_not_using_indexes = 1</code></pre><p>上述所有的参数配置完成之后，都需要重新启动MySQL服务器才可以生效。</p><h1 id="2-主从复制"><a href="#2-主从复制" class="headerlink" title="2.主从复制"></a>2.主从复制</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这 些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。 MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状 复制。</p><p><img src="/mysql-03/image-20230320142319910.png" alt="image-20230320142319910"></p><p>MySQL 复制的优点主要包含以下三个方面：</p><ul><li>主库出现问题，可以快速切换到从库提供服务。</li><li>实现读写分离，降低主库的访问压力。</li><li>可以在从库中执行备份，以避免备份期间影响主库服务。</li></ul><h2 id="2-2-原理"><a href="#2-2-原理" class="headerlink" title="2.2 原理"></a>2.2 原理</h2><p>MySQL主从复制的核心就是 二进制日志，具体的过程如下:</p><p><img src="/mysql-03/image-20230320142705600.png" alt="image-20230320142705600"></p><p>从上图来看，复制分成三步：</p><ol><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li><li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ol><h2 id="2-3-搭建"><a href="#2-3-搭建" class="headerlink" title="2.3 搭建"></a>2.3 搭建</h2><h3 id="2-3-2-主库配置"><a href="#2-3-2-主库配置" class="headerlink" title="2.3.2 主库配置"></a>2.3.2 主库配置</h3><ol><li>修改配置文件 /etc/my.cnf</li></ol><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 232-1，默认为1server-id=1#是否只读,1 代表只读, 0 代表读写read-only=0#忽略的数据, 指不需要同步的数据库#binlog-ignore-db=mysql#指定同步的数据库#binlog-do-db=db01</code></pre><ol start="2"><li>重启MySQL服务器</li></ol><pre><code>systemctl restart mysqld</code></pre><ol start="3"><li>登录mysql，创建远程连接的账号，并授予主从复制权限</li></ol><pre><code>#创建用户，并设置密码，该用户可在任意主机连接该MySQL服务CREATE USER &#39;用户名&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;Root@123456&#39;;#为 &#39;用户名&#39;@&#39;%&#39; 用户分配主从复制权限GRANT REPLICATION SLAVE ON *.* TO &#39;用户名&#39;@&#39;%&#39;;</code></pre><ol start="4"><li>通过指令，查看二进制日志坐标</li></ol><pre><code>show master status ;</code></pre><p><img src="/mysql-03/image-20230320143411901.png" alt="image-20230320143411901"></p><p>字段含义说明：</p><p>file : 从哪个日志文件开始推送日志文件 </p><p>position ： 从哪个位置开始推送日志 </p><p>binlog_ignore_db : 指定不需要同步的数据库</p><h3 id="2-3-3-从库配置"><a href="#2-3-3-从库配置" class="headerlink" title="2.3.3 从库配置"></a>2.3.3 从库配置</h3><ol><li>修改配置文件 /etc/my.cnf</li></ol><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，和主库不一样即可server-id=2#是否只读,1 代表只读, 0 代表读写read-only=1</code></pre><ol start="2"><li>重新启动MySQL服务</li></ol><pre><code>systemctl restart mysqld</code></pre><ol start="3"><li>登录mysql，设置主库配置</li></ol><pre><code>CHANGE REPLICATION SOURCE TO SOURCE_HOST=&#39;192.168.200.200（主的IP）&#39;, SOURCE_USER=&#39;主机配置的主从权限的用户名&#39;,SOURCE_PASSWORD=&#39;Root@123456&#39;, SOURCE_LOG_FILE=&#39;binlog.000004&#39;,SOURCE_LOG_POS=663;</code></pre><p>上述是8.0.23中的语法。如果mysql是 8.0.23 之前的版本，执行如下SQL：</p><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.200.200&#39;, MASTER_USER=&#39;主机配置的主从权限的用户名&#39;,MASTER_PASSWORD=&#39;Root@123456&#39;, MASTER_LOG_FILE=&#39;binlog.000004&#39;,MASTER_LOG_POS=663;</code></pre><table><thead><tr><th>参数名</th><th>含义</th><th>8.0.23之前</th></tr></thead><tbody><tr><td>SOURCE_HOST</td><td>主库IP地址</td><td>MASTER_HOST</td></tr><tr><td>SOURCE_USER</td><td>连接主库的用户名</td><td>MASTER_USER</td></tr><tr><td>SOURCE_PASSWORD</td><td>连接主库的密码</td><td>MASTER_PASSWORD</td></tr><tr><td>SOURCE_LOG_FILE</td><td>binlog日志文件名</td><td>MASTER_LOG_FILE</td></tr><tr><td>SOURCE_LOG_POS</td><td>binlog日志文件位置</td><td>MASTER_LOG_POS</td></tr></tbody></table><ol start="4"><li>开启同步操作</li></ol><pre><code>start replica ; #8.0.22之后start slave ; #8.0.22之前</code></pre><ol start="5"><li>查看主从同步状态</li></ol><pre><code>show replica status ; #8.0.22之后show slave status ; #8.0.22之前</code></pre><p><img src="/mysql-03/image-20230320144151638.png" alt="image-20230320144151638"></p><h1 id="3-分库分表"><a href="#3-分库分表" class="headerlink" title="3.分库分表"></a>3.分库分表</h1><h2 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h2><h3 id="3-1-1-问题分析"><a href="#3-1-1-问题分析" class="headerlink" title="3.1.1 问题分析"></a>3.1.1 问题分析</h3><p><img src="/mysql-03/image-20230320144250086.png" alt="image-20230320144250086"></p><p>随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存 储，存在以下性能瓶颈：</p><ol><li>IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。 请求数据太多，带宽 不够，网络IO瓶颈。</li><li>CPU瓶颈：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出 现瓶颈。</li></ol><p>为了解决上述问题，需要对数据库进行分库分表处理。</p><p><img src="/mysql-03/image-20230320144509133.png" alt="image-20230320144509133"></p><p>分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能 问题，从而达到提升数据库性能的目的。</p><h3 id="3-1-2-拆分策略"><a href="#3-1-2-拆分策略" class="headerlink" title="3.1.2 拆分策略"></a>3.1.2 拆分策略</h3><p>分库分表的形式，主要是两种：垂直拆分和水平拆分。而拆分的粒度，一般又分为分库和分表，所以组 成的拆分策略最终如下:</p><p><img src="/mysql-03/image-20230320145312892.png" alt="image-20230320145312892"></p><h3 id="3-1-3-垂直拆分"><a href="#3-1-3-垂直拆分" class="headerlink" title="3.1.3 垂直拆分"></a>3.1.3 垂直拆分</h3><ol><li>垂直分库</li></ol><p><img src="/mysql-03/image-20230320145342887.png" alt="image-20230320145342887"></p><p>垂直分库：以表为依据，根据业务将不同表拆分到不同库中。</p><p>特点：</p><ul><li>每个库的表结构都不一样。 </li><li>每个库的数据也不一样。</li><li>所有库的并集是全量数据。</li></ul><ol start="2"><li>垂直分表</li></ol><p><img src="/mysql-03/image-20230320145429454.png" alt="image-20230320145429454"></p><p>垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中。</p><p>特点： </p><ul><li>每个表的结构都不一样。</li><li>每个表的数据也不一样，一般通过一列（主键/外键）关联。</li><li>所有表的并集是全量数据。</li></ul><h3 id="3-1-4-水平拆分"><a href="#3-1-4-水平拆分" class="headerlink" title="3.1.4 水平拆分"></a>3.1.4 水平拆分</h3><ol><li>水平分库</li></ol><p><img src="/mysql-03/image-20230320145608750.png" alt="image-20230320145608750"></p><p>水平分库：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。</p><p>特点：</p><ul><li>每个库的表结构都一样。 </li><li>每个库的数据都不一样。 </li><li>所有库的并集是全量数据。</li></ul><ol start="2"><li>水平分表</li></ol><p><img src="/mysql-03/image-20230320145849506.png" alt="image-20230320145849506"></p><p>水平分表：以字段为依据，按照一定策略，将一个表的数据拆分到多个表中。</p><p>特点：</p><ul><li>每个表的表结构都一样。</li><li>每个表的数据都不一样。 </li><li>所有表的并集是全量数据。</li></ul><p>在业务系统中，为了缓解磁盘IO及CPU的性能瓶颈，到底是垂直拆分，还是水平拆分；具体是分 库，还是分表，都需要根据具体的业务需求具体分析。</p><h3 id="3-1-5-实现技术"><a href="#3-1-5-实现技术" class="headerlink" title="3.1.5 实现技术"></a>3.1.5 实现技术</h3><ul><li>shardingJDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处 理。需要自行编码配置实现，只支持java语言，性能较高。</li><li>MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者</li></ul><p><img src="/mysql-03/image-20230320150320070.png" alt="image-20230320150320070"></p><h2 id="3-2-MyCat概述"><a href="#3-2-MyCat概述" class="headerlink" title="3.2 MyCat概述"></a>3.2 MyCat概述</h2><h3 id="3-2-1-介绍"><a href="#3-2-1-介绍" class="headerlink" title="3.2.1 介绍"></a>3.2.1 介绍</h3><p>Mycat是开源的、活跃的、基于Java语言编写的MySQL数据库中间件。可以像使用mysql一样来使用 mycat，对于开发人员来说根本感觉不到mycat的存在。 开发人员只需要连接MyCat即可，而具体底层用到几台数据库，每一台数据库服务器里面存储了什么数 据，都无需关心。 具体的分库分表的策略，只需要在MyCat中配置即可。</p><p><img src="/mysql-03/image-20230320150523355.png" alt="image-20230320150523355"></p><h3 id="3-2-2-下载"><a href="#3-2-2-下载" class="headerlink" title="3.2.2 下载"></a>3.2.2 下载</h3><p><a href="http://dl.mycat.org.cn/" target="_blank" rel="noopener">Index of / (mycat.org.cn)</a></p><p><a href="http://www.mycat.org.cn/" target="_blank" rel="noopener">上海云业网络科技有限公司 (mycat.org.cn)</a></p><h3 id="3-2-3-安装"><a href="#3-2-3-安装" class="headerlink" title="3.2.3 安装"></a>3.2.3 安装</h3><p>Mycat是采用java语言开发的开源的数据库中间件，支持Windows和Linux运行环境，下面介绍 MyCat的Linux中的环境搭建。</p><h3 id="3-2-4-目录介绍"><a href="#3-2-4-目录介绍" class="headerlink" title="3.2.4 目录介绍"></a>3.2.4 目录介绍</h3><p><img src="/mysql-03/image-20230320150737718.png" alt="image-20230320150737718"></p><p>bin : 存放可执行文件，用于启动停止mycat </p><p>conf：存放mycat的配置文件 </p><p>lib：存放mycat的项目依赖包（jar）</p><p> logs：存放mycat的日志文件</p><h3 id="3-2-5-概念介绍"><a href="#3-2-5-概念介绍" class="headerlink" title="3.2.5 概念介绍"></a>3.2.5 概念介绍</h3><p>在MyCat的整体结构中，分为两个部分：上面的逻辑结构、下面的物理结构。</p><p><img src="/mysql-03/image-20230320150825985.png" alt="image-20230320150825985"></p><p>在MyCat的逻辑结构主要负责逻辑库、逻辑表、分片规则、分片节点等逻辑结构的处理，而具体的数据 存储还是在物理结构，也就是数据库服务器中存储的。</p><h2 id="3-3-MyCat入门"><a href="#3-3-MyCat入门" class="headerlink" title="3.3 MyCat入门"></a>3.3 MyCat入门</h2><h3 id="3-3-1-需求"><a href="#3-3-1-需求" class="headerlink" title="3.3.1 需求"></a>3.3.1 需求</h3><p>由于 tb_order 表中数据量很大，磁盘IO及容量都到达了瓶颈，现在需要对 tb_order 表进行数 据分片，分为三个数据节点，每一个节点主机位于不同的服务器上, 具体的结构，参考下图:</p><p><img src="/mysql-03/image-20230320150915592.png" alt="image-20230320150915592"></p><h3 id="3-3-2-环境准备"><a href="#3-3-2-环境准备" class="headerlink" title="3.3.2 环境准备"></a>3.3.2 环境准备</h3><p>准备3台服务器</p><p>192.168.200.210：MyCat中间件服务器，同时也是第一个分片服务器。 </p><p>192.168.200.213：第二个分片服务器。 </p><p>192.168.200.214：第三个分片服务器</p><p><img src="/mysql-03/image-20230320150949987.png" alt="image-20230320150949987"></p><h3 id="3-3-3-配置"><a href="#3-3-3-配置" class="headerlink" title="3.3.3 配置"></a>3.3.3 配置</h3><p>1). schema.xml</p><p>在schema.xml中配置逻辑库、逻辑表、数据节点、节点主机等相关信息。具体的配置如下：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?></span><span class="token doctype">&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mycat:</span>schema</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>mycat</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://io.mycat/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>schema</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>DB01<span class="token punctuation">"</span></span> <span class="token attr-name">checkSQLschema</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">sqlMaxLimit</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>TB_ORDER<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1,dn2,dn3<span class="token punctuation">"</span></span> <span class="token attr-name">rule</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>auto-sharding-long<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>schema</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost1<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>db01<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn2<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost2<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>db01<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost3<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>db01<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    &lt;dataHost name="dhost1" maxCon="1000" minCon="10" balance="0"writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"slaveThreshold="100">        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.210:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span>    &lt;dataHost name="dhost2" maxCon="1000" minCon="10" balance="0"writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"slaveThreshold="100">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.213:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span>    &lt;dataHost name="dhost3" maxCon="1000" minCon="10" balance="0"writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"slaveThreshold="100">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.214:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mycat:</span>schema</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2). server.xml</p><p>需要在server.xml中配置用户名、密码，以及用户的访问权限信息，具体的配置如下：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">defaultAccount</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>DB01<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 表级 DML 权限设置 --></span><span class="token comment" spellcheck="true">&lt;!--&lt;privileges check="true">&lt;schema name="DB01" dml="0110" >&lt;table name="TB_ORDER" dml="1110">&lt;/table>&lt;/schema>&lt;/privileges>--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>DB01<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>readOnly<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述的配置表示，定义了两个用户 root 和 user ，这两个用户都可以访问 DB01 这个逻辑库，访 问密码都是123456，但是root用户访问DB01逻辑库，既可以读，又可以写，但是 user用户访问 DB01逻辑库是只读的。</p><h3 id="3-3-4-测试"><a href="#3-3-4-测试" class="headerlink" title="3.3.4 测试"></a>3.3.4 测试</h3><h5 id="3-3-4-1-启动"><a href="#3-3-4-1-启动" class="headerlink" title="3.3.4.1 启动"></a>3.3.4.1 启动</h5><p>配置完毕后，先启动涉及到的3台分片服务器，然后启动MyCat服务器。切换到Mycat的安装目录，执 行如下指令，启动Mycat：</p><pre><code>#启动bin/mycat start#停止bin/mycat stop</code></pre><p>Mycat启动之后，占用端口号 8066。 启动完毕之后，可以查看logs目录下的启动日志，查看Mycat是否启动完成。</p><p><img src="/mysql-03/image-20230320151743184.png" alt="image-20230320151743184"></p><h5 id="3-3-4-2-测试"><a href="#3-3-4-2-测试" class="headerlink" title="3.3.4.2 测试"></a>3.3.4.2 测试</h5><p>1). 连接MyCat 通过如下指令，就可以连接并登陆MyCat。</p><pre><code>mysql -h 192.168.200.210 -P 8066 -uroot -p123456</code></pre><p>通过MySQL的指令来连接的MyCat，因为MyCat在底层实际上是模拟了MySQL的协议。</p><h2 id="3-4-MyCat配置"><a href="#3-4-MyCat配置" class="headerlink" title="3.4 MyCat配置"></a>3.4 MyCat配置</h2><h3 id="3-4-1-schema-xml"><a href="#3-4-1-schema-xml" class="headerlink" title="3.4.1 schema.xml"></a>3.4.1 schema.xml</h3><p>schema.xml 作为MyCat中最重要的配置文件之一 , 涵盖了MyCat的逻辑库 、 逻辑表 、 分片规 则、分片节点及数据源的配置。</p><p><img src="/mysql-03/image-20230320155347462.png" alt="image-20230320155347462"></p><p>主要包含以下三组标签：</p><ul><li>schema标签 </li><li>datanode标签 </li><li>datahost标签</li></ul><h4 id="3-4-1-1-schema标签"><a href="#3-4-1-1-schema标签" class="headerlink" title="3.4.1.1 schema标签"></a>3.4.1.1 schema标签</h4><p>1). schema 定义逻辑库</p><p><img src="/mysql-03/image-20230320155440593.png" alt="image-20230320155440593"></p><p>schema 标签用于定义 MyCat实例中的逻辑库 , 一个MyCat实例中, 可以有多个逻辑库 , 可以通 过 schema 标签来划分不同的逻辑库。MyCat中的逻辑库的概念，等同于MySQL中的database概念 , 需要操作某个逻辑库下的表时, 也需要切换逻辑库(use xxx)。</p><p>核心属性：</p><ul><li>name：指定自定义的逻辑库库名 </li><li>checkSQLschema：在SQL语句操作时指定了数据库名称，执行时是否自动去除；true：自动去 除，false：不自动去除 </li><li>sqlMaxLimit：如果未指定limit进行查询，列表查询模式查询多少条记录</li></ul><p>2). schema 中的table定义逻辑表</p><p><img src="/mysql-03/image-20230320155722222.png" alt="image-20230320155722222"></p><ul><li>table 标签定义了MyCat中逻辑库schema下的逻辑表 , 所有需要拆分的表都需要在table标签中定义 </li><li>name：定义逻辑表表名，在该逻辑库下唯一 </li><li>dataNode：定义逻辑表所属的dataNode，该属性需要与dataNode标签中name对应；多个 dataNode逗号分隔 </li><li>rule：分片规则的名字，分片规则名字是在rule.xml中定义的</li><li>primaryKey：逻辑表对应真实表的主键</li><li>type：逻辑表的类型，目前逻辑表只有全局表和普通表，如果未配置，就是普通表；全局表，配 置为 global</li></ul><h4 id="3-4-1-2-datanode标签"><a href="#3-4-1-2-datanode标签" class="headerlink" title="3.4.1.2 datanode标签"></a>3.4.1.2 datanode标签</h4><p><img src="/mysql-03/image-20230320155909258.png" alt="image-20230320155909258"></p><p>核心属性：</p><ul><li>name：定义数据节点名称 </li><li>dataHost：数据库实例主机名称，引用自 dataHost 标签中name属性 </li><li>database：定义分片所属数据库</li></ul><h4 id="3-4-1-3-datahost标签"><a href="#3-4-1-3-datahost标签" class="headerlink" title="3.4.1.3 datahost标签"></a>3.4.1.3 datahost标签</h4><p><img src="/mysql-03/image-20230320160009277.png" alt="image-20230320160009277"></p><p>该标签在MyCat逻辑库中作为底层标签存在, 直接定义了具体的数据库实例、读写分离、心跳语句。</p><p>核心属性：</p><ul><li>name：唯一标识，供上层标签使用 </li><li>maxCon/minCon：最大连接数/最小连接数 </li><li>balance：负载均衡策略，取值 0,1,2,3 </li><li>writeType：写操作分发方式（0：写操作转发到第一个writeHost，第一个挂了，切换到第二 个；1：写操作随机分发到配置的writeHost） </li><li>dbDriver：数据库驱动，支持 native、jdbc</li></ul><h3 id="3-4-2-rule-xml"><a href="#3-4-2-rule-xml" class="headerlink" title="3.4.2 rule.xml"></a>3.4.2 rule.xml</h3><p>rule.xml中定义所有拆分表的规则, 在使用过程中可以灵活的使用分片算法, 或者对同一个分片算法 使用不同的参数, 它让分片过程可配置化。主要包含两类标签：tableRule、Function。</p><p><img src="/mysql-03/image-20230320161120658.png" alt="image-20230320161120658"></p><h3 id="3-4-3-server-xml"><a href="#3-4-3-server-xml" class="headerlink" title="3.4.3 server.xml"></a>3.4.3 server.xml</h3><p>server.xml配置文件包含了MyCat的系统配置信息，主要有两个重要的标签：system、user。</p><p>1). system标签</p><p><img src="/mysql-03/image-20230320161144281.png" alt="image-20230320161144281"></p><p>主要配置MyCat中的系统配置信息，对应的系统配置项及其含义，如下：</p><p><img src="/mysql-03/image-20230320161525830.png" alt="image-20230320161525830"></p><p><img src="/mysql-03/image-20230320161540434.png" alt="image-20230320161540434"></p><p><img src="/mysql-03/image-20230320161552677.png" alt="image-20230320161552677"></p><p><img src="/mysql-03/image-20230320161602557.png" alt="image-20230320161602557"></p><p><img src="/mysql-03/image-20230320161610512.png" alt="image-20230320161610512"></p><p>2). user标签 配置MyCat中的用户、访问密码，以及用户针对于逻辑库、逻辑表的权限信息，具体的权限描述方式及 配置说明如下：</p><p><img src="/mysql-03/image-20230320161624635.png" alt="image-20230320161624635"></p><p>在测试权限操作时，只需要将 privileges 标签的注释放开。 在 privileges 下的schema 标签中配置的dml属性配置的是逻辑库的权限。 在privileges的schema下的table标签的dml属性 中配置逻辑表的权限。</p><h2 id="3-5-MyCat分片"><a href="#3-5-MyCat分片" class="headerlink" title="3.5 MyCat分片"></a>3.5 MyCat分片</h2><h3 id="3-5-1-垂直拆分"><a href="#3-5-1-垂直拆分" class="headerlink" title="3.5.1 垂直拆分"></a>3.5.1 垂直拆分</h3><h4 id="3-5-1-1-场景"><a href="#3-5-1-1-场景" class="headerlink" title="3.5.1.1 场景"></a>3.5.1.1 场景</h4><p>在业务系统中, 涉及以下表结构 ,但是由于用户与订单每天都会产生大量的数据, 单台服务器的数据 存储及处理能力是有限的, 可以对数据库表进行拆分, 原有的数据库表如下。</p><p><img src="/mysql-03/image-20230320161732844.png" alt="image-20230320161732844"></p><p>现在考虑将其进行垂直分库操作，将商品相关的表拆分到一个数据库服务器，订单表拆分的一个数据库 服务器，用户及省市区表拆分到一个服务器。最终结构如下：</p><p><img src="/mysql-03/image-20230320161813202.png" alt="image-20230320161813202"></p><h4 id="3-5-1-2-准备"><a href="#3-5-1-2-准备" class="headerlink" title="3.5.1.2 准备"></a>3.5.1.2 准备</h4><p><img src="/mysql-03/image-20230320161837383.png" alt="image-20230320161837383"></p><p>并且在192.168.200.210，192.168.200.213, 192.168.200.214上面创建数据库 shopping。</p><h4 id="3-5-1-3-配置"><a href="#3-5-1-3-配置" class="headerlink" title="3.5.1.3 配置"></a>3.5.1.3 配置</h4><p>1). schema.xml</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>schema</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>SHOPPING<span class="token punctuation">"</span></span> <span class="token attr-name">checkSQLschema</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">sqlMaxLimit</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_goods_base<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_goods_brand<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_goods_cat<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_goods_desc<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>goods_id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_goods_item<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_order_item<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn2<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_order_master<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn2<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>order_id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_order_pay_log<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn2<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>out_trade_no<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_user<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_user_address<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_areas_provinces<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_areas_city<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_areas_region<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>schema</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost1<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>shopping<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn2<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost2<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>shopping<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost3<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>shopping<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataHost</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost1<span class="token punctuation">"</span></span> <span class="token attr-name">maxCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span> <span class="token attr-name">minCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">balance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token attr-name">writeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">dbType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span> <span class="token attr-name">dbDriver</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc<span class="token punctuation">"</span></span> <span class="token attr-name">switchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token attr-name">slaveThreshold</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.210:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataHost</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost2<span class="token punctuation">"</span></span> <span class="token attr-name">maxCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span> <span class="token attr-name">minCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">balance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token attr-name">writeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">dbType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span> <span class="token attr-name">dbDriver</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc<span class="token punctuation">"</span></span> <span class="token attr-name">switchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token attr-name">slaveThreshold</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.213:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataHost</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost3<span class="token punctuation">"</span></span> <span class="token attr-name">maxCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span> <span class="token attr-name">minCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">balance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token attr-name">writeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">dbType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span> <span class="token attr-name">dbDriver</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc<span class="token punctuation">"</span></span> <span class="token attr-name">switchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token attr-name">slaveThreshold</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.214:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2). server.xml</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">defaultAccount</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>SHOPPING<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 表级 DML 权限设置 --></span><span class="token comment" spellcheck="true">&lt;!--&lt;privileges check="true">&lt;schema name="DB01" dml="0110" >&lt;table name="TB_ORDER" dml="1110">&lt;/table>&lt;/schema>&lt;/privileges>--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>SHOPPING<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>readOnly<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-5-1-4-测试"><a href="#3-5-1-4-测试" class="headerlink" title="3.5.1.4 测试"></a>3.5.1.4 测试</h4><p>重新启动MyCat后，在mycat的命令行中，通过source指令导入表结构，以及对应的数据，查看数据 分布情况。</p><pre><code>source /root/shopping-table.sqlsource /root/shopping-insert.sql</code></pre><p>将表结构及对应的测试数据导入之后，可以检查一下各个数据库服务器中的表结构分布情况。 检查是 否和我们准备工作中规划的服务器一致。</p><p><img src="/mysql-03/image-20230320162038225.png" alt="image-20230320162038225"></p><p>订单相关的表结构是在 192.168.200.213 数据库服务器中，而省市区的数 据库表是在 192.168.200.214 数据库服务器中。会出现问题</p><p>因为MyCat在执行该SQL语句时，需要往具体的数 据库服务器中路由，而当前没有一个数据库服务器完全包含了订单以及省市区的表结构，造成SQL语句失败报错。</p><p>可以使用全局表</p><h4 id="3-5-1-5-全局表"><a href="#3-5-1-5-全局表" class="headerlink" title="3.5.1.5 全局表"></a>3.5.1.5 全局表</h4><p>对于省、市、区/县表tb_areas_provinces , tb_areas_city , tb_areas_region，是属于 数据字典表，在多个业务模块中都可能会遇到，可以将其设置为全局表，利于业务操作。</p><p>修改schema.xml中的逻辑表的配置，修改 tb_areas_provinces、tb_areas_city、 tb_areas_region 三个逻辑表，增加 type 属性，配置为global，就代表该表是全局表，就会在 所涉及到的dataNode中创建给表。对于当前配置来说，也就意味着所有的节点中都有该表了。</p><pre><code>&lt;table name=&quot;tb_areas_provinces&quot; dataNode=&quot;dn1,dn2,dn3&quot; primaryKey=&quot;id&quot;type=&quot;global&quot;/&gt;&lt;table name=&quot;tb_areas_city&quot; dataNode=&quot;dn1,dn2,dn3&quot; primaryKey=&quot;id&quot;type=&quot;global&quot;/&gt;&lt;table name=&quot;tb_areas_region&quot; dataNode=&quot;dn1,dn2,dn3&quot; primaryKey=&quot;id&quot;type=&quot;global&quot;/&gt;</code></pre><p><img src="/mysql-03/image-20230320162458936.png" alt="image-20230320162458936"></p><p>配置完毕后，重新启动MyCat。</p><p>1). 删除原来每一个数据库服务器中的所有表结构</p><p>2). 通过source指令，导入表及数据</p><pre><code>source /root/shopping-table.sqlsource /root/shopping-insert.sql</code></pre><p>3). 检查每一个数据库服务器中的表及数据分布，看到三个节点中都有这三张全局表 4). 然后再次执行上面的多表联查的SQL语句</p><pre><code>SELECT order_id , payment ,receiver, province , city , area FROM tb_order_master o, tb_areas_provinces p , tb_areas_city c , tb_areas_region r WHEREo.receiver_province = p.provinceid AND o.receiver_city = c.cityid ANDo.receiver_region = r.areaid ;</code></pre><p><img src="/mysql-03/image-20230320162600231.png" alt="image-20230320162600231"></p><p>是可以正常执行成功的。</p><p> 5). 当在MyCat中更新全局表的时候，我们可以看到，所有分片节点中的数据都发生了变化，每个节 点的全局表数据时刻保持一致。</p><h3 id="3-5-2-水平拆分"><a href="#3-5-2-水平拆分" class="headerlink" title="3.5.2 水平拆分"></a>3.5.2 水平拆分</h3><h4 id="3-5-2-1-场景"><a href="#3-5-2-1-场景" class="headerlink" title="3.5.2.1 场景"></a>3.5.2.1 场景</h4><p>在业务系统中, 有一张表(日志表), 业务系统每天都会产生大量的日志数据 , 单台服务器的数据存 储及处理能力是有限的, 可以对数据库表进行拆分。</p><p><img src="/mysql-03/image-20230320162710396.png" alt="image-20230320162710396"></p><h4 id="3-5-2-2-准备"><a href="#3-5-2-2-准备" class="headerlink" title="3.5.2.2 准备"></a>3.5.2.2 准备</h4><p>准备三台服务器，具体的结构如下：</p><p><img src="/mysql-03/image-20230320162730435.png" alt="image-20230320162730435"></p><h4 id="3-5-2-3-配置"><a href="#3-5-2-3-配置" class="headerlink" title="3.5.2.3 配置"></a>3.5.2.3 配置</h4><p>1). schema.xml</p><pre><code>&lt;schema name=&quot;ITCAST&quot; checkSQLschema=&quot;true&quot; sqlMaxLimit=&quot;100&quot;&gt;&lt;table name=&quot;tb_log&quot; dataNode=&quot;dn4,dn5,dn6&quot; primaryKey=&quot;id&quot; rule=&quot;mod-long&quot; /&gt;&lt;/schema&gt;&lt;dataNode name=&quot;dn4&quot; dataHost=&quot;dhost1&quot; database=&quot;itcast&quot; /&gt;&lt;dataNode name=&quot;dn5&quot; dataHost=&quot;dhost2&quot; database=&quot;itcast&quot; /&gt;&lt;dataNode name=&quot;dn6&quot; dataHost=&quot;dhost3&quot; database=&quot;itcast&quot; /&gt;</code></pre><p>tb_log表最终落在3个节点中，分别是 dn4、dn5、dn6 ，而具体的数据分别存储在 dhost1、 dhost2、dhost3的itcast数据库中。</p><p>2). server.xml</p><p>配置root用户既可以访问 SHOPPING 逻辑库，又可以访问ITCAST逻辑库。</p><pre><code>&lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;&lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;&lt;property name=&quot;schemas&quot;&gt;SHOPPING,ITCAST&lt;/property&gt;&lt;!-- 表级 DML 权限设置 --&gt;&lt;!--&lt;privileges check=&quot;true&quot;&gt;&lt;schema name=&quot;DB01&quot; dml=&quot;0110&quot; &gt;&lt;table name=&quot;TB_ORDER&quot; dml=&quot;1110&quot;&gt;&lt;/table&gt;&lt;/schema&gt;&lt;/privileges&gt;--&gt;&lt;/user&gt;</code></pre><h3 id="3-5-3-分片规则"><a href="#3-5-3-分片规则" class="headerlink" title="3.5.3 分片规则"></a>3.5.3 分片规则</h3><h4 id="3-5-3-1-范围分片"><a href="#3-5-3-1-范围分片" class="headerlink" title="3.5.3.1 范围分片"></a>3.5.3.1 范围分片</h4><p>1). 介绍</p><p>根据指定的字段及其配置的范围与数据节点的对应情况， 来决定该数据属于哪一个分片。</p><p><img src="/mysql-03/image-20230320164124963.png" alt="image-20230320164124963"></p><p>2). 配置</p><p>schema.xml逻辑表配置：</p><pre><code>&lt;table name=&quot;TB_ORDER&quot; dataNode=&quot;dn1,dn2,dn3&quot; rule=&quot;auto-sharding-long&quot; /&gt;</code></pre><p>schema.xml数据节点配置：</p><pre><code>&lt;dataNode name=&quot;dn1&quot; dataHost=&quot;dhost1&quot; database=&quot;db01&quot; /&gt;&lt;dataNode name=&quot;dn2&quot; dataHost=&quot;dhost2&quot; database=&quot;db01&quot; /&gt;&lt;dataNode name=&quot;dn3&quot; dataHost=&quot;dhost3&quot; database=&quot;db01&quot; /&gt;</code></pre><p>rule.xml分片规则配置：</p><pre><code>&lt;tableRule name=&quot;auto-sharding-long&quot;&gt;&lt;rule&gt;&lt;columns&gt;id&lt;/columns&gt;&lt;algorithm&gt;rang-long&lt;/algorithm&gt;&lt;/rule&gt;&lt;/tableRule&gt;&lt;function name=&quot;rang-long&quot; class=&quot;io.mycat.route.function.AutoPartitionByLong&quot;&gt;&lt;property name=&quot;mapFile&quot;&gt;autopartition-long.txt&lt;/property&gt;&lt;property name=&quot;defaultNode&quot;&gt;0&lt;/property&gt;&lt;/function&gt;</code></pre><p>分片规则配置属性含义：</p><p><img src="/mysql-03/image-20230320164320830.png" alt="image-20230320164320830"></p><p>在rule.xml中配置分片规则时，关联了一个映射配置文件 autopartition-long.txt，该配置文 件的配置如下：</p><pre><code># range start-end ,data node index# K=1000,M=10000.0-500M=0500M-1000M=11000M-1500M=2</code></pre><p>含义：0-500万之间的值，存储在0号数据节点(数据节点的索引从0开始) ； 500万-1000万之间的 数据存储在1号数据节点 ； 1000万-1500万的数据节点存储在2号节点 ；该分片规则，主要是针对于数字类型的字段适用。 </p><h4 id="3-5-3-2-取模分片"><a href="#3-5-3-2-取模分片" class="headerlink" title="3.5.3.2 取模分片"></a>3.5.3.2 取模分片</h4><p>1). 介绍</p><p>根据指定的字段值与节点数量进行求模运算，根据运算结果， 来决定该数据属于哪一个分片。</p><p><img src="/mysql-03/image-20230320164524561.png" alt="image-20230320164524561"></p><p>2). 配置</p><p>schema.xml逻辑表配置：</p><pre><code>&lt;table name=&quot;tb_log&quot; dataNode=&quot;dn4,dn5,dn6&quot; primaryKey=&quot;id&quot; rule=&quot;mod-long&quot; /&gt;</code></pre><p>schema.xml数据节点配置：</p><pre><code>&lt;dataNode name=&quot;dn4&quot; dataHost=&quot;dhost1&quot; database=&quot;itcast&quot; /&gt;&lt;dataNode name=&quot;dn5&quot; dataHost=&quot;dhost2&quot; database=&quot;itcast&quot; /&gt;&lt;dataNode name=&quot;dn6&quot; dataHost=&quot;dhost3&quot; database=&quot;itcast&quot; /&gt;</code></pre><p>rule.xml分片规则配置：</p><pre><code>&lt;tableRule name=&quot;mod-long&quot;&gt;&lt;rule&gt;&lt;columns&gt;id&lt;/columns&gt;&lt;algorithm&gt;mod-long&lt;/algorithm&gt;&lt;/rule&gt;&lt;/tableRule&gt;&lt;function name=&quot;mod-long&quot; class=&quot;io.mycat.route.function.PartitionByMod&quot;&gt;&lt;property name=&quot;count&quot;&gt;3&lt;/property&gt;&lt;/function&gt;</code></pre><p>分片规则属性说明如下：</p><p><img src="/mysql-03/image-20230320164606426.png" alt="image-20230320164606426"></p><p>该分片规则，主要是针对于数字类型的字段适用。 在前面水平拆分的演示中，我们选择的就是取模分 片。</p><p>更多规则可看管网</p><p><a href="https://www.yuque.com/ccazhw/ml3nkf/fd9bb7d92f18138725bd53bae67d1d98" target="_blank" rel="noopener">分片算法简介 (yuque.com)</a></p><h2 id="3-6-MyCat管理及监控"><a href="#3-6-MyCat管理及监控" class="headerlink" title="3.6 MyCat管理及监控"></a>3.6 MyCat管理及监控</h2><h3 id="3-6-1-MyCat原理"><a href="#3-6-1-MyCat原理" class="headerlink" title="3.6.1 MyCat原理"></a>3.6.1 MyCat原理</h3><p><img src="/mysql-03/image-20230320164824809.png" alt="image-20230320164824809"></p><p>在MyCat中，当执行一条SQL语句时，MyCat需要进行SQL解析、分片分析、路由分析、读写分离分析 等操作，最终经过一系列的分析决定将当前的SQL语句到底路由到那几个(或哪一个)节点数据库，数据 库将数据执行完毕后，如果有返回的结果，则将结果返回给MyCat，最终还需要在MyCat中进行结果合 并、聚合处理、排序处理、分页处理等操作，最终再将结果返回给客户端。 而在MyCat的使用过程中，MyCat官方也提供了一个管理监控平台MyCat-Web（MyCat-eye）。 Mycat-web 是 Mycat 可视化运维的管理和监控平台，弥补了 Mycat 在监控上的空白。帮 Mycat 分担统计任务和配置管理任务。Mycat-web 引入了 ZooKeeper 作为配置中心，可以管理多个节 点。Mycat-web 主要管理和监控 Mycat 的流量、连接、活动线程和内存等，具备 IP 白名单、邮 件告警等模块，还可以统计 SQL 并分析慢 SQL 和高频 SQL 等。为优化 SQL 提供依据。</p><h3 id="3-6-2-MyCat管理"><a href="#3-6-2-MyCat管理" class="headerlink" title="3.6.2 MyCat管理"></a>3.6.2 MyCat管理</h3><p>Mycat默认开通2个端口，可以在server.xml中进行修改。 </p><p>8066 数据访问端口，即进行 DML 和 DDL 操作。 </p><p>9066 数据库管理端口，即 mycat 服务管理控制功能，用于管理mycat的整个集群状态 </p><p>连接MyCat的管理控制台：</p><pre><code>1 mysql -h 192.168.200.210 -p 9066 -uroot -p123456</code></pre><p><img src="/mysql-03/image-20230320164926322.png" alt="image-20230320164926322"></p><h3 id="3-6-3-MyCat-eye"><a href="#3-6-3-MyCat-eye" class="headerlink" title="3.6.3 MyCat-eye"></a>3.6.3 MyCat-eye</h3><h4 id="3-6-3-1-介绍"><a href="#3-6-3-1-介绍" class="headerlink" title="3.6.3.1 介绍"></a>3.6.3.1 介绍</h4><p>Mycat-web(Mycat-eye)是对mycat-server提供监控服务，功能不局限于对mycat-server使 用。他通过JDBC连接对Mycat、Mysql监控，监控远程服务器(目前仅限于linux系统)的cpu、内 存、网络、磁盘。 Mycat-eye运行过程中需要依赖zookeeper，因此需要先安装zookeeper。</p><h1 id="4-读写分离"><a href="#4-读写分离" class="headerlink" title="4.读写分离"></a>4.读写分离</h1><h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h2><p>读写分离,简单地说是把对数据库的读和写操作分开,以对应不同的数据库服务器。主数据库提供写操 作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。 通过MyCat即可轻易实现上述功能，不仅可以支持MySQL，也可以支持Oracle和SQL Server。</p><p><img src="/mysql-03/image-20230320165609781.png" alt="image-20230320165609781"></p><h2 id="4-2-一主一从"><a href="#4-2-一主一从" class="headerlink" title="4.2 一主一从"></a>4.2 一主一从</h2><h3 id="4-2-1-原理"><a href="#4-2-1-原理" class="headerlink" title="4.2.1 原理"></a>4.2.1 原理</h3><p>MySQL的主从复制，是基于二进制日志（binlog）实现的。</p><p><img src="/mysql-03/image-20230320165744188.png" alt="image-20230320165744188"></p><p>4.2.2 准备</p><p><img src="/mysql-03/image-20230320165754344.png" alt="image-20230320165754344"></p><p>主从复制的搭建，可以参考前面课程中 主从复制 章节讲解的步骤操作。</p><h2 id="4-3-一主一从读写分离"><a href="#4-3-一主一从读写分离" class="headerlink" title="4.3 一主一从读写分离"></a>4.3 一主一从读写分离</h2><p>MyCat控制后台数据库的读写分离和负载均衡由schema.xml文件datahost标签的balance属性控制。</p><h4 id="4-3-1-schema-xml配置"><a href="#4-3-1-schema-xml配置" class="headerlink" title="4.3.1 schema.xml配置"></a>4.3.1 schema.xml配置</h4><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置逻辑库 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>schema</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ITCAST_RW<span class="token punctuation">"</span></span> <span class="token attr-name">checkSQLschema</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">sqlMaxLimit</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn7<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>schema</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn7<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost7<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>itcast<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataHost</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost7<span class="token punctuation">"</span></span> <span class="token attr-name">maxCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span> <span class="token attr-name">minCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">balance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">writeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token attr-name">dbType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span> <span class="token attr-name">dbDriver</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc<span class="token punctuation">"</span></span> <span class="token attr-name">switchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">slaveThreshold</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master1<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.211:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>readHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>slave1<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.212:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>writeHost</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述配置的具体关联对应情况如下：</p><p><img src="/mysql-03/image-20230320165949477.png" alt="image-20230320165949477"></p><p>writeHost代表的是写操作对应的数据库，readHost代表的是读操作对应的数据库。 所以要想 实现读写分离，就得配置writeHost关联的是主库，readHost关联的是从库。 而仅仅配置好了writeHost以及readHost还不能完成读写分离，还需要配置一个非常重要的负责均衡 的参数 balance，取值有4种，具体含义如下：</p><p><img src="/mysql-03/image-20230320170029317.png" alt="image-20230320170029317"></p><p>所以，在一主一从模式的读写分离中，balance配置1或3都是可以完成读写分离的。</p><h4 id="4-3-2-server-xml配置"><a href="#4-3-2-server-xml配置" class="headerlink" title="4.3.2 server.xml配置"></a>4.3.2 server.xml配置</h4><p>配置root用户可以访问SHOPPING、ITCAST 以及 ITCAST_RW逻辑库。</p><pre><code>&lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;&lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;&lt;property name=&quot;schemas&quot;&gt;SHOPPING,ITCAST,ITCAST_RW&lt;/property&gt;&lt;!-- 表级 DML 权限设置 --&gt;&lt;!--&lt;privileges check=&quot;true&quot;&gt;&lt;schema name=&quot;DB01&quot; dml=&quot;0110&quot; &gt;&lt;table name=&quot;TB_ORDER&quot; dml=&quot;1110&quot;&gt;&lt;/table&gt;&lt;/schema&gt;&lt;/privileges&gt;--&gt;&lt;/user&gt;</code></pre><h2 id="4-4-双主双从"><a href="#4-4-双主双从" class="headerlink" title="4.4 双主双从"></a>4.4 双主双从</h2><h3 id="4-4-1-介绍"><a href="#4-4-1-介绍" class="headerlink" title="4.4.1 介绍"></a>4.4.1 介绍</h3><p>一个主机 Master1 用于处理所有写请求，它的从机 Slave1 和另一台主机 Master2 还有它的从 机 Slave2 负责所有读请求。当 Master1 主机宕机后，Master2 主机负责写请求，Master1 、 Master2 互为备机。架构图如下:</p><p><img src="/mysql-03/image-20230320170501362.png" alt="image-20230320170501362"></p><h3 id="4-4-2-准备"><a href="#4-4-2-准备" class="headerlink" title="4.4.2 准备"></a>4.4.2 准备</h3><p>需要准备5台服务器，具体的服务器及软件安装情况如下：</p><p><img src="/mysql-03/image-20230320170523699.png" alt="image-20230320170523699"></p><h3 id="4-4-3-搭建"><a href="#4-4-3-搭建" class="headerlink" title="4.4.3 搭建"></a>4.4.3 搭建</h3><h4 id="4-4-3-1-主库配置"><a href="#4-4-3-1-主库配置" class="headerlink" title="4.4.3.1 主库配置"></a>4.4.3.1 主库配置</h4><p>1). Master1(192.168.200.211)</p><p><img src="/mysql-03/image-20230320170609174.png" alt="image-20230320170609174"></p><p>A. 修改配置文件 /etc/my.cnf</p><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，默认为1server-id=1#指定同步的数据库binlog-do-db=db01binlog-do-db=db02binlog-do-db=db03# 在作为从数据库的时候，有写入操作也要更新二进制日志文件log-slave-update</code></pre><p>B. 重启MySQL服务器</p><pre><code>systemctl restart mysqld</code></pre><p>C. 创建账户并授权</p><pre><code>#创建itcast用户，并设置密码，该用户可在任意主机连接该MySQL服务CREATE USER &#39;itcast&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;Root@123456&#39;;#为 &#39;itcast&#39;@&#39;%&#39; 用户分配主从复制权限GRANT REPLICATION SLAVE ON *.* TO &#39;itcast&#39;@&#39;%&#39;;</code></pre><p>通过指令，查看两台主库的二进制日志坐标</p><pre><code>show master status ;</code></pre><p><img src="/mysql-03/image-20230320170857167.png" alt="image-20230320170857167"></p><p>2). Master2(192.168.200.213)</p><p><img src="/mysql-03/image-20230320170926570.png" alt="image-20230320170926570"></p><p>A. 修改配置文件 /etc/my.cnf</p><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，默认为1server-id=3#指定同步的数据库binlog-do-db=db01binlog-do-db=db02binlog-do-db=db03# 在作为从数据库的时候，有写入操作也要更新二进制日志文件log-slave-updates</code></pre><p>B. 重启MySQL服务器</p><p>C. 创建账户并授权</p><p>通过指令，查看两台主库的二进制日志坐标</p><h4 id="4-4-3-2-从库配置"><a href="#4-4-3-2-从库配置" class="headerlink" title="4.4.3.2 从库配置"></a>4.4.3.2 从库配置</h4><p><img src="/mysql-03/image-20230320171028146.png" alt="image-20230320171028146"></p><p>A. 修改配置文件 /etc/my.cnf</p><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 232-1，默认为1server-id=2</code></pre><p>B. 重新启动MySQL服务器</p><p>2). Slave2(192.168.200.214)</p><p><img src="/mysql-03/image-20230320171052260.png" alt="image-20230320171052260"></p><p>A. 修改配置文件 /etc/my.cnf</p><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 232-1，默认为1server-id=4</code></pre><p>B. 重新启动MySQL服务器</p><h4 id="4-4-3-3-从库关联主库"><a href="#4-4-3-3-从库关联主库" class="headerlink" title="4.4.3.3 从库关联主库"></a>4.4.3.3 从库关联主库</h4><p>1). 两台从库配置关联的主库</p><p><img src="/mysql-03/image-20230320171126319.png" alt="image-20230320171126319"></p><p>slave1绑的是master1，slave2绑的是master2。</p><p>A. 在 slave1(192.168.200.212)上执行</p><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.200.211&#39;, MASTER_USER=&#39;itcast&#39;,MASTER_PASSWORD=&#39;Root@123456&#39;, MASTER_LOG_FILE=&#39;binlog.000002&#39;,MASTER_LOG_POS=663;</code></pre><p>B. 在 slave2(192.168.200.214)上执行</p><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.200.213&#39;, MASTER_USER=&#39;itcast&#39;,MASTER_PASSWORD=&#39;Root@123456&#39;, MASTER_LOG_FILE=&#39;binlog.000002&#39;,MASTER_LOG_POS=663;</code></pre><p>C. 启动两台从库主从复制，查看从库状态</p><pre><code>start slave;show slave status \G;</code></pre><p><img src="/mysql-03/image-20230320171537700.png" alt="image-20230320171537700"></p><p>2). 两台主库相互复</p><p><img src="/mysql-03/image-20230320171552428.png" alt="image-20230320171552428"></p><p>Master2 复制 Master1，Master1 复制 Master2。</p><p>A. 在 Master1(192.168.200.211)上执行</p><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.200.213&#39;, MASTER_USER=&#39;itcast&#39;,MASTER_PASSWORD=&#39;Root@123456&#39;, MASTER_LOG_FILE=&#39;binlog.000002&#39;,MASTER_LOG_POS=663;</code></pre><p>B. 在 Master2(192.168.200.213)上执行</p><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.200.211&#39;, MASTER_USER=&#39;itcast&#39;,MASTER_PASSWORD=&#39;Root@123456&#39;, MASTER_LOG_FILE=&#39;binlog.000002&#39;,MASTER_LOG_POS=663;</code></pre><p>C. 启动两台从库主从复制，查看从库状态</p><pre><code>start slave;show slave status \G;</code></pre><p><img src="/mysql-03/image-20230320171650604.png" alt="image-20230320171650604"></p><h2 id="4-5-双主双从读写分离"><a href="#4-5-双主双从读写分离" class="headerlink" title="4.5 双主双从读写分离"></a>4.5 双主双从读写分离</h2><h3 id="4-5-1-配置"><a href="#4-5-1-配置" class="headerlink" title="4.5.1 配置"></a>4.5.1 配置</h3><p>MyCat控制后台数据库的读写分离和负载均衡由schema.xml文件datahost标签的balance属性控 制，通过writeType及switchType来完成失败自动切换的。</p><p>1). schema.xml</p><p>配置逻辑库：</p><pre><code>&lt;schema name=&quot;ITCAST_RW2&quot; checkSQLschema=&quot;true&quot; sqlMaxLimit=&quot;100&quot; dataNode=&quot;dn7&quot;&gt;&lt;/schema</code></pre><p>配置数据节点：</p><pre><code>&lt;dataNode name=&quot;dn7&quot; dataHost=&quot;dhost7&quot; database=&quot;db01&quot; /&gt;</code></pre><p>配置节点主机：</p><pre><code>&lt;dataHost name=&quot;dhost7&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;1&quot; writeType=&quot;0&quot;dbType=&quot;mysql&quot; dbDriver=&quot;jdbc&quot; switchType=&quot;1&quot; slaveThreshold=&quot;100&quot;&gt;&lt;heartbeat&gt;select user()&lt;/heartbeat&gt;&lt;writeHost host=&quot;master1&quot; url=&quot;jdbc:mysql://192.168.200.211:3306?useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf8&quot;user=&quot;root&quot; password=&quot;1234&quot; &gt;&lt;readHost host=&quot;slave1&quot; url=&quot;jdbc:mysql://192.168.200.212:3306?useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf8&quot;user=&quot;root&quot; password=&quot;1234&quot; /&gt;&lt;/writeHost&gt;&lt;writeHost host=&quot;master2&quot; url=&quot;jdbc:mysql://192.168.200.213:3306?useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf8&quot;user=&quot;root&quot; password=&quot;1234&quot; &gt;&lt;readHost host=&quot;slave2&quot; url=&quot;jdbc:mysql://192.168.200.214:3306?useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf8&quot;user=&quot;root&quot; password=&quot;1234&quot; /&gt;&lt;/writeHost&gt;&lt;/dataHost&gt;</code></pre><p>具体的对应情况如下：</p><p><img src="/mysql-03/image-20230320172202322.png" alt="image-20230320172202322"></p><p>属性说明：</p><p>balance=”1” 代表全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡，简 单的说，当双主双从模式(M1-&gt;S1，M2-&gt;S2，并且 M1 与 M2 互为主备)，正常情况下， M2,S1,S2 都参与 select 语句的负载均衡 </p><p>writeType 0 : 写操作都转发到第1台writeHost, writeHost1挂了, 会切换到writeHost2上; 1 : 所有的写操作都随机地发送到配置的writeHost上 ;</p><p>switchType -1 : 不自动切换 1 : 自动切换</p><p>2). user.xml</p><p>配置root用户也可以访问到逻辑库 ITCAST_RW2。</p><pre><code>&lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;&lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;&lt;property name=&quot;schemas&quot;&gt;SHOPPING,ITCAST,ITCAST_RW2&lt;/property&gt;&lt;!-- 表级 DML 权限设置 --&gt;&lt;!--&lt;privileges check=&quot;true&quot;&gt;&lt;schema name=&quot;DB01&quot; dml=&quot;0110&quot; &gt;&lt;table name=&quot;TB_ORDER&quot; dml=&quot;1110&quot;&gt;&lt;/table&gt;&lt;/schema&gt;&lt;/privileges&gt;--&gt;&lt;/user&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-02</title>
      <link href="/mysql-02.html"/>
      <url>/mysql-02.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1.存储引擎"></a>1.存储引擎</h1><h2 id="1-1-MySQL体系结构"><a href="#1-1-MySQL体系结构" class="headerlink" title="1.1 MySQL体系结构"></a>1.1 MySQL体系结构</h2><p><img src="/mysql-02/image-20230318181430255.png" alt="image-20230318181430255"></p><p>1). 连接层</p><p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务 器也会为安全接入的每个客户端验证它所具有的操作权限。</p><p>2). 服务层</p><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部 分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解 析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大， 这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><p>3). 引擎层</p><p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通 信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库 中的索引是在存储引擎层实现的。</p><p>4). 存储层</p><p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</p><p>和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要 体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。 这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><h2 id="1-2-存储引擎介绍"><a href="#1-2-存储引擎介绍" class="headerlink" title="1.2 存储引擎介绍"></a>1.2 存储引擎介绍</h2><p>对于存储引擎，也是一样，他是mysql数据库的核心，需要在合适的场景选择合适的存储引 擎。接下来就来介绍一下存储引擎。 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是 基于库的，所以存储引擎也可被称为表类型。可以在创建表的时候，来指定选择的存储引擎，如果 没有指定将自动选择默认的存储引擎。</p><p>1). 建表时指定存储引擎</p><pre><code>CREATE TABLE 表名(字段1 字段1类型 [ COMMENT 字段1注释 ] ,......字段n 字段n类型 [COMMENT 字段n注释 ]) ENGINE = INNODB [ COMMENT 表注释 ] ;</code></pre><p>2). 查询当前数据库支持的存储引擎</p><pre><code> show engines;</code></pre><p>示例演示:</p><p>A. 查询建表语句 — 默认存储引擎: InnoDB</p><pre><code> show create table account;</code></pre><p><img src="/mysql-02/image-20230318182248843.png" alt="image-20230318182248843"></p><p>创建表时，即使没有指定存储疫情，数据库也会自动选择默认的存储引擎。</p><p>B. 查询当前数据库支持的存储引擎</p><pre><code>show engines ;</code></pre><p><img src="/mysql-02/image-20230318182342529.png" alt="image-20230318182342529"></p><p>C. 创建表 my_myisam , 并指定MyISAM存储引擎</p><pre><code>create table my_myisam(id int,name varchar(10)) engine = MyISAM ;</code></pre><h2 id="1-3-存储引擎特点"><a href="#1-3-存储引擎特点" class="headerlink" title="1.3 存储引擎特点"></a>1.3 存储引擎特点</h2><h3 id="1-3-1-InnoDB"><a href="#1-3-1-InnoDB" class="headerlink" title="1.3.1 InnoDB"></a>1.3.1 InnoDB</h3><p>1). 介绍</p><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。</p><p>2). 特点</p><ul><li>DML操作遵循ACID模型，支持事务； </li><li>行级锁，提高并发访问性能； </li><li>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</li></ul><p>3). 文件</p><p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结 构（frm-早期的 、sdi-新版的）、数据和索引。</p><p>参数：innodb_file_per_table</p><pre><code>show variables like &#39;innodb_file_per_table&#39;</code></pre><p><img src="/mysql-02/image-20230318182528184.png" alt="image-20230318182528184"></p><p>如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 直接打开MySQL的 数据存放目录： C:\ProgramData\MySQL\MySQL Server 8.0\Data ， 这个目录下有很多文件 夹，不同的文件夹代表不同的数据库。</p><p><img src="/mysql-02/image-20230318182600816.png" alt="image-20230318182600816"></p><p>可以看到里面有很多的ibd文件，每一个ibd文件就对应一张表，比如：有一张表 account，就 有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的 索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一 个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。</p><p><img src="/mysql-02/image-20230318182704471.png" alt="image-20230318182704471"></p><p>4). 逻辑存储结构</p><p><img src="/mysql-02/image-20230318182718828.png" alt="image-20230318182718828"></p><ul><li>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以 包含多个Segment段。 </li><li>段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管 理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。 </li><li>区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为 16K， 即一个区中一共有64个连续的页。</li><li>页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默 认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li><li>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时 所指定的字段以外，还包含两个隐藏字段。</li></ul><h3 id="1-3-2-MyISAM"><a href="#1-3-2-MyISAM" class="headerlink" title="1.3.2 MyISAM"></a>1.3.2 MyISAM</h3><p>1). 介绍</p><p>MyISAM是MySQL早期的默认存储引擎</p><p>2). 特点 </p><p>不支持事务，</p><p>不支持外键</p><p> 支持表锁，不支持行锁 </p><p>访问速度快</p><p>3). 文件</p><p>xxx.sdi：存储表结构信息</p><p> xxx.MYD: 存储数据 </p><p>xxx.MYI: 存储索引</p><p><img src="/mysql-02/image-20230318182949362.png" alt="image-20230318182949362"></p><h3 id="1-3-3-Memory"><a href="#1-3-3-Memory" class="headerlink" title="1.3.3 Memory"></a>1.3.3 Memory</h3><p>1). 介绍</p><p>Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为 临时表或缓存使用。</p><p>2). 特点</p><p> 内存存放</p><p> hash索引（默认）</p><p>3).文件</p><p>xxx.sdi：存储表结构信息</p><h3 id="1-3-4-区别及特点"><a href="#1-3-4-区别及特点" class="headerlink" title="1.3.4 区别及特点"></a>1.3.4 区别及特点</h3><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持(5.6版本之后)</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N/A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table><p>InnoDB引擎与MyISAM引擎的区别 ? </p><p>①. InnoDB引擎, 支持事务, 而MyISAM不支持。 </p><p>②. InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。 </p><p>③. InnoDB引擎, 支持外键, 而MyISAM是不支持的。 </p><p>主要是上述三点区别，当然也可以从索引结构、存储限制等方面，更加深入的回答，具体参 考如下官方文档：</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html</a></p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html</a></p><h3 id="1-4-存储引擎选择"><a href="#1-4-存储引擎选择" class="headerlink" title="1.4 存储引擎选择"></a>1.4 存储引擎选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据 实际情况选择多种存储引擎进行组合。 </p><p>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要 求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操 作，那么InnoDB存储引擎是比较合适的选择。 </p><p>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完 整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。 </p><p>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是 对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</p><h1 id="2-索引"><a href="#2-索引" class="headerlink" title="2.索引"></a>2.索引</h1><h3 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h3><h4 id="2-1-1-介绍"><a href="#2-1-1-介绍" class="headerlink" title="2.1.1 介绍"></a>2.1.1 介绍</h4><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足 特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。</p><h4 id="2-2-演示"><a href="#2-2-演示" class="headerlink" title="2.2 演示"></a>2.2 演示</h4><p>表结构及其数据如下：</p><p><img src="/mysql-02/image-20230318194855504.png" alt="image-20230318194855504"></p><p>假如要执行的SQL语句为 ： select * from user where age = 45</p><p>1). 无索引情况</p><p><img src="/mysql-02/image-20230318194914129.png" alt="image-20230318194914129"></p><p>在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为 全表扫描，性能很 低。</p><p>2). 有索引情况</p><p>如果针对于这张表建立了索引，假设索引结构就是二叉树，那么也就意味着，会对age这个字段建 立一个二叉树的索引结构。</p><p><img src="/mysql-02/image-20230318194942971.png" alt="image-20230318194942971"></p><p>此时进行查询时，只需要扫描三次就可以找到数据了，极大的提高的查询的效率。</p><h4 id="2-3-特点"><a href="#2-3-特点" class="headerlink" title="2.3 特点"></a>2.3 特点</h4><table><thead><tr><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>提高数据检索的效率，降低数据库 的IO成本</td><td>索引列也是要占用空间的。</td></tr><tr><td>通过索引列对数据进行排序，降低 数据排序的成本，降低CPU的消 耗。</td><td>索引大大提高了查询效率，同时却也降低更新表的速度， 如对表进行INSERT、UPDATE、DELETE时，效率降低。</td></tr></tbody></table><h3 id="2-2-索引结构"><a href="#2-2-索引结构" class="headerlink" title="2.2 索引结构"></a>2.2 索引结构</h3><h4 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1 概述"></a>2.2.1 概述</h4><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td></tr><tr><td>Hash索引</td><td>底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不 支持范围查询</td></tr><tr><td>R-tree(空间索 引）</td><td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类 型，通常使用较少</td></tr><tr><td>Full-text(全文 索引)</td><td>是一种通过建立倒排索引,快速匹配文档的方式。类似于 Lucene,Solr,ES</td></tr></tbody></table><p>上述是MySQL中所支持的所有的索引结构.</p><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h4 id="2-2-2-二叉树"><a href="#2-2-2-二叉树" class="headerlink" title="2.2.2 二叉树"></a>2.2.2 二叉树</h4><p>假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下:</p><p><img src="/mysql-02/image-20230318195506632.png" alt="image-20230318195506632"></p><p>如果主键是顺序插入的，则会形成一个单向链表，结构如下：</p><p><img src="/mysql-02/image-20230318195523470.png" alt="image-20230318195523470"></p><p>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p><ul><li>顺序插入时，会形成一个链表，查询性能大大降低。 </li><li>大数据量情况下，层级较深，检索速度慢。</li></ul><p>可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数 据，最终形成的数据结构也是一颗平衡的二叉树,结构如下</p><p><img src="/mysql-02/image-20230318195600407.png" alt="image-20230318195600407"></p><p>但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：</p><ul><li>大数据量情况下，层级较深，检索速度慢。</li></ul><p>所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree.</p><h4 id="2-2-3-B-Tree"><a href="#2-2-3-B-Tree" class="headerlink" title="2.2.3 B-Tree"></a>2.2.3 B-Tree</h4><p>B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。</p><p>以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5 个指针：</p><p><img src="/mysql-02/image-20230318200101312.png" alt="image-20230318200101312"></p><p>树的度数指的是一个节点的子节点个数。</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html" target="_blank" rel="noopener">B-Tree Visualization (usfca.edu)</a></p><p>演示</p><p><img src="/mysql-02/image-20230318200153552.png" alt="image-20230318200153552"></p><p><img src="/mysql-02/image-20230318200233820.png" alt="image-20230318200233820"></p><p>特点：</p><ul><li>5阶的B树，每一个节点最多存储4个key，对应5个指针。 </li><li>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。 </li><li>在B树中，非叶子节点和叶子节点都会存放数据。</li></ul><h4 id="2-2-4-B-Tree"><a href="#2-2-4-B-Tree" class="headerlink" title="2.2.4 B+Tree"></a>2.2.4 B+Tree</h4><p>B+Tree是B-Tree的变种，以一颗最大度数（max-degree）为4（4阶）的b+tree为例，</p><p><img src="/mysql-02/image-20230318201225101.png" alt="image-20230318201225101"></p><p>可以看到，两部分： </p><p>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。 </p><p>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</p><p><img src="/mysql-02/image-20230318201257821.png" alt="image-20230318201257821"></p><p>B+Tree 与 B-Tree相比，主要有以下三点区别： </p><ul><li>所有的数据都会出现在叶子节点。 </li><li>叶子节点形成一个单向链表。 </li><li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</li></ul><p>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点 的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</p><p><img src="/mysql-02/image-20230318201350644.png" alt="image-20230318201350644"></p><h4 id="2-2-5-Hash"><a href="#2-2-5-Hash" class="headerlink" title="2.2.5 Hash"></a>2.2.5 Hash</h4><p>MySQL中除了支持B+Tree索引，还支持一种索引类型—Hash索引。</p><p>1). 结构 哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash表中。</p><p><img src="/mysql-02/image-20230318201435838.png" alt="image-20230318201435838"></p><p>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可 以通过链表来解决。</p><p><img src="/mysql-02/image-20230318201504428.png" alt="image-20230318201504428"></p><p>2). 特点 </p><p>A. Hash索引只能用于对等比较(=，in)，不支持范围查询（between，&gt;，&lt; ，…）</p><p>B. 无法利用索引完成排序操作 C. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</p><p>3). 存储引擎支持</p><p> 在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。</p><h3 id="2-3-索引分类"><a href="#2-3-索引分类" class="headerlink" title="2.3 索引分类"></a>2.3 索引分类</h3><h4 id="2-3-1-索引分类"><a href="#2-3-1-索引分类" class="headerlink" title="2.3.1 索引分类"></a>2.3.1 索引分类</h4><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键 索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建, 只能 有一个</td><td>PRIMARY</td></tr><tr><td>唯一 索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规 索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文 索引</td><td>全文索引查找的是文本中的关键词，而不是比 较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><h4 id="2-3-2-聚集索引-amp-二级索引"><a href="#2-3-2-聚集索引-amp-二级索引" class="headerlink" title="2.3.2 聚集索引&amp;二级索引"></a>2.3.2 聚集索引&amp;二级索引</h4><p>而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据</td><td>必须有,而且只 有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>聚集索引选取规则:</p><ul><li>如果存在主键，主键索引就是聚集索引。</li></ul><ul><li><p>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p></li><li><p>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p></li></ul><p>聚集索引选取规则:</p><ul><li>如果存在主键，主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索 引。</li></ul><p>聚集索引和二级索引的具体结构如下：</p><p><img src="/mysql-02/image-20230318221645990.png" alt="image-20230318221645990"></p><ul><li>聚集索引的叶子节点下挂的是这一行的数据 。 </li><li>二级索引的叶子节点下挂的是该字段值对应的主键值。</li></ul><p>执行如下的SQL语句时，具体的查找过程是什么样子的。</p><p><img src="/mysql-02/image-20230318221907869.png" alt="image-20230318221907869"></p><p>具体过程如下:</p><p>①. 由于是根据name字段进行查询，所以先根据name=’Arm’到name字段的二级索引中进行匹配查 找。但是在二级索引中只能查找到 Arm 对应的主键值10</p><p>②. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最 终找到10对应的行row。</p><p>③. 最终拿到这一行的数据，直接返回即可。</p><p>回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取 数据的方式，就称之为回表查询。</p><p><img src="/mysql-02/image-20230318222059039.png" alt="image-20230318222059039"></p><p>假设:</p><p>一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空 间，主键即使为bigint，占用字节数为8。</p><p>高度为2：</p><p>​        n * 8 + (n + 1) * 6 = 16*1024 , 算出n约为 1170</p><p>​        1171* 16 = 18736</p><p>也就是说，如果树的高度为2，则可以存储 18000 多条记录。</p><p>高度为3：</p><p>1171 * 1171 * 16 = 21939856</p><p>也就是说，如果树的高度为3，则可以存储 2200w 左右的记录。</p><h3 id="2-4-索引语法"><a href="#2-4-索引语法" class="headerlink" title="2.4 索引语法"></a>2.4 索引语法</h3><p>1). 创建索引</p><pre><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,... ) ;</code></pre><p>2). 查看索引</p><pre><code> SHOW INDEX FROM table_name ;</code></pre><p>3). 删除索引</p><pre><code>DROP INDEX index_name ON table_name ;</code></pre><p>演示表</p><pre><code>create table tb_user(id int primary key auto_increment comment &#39;主键&#39;,name varchar(50) not null comment &#39;用户名&#39;,phone varchar(11) not null comment &#39;手机号&#39;,email varchar(100) comment &#39;邮箱&#39;,profession varchar(11) comment &#39;专业&#39;,age tinyint unsigned comment &#39;年龄&#39;,gender char(1) comment &#39;性别 , 1: 男, 2: 女&#39;,status char(1) comment &#39;状态&#39;,createtime datetime comment &#39;创建时间&#39;) comment &#39;系统用户表&#39;</code></pre><p><img src="/mysql-02/image-20230318222406413.png" alt="image-20230318222406413"></p><p>A. name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。</p><pre><code>CREATE INDEX idx_user_name ON tb_user(name);</code></pre><p>B. phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引。</p><pre><code>CREATE UNIQUE INDEX idx_user_phone ON tb_user(phone);</code></pre><p>C. 为profession、age、status创建联合索引。</p><pre><code>CREATE INDEX idx_user_pro_age_sta ON tb_user(profession,age,status);</code></pre><p>D. 为email建立合适的索引来提升查询效率</p><pre><code>CREATE INDEX idx_email ON tb_user(email)</code></pre><p><img src="/mysql-02/image-20230318222612965.png" alt="image-20230318222612965"></p><h3 id="2-5-SQL性能分析"><a href="#2-5-SQL性能分析" class="headerlink" title="2.5 SQL性能分析"></a>2.5 SQL性能分析</h3><h4 id="2-5-1-SQL执行频率"><a href="#2-5-1-SQL执行频率" class="headerlink" title="2.5.1 SQL执行频率"></a>2.5.1 SQL执行频率</h4><p>通过 show [session|global] status 命令可以提供服务器状态信 息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：</p><pre><code>-- session 是查看当前会话 ;-- global 是查询全局数据 ;SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;;</code></pre><p><img src="/mysql-02/image-20230318222752012.png" alt="image-20230318222752012"></p><p>查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，可以考虑不对其进行索引的优化。 如果是以查询为主，那么就要考虑对数据库的索引进行优化了。</p><h4 id="2-5-2-慢查询日志"><a href="#2-5-2-慢查询日志" class="headerlink" title="2.5.2 慢查询日志"></a>2.5.2 慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志</p><p>MySQL的慢查询日志默认没有开启，</p><p><img src="/mysql-02/image-20230318224609961.png" alt="image-20230318224609961"></p><p>如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p><pre><code># 开启MySQL慢日志查询开关slow_query_log=1# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志long_query_time=2</code></pre><p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息</p><p>/var/lib/mysql/localhost-slow.log。</p><pre><code>systemctl restart mysqld</code></pre><p>然后，再次查看开关情况，慢查询日志就已经打开了。</p><p><img src="/mysql-02/image-20230318224945351.png" alt="image-20230318224945351"></p><p>A. 执行如下SQL语句 ：</p><pre><code>select * from tb_user; -- 这条SQL执行效率比较高, 执行耗时 0.00secselect count(*) from tb_sku; -- 由于tb_sku表中, 预先存入了1000w的记录, count一次,耗时13.35sec</code></pre><p>B. 检查慢查询日志 ：在慢查询日志中，只会记录执行时间超多预设时间（2s）的SQL，执行较快的SQL 是不会记录的。</p><p><img src="/mysql-02/image-20230318225343630.png" alt="image-20230318225343630"></p><h4 id="2-5-3-profile详情"><a href="#2-5-3-profile详情" class="headerlink" title="2.5.3 profile详情"></a>2.5.3 profile详情</h4><p>show profiles 能够在做SQL优化时帮助了解时间都耗费到哪里去了。通过have_profiling 参数，能够看到当前MySQL是否支持profile操作：</p><pre><code>SELECT @@have_profiling ;</code></pre><p><img src="/mysql-02/image-20230318225426205.png" alt="image-20230318225426205"></p><p>可以看到，当前MySQL是支持 profile操作的，但是开关是关闭的。可以通过set语句在 session/global级别开启profiling：</p><pre><code>SET profiling = 1;</code></pre><p>开关已经打开了，接下来，执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去 了。 </p><p>执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：</p><pre><code>-- 查看每一条SQL的耗时基本情况show profiles;-- 查看指定query_id的SQL语句各个阶段的耗时情况show profile for query query_id;-- 查看指定query_id的SQL语句CPU的使用情况show profile cpu for query query_id;</code></pre><p><img src="/mysql-02/image-20230318225648176.png" alt="image-20230318225648176"></p><p>查看指定SQL各个阶段的耗时情况 :  query_id为16的情况</p><p><img src="/mysql-02/image-20230318225705567.png" alt="image-20230318225705567"></p><h4 id="2-5-4-explain"><a href="#2-5-4-explain" class="headerlink" title="2.5.4 explain"></a>2.5.4 explain</h4><p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行 过程中表如何连接和连接的顺序。</p><p>语法:</p><pre><code>-- 直接在select语句之前加上关键字 explain / descEXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;</code></pre><p><img src="/mysql-02/image-20230318225806472.png" alt="image-20230318225806472"></p><p>Explain 执行计划中各个字段的含义:</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序 (id相同，执行顺序从上到下；id不同，值越大，越先执行)。</td></tr><tr><td>select_type</td><td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接 或者子查询）、PRIMARY（主查询，即外层的查询）、 UNION（UNION 中的第二个或者后面的查询语句）、 SUBQUERY（SELECT/WHERE之后包含了子查询）等</td></tr><tr><td>type</td><td>表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。</td></tr><tr><td>possible_key</td><td>显示可能应用在这张表上的索引，一个或多个。</td></tr><tr><td>key</td><td>实际使用的索引，如果为NULL，则没有使用索引。</td></tr><tr><td>key_len</td><td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。</td></tr><tr><td>rows</td><td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值， 可能并不总是准确的。</td></tr><tr><td>filtered</td><td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td></tr></tbody></table><h3 id="2-6-索引使用"><a href="#2-6-索引使用" class="headerlink" title="2.6 索引使用"></a>2.6 索引使用</h3><h4 id="2-6-1-验证索引效率"><a href="#2-6-1-验证索引效率" class="headerlink" title="2.6.1 验证索引效率"></a>2.6.1 验证索引效率</h4><p>这表中有1000W的记录</p><p>这张表中id为主键，有主键索引，而其他字段是没有建立索引的。 先来查询其中的一条记录，看 看里面的字段情况，执行如下SQL：</p><pre><code>select * from tb_sku where id = 1\G;\G是垂直显示</code></pre><p><img src="/mysql-02/image-20230318230447872.png" alt="image-20230318230447872"></p><p>可以看到即使有1000w的数据,根据id进行数据查询,性能依然很快，因为主键id是有索引的。</p><pre><code>SELECT * FROM tb_sku WHERE sn = &#39;100000003145001&#39;;</code></pre><p><img src="/mysql-02/image-20230318230511242.png" alt="image-20230318230511242"></p><p>可以看到根据sn字段进行查询，查询返回了一条数据，结果耗时 20.78sec，就是因为sn没有索 引，而造成查询效率很低。 可以针对于sn字段，建立一个索引，建立了索引之后，再次根据sn进行查询，再来看一 下查询耗时情况。</p><p>创建索引：</p><pre><code>create index idx_sku_sn on tb_sku(sn) ;</code></pre><p><img src="/mysql-02/image-20230318230652231.png" alt="image-20230318230652231"></p><p>然后再次执行相同的SQL语句，再次查看SQL的耗时。</p><pre><code>SELECT * FROM tb_sku WHERE sn = &#39;100000003145001&#39;;</code></pre><p><img src="/mysql-02/image-20230318230724284.png" alt="image-20230318230724284"></p><p>明显会看到，sn字段建立了索引之后，查询性能大大提升。建立索引前后，查询耗时都不是一个数 量级的。</p><h4 id="2-6-2-最左前缀法则"><a href="#2-6-2-最左前缀法则" class="headerlink" title="2.6.2 最左前缀法则"></a>2.6.2 最左前缀法则</h4><p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。</p><p>以 tb_user 表为例，</p><p><img src="/mysql-02/image-20230318230807101.png" alt="image-20230318230807101"></p><p>在 tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession， age，status。 对于最左前缀法则指的是，查询时，最左边的列，也就是profession必须存在，否则索引全部失效。 而且中间不能跳过某一列，否则该列后面的字段索引将失效。</p><p>当执行SQL语句: explain select * from tb_user where age = 31 and status = ‘0’ and profession = ‘软件工程’； 时，是否满足最左前缀法则，走不走 上述的联合索引，索引长度？</p><p><img src="/mysql-02/image-20230318230911191.png" alt="image-20230318230911191"></p><p>可以看到，是完全满足最左前缀法则的，索引长度54，联合索引是生效的。</p><p>注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是 第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p><h4 id="2-6-3-范围查询"><a href="#2-6-3-范围查询" class="headerlink" title="2.6.3 范围查询"></a>2.6.3 范围查询</h4><p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效。</p><pre><code>explain select * from tb_user where profession = &#39;软件工程&#39; and age &gt; 30 and status= &#39;0&#39;;</code></pre><p><img src="/mysql-02/image-20230318231120926.png" alt="image-20230318231120926"></p><p>当范围查询使用&gt; 或 &lt; 时，走联合索引了，但是索引的长度为49，就说明范围查询右边的status字 段是没有走索引的。</p><pre><code>explain select * from tb_user where profession = &#39;软件工程&#39; and age &gt;= 30 andstatus = &#39;0&#39;;</code></pre><p><img src="/mysql-02/image-20230318231212418.png" alt="image-20230318231212418"></p><p>当范围查询使用&gt;= 或 &lt;= 时，走联合索引了，但是索引的长度为54，就说明所有的字段都是走索引 的。 所以，在业务允许的情况下，尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，而避免使用 &gt; 或 &lt; 。</p><h4 id="2-6-4-索引失效情况"><a href="#2-6-4-索引失效情况" class="headerlink" title="2.6.4 索引失效情况"></a>2.6.4 索引失效情况</h4><h5 id="2-6-4-1-索引列运算"><a href="#2-6-4-1-索引列运算" class="headerlink" title="2.6.4.1 索引列运算"></a>2.6.4.1 索引列运算</h5><p>不要在索引列上进行运算操作， 索引将失效。</p><p>在tb_user表中，除了前面介绍的联合索引之外，还有一个索引，是phone字段的单列索引。</p><p><img src="/mysql-02/image-20230318231259493.png" alt="image-20230318231259493"></p><p>A. 当根据phone字段进行等值匹配查询时, 索引生效。</p><pre><code>explain select * from tb_user where phone = &#39;17799990015&#39;;</code></pre><p>B. 当根据phone字段进行函数运算操作之后，索引失效。</p><pre><code>explain select * from tb_user where substring(phone,10,2) = &#39;15&#39;</code></pre><p><img src="/mysql-02/image-20230318231423997.png" alt="image-20230318231423997"></p><h5 id="2-6-4-2-字符串不加引号"><a href="#2-6-4-2-字符串不加引号" class="headerlink" title="2.6.4.2 字符串不加引号"></a>2.6.4.2 字符串不加引号</h5><p>字符串类型字段使用时，不加引号，索引将失效。</p><pre><code>explain select * from tb_user where profession = &#39;软件工程&#39; and age = 31 and status= &#39;0&#39;;explain select * from tb_user where profession = &#39;软件工程&#39; and age = 31 and status= 0;</code></pre><p><img src="/mysql-02/image-20230318231630498.png" alt="image-20230318231630498"></p><pre><code>explain select * from tb_user where phone = &#39;17799990015&#39;;explain select * from tb_user where phone = 17799990015;</code></pre><p><img src="/mysql-02/image-20230318231652044.png" alt="image-20230318231652044"></p><p>经过上面两组示例，会明显的发现，如果字符串不加单引号，对于查询结果，没什么影响，但是数 据库存在隐式类型转换，索引将失效。</p><h5 id="2-6-4-3-模糊查询"><a href="#2-6-4-3-模糊查询" class="headerlink" title="2.6.4.3 模糊查询"></a>2.6.4.3 模糊查询</h5><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><p>由于下面查询语句中，都是根据profession字段查询，符合最左前缀法则，联合索引是可以生效的， 主要看一下，模糊查询时，%加在关键字之前，和加在关键字之后的影响。</p><pre><code>explain select * from tb_user where profession like &#39;软件%&#39;;explain select * from tb_user where profession like &#39;%工程&#39;;explain select * from tb_user where profession like &#39;%工%&#39;;</code></pre><p><img src="/mysql-02/image-20230318231758572.png" alt="image-20230318231758572"></p><p>经过上述的测试，在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字 前面加了%，索引将会失效。</p><h5 id="3-6-4-4-or连接条件"><a href="#3-6-4-4-or连接条件" class="headerlink" title="3.6.4.4 or连接条件"></a>3.6.4.4 or连接条件</h5><p>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会 被用到。</p><pre><code>xplain select * from tb_user where id = 10 or age = 23;explain select * from tb_user where phone = &#39;17799990017&#39; or age = 23;</code></pre><p><img src="/mysql-02/image-20230318231912002.png" alt="image-20230318231912002"></p><p>由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。</p><p>然后，可以对age字段建立索引。</p><pre><code>create index idx_user_age on tb_user(age)</code></pre><p><img src="/mysql-02/image-20230318231942043.png" alt="image-20230318231942043"></p><p>建立了索引之后，再次执行上述的SQL语句，看看前后执行计划的变化。</p><p><img src="/mysql-02/image-20230318231954670.png" alt="image-20230318231954670"></p><p>当or连接的条件，左右两侧字段都有索引时，索引才会生效。</p><h5 id="3-6-4-5-数据分布影响"><a href="#3-6-4-5-数据分布影响" class="headerlink" title="3.6.4.5 数据分布影响"></a>3.6.4.5 数据分布影响</h5><pre><code>select * from tb_user where phone &gt;= &#39;17799990005&#39;;select * from tb_user where phone &gt;= &#39;17799990015&#39;;</code></pre><p><img src="/mysql-02/image-20230318232049614.png" alt="image-20230318232049614"></p><p>相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样</p><p>因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃 索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不 如走全表扫描来的快，此时索引就会失效。</p><p> is null 与 is not null 操作是否走索引。</p><p>执行如下两条语句 ：</p><pre><code>explain select * from tb_user where profession is null;explain select * from tb_user where profession is not null;</code></pre><p><img src="/mysql-02/image-20230318232202493.png" alt="image-20230318232202493"></p><p>将profession字段值全部更新为null。</p><p><img src="/mysql-02/image-20230318232214786.png" alt="image-20230318232214786"></p><p>然后，再次执行上述的两条SQL，查看SQL语句的执行计划。</p><p>最终看到，一模一样的SQL语句，先后执行了两次，结果查询计划是不一样的，为什么会出现这种 现象，这是和数据库的数据分布有关系。查询时MySQL会评估，走索引快，还是全表扫描快，如果全表 扫描更快，则放弃索引走全表扫描。 因此，is null 、is not null是否走索引，得具体情况具体 分析，并不是固定的。</p><h5 id="2-6-5-SQL提示"><a href="#2-6-5-SQL提示" class="headerlink" title="2.6.5 SQL提示"></a>2.6.5 SQL提示</h5><p>目前tb_user表的数据情况如下:</p><p><img src="/mysql-02/image-20230318232304149.png" alt="image-20230318232304149"></p><p>索引情况如下:</p><p><img src="/mysql-02/image-20230318232313580.png" alt="image-20230318232313580"></p><p>把上述的 idx_user_age, idx_email 这两个之前测试使用过的索引直接删除。</p><pre><code>drop index idx_user_age on tb_user;drop index idx_email on tb_user;</code></pre><p>A. 执行SQL : explain select * from tb_user where profession = ‘软件工程’;</p><p><img src="/mysql-02/image-20230318232402315.png" alt="image-20230318232402315"></p><p>查询走了联合索引。</p><p>B. 执行SQL，创建profession的单列索引：create index idx_user_pro on tb_user(profession);</p><p><img src="/mysql-02/image-20230318232418417.png" alt="image-20230318232418417"></p><p>C. 创建单列索引后，再次执行A中的SQL语句，查看执行计划，看看到底走哪个索引。</p><p><img src="/mysql-02/image-20230318232427617.png" alt="image-20230318232427617"></p><p>可以看到，possible_keys中 idx_user_pro_age_sta,idx_user_pro 这两个 索引都可能用到，最终MySQL选择了idx_user_pro_age_sta索引。这是MySQL自动选择的结果。</p><p>手动指定使用索引</p><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优 化操作的目的。</p><p>1). use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进 行评估）。</p><pre><code>explain select * from tb_user use index(idx_user_pro) where profession = &#39;软件工程&#39;;</code></pre><p>2). ignore index ： 忽略指定的索引。</p><pre><code>explain select * from tb_user ignore index(idx_user_pro) where profession = &#39;软件工程&#39;;</code></pre><p>3). force index ： 强制使用索引。</p><pre><code>explain select * from tb_user force index(idx_user_pro) where profession = &#39;软件工程&#39;;</code></pre><h5 id="2-6-6-覆盖索引"><a href="#2-6-6-覆盖索引" class="headerlink" title="2.6.6 覆盖索引"></a>2.6.6 覆盖索引</h5><p>尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ 覆盖索引是指 查询使用了索引，并 且需要返回的列，在该索引中已经全部能够找到 。</p><p>执行下述sql语句</p><pre><code>explain select id, profession from tb_user where profession = &#39;软件工程&#39; and age =31 and status = &#39;0&#39; ;explain select id,profession,age, status from tb_user where profession = &#39;软件工程&#39;and age = 31 and status = &#39;0&#39; ;explain select id,profession,age, status, name from tb_user where profession = &#39;软件工程&#39; and age = 31 and status = &#39;0&#39; ;explain select * from tb_user where profession = &#39;软件工程&#39; and age = 31 and status= &#39;0&#39;;</code></pre><p>上述这几条SQL的执行结果为:</p><p><img src="/mysql-02/image-20230318232641116.png" alt="image-20230318232641116"></p><p>从上述的执行计划我们可以看到，这四条SQL语句的执行计划前面所有的指标都是一样的，看不出来差 异。但是此时主要关注的是后面的Extra，前面两天SQL的结果为 Using where; Using Index ; 而后面两条SQL的结果为: Using index condition 。</p><table><thead><tr><th>Extra</th><th>含义</th></tr></thead><tbody><tr><td>Using where; Using Index</td><td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需 要回表查询数据</td></tr><tr><td>Using index condition</td><td>查找使用了索引，但是需要回表查询数据</td></tr></tbody></table><p>因为，在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段 profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主 键id。</p><p> 所以当查询返回的数据在 id、profession、age、status 之中，则直接走二级索引 直接返回数据了。 如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据 ，这个过程就是回表。 而如果一直使用select * 查询返回所有字段值，很容易就会造成回表 查询（除非是根据主键查询，此时只会扫描聚集索引）。</p><p>A. 表结构及索引示意图:</p><p><img src="/mysql-02/image-20230319123949489.png" alt="image-20230319123949489"></p><p><img src="/mysql-02/image-20230319123957065.png" alt="image-20230319123957065"></p><p>id是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）。</p><p>B. 执行SQL : select * from tb_user where id = 2;</p><p><img src="/mysql-02/image-20230319124138268.png" alt="image-20230319124138268"></p><p>根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p><p>C. 执行SQL：selet id,name from tb_user where name = ‘Arm’</p><p><img src="/mysql-02/image-20230319124238772.png" alt="image-20230319124238772"></p><p>虽然是根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在name的二级索 引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。</p><p>D. 执行SQL：selet id,name,gender from tb_user where name = ‘Arm’;</p><p><img src="/mysql-02/image-20230319124305169.png" alt="image-20230319124305169"></p><p>由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相 对较差一点。</p><p>例如</p><p>一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对 以下SQL语句进行优化, </p><p> select id,username,password from tb_user where username = ‘itcast’; </p><p>针对于 username, password建立联合索引, sql为: create index idx_user_name_pass on tb_user(username,password); </p><p>这样可以避免上述的SQL语句，在查询的过程中，出现回表查询</p><h5 id="2-6-7-前缀索引"><a href="#2-6-7-前缀索引" class="headerlink" title="2.6.7 前缀索引"></a>2.6.7 前缀索引</h5><p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让 索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建 立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>1). 语法</p><pre><code>create index idx_xxxx on table_name(column(n)) ;</code></pre><p>示例:</p><p>为tb_user表的email字段，建立长度为5的前缀索引。</p><pre><code>create index idx_email_5 on tb_user(email(5));</code></pre><p><img src="/mysql-02/image-20230319125857546.png" alt="image-20230319125857546"></p><p>2). 前缀长度</p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值， 索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><pre><code>select count(distinct email) / count(*) from tb_user ;select count(distinct substring(email,1,5)) / count(*) from tb_user ;</code></pre><p>3). 前缀索引的查询流程</p><p><img src="/mysql-02/image-20230319130224881.png" alt="image-20230319130224881"></p><h5 id="2-6-8-单列索引与联合索引"><a href="#2-6-8-单列索引与联合索引" class="headerlink" title="2.6.8 单列索引与联合索引"></a>2.6.8 单列索引与联合索引</h5><p>单列索引：即一个索引只包含单个列。</p><p>联合索引：即一个索引包含了多个列。</p><p><img src="/mysql-02/image-20230319130401139.png" alt="image-20230319130401139"></p><p>在查询出来的索引中，既有单列索引，又有联合索引。</p><p><img src="/mysql-02/image-20230319130514769.png" alt="image-20230319130514769"></p><p>通过上述执行计划可以看出来，在and连接的两个字段 phone、name上都是有单列索引的，但是 最终mysql只会选择一个索引，也就是说，只能走一个字段的索引，此时是会回表查询的。</p><p>紧接着，再来创建一个phone和name字段的联合索引来查询一下执行计划。</p><pre><code>create unique index idx_user_phone_name on tb_user(phone,name)</code></pre><p><img src="/mysql-02/image-20230319130604210.png" alt="image-20230319130604210"></p><p>此时，查询时，就走了联合索引，而在联合索引中包含 phone、name的信息，在叶子节点下挂的是对 应的主键id，所以查询是无需回表查询的。</p><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。</p><p>如果查询使用的是联合索引，具体的结构示意图如下：</p><p><img src="/mysql-02/image-20230319130818720.png" alt="image-20230319130818720"></p><h3 id="2-7-索引设计原则"><a href="#2-7-索引设计原则" class="headerlink" title="2.7 索引设计原则"></a>2.7 索引设计原则</h3><p>1). 针对于数据量较大，且查询比较频繁的表建立索引。</p><p>2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索 引。</p><p>3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p><p>4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p><p>5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。</p><p>6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增 删改的效率。</p><p>7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p><h1 id="3-SQL优化"><a href="#3-SQL优化" class="headerlink" title="3.SQL优化"></a>3.SQL优化</h1><h2 id="3-1-插入数据"><a href="#3-1-插入数据" class="headerlink" title="3.1 插入数据"></a>3.1 插入数据</h2><h3 id="3-1-1-insert"><a href="#3-1-1-insert" class="headerlink" title="3.1.1 insert"></a>3.1.1 insert</h3><p>如果需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。</p><pre><code>insert into tb_test values(1,&#39;tom&#39;);insert into tb_test values(2,&#39;cat&#39;);insert into tb_test values(3,&#39;jerry&#39;);.....</code></pre><p>1). 优化方案一</p><p>批量插入数据</p><pre><code>Insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;);</code></pre><p>2). 优化方案二</p><p>手动控制事务</p><pre><code>start transaction;insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;);insert into tb_test values(4,&#39;Tom&#39;),(5,&#39;Cat&#39;),(6,&#39;Jerry&#39;);insert into tb_test values(7,&#39;Tom&#39;),(8,&#39;Cat&#39;),(9,&#39;Jerry&#39;);commit;</code></pre><p>3). 优化方案三</p><p>主键顺序插入，性能要高于乱序插入。</p><pre><code>主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89</code></pre><h3 id="3-1-2-大批量插入数据"><a href="#3-1-2-大批量插入数据" class="headerlink" title="3.1.2 大批量插入数据"></a>3.1.2 大批量插入数据</h3><p>如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使 用MySQL数据库提供的load指令进行插入。操作如下：</p><p><img src="/mysql-02/image-20230319131426081.png" alt="image-20230319131426081"></p><p>可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</p><pre><code>-- 客户端连接服务端时，加上参数 -–local-infilemysql –-local-infile -u root -p-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关set global local_infile = 1;-- 执行load指令将准备好的数据，加载到表结构中load data local infile &#39;/root/sql1.log&#39; into table tb_user fieldsterminated by &#39;,&#39; lines terminated by &#39;\n&#39; ;</code></pre><p>主键顺序插入性能高于乱序插入</p><p>在load时，主键顺序插入性能高于乱序插入</p><h2 id="3-2-主键优化"><a href="#3-2-主键优化" class="headerlink" title="3.2 主键优化"></a>3.2 主键优化</h2><p>1). 数据组织方式</p><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表 (index organized table IOT)。</p><p><img src="/mysql-02/image-20230319131635559.png" alt="image-20230319131635559"></p><p>行数据，都是存储在聚集索引的叶子节点上的。</p><p><img src="/mysql-02/image-20230319131651509.png" alt="image-20230319131651509"></p><p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。 那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储 到下一个页中，页与页之间会通过指针连接。</p><p>2). 页分裂</p><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行 溢出)，根据主键排列。</p><p>A. 主键顺序插入效果</p><p>①. 从磁盘中申请页， 主键顺序插</p><p><img src="/mysql-02/image-20230319131730097.png" alt="image-20230319131730097"></p><p>②. 第一个页没有满，继续往第一页插入</p><p><img src="/mysql-02/image-20230319131743300.png" alt="image-20230319131743300"></p><p>③. 当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</p><p><img src="/mysql-02/image-20230319131755919.png" alt="image-20230319131755919"></p><p>④. 当第二页写满了，再往第三页写入</p><p><img src="/mysql-02/image-20230319131808096.png" alt="image-20230319131808096"></p><p>B. 主键乱序插入效果</p><p>①. 加入1#,2#页都已经写满了，存放了如图所示的数据</p><p><img src="/mysql-02/image-20230319131820529.png" alt="image-20230319131820529"></p><p>②. 此时再插入id为50的记录，会发生什么现象</p><p><img src="/mysql-02/image-20230319131849019.png" alt="image-20230319131849019"></p><p>不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。</p><p><img src="/mysql-02/image-20230319131901394.png" alt="image-20230319131901394"></p><p>但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。</p><p><img src="/mysql-02/image-20230319131913267.png" alt="image-20230319131913267"></p><p>但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。</p><p><img src="/mysql-02/image-20230319131934335.png" alt="image-20230319131934335"></p><p><img src="/mysql-02/image-20230319131941911.png" alt="image-20230319131941911"></p><p>移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个 页，应该是3#， 3#的下一个页是2#。 所以，此时，需要重新设置链表指针。</p><p>上述的这种现象，称之为 “页分裂”，是比较耗费性能的操作。</p><p>3). 页合并</p><p>目前表中已有数据的索引结构(叶子节点)如下：</p><p><img src="/mysql-02/image-20230319132139676.png" alt="image-20230319132139676"></p><p>对已有数据进行删除时，具体的效果如下: 当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间 变得允许被其他记录声明使用。</p><p><img src="/mysql-02/image-20230319132202748.png" alt="image-20230319132202748"></p><p>继续删除2#的数据记录</p><p><img src="/mysql-02/image-20230319132214171.png" alt="image-20230319132214171"></p><p><img src="/mysql-02/image-20230319132310575.png" alt="image-20230319132310575"></p><p>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前 或后）看看是否可以将两个页合并以优化空间使用。</p><p><img src="/mysql-02/image-20230319132502279.png" alt="image-20230319132502279"></p><p>删除数据，并将页合并之后，再次插入新的数据21，则直接插入3#页</p><p><img src="/mysql-02/image-20230319132513231.png" alt="image-20230319132513231"></p><p>这个里面所发生的合并页的这个现象，就称之为 “页合并”。</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</p><p>4). 索引设计原则</p><ul><li><p>满足业务需求的情况下，尽量降低主键的长度。</p></li><li><p>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键</p></li><li><p>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</p></li><li><p>业务操作时，避免对主键的修改。</p></li></ul><p><img src="/mysql-02/image-20230319132620948.png" alt="image-20230319132620948"></p><h2 id="3-3-order-by优化"><a href="#3-3-order-by优化" class="headerlink" title="3.3 order by优化"></a>3.3 order by优化</h2><p>MySQL的排序，有两种方式：</p><p>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p><p>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要 额外排序，操作效率高。</p><p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，在优化排序 操作时，尽量要优化为 Using index。</p><p>C. 创建索引</p><pre><code>-- 创建索引create index idx_user_age_phone_aa on tb_user(age,phone);</code></pre><p>D. 创建索引后，根据age, phone进行升序排序</p><pre><code>explain select id,age,phone from tb_user order by age;</code></pre><p><img src="/mysql-02/image-20230319133656461.png" alt="image-20230319133656461"></p><p><img src="/mysql-02/image-20230319133721578.png" alt="image-20230319133721578"></p><p>建立索引之后，再次进行排序查询，就由原来的Using filesort， 变为了 Using index，性能 就是比较高的了。</p><p>E. 创建索引后，根据age, phone进行降序排序</p><pre><code>explain select id,age,phone from tb_user order by age desc , phone desc ;</code></pre><p><img src="/mysql-02/image-20230319133749616.png" alt="image-20230319133749616"></p><p>也出现 Using index， 但是此时Extra中出现了 Backward index scan，这个代表反向扫描索 引，因为在MySQL中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序 时，是从大到小，所以，在扫描时，就是反向扫描，就会出现 Backward index scan。 在 MySQL8版本中，支持降序索引，我们也可以创建降序索引。</p><p>F. 根据phone，age进行升序排序，phone在前，age在后。</p><pre><code>explain select id,age,phone from tb_user order by phone , age</code></pre><p><img src="/mysql-02/image-20230319133818129.png" alt="image-20230319133818129"></p><p>排序时,也需要满足最左前缀法则,否则也会出现 filesort。因为在创建索引的时候， age是第一个 字段，phone是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现 Using filesort。</p><p>F. 根据age, phone进行降序一个升序，一个降序</p><pre><code>explain select id,age,phone from tb_user order by age asc , phone desc ;</code></pre><p><img src="/mysql-02/image-20230319133847158.png" alt="image-20230319133847158"></p><p>因为创建索引时，如果未指定顺序，默认都是按照升序排序的，而查询时，一个升序，一个降序，此时 就会出现Using filesort。</p><p><img src="/mysql-02/image-20230319133858645.png" alt="image-20230319133858645"></p><p>G. 创建联合索引(age 升序排序，phone 倒序排序)</p><pre><code>create index idx_user_age_phone_ad on tb_user(age asc ,phone desc);</code></pre><p><img src="/mysql-02/image-20230319134002511.png" alt="image-20230319134002511"></p><p>H. 然后再次执行如下SQL</p><pre><code>explain select id,age,phone from tb_user order by age asc , phone desc ;</code></pre><p><img src="/mysql-02/image-20230319134017143.png" alt="image-20230319134017143"></p><p>升序/降序联合索引结构图示:</p><p><img src="/mysql-02/image-20230319155114654.png" alt="image-20230319155114654"></p><p><img src="/mysql-02/image-20230319155120751.png" alt="image-20230319155120751"></p><p>由上述的测试,我们得出order by优化原则:</p><p>A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p><p>B. 尽量使用覆盖索引。</p><p>C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</p><p>D. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。</p><h2 id="3-4-group-by优化"><a href="#3-4-group-by优化" class="headerlink" title="3.4 group by优化"></a>3.4 group by优化</h2><p>在没有索引的情况下，执行如下SQL，查询执行计划：</p><pre><code>explain select profession , count(*) from tb_user group by profession ;</code></pre><p><img src="/mysql-02/image-20230319155255946.png" alt="image-20230319155255946"></p><p>针对于 profession ， age， status 创建一个联合索引。</p><pre><code>create index idx_user_pro_age_sta on tb_user(profession , age , status);</code></pre><p>再执行前面相同的SQL查看执行计划。</p><pre><code>explain select profession , count(*) from tb_user group by profession ;</code></pre><p><img src="/mysql-02/image-20230319155359691.png" alt="image-20230319155359691"></p><p><img src="/mysql-02/image-20230319155546400.png" alt="image-20230319155546400"></p><p><img src="/mysql-02/image-20230319155556578.png" alt="image-20230319155556578"></p><p>如果仅仅根据age分组，就会出现 Using temporary ；而如果是 根据 profession,age两个字段同时分组，则不会出现 Using temporary。原因是因为对于分组操作， 在联合索引中，也是符合最左前缀法则的。</p><p>所以，在分组操作中需要通过以下两点进行优化，以提升性能： </p><p>A. 在分组操作时，可以通过索引来提高效率。 </p><p>B. 分组操作时，索引的使用也是满足最左前缀法则的。</p><h2 id="3-5-limit优化"><a href="#3-5-limit优化" class="headerlink" title="3.5 limit优化"></a>3.5 limit优化</h2><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p><p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查 询形式进行优化。</p><pre><code> select * from tb_sku t , (select id from tb_sku order by idlimit 2000000,10) a where t.id = a.id;</code></pre><h2 id="3-6-count优化"><a href="#3-6-count优化" class="headerlink" title="3.6 count优化"></a>3.6 count优化</h2><h3 id="3-6-1-概述"><a href="#3-6-1-概述" class="headerlink" title="3.6.1 概述"></a>3.6.1 概述</h3><pre><code>select count(*) from tb_user ;</code></pre><ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(<em>) 的时候会直接返回这个 数，效率很高； 但是如果是带条件的count，MyISAM也慢。 I</em></li><li><em>nnoDB 引擎就麻烦了，它执行 count(</em>) 的时候，需要把数据一行一行地从引擎里面读出 来，然后累积计数。 </li></ul><p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数 据库进行,但是如果是带条件的count又比较麻烦了)。</p><h3 id="3-6-2-count用法"><a href="#3-6-2-count用法" class="headerlink" title="3.6.2 count用法"></a>3.6.2 count用法</h3><p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加，最后返回累计值。</p><p>用法：count（*）、count（主键）、count（字段）、count（数字）</p><table><thead><tr><th>count用 法</th><th>含义</th></tr></thead><tbody><tr><td>count(主 键)</td><td>InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。 服务层拿到主键后，直接按行进行累加(主键不可能为null)</td></tr><tr><td>count(字 段)</td><td>没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出 来，返回给服务层，服务层判断是否为null，不为null，计数累加。 有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返 回给服务层，直接按行进行累加。</td></tr><tr><td>count(数 字)</td><td>InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1” 进去，直接按行进行累加。</td></tr><tr><td>count(*)</td><td>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接 按行进行累加。</td></tr></tbody></table><p>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(<em>)，所以尽 量使用 count(</em>)。</p><h2 id="3-7-update优化"><a href="#3-7-update优化" class="headerlink" title="3.7 update优化"></a>3.7 update优化</h2><pre><code>update course set name = &#39;javaEE&#39; where id = 1 ;</code></pre><p>在执行删除的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放</p><p>但是当在执行如下SQL时:</p><pre><code>update course set name = &#39;SpringBoot&#39; where name = &#39;PHP&#39; </code></pre><p>开启多个事务，在执行上述的SQL时，行锁升级为了表锁。 导致该update语句的性能 大大降低。</p><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁 升级为表锁 。</p><h1 id="4-视图-存储过程-触发器"><a href="#4-视图-存储过程-触发器" class="headerlink" title="4.视图/存储过程/触发器"></a>4.视图/存储过程/触发器</h1><h2 id="4-1-视图"><a href="#4-1-视图" class="headerlink" title="4.1 视图"></a>4.1 视图</h2><h3 id="4-1-1-介绍"><a href="#4-1-1-介绍" class="headerlink" title="4.1.1 介绍"></a>4.1.1 介绍</h3><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视 图的查询中使用的表，并且是在使用视图时动态生成的。 通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><h3 id="4-1-2-语法"><a href="#4-1-2-语法" class="headerlink" title="4.1.2 语法"></a>4.1.2 语法</h3><p>1). 创建</p><pre><code>CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [CASCADED | LOCAL ] CHECK OPTION ]</code></pre><p>2). 查询</p><pre><code>查看创建视图语句：SHOW CREATE VIEW 视图名称;查看视图数据：SELECT * FROM 视图名称 ...... ;</code></pre><p>3). 修改</p><pre><code>方式一：CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH[ CASCADED | LOCAL ] CHECK OPTION ]方式二：ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED |LOCAL ] CHECK OPTION ]</code></pre><p>4). 删除</p><pre><code>DROP VIEW [IF EXISTS] 视图名称 [,视图名称] ..</code></pre><p>演示示例：</p><pre><code>-- 创建视图create or replace view stu_v_1 as select id,name from student where id &lt;= 10;-- 查询视图show create view stu_v_1;-- 修改视图create or replace view stu_v_1 as select id,name,no from student where id &lt;= 10;alter view stu_v_1 as select id,name from student where id &lt;= 10;-- 删除视图drop view if exists stu_v_1;</code></pre><p>通过视图来插入、更新数据</p><pre><code>create or replace view stu_v_1 as select id,name from student where id &lt;= 10 ;select * from stu_v_1;insert into stu_v_1 values(6,&#39;Tom&#39;);insert into stu_v_1 values(17,&#39;Tom22&#39;);</code></pre><p><img src="/mysql-02/image-20230319162630797.png" alt="image-20230319162630797"></p><p>因为在创建视图的时候，指定的条件为 id&lt;=10, id为17的数据，是不符合条件的，所以没有查 询出来，但是这条数据确实是已经成功的插入到了基表中。  </p><p>如果在定义视图时，如果指定了条件，然后在插入、修改、删除数据时，是否可以做到必须满足 条件才能操作，否则不能够操作呢？ 答案是可以的，这就需要借助于视图的检查选项了。</p><h3 id="4-1-3-检查选项"><a href="#4-1-3-检查选项" class="headerlink" title="4.1.3 检查选项"></a>4.1.3 检查选项</h3><p>当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插 入，更新，删除，以使其符合视图的定义。 MySQL允许基于另一个视图创建视图，它还会检查依赖视 图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项： CASCADED 和 LOCAL ，默认值为 CASCADED 。</p><p>1). CASCADED</p><p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 cascaded，但是v1视图 创建时未指定检查选项。 则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1。</p><p><img src="/mysql-02/image-20230319162933805.png" alt="image-20230319162933805"></p><p>2). LOCAL</p><p>本地。 </p><p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创 建时未指定检查选项。 则在执行检查时，只会检查v2，不会检查v2的关联视图v1。</p><p><img src="/mysql-02/image-20230319163019438.png" alt="image-20230319163019438"></p><h3 id="4-1-4-视图的更新"><a href="#4-1-4-视图的更新" class="headerlink" title="4.1.4 视图的更新"></a>4.1.4 视图的更新</h3><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一 项，则该视图不可更新：</p><p>A. 聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等） </p><p>B. DISTINCT</p><p> C. GROUP BY </p><p>D. HAVING </p><p>E. UNION 或者 UNION ALL</p><p>示例演示:</p><pre><code>create view stu_v_count as select count(*) from student;</code></pre><p>上述的视图中，就只有一个单行单列的数据，如果对这个视图进行更新或插入的，将会报错。</p><p><img src="/mysql-02/image-20230319163324871.png" alt="image-20230319163324871"></p><p><img src="/mysql-02/image-20230319163331287.png" alt="image-20230319163331287"></p><h3 id="4-1-5-视图作用"><a href="#4-1-5-视图作用" class="headerlink" title="4.1.5 视图作用"></a>4.1.5 视图作用</h3><p>1). 简单</p><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视 图，从而使得用户不必为以后的操作每次指定全部的条件。</p><h4 id="2-安全"><a href="#2-安全" class="headerlink" title="2). 安全"></a>2). 安全</h4><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见 到的数据</p><h4 id="3-数据独立"><a href="#3-数据独立" class="headerlink" title="3). 数据独立"></a>3). 数据独立</h4><p>视图可帮助用户屏蔽真实表结构变化带来的影响。</p><h3 id="4-1-6-案例"><a href="#4-1-6-案例" class="headerlink" title="4.1.6 案例"></a>4.1.6 案例</h3><p>1). 为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽 手机号和邮箱两个字段。</p><pre><code>create view tb_user_view as select id,name,profession,age,gender,status,createtimefrom tb_user;select * from tb_user_view;</code></pre><p>2). 查询每个学生所选修的课程（三张表联查），这个功能在很多的业务中都有使用到，为了简化操 作，定义一个视图。</p><pre><code>create view tb_stu_course_view as select s.name student_name , s.no student_no ,c.name course_name from student s, student_course sc , course c where s.id =sc.studentid and sc.courseid = c.id;select * from tb_stu_course_view;</code></pre><h2 id="4-2-存储过程"><a href="#4-2-存储过程" class="headerlink" title="4.2 存储过程"></a>4.2 存储过程</h2><h3 id="4-2-1-介绍"><a href="#4-2-1-介绍" class="headerlink" title="4.2.1 介绍"></a>4.2.1 介绍</h3><p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发 人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p><p><img src="/mysql-02/image-20230319164940096.png" alt="image-20230319164940096"></p><p>特点:</p><ul><li>封装，复用 ———————–&gt; 可以把某一业务SQL封装在存储过程中，需要用到 的时候直接调用即可。 </li><li>可以接收参数，也可以返回数据 ——–&gt; 再存储过程中，可以传递参数，也可以接收返回 值。 </li><li>减少网络交互，效率提升 ————-&gt; 如果涉及到多条SQL，每执行一次都是一次网络传 输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</li></ul><h3 id="4-2-2-基本语法"><a href="#4-2-2-基本语法" class="headerlink" title="4.2.2 基本语法"></a>4.2.2 基本语法</h3><p>1). 创建</p><pre><code>CREATE PROCEDURE 存储过程名称 ([ 参数列表 ])BEGIN-- SQL语句END ;</code></pre><p>2). 调用</p><pre><code>CALL 名称 ([ 参数 ]);</code></pre><p>3). 查看</p><pre><code>SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#39;xxx&#39;; -- 查询指定数据库的存储过程及状态信息SHOW CREATE PROCEDURE 存储过程名称 ; -- 查询某个存储过程的定义</code></pre><p>4). 删除</p><pre><code>DROP PROCEDURE [ IF EXISTS ] 存储过程名称 ；</code></pre><pre><code>在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的结束符。</code></pre><p>演示示例:</p><pre><code>-- 存储过程基本语法-- 创建create procedure p1()beginselect count(*) from student;end;-- 调用call p1();-- 查看select * from information_schema.ROUTINES where ROUTINE_SCHEMA = &#39;数据库名字&#39;;show create procedure p1;-- 删除drop procedure if exists p1;</code></pre><h3 id="4-2-3-变量"><a href="#4-2-3-变量" class="headerlink" title="4.2.3 变量"></a>4.2.3 变量</h3><p>在MySQL中变量分为三种类型: 系统变量、用户定义变量、局部变量。</p><h4 id="4-2-3-1-系统变量"><a href="#4-2-3-1-系统变量" class="headerlink" title="4.2.3.1 系统变量"></a>4.2.3.1 系统变量</h4><p>系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话 变量（SESSION）。</p><p>1). 查看系统变量</p><pre><code>SHOW [ SESSION | GLOBAL ] VARIABLES ; -- 查看所有系统变量SHOW [ SESSION | GLOBAL ] VARIABLES LIKE &#39;......&#39;; -- 可以通过LIKE模糊匹配方式查找变量SELECT @@[SESSION | GLOBAL] 系统变量名; -- 查看指定变量的值</code></pre><p>2). 设置系统变量</p><pre><code>SET [ SESSION | GLOBAL ] 系统变量名 = 值 ;SET @@[SESSION | GLOBAL]系统变量名 = 值 ;</code></pre><p>如果没有指定SESSION/GLOBAL，默认是SESSION，会话变量。</p><p>mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 /etc/my.cnf 中配置。</p><p>A. 全局变量(GLOBAL): 全局变量针对于所有的会话。 B. 会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。</p><p>演示示例:</p><pre><code>-- 查看系统变量show session variables ;show session variables like &#39;auto%&#39;;show global variables like &#39;auto%&#39;;select @@global.autocommit;select @@session.autocommit;-- 设置系统变量set session autocommit = 1;insert into course(id, name) VALUES (6, &#39;ES&#39;);set global autocommit = 0;select @@global.autocommit;</code></pre><h4 id="4-2-3-2-用户定义变量"><a href="#4-2-3-2-用户定义变量" class="headerlink" title="4.2.3.2 用户定义变量"></a>4.2.3.2 用户定义变量</h4><p>用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 “@变量 名” 使用就可以。其作用域为当前连接。 </p><p>1). 赋值 </p><p>方式一:</p><pre><code>SET @var_name = expr [, @var_name = expr] ... ;SET @var_name := expr [, @var_name := expr] ... ;</code></pre><p>赋值时，可以使用 = ，也可以使用 := 。</p><p>方式二:</p><pre><code>SELECT @var_name := expr [, @var_name := expr] ... ;SELECT 字段名 INTO @var_name FROM 表名;</code></pre><p>2). 使用</p><pre><code>SELECT @var_name ;</code></pre><p>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</p><p>演示示例:</p><pre><code>-- 赋值set @myname = &#39;ccc&#39;;set @myage := 10;set @mygender := &#39;男&#39;,@myhobby := &#39;java&#39;;select @mycolor := &#39;red&#39;;select count(*) into @mycount from tb_user;-- 使用select @myname,@myage,@mygender,@myhobby;select @mycolor , @mycount;</code></pre><h4 id="4-2-3-3-局部变量"><a href="#4-2-3-3-局部变量" class="headerlink" title="4.2.3.3 局部变量"></a>4.2.3.3 局部变量</h4><p>局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的 局部变量和输入参数，局部变量的范围是在其内声明的BEGIN … END块。</p><p>1). 声明</p><pre><code>DECLARE 变量名 变量类型 [DEFAULT ... ] ;</code></pre><p>变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。</p><p>2). 赋值</p><pre><code>SET 变量名 = 值 ;SET 变量名 := 值 ;SELECT 字段名 INTO 变量名 FROM 表名 ... ;</code></pre><p>演示示例:</p><pre><code>-- 声明局部变量 - declare-- 赋值create procedure p2()begindeclare stu_count int default 0;select count(*) into stu_count from student;select stu_count;end;call p2();</code></pre><h4 id="4-2-4-if"><a href="#4-2-4-if" class="headerlink" title="4.2.4 if"></a>4.2.4 if</h4><p>1). 介绍</p><p>if 用于做条件判断，具体的语法结构为：</p><pre><code>IF 条件1 THEN.....ELSEIF 条件2 THEN -- 可选.....ELSE -- 可选.....END IF;</code></pre><p>在if条件判断的结构中，ELSE IF 结构可以有多个，也可以没有。 ELSE结构可以有，也可以没有。</p><p>2). 案例</p><p> 根据定义的分数score变量，判定当前分数对应的分数等级。</p><p> score &gt;= 85分，等级为优秀。 </p><p>score &gt;= 60分 且 score &lt; 85分，等级为及格。</p><p> score &lt; 60分，等级为不及格。</p><pre><code>create procedure p3()begindeclare score int default 58;declare result varchar(10);if score &gt;= 85 thenset result := &#39;优秀&#39;;elseif score &gt;= 60 thenset result := &#39;及格&#39;;elseset result := &#39;不及格&#39;;end if;select result;end;call p3();</code></pre><h4 id="4-2-5-参数"><a href="#4-2-5-参数" class="headerlink" title="4.2.5 参数"></a>4.2.5 参数</h4><p>1). 介绍</p><p>参数的类型，主要分为以下三种：IN、OUT、INOUT。 具体的含义如下：</p><table><thead><tr><th>类型</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>IN</td><td>该类参数作为输入，也就是需要调用时传入值</td><td>默认</td></tr><tr><td>OUT</td><td>该类参数作为输出，也就是该参数可以作为返回值</td><td></td></tr><tr><td>INOUT</td><td>既可以作为输入参数，也可以作为输出参数</td><td></td></tr></tbody></table><p>用法：</p><pre><code>CREATE PROCEDURE 存储过程名称 ([ IN/OUT/INOUT 参数名 参数类型 ])BEGIN-- SQL语句END ;</code></pre><p>2). 案例</p><p>将传入的200分制的分数，进行换算，换算成百分制，然后返回。</p><pre><code>create procedure p5(inout score double)beginset score := score * 0.5;end;set @score = 198;call p5(@score);select @score;</code></pre><p>根据传入参数score，判定当前分数对应的分数等级，并返回。 </p><p>score &gt;= 85分，等级为优秀。 </p><p>score &gt;= 60分 且 score &lt; 85分，等级为及格。 </p><p>score &lt; 60分，等级为不及格。</p><pre><code>create procedure p4(in score int, out result varchar(10))beginif score &gt;= 85 thenset result := &#39;优秀&#39;;elseif score &gt;= 60 thenset result := &#39;及格&#39;;elseset result := &#39;不及格&#39;;end if;end;-- 定义用户变量 @result来接收返回的数据, 用户变量可以不用声明call p4(18, @result);select @result;</code></pre><h4 id="4-2-6-case"><a href="#4-2-6-case" class="headerlink" title="4.2.6 case"></a>4.2.6 case</h4><p>1). 介绍 case结构及作用。有两种语法格式： 语法1：</p><pre><code>-- 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，执行statement_list2， 否则就执行 statement_listCASE case_valueWHEN when_value1 THEN statement_list1[ WHEN when_value2 THEN statement_list2] ...[ ELSE statement_list ]END CASE;</code></pre><p>语法2：</p><pre><code>-- 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成立时，执行statement_list2， 否则就执行 statement_listCASEWHEN search_condition1 THEN statement_list1[WHEN search_condition2 THEN statement_list2] ...[ELSE statement_list]END CASE;</code></pre><p>如果判定条件有多个，多个条件之间，可以使用 and 或 or 进行连接。</p><h4 id="4-2-7-while"><a href="#4-2-7-while" class="headerlink" title="4.2.7 while"></a>4.2.7 while</h4><p>1). 介绍</p><p>while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</p><pre><code>-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑WHILE 条件 DOSQL逻辑...END WHILE;</code></pre><h4 id="4-2-8-repeat"><a href="#4-2-8-repeat" class="headerlink" title="4.2.8 repeat"></a>4.2.8 repeat</h4><p>1). 介绍</p><p>repeat是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环 。具体语法为：</p><pre><code>-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环REPEATSQL逻辑...UNTIL 条件END REPEAT;</code></pre><h4 id="4-2-9-loop"><a href="#4-2-9-loop" class="headerlink" title="4.2.9 loop"></a>4.2.9 loop</h4><p>1). 介绍</p><p>LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。 LOOP可以配合一下两个语句使用： </p><p>LEAVE ：配合循环使用，退出循环。 </p><p>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</p><pre><code>[begin_label:] LOOPSQL逻辑...END LOOP [end_label];</code></pre><pre><code>LEAVE label; -- 退出指定标记的循环体ITERATE label; -- 直接进入下一次循环</code></pre><p>上述语法中出现的 begin_label，end_label，label 指的都是自定义的标记。</p><p>2). 案例一</p><p>计算从1累加到n的值，n为传入的参数值。</p><pre><code>-- A. 定义局部变量, 记录累加之后的值;-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xxcreate procedure p9(in n int)begindeclare total int default 0;sum:loopif n&lt;=0 thenleave sum;end if;set total := total + n;set n := n - 1;end loop sum;select total;end;call p9(100);</code></pre><p>3). 案例二</p><p>计算从1到n之间的偶数累加的值，n为传入的参数值。</p><pre><code>-- A. 定义局部变量, 记录累加之后的值;-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xx-- C. 如果当次累加的数据是奇数, 则直接进入下一次循环. --------&gt; iterate xxcreate procedure p10(in n int)begindeclare total int default 0;sum:loopif n&lt;=0 thenleave sum;end if;if n%2 = 1 thenset n := n - 1;iterate sum;end if;set total := total + n;set n := n - 1;end loop sum;select total;end;call p10(100);</code></pre><h4 id="4-2-10-游标"><a href="#4-2-10-游标" class="headerlink" title="4.2.10 游标"></a>4.2.10 游标</h4><p>1). 介绍 游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进 行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p><p>A. 声明游标</p><pre><code>DECLARE 游标名称 CURSOR FOR 查询语句 ;</code></pre><p>B. 打开游标</p><pre><code> OPEN 游标名称 ;</code></pre><p>C. 获取游标记录</p><pre><code>FETCH 游标名称 INTO 变量 [, 变量 ] ;</code></pre><p>D. 关闭游标</p><pre><code>CLOSE 游标名称 ;</code></pre><p>2). 案例</p><p>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名 （name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表 (id,name,profession)中。</p><pre><code>-- 逻辑:-- A. 声明游标, 存储查询结果集-- B. 准备: 创建表结构-- C. 开启游标-- D. 获取游标中的记录-- E. 插入数据到新表中-- F. 关闭游标create procedure p11(in uage int)begindeclare uname varchar(100);declare upro varchar(100);declare u_cursor cursor for select name,profession from tb_user where age &lt;=uage;drop table if exists tb_user_pro;create table if not exists tb_user_pro(id int primary key auto_increment,name varchar(100),profession varchar(100));open u_cursor;while true dofetch u_cursor into uname,upro;insert into tb_user_pro values (null, uname, upro);end while;close u_cursor;end;call p11(30)；</code></pre><p>上述的存储过程，最终我们在调用的过程中，会报错，之所以报错是因为上面的while循环中，并没有 退出条件。当游标的数据集获取完毕之后，再次获取数据，就会报错，从而终止了程序的执行。</p><p><img src="/mysql-02/image-20230319172816754.png" alt="image-20230319172816754"></p><p>但是此时，tb_user_pro表结构及其数据都已经插入成功了，可以直接刷新表结构，检查表结构 中的数据。</p><p><img src="/mysql-02/image-20230319172837052.png" alt="image-20230319172837052"></p><p>要想解决这个问题，就需要通过MySQL中提供的 条件处理程序 Handle（条件处理程序）来解决。</p><h4 id="4-2-11-条件处理程序"><a href="#4-2-11-条件处理程序" class="headerlink" title="4.2.11 条件处理程序"></a>4.2.11 条件处理程序</h4><p>1). 介绍</p><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体 语法为</p><pre><code>DECLARE handler_action HANDLER FOR condition_value [, condition_value]... statement ;handler_action 的取值：CONTINUE: 继续执行当前程序EXIT: 终止执行当前程序condition_value 的取值：SQLSTATE sqlstate_value: 状态码，如 02000SQLWARNING: 所有以01开头的SQLSTATE代码的简写NOT FOUND: 所有以02开头的SQLSTATE代码的简写SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写</code></pre><p>2). 案例</p><p>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名 （name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表 (id,name,profession)中。</p><p>A. 通过SQLSTATE指定具体的状态码</p><pre><code>-- 逻辑:-- A. 声明游标, 存储查询结果集-- B. 准备: 创建表结构-- C. 开启游标-- D. 获取游标中的记录-- E. 插入数据到新表中-- F. 关闭游标create procedure p11(in uage int)begindeclare uname varchar(100);declare upro varchar(100);declare u_cursor cursor for select name,profession from tb_user where age &lt;=uage;-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02000时，将关闭游标u_cursor，并退出declare exit handler for SQLSTATE &#39;02000&#39; close u_cursor;drop table if exists tb_user_pro;create table if not exists tb_user_pro(id int primary key auto_increment,name varchar(100),profession varchar(100));open u_cursor;while true dofetch u_cursor into uname,upro;insert into tb_user_pro values (null, uname, upro);end while;close u_cursor;end;call p11(30);</code></pre><p>B. 通过SQLSTATE的代码简写方式 NOT FOUND</p><p>02 开头的状态码，代码简写为 NOT FOUND</p><pre><code>create procedure p12(in uage int)begindeclare uname varchar(100);declare upro varchar(100);declare u_cursor cursor for select name,profession from tb_user where age &lt;=uage;-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02开头时，将关闭游标u_cursor，并退出declare exit handler for not found close u_cursor;drop table if exists tb_user_pro;create table if not exists tb_user_pro(id int primary key auto_increment,name varchar(100),profession varchar(100));open u_cursor;while true dofetch u_cursor into uname,upro;insert into tb_user_pro values (null, uname, upro);end while;close u_cursor;end;call p12(30);</code></pre><p>具体的错误状态码，可以参考官方文档：</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html" target="_blank" rel="noopener">MySQL :: MySQL 8.0 Reference Manual :: 13.6.7.2 DECLARE … HANDLER Statement</a></p><p><a href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html" target="_blank" rel="noopener">MySQL :: MySQL 8.0 Error Reference :: 2 Server Error Message Reference</a></p><h2 id="4-3-存储函数"><a href="#4-3-存储函数" class="headerlink" title="4.3 存储函数"></a>4.3 存储函数</h2><p>1). 介绍 存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：</p><pre><code>CREATE FUNCTION 存储函数名称 ([ 参数列表 ])RETURNS type [characteristic ...]BEGIN-- SQL语句RETURN ...;END ;</code></pre><p>characteristic说明： </p><ul><li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li><li>NO SQL ：不包含 SQL 语句。 </li><li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。</li></ul><p>2). 案例</p><p>计算从1累加到n的值，n为传入的参数值。</p><pre><code>create function fun1(n int)returns int deterministicbegindeclare total int default 0;while n&gt;0 doset total := total + n;set n := n - 1;end while;return total;end;select fun1(50)</code></pre><p>在mysql8.0版本中binlog默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定 characteristic特性，否则就会报如下错误：</p><p><img src="/mysql-02/image-20230319174608555.png" alt="image-20230319174608555"></p><h2 id="4-4-触发器"><a href="#4-4-触发器" class="headerlink" title="4.4 触发器"></a>4.4 触发器</h2><h3 id="4-4-1-介绍"><a href="#4-4-1-介绍" class="headerlink" title="4.4.1 介绍"></a>4.4.1 介绍</h3><p>触发器是与表有关的数据库对象，指在insert/update/delete之前(BEFORE)或之后(AFTER)，触 发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。 使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还 只支持行级触发，不支持语句级触发。</p><table><thead><tr><th>触发器类型</th><th>NEW 和 OLD</th></tr></thead><tbody><tr><td>INSERT 型触发器</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE 型触发器</td><td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td></tr><tr><td>DELETE 型触发器</td><td>OLD 表示将要或者已经删除的数据</td></tr></tbody></table><h3 id="4-4-2-语法"><a href="#4-4-2-语法" class="headerlink" title="4.4.2 语法"></a>4.4.2 语法</h3><p>1). 创建</p><pre><code>CREATE TRIGGER trigger_nameBEFORE/AFTER INSERT/UPDATE/DELETEON tbl_name FOR EACH ROW -- 行级触发器BEGINtrigger_stmt ;END;</code></pre><p>2). 查看</p><pre><code>SHOW TRIGGERS ;</code></pre><p>3). 删除</p><pre><code>DROP TRIGGER [schema_name.]trigger_name ; -- 如果没有指定 schema_name，默认为当前数据库 。</code></pre><h3 id="4-4-3-案例"><a href="#4-4-3-案例" class="headerlink" title="4.4.3 案例"></a>4.4.3 案例</h3><p>通过触发器记录 tb_user 表的数据变更日志，将变更日志插入到日志表user_logs中, 包含增加, 修改 , 删除 ; 表结构准备:</p><pre><code>-- 准备工作 : 日志表 user_logscreate table user_logs(id int(11) not null auto_increment,operation varchar(20) not null comment &#39;操作类型, insert/update/delete&#39;,operate_time datetime not null comment &#39;操作时间&#39;,operate_id int(11) not null comment &#39;操作的ID&#39;,operate_params varchar(500) comment &#39;操作参数&#39;,primary key(`id`))engine=innodb default charset=utf8;</code></pre><p>A. 插入数据触发器</p><pre><code>create trigger tb_user_insert_triggerafter insert on tb_user for each rowbegininsert into user_logs(id, operation, operate_time, operate_id, operate_params)VALUES(null, &#39;insert&#39;, now(), new.id, concat(&#39;插入的数据内容为:id=&#39;,new.id,&#39;,name=&#39;,new.name, &#39;, phone=&#39;, NEW.phone, &#39;, email=&#39;, NEW.email, &#39;,profession=&#39;, NEW.profession));end;</code></pre><p>测试:</p><pre><code>-- 查看show triggers ;-- 插入数据到tb_userinsert into tb_user(id, name, phone, email, profession, age, gender, status,createtime) VALUES (26,&#39;三皇子&#39;,&#39;18809091212&#39;,&#39;erhuangzi@163.com&#39;,&#39;软件工程&#39;,23,&#39;1&#39;,&#39;1&#39;,now());</code></pre><p>测试完毕之后，检查日志表中的数据是否可以正常插入，以及插入数据的正确性。</p><p>B. 修改数据触发器</p><pre><code>create trigger tb_user_update_triggerafter update on tb_user for each rowbegininsert into user_logs(id, operation, operate_time, operate_id, operate_params)VALUES(null, &#39;update&#39;, now(), new.id,concat(&#39;更新之前的数据: id=&#39;,old.id,&#39;,name=&#39;,old.name, &#39;, phone=&#39;,old.phone, &#39;, email=&#39;, old.email, &#39;, profession=&#39;, old.profession,&#39; | 更新之后的数据: id=&#39;,new.id,&#39;,name=&#39;,new.name, &#39;, phone=&#39;,NEW.phone, &#39;, email=&#39;, NEW.email, &#39;, profession=&#39;, NEW.profession));end;</code></pre><p>测试:</p><pre><code>-- 查看show triggers ;-- 更新update tb_user set profession = &#39;会计&#39; where id = 23;update tb_user set profession = &#39;会计&#39; where id &lt;= 5;</code></pre><p>测试完毕之后，检查日志表中的数据是否可以正常插入，以及插入数据的正确性。</p><p>C. 删除数据触发器</p><pre><code>create trigger tb_user_delete_triggerafter delete on tb_user for each rowbegininsert into user_logs(id, operation, operate_time, operate_id, operate_params)VALUES(null, &#39;delete&#39;, now(), old.id,concat(&#39;删除之前的数据: id=&#39;,old.id,&#39;,name=&#39;,old.name, &#39;, phone=&#39;,old.phone, &#39;, email=&#39;, old.email, &#39;, profession=&#39;, old.profession));end;</code></pre><p>测试:</p><pre><code>-- 查看show triggers ;-- 删除数据delete from tb_user where id = 26;</code></pre><h1 id="5-锁"><a href="#5-锁" class="headerlink" title="5.锁"></a>5.锁</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、 RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有 效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个 角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><pre><code>全局锁：锁定数据库中的所有表。表级锁：每次操作锁住整张表。行级锁：每次操作锁住对应的行数据。</code></pre><h2 id="5-2-全局锁"><a href="#5-2-全局锁" class="headerlink" title="5.2 全局锁"></a>5.2 全局锁</h2><h3 id="5-2-1-介绍"><a href="#5-2-1-介绍" class="headerlink" title="5.2.1 介绍"></a>5.2.1 介绍</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语 句，已经更新操作的事务提交语句都将被阻塞。 其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整 性。</p><p>不加全局锁，可能存在的问题。</p><p><img src="/mysql-02/image-20230319183403451.png" alt="image-20230319183403451"></p><ul><li>在进行数据备份时，先备份了tb_stock库存表。</li><li>然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入 tb_order表）。</li><li>然后再执行备份 tb_order表的逻辑。 </li><li>业务中执行插入订单日志操作。 </li><li>最后，又备份了tb_orderlog表。</li></ul><p>此时备份出来的数据，是存在问题的。因为备份出来的数据，tb_stock表与tb_order表的数据不一 致(有最新操作的订单信息,但是库存数没减)。</p><p>那如何来规避这种问题呢? 此时就可以借助于MySQL的全局锁来解决。</p><p>B. 再来分析一下加了全局锁后的情况</p><p><img src="/mysql-02/image-20230319184239125.png" alt="image-20230319184239125"></p><p>对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、 DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。 那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性 和完整性</p><h3 id="5-2-2-语法"><a href="#5-2-2-语法" class="headerlink" title="5.2.2 语法"></a>5.2.2 语法</h3><p>1). 加全局锁</p><pre><code>flush tables with read lock ;</code></pre><p>2). 数据备份</p><pre><code>mysqldump -uroot –p1234 备份的数据库名 &gt; 备份到的名称.sql</code></pre><p>3). 释放锁</p><pre><code>unlock tables ;</code></pre><h3 id="5-2-3-特点"><a href="#5-2-3-特点" class="headerlink" title="5.2.3 特点"></a>5.2.3 特点</h3><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导 致主从延迟。 </li></ul><p>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致 性数据备份。</p><pre><code>mysqldump --single-transaction -uroot –p123456 备份的数据库名 &gt; 备份到的名称.sql</code></pre><h2 id="5-3-表级锁"><a href="#5-3-表级锁" class="headerlink" title="5.3 表级锁"></a>5.3 表级锁</h2><h3 id="5-3-1-介绍"><a href="#5-3-1-介绍" class="headerlink" title="5.3.1 介绍"></a>5.3.1 介绍</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、 InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ul><li>表锁 </li><li>元数据锁（meta data lock，MDL） </li><li>意向锁</li></ul><h3 id="5-3-2-表锁"><a href="#5-3-2-表锁" class="headerlink" title="5.3.2 表锁"></a>5.3.2 表锁</h3><p>对于表锁，分为两类：</p><ul><li>表共享读锁（read lock） </li><li>表独占写锁（write lock）</li></ul><p>语法： </p><p>加锁：lock tables 表名… read/write。 </p><p>释放锁：unlock tables / 客户端断开连接 。</p><p>特点:</p><p>A. 读锁</p><p><img src="/mysql-02/image-20230319185630541.png" alt="image-20230319185630541"></p><p><img src="/mysql-02/image-20230319185720262.png" alt="image-20230319185720262"></p><p>B. 写锁</p><p><img src="/mysql-02/image-20230319185826564.png" alt="image-20230319185826564"></p><p>左侧为客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写。</p><p><img src="/mysql-02/image-20230319185842742.png" alt="image-20230319185842742"></p><p>读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞 其他客户端的写。</p><h3 id="5-3-3-元数据锁"><a href="#5-3-3-元数据锁" class="headerlink" title="5.3.3 元数据锁"></a>5.3.3 元数据锁</h3><p>meta data lock , 元数据锁，简写MDL。</p><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维 护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与 DDL冲突，保证读写的正确性。 </p><p>这里的元数据，可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务 时，是不能够修改这张表的表结构的。</p><p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变 更操作的时候，加MDL写锁(排他)</p><p>常见的SQL操作时，所添加的元数据锁</p><table><thead><tr><th>对应SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td>lock tables xxx read / write</td><td>SHARED_READ_ONLY / SHARED_NO_READ_WRITE</td><td></td></tr><tr><td>select 、select … lock in share mode</td><td>SHARED_READ</td><td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td></tr><tr><td>insert 、update、 delete、select … for update</td><td>SHARED_WRITE</td><td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td></tr><tr><td>alter table …</td><td>EXCLUSIVE</td><td>与其他的MDL都互斥</td></tr></tbody></table><p>演示：</p><p> 当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ / SHARED_WRITE），之间是兼容的。</p><p><img src="/mysql-02/image-20230319192508226.png" alt="image-20230319192508226"></p><p>当执行SELECT语句时，添加的是元数据共享锁（SHARED_READ），会阻塞元数据排他锁 （EXCLUSIVE），之间是互斥的。</p><p><strong><img src="/mysql-02/image-20230319210202353.png" alt="image-20230319210202353"></strong></p><h3 id="5-3-4-意向锁"><a href="#5-3-4-意向锁" class="headerlink" title="5.3.4 意向锁"></a>5.3.4 意向锁</h3><p>1). 介绍</p><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行 数据是否加锁，使用意向锁来减少表锁的检查。</p><p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一 下：</p><p>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。</p><p><img src="/mysql-02/image-20230319210333562.png" alt="image-20230319210333562"></p><p>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就 会从第一行数据，检查到最后一行数据，效率较低。</p><p><img src="/mysql-02/image-20230319210346840.png" alt="image-20230319210346840"></p><p>有了意向锁之后 :</p><p>客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。</p><p><img src="/mysql-02/image-20230319210406968.png" alt="image-20230319210406968"></p><p>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而 不用逐行判断行锁情况了。</p><p><img src="/mysql-02/image-20230319210613130.png" alt="image-20230319210613130"></p><p>2). 分类</p><ul><li>意向共享锁(IS): 由语句select … lock in share mode添加 。 与 表锁共享锁 (read)兼容，与表锁排他锁(write)互斥。</li><li>意向排他锁(IX): 由insert、update、delete、select…for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</li></ul><p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><pre><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data fromperformance_schema.data_locks;</code></pre><p>A. 意向共享锁与表读锁是兼容的</p><p><img src="/mysql-02/image-20230319210911250.png" alt="image-20230319210911250"></p><p>B. 意向排他锁与表读锁、写锁都是互斥的</p><p><img src="/mysql-02/image-20230319210922329.png" alt="image-20230319210922329"></p><h2 id="5-4-行级锁"><a href="#5-4-行级锁" class="headerlink" title="5.4 行级锁"></a>5.4 行级锁</h2><h3 id="5-4-1-介绍"><a href="#5-4-1-介绍" class="headerlink" title="5.4.1 介绍"></a>5.4.1 介绍</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的 锁。对于行级锁，主要分为以下三类</p><p>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在 RC、RR隔离级别下都支持。</p><p><img src="/mysql-02/image-20230319211512113.png" alt="image-20230319211512113"></p><p>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事 务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</p><p><img src="/mysql-02/image-20230319211522999.png" alt="image-20230319211522999"></p><p>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。 在RR隔离级别下支持。</p><p><img src="/mysql-02/image-20230319211611369.png" alt="image-20230319211611369"></p><h3 id="5-4-2-行锁"><a href="#5-4-2-行锁" class="headerlink" title="5.4.2 行锁"></a>5.4.2 行锁</h3><p>1). 介绍</p><p>InnoDB实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。 </li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他 锁。</li></ul><p>两种行锁的兼容情况如下:</p><p><img src="/mysql-02/image-20230319212308484.png" alt="image-20230319212308484"></p><p>常见的SQL语句，在执行时，所加的行锁如下：</p><table><thead><tr><th>SQL</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td>INSERT …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>UPDATE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>DELETE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>SELECT（正常）</td><td>不加任何 锁</td><td></td></tr><tr><td>SELECT … LOCK IN SHARE MODE</td><td>共享锁</td><td>需要手动在SELECT之后加LOCK IN SHARE MODE</td></tr><tr><td>SELECT … FOR UPDATE</td><td>排他锁</td><td>需要手动在SELECT之后加FOR UPDATE</td></tr></tbody></table><p>2). 演示</p><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜 索和索引扫描，以防止幻读。</p><ul><li><p>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p></li><li><p>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记 录加锁，此时 就会升级为表锁。</p></li></ul><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><pre><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data fromperformance_schema.data_locks;</code></pre><p>示例演示 数据准备:</p><pre><code>CREATE TABLE `stu` (`id` int NOT NULL PRIMARY KEY AUTO_INCREMENT,`name` varchar(255) DEFAULT NULL,`age` int NOT NULL) ENGINE = InnoDB CHARACTER SET = utf8mb4;INSERT INTO `stu` VALUES (1, &#39;tom&#39;, 1);INSERT INTO `stu` VALUES (3, &#39;cat&#39;, 3);INSERT INTO `stu` VALUES (8, &#39;rose&#39;, 8);INSERT INTO `stu` VALUES (11, &#39;jetty&#39;, 11);INSERT INTO `stu` VALUES (19, &#39;lily&#39;, 19);INSERT INTO `stu` VALUES (25, &#39;luci&#39;, 25);</code></pre><p>A. 普通的select语句，执行时，不会加锁。</p><p><img src="/mysql-02/image-20230319213654433.png" alt="image-20230319213654433"></p><p>B. select…lock in share mode，加共享锁，共享锁与共享锁之间兼容。</p><p><img src="/mysql-02/image-20230319213856151.png" alt="image-20230319213856151"></p><p>共享锁与排他锁之间互斥。</p><p><img src="/mysql-02/image-20230319213929646.png" alt="image-20230319213929646"></p><p>客户端一获取的是id为1这行的共享锁，客户端二是可以获取id为3这行的排它锁的，因为不是同一行 数据。 而如果客户端二想获取id为1这行的排他锁，会处于阻塞状态，以为共享锁与排他锁之间互 斥。</p><p>C. 排它锁与排他锁之间互斥</p><p><img src="/mysql-02/image-20230319213947892.png" alt="image-20230319213947892"></p><p>当客户端一，执行update语句，会为id为1的记录加排他锁； 客户端二，如果也执行update语句更 新id为1的数据，也要为id为1的数据加排他锁，但是客户端二会处于阻塞状态，因为排他锁之间是互 斥的。 直到客户端一，把事务提交了，才会把这一行的行锁释放，此时客户端二，解除阻塞。</p><p>D. 无索引行锁升级为表锁</p><p>stu表中数据如下:</p><p><img src="/mysql-02/image-20230319214028644.png" alt="image-20230319214028644"></p><p><img src="/mysql-02/image-20230319214319115.png" alt="image-20230319214319115"></p><p>在客户端一中，开启事务，并执行update语句，更新name为Lily的数据，也就是id为19的记录 。 然后在客户端二中更新id为3的记录，却不能直接执行，会处于阻塞状态，为什么呢？ 原因就是因为此时，客户端一，根据name字段进行更新时，name字段是没有索引的，如果没有索引， 此时行锁会升级为表锁(因为行锁是对索引项加的锁，而name没有索引)。</p><p>针对name字段建立索引，索引建立之后，再次做一个测试：</p><p><img src="/mysql-02/image-20230319214352192.png" alt="image-20230319214352192"></p><p>客户端一，开启事务，然后依然是根据name进行更新。而客户端二，在更新id为3 的数据时，更新成功，并未进入阻塞状态。 这样就说明，根据索引字段进行更新操作，就可以避 免行锁升级为表锁的情况。</p><h3 id="5-4-3-间隙锁-amp-临键锁"><a href="#5-4-3-间隙锁-amp-临键锁" class="headerlink" title="5.4.3 间隙锁&amp;临键锁"></a>5.4.3 间隙锁&amp;临键锁</h3><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key（临键锁） 锁进行搜 索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。 </li><li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。 </li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li></ul><p>间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会 阻止另一个事务在同一间隙上采用间隙锁。</p><p><img src="/mysql-02/image-20230319215902885.png" alt="image-20230319215902885"></p><p>B. 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。 </p><p>InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，要根据这个二级索引查询值 为18的数据，并加上共享锁，只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个 结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也 就是29）。此时会对18加临键锁，并对29之前的间隙加锁。</p><p><img src="/mysql-02/image-20230319220818787.png" alt="image-20230319220818787"></p><p><img src="/mysql-02/image-20230319220847147.png" alt="image-20230319220847147"></p><p>C. 索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</p><p><img src="/mysql-02/image-20230319221216040.png" alt="image-20230319221216040"></p><p>查询的条件为id&gt;=19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部 分：[19] (19,25] (25,+∞]</p><p>所以数据库数据在加锁是，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临 键锁(正无穷及之前的间隙)。</p><h1 id="6-InnoDB引擎"><a href="#6-InnoDB引擎" class="headerlink" title="6.InnoDB引擎"></a>6.InnoDB引擎</h1><h2 id="6-1-逻辑存储结构"><a href="#6-1-逻辑存储结构" class="headerlink" title="6.1 逻辑存储结构"></a>6.1 逻辑存储结构</h2><p>InnoDB的逻辑存储结构如下图所示:</p><p><img src="/mysql-02/image-20230319221704166.png" alt="image-20230319221704166"></p><p>1). 表空间</p><p>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在 8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空 间，用于存储记录、索引等数据。</p><p>2). 段</p><p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段 （Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的 非叶子节点。段用来管理多个Extent（区）。</p><p>3). 区</p><p>区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一 个区中一共有64个连续的页。</p><p>4). 页</p><p>页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性， InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p><p>5). 行</p><p>行，InnoDB 存储引擎数据是按行进行存放的。 在行中，默认有两个隐藏字段： Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。 Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个 隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p><h2 id="6-2-架构"><a href="#6-2-架构" class="headerlink" title="6.2 架构"></a>6.2 架构</h2><h3 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1 概述"></a>6.2.1 概述</h3><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发 中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p><p><img src="/mysql-02/image-20230319223436173.png" alt="image-20230319223436173"></p><h3 id="6-2-2-内存结构"><a href="#6-2-2-内存结构" class="headerlink" title="6.2.2 内存结构"></a>6.2.2 内存结构</h3><p><img src="/mysql-02/image-20230319223451003.png" alt="image-20230319223451003"></p><p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。</p><p>1). Buffer Pool</p><p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能 弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁 盘I/O。</p><p>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及 InnoDB的锁信息等等。</p><p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增 删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频 率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型： </p><p>• free page：空闲page，未被使用。</p><p> • clean page：被使用page，数据没有被修改过。</p><p> • dirty page：脏页，被使用page，数据被修改过，其中数据与磁盘的数据产生了不一致。</p><p>在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。参数设置： show variables like ‘innodb_buffer_pool_size’;</p><p><img src="/mysql-02/image-20230319225434479.png" alt="image-20230319225434479"></p><p>2). Change Buffer</p><p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page 没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer 中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p>Change Buffer的意义</p><p><img src="/mysql-02/image-20230319225518087.png" alt="image-20230319225518087"></p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新 可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了 ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p><p>3). Adaptive Hash Index</p><p>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持 hash索引，但是给我们提供了一个功能就是这个自适应hash索引。hash索引在 进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需 要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。 InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度， 则建立hash索引，称之为自适应hash索引</p><p>适应哈希索引，无需人工干预，是系统根据情况自动完成。</p><p>参数： adaptive_hash_index</p><p>4). Log Buffer</p><p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log）， 默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事 务，增加日志缓冲区的大小可以节省磁盘 I/O。 </p><p>参数: </p><p>innodb_log_buffer_size：缓冲区大小 </p><p>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：</p><p> 1: 日志在每次事务提交时写入并刷新到磁盘，默认值。</p><p> 0: 每秒将日志写入并刷新到磁盘一次</p><p>2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</p><h3 id="6-2-3-磁盘结构"><a href="#6-2-3-磁盘结构" class="headerlink" title="6.2.3 磁盘结构"></a>6.2.3 磁盘结构</h3><p><img src="/mysql-02/image-20230319225851507.png" alt="image-20230319225851507"></p><p>1). System Tablespace</p><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建 的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等) </p><p>参数：innodb_data_file_path</p><p><img src="/mysql-02/image-20230319225941139.png" alt="image-20230319225941139"></p><p>系统表空间，默认的文件名叫 ibdata1。</p><p>2). File-Per-Table Tablespaces</p><p>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索 引 ，并存储在文件系统上的单个数据文件中。 开关参数：innodb_file_per_table ，该参数默认开启。</p><p><img src="/mysql-02/image-20230319230007205.png" alt="image-20230319230007205"></p><p>那也就是说，每创建一个表，都会产生一个表空间文件，如图：</p><p><img src="/mysql-02/image-20230319230041529.png" alt="image-20230319230041529"></p><p>3). General Tablespaces</p><p>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空 间。</p><p>A. 创建表空间、</p><pre><code>CREATE TABLESPACE ts_name ADD DATAFILE &#39;file_name&#39; ENGINE = engine_name;</code></pre><p><img src="/mysql-02/image-20230319230149322.png" alt="image-20230319230149322"></p><p>B. 创建表时指定表空间</p><pre><code>CREATE TABLE xxx ... TABLESPACE ts_name；</code></pre><p><img src="/mysql-02/image-20230319230236014.png" alt="image-20230319230236014"></p><p>4). Undo Tablespaces</p><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储 undo log日志。</p><p>5). Temporary Tablespaces</p><p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><p>6). Doublewrite Buffer Files</p><p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件 中，便于系统异常时恢复数据。</p><p><img src="/mysql-02/image-20230319230341360.png" alt="image-20230319230341360"></p><p>7). Redo Log</p><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所 有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。 以循环方式写入重做日志文件，涉及两个文件：</p><p><img src="/mysql-02/image-20230319232634292.png" alt></p><p><img src="/mysql-02/image-20230319232657863.png" alt="image-20230319232657863"></p><h3 id="6-2-4-后台线程"><a href="#6-2-4-后台线程" class="headerlink" title="6.2.4 后台线程"></a>6.2.4 后台线程</h3><p><img src="/mysql-02/image-20230319232718514.png" alt="image-20230319232718514"></p><p>在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、 Page Cleaner Thread。</p><p>1). Master Thread 核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性， 还包括脏页的刷新、合并插入缓存、undo页的回收 。</p><p> 2). IO Thread 在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。</p><table><thead><tr><th>线程类型</th><th>默认个数</th><th>职责</th></tr></thead><tbody><tr><td>Read thread</td><td>4</td><td>负责读操作</td></tr><tr><td>Write thread</td><td>4</td><td>负责写操作</td></tr><tr><td>Log thread</td><td>1</td><td>负责将日志缓冲区刷新到磁盘</td></tr><tr><td>Insert buffer thread</td><td>1</td><td>负责将写缓冲区内容刷新到磁盘</td></tr></tbody></table><p>可以通过以下的这条指令，查看到InnoDB的状态信息，其中就包含IO Thread信息</p><pre><code>show engine innodb status \G;</code></pre><p><img src="/mysql-02/image-20230319233258967.png" alt="image-20230319233258967"></p><p>3). Purge Thread</p><p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回 收。</p><p>4). Page Cleaner Thread</p><p>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻 塞。</p><h2 id="6-3-事务原理"><a href="#6-3-事务原理" class="headerlink" title="6.3 事务原理"></a>6.3 事务原理</h2><p>1). 事务 事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>2). 特性</p><ul><li><p>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 </p></li><li><p>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</p></li><li><p>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。 </p></li><li><p>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p></li></ul><p>对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的 两份日志来保证的，一份是redo log日志，一份是undo log日志。 而持久性是通过数据库的锁， 加上MVCC来保证的。</p><p><img src="/mysql-02/image-20230320125859308.png" alt="image-20230320125859308"></p><h3 id="6-3-2-redo-log"><a href="#6-3-2-redo-log" class="headerlink" title="6.3.2 redo log"></a>6.3.2 redo log</h3><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。 </p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用 于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p>在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数 据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果 缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中 的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘 中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后 将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却 没有持久化下来，这就出现问题了，没有保证事务的持久性。</p><p><img src="/mysql-02/image-20230320130234652.png" alt="image-20230320130234652"></p><p>如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，</p><p><img src="/mysql-02/image-20230320130303560.png" alt="image-20230320130303560"></p><p>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。 过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据 恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此 时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。</p><p>为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新 到磁盘呢 ? 因为在业务操作中，操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这 种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p><h3 id="6-3-3-undo-log"><a href="#6-3-3-undo-log" class="headerlink" title="6.3.3 undo log"></a>6.3.3 undo log</h3><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和 MVCC(多版本并发控制) 。 undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的 update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些 日志可能还用于MVCC。</p><p>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment。</p><h3 id="6-4-MVCC"><a href="#6-4-MVCC" class="headerlink" title="6.4 MVCC"></a>6.4 MVCC</h3><h4 id="6-4-1-基本概念"><a href="#6-4-1-基本概念" class="headerlink" title="6.4.1 基本概念"></a>6.4.1 基本概念</h4><p>1). 当前读</p><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加 锁。对于我们日常的操作，如：select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读。</p><p>测试：</p><p><img src="/mysql-02/image-20230320132044636.png" alt="image-20230320132044636"></p><p>在测试中可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内 容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。</p><p>2). 快照读</p><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据， 不加锁，是非阻塞读。</p><ul><li><p>Read Committed：每次select，都生成一个快照读。</p></li><li><p>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</p></li><li><p>Serializable：快照读会退化为当前读。</p></li></ul><p><img src="/mysql-02/image-20230320132658484.png" alt="image-20230320132658484"></p><p>看到即使事务B提交了数据,事务A中也查询不到。 原因就是因为普通的select是快照 读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同 的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。</p><p>3). MVCC</p><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本， 使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需 要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><h4 id="6-4-2-隐藏字段"><a href="#6-4-2-隐藏字段" class="headerlink" title="6.4.2 隐藏字段"></a>6.4.2 隐藏字段</h4><h5 id="6-4-2-1-介绍"><a href="#6-4-2-1-介绍" class="headerlink" title="6.4.2.1 介绍"></a>6.4.2.1 介绍</h5><p><img src="/mysql-02/image-20230320132925148.png" alt="image-20230320132925148"></p><p>际上除了 这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p><table><thead><tr><th>隐藏字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</td></tr><tr><td>DB_ROLL_PTR</td><td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版 本。</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td></tr></tbody></table><h4 id="6-4-3-undolog"><a href="#6-4-3-undolog" class="headerlink" title="6.4.3 undolog"></a>6.4.3 undolog</h4><h5 id="6-4-3-1-介绍"><a href="#6-4-3-1-介绍" class="headerlink" title="6.4.3.1 介绍"></a>6.4.3.1 介绍</h5><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。 </p><p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即 被删除。</p><h5 id="6-4-3-2-版本链"><a href="#6-4-3-2-版本链" class="headerlink" title="6.4.3.2 版本链"></a>6.4.3.2 版本链</h5><p>有一张表原始数据为：</p><p><img src="/mysql-02/image-20230320133520301.png" alt="image-20230320133520301"></p><p>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是 自增的。 DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</p><p>然后，有四个并发事务同时在访问这张表。</p><p>A. 第一步</p><p><img src="/mysql-02/image-20230320133629860.png" alt="image-20230320133629860"></p><p>当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录， 并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/mysql-02/image-20230320133646700.png" alt="image-20230320133646700"></p><p>B.第二步</p><p><img src="/mysql-02/image-20230320133743966.png" alt="image-20230320133743966"></p><p>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记 录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/mysql-02/image-20230320133920671.png" alt="image-20230320133920671"></p><p>C. 第三步</p><p><img src="/mysql-02/image-20230320133931367.png" alt="image-20230320133931367"></p><p>当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记 录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/mysql-02/image-20230320133949503.png" alt="image-20230320133949503"></p><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条 记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><h4 id="6-4-4-readview"><a href="#6-4-4-readview" class="headerlink" title="6.4.4 readview"></a>6.4.4 readview</h4><p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务 （未提交的）id。</p><p>ReadView中包含了四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务ID集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务ID</td></tr><tr><td>max_trx_id</td><td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td></tr><tr><td>creator_trx_id</td><td>ReadView创建者的事务ID</td></tr></tbody></table><p>而在readview中就规定了版本链数据的访问规则：</p><p>trx_id 代表当前undolog版本链对应事务ID。</p><table><thead><tr><th>条件</th><th>是否可以访问</th><th>说明</th></tr></thead><tbody><tr><td>trx_id == creator_trx_id</td><td>可以访问该版本</td><td>成立，说明数据是当前这个事 务更改的。</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>可以访问该版本</td><td>成立，说明数据已经提交了。</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>不可以访问该版本</td><td>成立，说明该事务是在 ReadView生成后才开启。</td></tr><tr><td>min_trx_id &lt;= trx_id &lt;= max_trx_id</td><td>如果trx_id不在m_ids中， 是可以访问该版本的</td><td>成立，说明数据已经提交。</td></tr></tbody></table><p>不同的隔离级别，生成ReadView的时机不同：</p><ul><li><p>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。 </p></li><li><p>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</p></li></ul><h4 id="6-4-5-原理分析"><a href="#6-4-5-原理分析" class="headerlink" title="6.4.5 原理分析"></a>6.4.5 原理分析</h4><h5 id="6-4-5-1-RC隔离级别"><a href="#6-4-5-1-RC隔离级别" class="headerlink" title="6.4.5.1 RC隔离级别"></a>6.4.5.1 RC隔离级别</h5><p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView.</p><p>在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读 都会生成一个ReadView，那么两次生成的ReadView如下。</p><p><img src="/mysql-02/image-20230320135113643.png" alt="image-20230320135113643"></p><p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则， 到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p><p>A. 先来看第一次快照读具体的读取过程：</p><p><img src="/mysql-02/image-20230320135113643.png" alt="image-20230320135113643"></p><p><img src="/mysql-02/image-20230320135211340.png" alt="image-20230320135211340"></p><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><p>先匹配<img src="/mysql-02/image-20230320135227208.png" alt="image-20230320135227208"></p><p>这条记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</p><p>再匹配第二条<img src="/mysql-02/image-20230320135247714.png" alt="image-20230320135247714"></p><p>这条 记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也 不满足 ，都不满足，则继续匹配undo log版本链的下一条</p><p>再匹配第三条<img src="/mysql-02/image-20230320135302226.png" alt="image-20230320135302226"></p><p>这条记 录对应的trx_id为2，也就是将2带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照 读，返回的数据就是版本链中记录的这条数据。</p><p>B. 再来看第二次快照读具体的读取过程:</p><p><img src="/mysql-02/image-20230320135452732.png" alt="image-20230320135452732"></p><p><img src="/mysql-02/image-20230320135458225.png" alt="image-20230320135458225"></p><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><p>先匹配<img src="/mysql-02/image-20230320135516089.png" alt="image-20230320135516089"></p><p>这条记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</p><p>再匹配第二条<img src="/mysql-02/image-20230320135536540.png" alt="image-20230320135536540"></p><p>这条 记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次 快照读，返回的数据就是版本链中记录的这条数据。</p><h5 id="6-4-5-3-RR隔离级别"><a href="#6-4-5-3-RR隔离级别" class="headerlink" title="6.4.5.3 RR隔离级别"></a>6.4.5.3 RR隔离级别</h5><p>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可 重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p><p><img src="/mysql-02/image-20230320135625996.png" alt="image-20230320135625996"></p><p>在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该 ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返 回的结果也是一样的。 所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。 而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p><p><img src="/mysql-02/image-20230320135646957.png" alt="image-20230320135646957"></p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-01</title>
      <link href="/mysql-01.html"/>
      <url>/mysql-01.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-MySQL概述"><a href="#1-MySQL概述" class="headerlink" title="1.MySQL概述"></a>1.MySQL概述</h1><h2 id="1-1-数据库相关概念"><a href="#1-1-数据库相关概念" class="headerlink" title="1.1 数据库相关概念"></a>1.1 数据库相关概念</h2><table><thead><tr><th>名称</th><th>全称</th><th>简称</th></tr></thead><tbody><tr><td>数据库</td><td>存储数据的仓库，数据是有组织的进行存储</td><td>DataBase（DB）</td></tr><tr><td>数据库管理系统</td><td>操纵和管理数据库的大型软件</td><td>DataBase Management System (DBMS)</td></tr><tr><td>SQL</td><td>操作关系型数据库的编程语言，定义了一套操作 关系型数据库统一标准</td><td>Structured Query Language (SQL)</td></tr></tbody></table><h3 id="1-1-1mysql数据库连接"><a href="#1-1-1mysql数据库连接" class="headerlink" title="1.1.1mysql数据库连接"></a>1.1.1mysql数据库连接</h3><ol><li>使用MySQL提供的客户端命令行工具</li><li>使用系统自带的命令行工具执行指令</li></ol><pre><code>mysql [-h 127.0.0.1] [-P 3306] -u root -p参数：-h : MySQL服务所在的主机IP-P : MySQL服务端口号， 默认3306-u : MySQL数据库用户名-p ： MySQL数据库用户名对应的密码</code></pre><p>[]内为可选参数，如果需要连接远程的MySQL，需要加上这两个参数来指定远程主机IP、端口，如果 连接本地的MySQL，则无需指定这两个参数。</p><h3 id="1-1-2-数据模型"><a href="#1-1-2-数据模型" class="headerlink" title="1.1.2 数据模型"></a>1.1.2 数据模型</h3><p>1). 关系型数据库（RDBMS） 概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。 而所谓二维表，指的是由行和列组成的表，如下图（就类似于Excel表格数据，有表头、有列、有行， 还可以通过一列关联另外一个表格中的某一列数据）。MySQL、Oracle、DB2、 SQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。简单说，基于二维表存储 数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库。</p><p><img src="/mysql-01/image-20230317200345320.png" alt="image-20230317200345320"></p><p>特点： A. 使用表存储数据，格式统一，便于维护。 </p><p>​            B. 使用SQL语言操作，标准统一，使用方便。</p><p>2). 数据模型 MySQL是关系型数据库，是基于二维表进行数据存储的，具体的结构图下:</p><p><img src="/mysql-01/image-20230317200415240.png" alt="image-20230317200415240"></p><p>可以通过MySQL客户端连接数据库管理系统DBMS，然后通过DBMS操作数据库。 </p><p>可以使用SQL语句，通过数据库管理系统操作数据库，以及操作数据库中的表结构及数据。 一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包 含多行记录。</p><h1 id="2-SQL"><a href="#2-SQL" class="headerlink" title="2.SQL"></a>2.SQL</h1><p>全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了 一套操作关系型数据库统一标准 。</p><h2 id="2-1-SQL通用语法"><a href="#2-1-SQL通用语法" class="headerlink" title="2.1 SQL通用语法"></a>2.1 SQL通用语法</h2><ol><li>SQL语句可以单行或多行书写，以分号结尾。</li><li>SQL语句可以使用空格/缩进来增强语句的可读性。</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</li><li>注释： 单行注释：– 注释内容 或 # 注释内容 多行注释：/* 注释内容 */</li></ol><h2 id="2-2-sql分类"><a href="#2-2-sql分类" class="headerlink" title="2.2 sql分类"></a>2.2 sql分类</h2><p>SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL。</p><table><thead><tr><th>分类</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>数据定义语言，用来定义数据库对象(数据库，表， 字段)</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>数据操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据查询语言，用来查询数据库中表的记录</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>数据控制语言，用来创建数据库用户、控制数据库的 访问权限</td></tr></tbody></table><h2 id="2-3-DDL"><a href="#2-3-DDL" class="headerlink" title="2.3 DDL"></a>2.3 DDL</h2><p>Data Definition Language，数据定义语言，用来定义数据库对象(数据库，表，字段) 。</p><h3 id="2-3-1-数据库操作"><a href="#2-3-1-数据库操作" class="headerlink" title="2.3.1 数据库操作"></a>2.3.1 数据库操作</h3><p>1). 查询所有数据库</p><pre><code>show databases ;</code></pre><p>2). 查询当前数据库</p><pre><code>select database() ;</code></pre><p>3). 创建数据库</p><pre><code>create database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ;</code></pre><p>在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。</p><p>可以通过if not exists 参数来解决这个问题，数据库不存在, 则创建该数据库，如果存在，则不 创建。</p><pre><code>create database if not extists itcast;</code></pre><p>B. 创建一个itheima数据库，并且指定字符集</p><pre><code>create database 数据库名称 default charset utf8mb4;</code></pre><p>4). 删除数据库</p><pre><code> drop database [ if exists ] 数据库名 ;</code></pre><p>如果删除一个不存在的数据库，将会报错。此时，可以加上参数 if exists ，如果数据库存在，再 执行删除，否则不执行删除。</p><p>5). 切换数据库</p><pre><code>use 数据库名 ;</code></pre><p>要操作某一个数据库下的表时，就需要通过该指令，切换到对应的数据库下，否则是不能操作的。</p><h3 id="2-3-2-表操作"><a href="#2-3-2-表操作" class="headerlink" title="2.3.2 表操作"></a>2.3.2 表操作</h3><h4 id="2-3-2-1-表操作-查询创建"><a href="#2-3-2-1-表操作-查询创建" class="headerlink" title="2.3.2.1 表操作-查询创建"></a>2.3.2.1 表操作-查询创建</h4><p>1). 查询当前数据库所有表</p><pre><code>show tables;</code></pre><p>2). 查看指定表结构</p><pre><code>desc 表名 ;</code></pre><p>3). 查询指定表的建表语句</p><pre><code>show create table 表名 ;</code></pre><p>4). 创建表结构</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE 表名(字段1 字段1类型 [ COMMENT 字段1注释 ],字段2 字段2类型 [COMMENT 字段2注释 ],字段3 字段3类型 [COMMENT 字段3注释 ],......字段n 字段n类型 [COMMENT 字段n注释 ]) [ COMMENT 表注释 ] ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意: […] 内为可选参数，最后一个字段后面没有逗号</p><p>比如，创建一张表 tb_user ，对应的结构如下，那么建表语句为：</p><p><img src="/mysql-01/image-20230318122920257.png" alt="image-20230318122920257"></p><pre class="line-numbers language-mysql"><code class="language-mysql">create table tb_user(id int comment '编号',name varchar(50) comment '姓名',age int comment '年龄',gender varchar(1) comment '性别') comment '用户表';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-2-2-表操作-数据类型"><a href="#2-3-2-2-表操作-数据类型" class="headerlink" title="2.3.2.2 表操作-数据类型"></a>2.3.2.2 表操作-数据类型</h4><p> MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。</p><p>1). 数值类型</p><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">范围（有符号）</th><th align="left">范围（无符号）</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1 Bytes</td><td align="left">(-128，127)</td><td align="left">(0，255)</td><td align="left">小整数值</td></tr><tr><td align="left">SMALLINT</td><td align="left">2 Bytes</td><td align="left">(-32 768，32 767)</td><td align="left">(0，65 535)</td><td align="left">大整数值</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3 Bytes</td><td align="left">(-8 388 608，8 388 607)</td><td align="left">(0，16 777 215)</td><td align="left">大整数值</td></tr><tr><td align="left">INT或INTEGER</td><td align="left">4 Bytes</td><td align="left">(-2 147 483 648，2 147 483 647)</td><td align="left">(0，4 294 967 295)</td><td align="left">大整数值</td></tr><tr><td align="left">BIGINT</td><td align="left">8 Bytes</td><td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td align="left">(0，18 446 744 073 709 551 615)</td><td align="left">极大整数值</td></tr><tr><td align="left">FLOAT</td><td align="left">4 Bytes</td><td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="left">单精度 浮点数值</td></tr><tr><td align="left">DOUBLE</td><td align="left">8 Bytes</td><td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">双精度 浮点数值</td></tr><tr><td align="left">DECIMAL</td><td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="left">依赖于M和D的值</td><td align="left">依赖于M和D的值</td><td align="left">小数值</td></tr></tbody></table><pre><code>如:1). 年龄字段 -- 不会出现负数, 而且人的年龄不会太大age tinyint unsigned2). 分数 -- 总分100分, 最多出现一位小数score double(4,1)</code></pre><p>2). 字符串类型</p><table><thead><tr><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 bytes</td><td>定长字符串(需要指定长度)</td></tr><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串(需要指定长度)</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过255个字符的二进制数据</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table><p>char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和 字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性 能会更高些。</p><pre><code>如：1). 用户名 username ------&gt; 长度不定, 最长不会超过50username varchar(50)2). 性别 gender ---------&gt; 存储值, 不是男,就是女gender char(1)3). 手机号 phone --------&gt; 固定长度为11phone char(11)</code></pre><p>3). 日期时间类型</p><table><thead><tr><th align="left">类型</th><th align="left">大小 ( bytes)</th><th align="left">范围</th><th align="left">格式</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01/9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="left">日期值</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’/‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="left">时间值或持续时间</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901/2155</td><td align="left">YYYY</td><td align="left">年份值</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="left">混合日期和时间值</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="left">混合日期和时间值，时间戳</td></tr></tbody></table><pre><code>1). 生日字段 birthdaybirthday date2). 创建时间 createtimecreatetime datetime</code></pre><p>2.3.2.3 表操作-案例 设计一张员工信息表，要求如下：</p><ol><li>编号（纯数字） </li><li>员工工号 (字符串类型，长度不超过10位) </li><li>员工姓名（字符串类型，长度不超过10位）</li><li>性别（男/女，存储一个汉字） </li><li>年龄（正常人年龄，不可能存储负数）</li><li>身份证号（二代身份证号均为18位，身份证中有X这样的字符） </li><li>入职时间（取值年月日即可）</li></ol><pre><code>create table emp(    id int comment &quot;编号&quot;,    workno varchar(10) comment&#39;工号&#39;,    name varchar(10) comment&#39;姓名&#39;,    gender char(1) comment &#39;性别&#39;,    age tinyint unsigned comment &#39;年龄&#39;,    idcard char(10) comment &#39;身份证号&#39;,    entrydate date comment &#39;入职时间&#39;)comment &#39;员工表&#39;,</code></pre><h4 id="2-3-2-4-表操作-修改"><a href="#2-3-2-4-表操作-修改" class="headerlink" title="2.3.2.4 表操作-修改"></a>2.3.2.4 表操作-修改</h4><p>1). 添加字段</p><pre><code>ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</code></pre><p>案例:</p><p>为emp表增加一个新的字段”昵称”为nickname，类型为varchar(20)</p><pre><code>ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;</code></pre><p>2). 修改数据类型</p><pre><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型（长度);</code></pre><p>3). 修改字段名和字段类型</p><pre><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</code></pre><p>案例: 将emp表的nickname字段修改为username，类型为varchar(30)</p><pre><code>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;</code></pre><p>4). 删除字段</p><pre><code>ALTER TABLE 表名 DROP 字段名</code></pre><p>案例: </p><p>将emp表的字段username删除</p><pre><code>ALTER TABLE emp DROP username</code></pre><p>5). 修改表名</p><pre><code>ALTER TABLE 表名 RENAME TO 新表名;</code></pre><p>案例: </p><p>将emp表的表名修改为 employee</p><pre><code> ALTER TABLE emp RENAME TO employee;</code></pre><h4 id="2-3-2-5-表操作-删除"><a href="#2-3-2-5-表操作-删除" class="headerlink" title="2.3.2.5 表操作-删除"></a>2.3.2.5 表操作-删除</h4><pre><code>DROP TABLE [ IF EXISTS ] 表名;</code></pre><p>可选项 IF EXISTS 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不 加该参数项，删除一张不存在的表，执行将会报错)。 案例: 如果tb_user表存在，则删除tb_user表</p><pre><code>DROP TABLE IF EXISTS tb_user;</code></pre><p>2). 删除指定表, 并重新创建表</p><pre><code>TRUNCATE TABLE 表名</code></pre><p>注意: 在删除表的时候，表中的全部数据也都会被删除。</p><h2 id="2-4-图形化界面工具"><a href="#2-4-图形化界面工具" class="headerlink" title="2.4 图形化界面工具"></a>2.4 图形化界面工具</h2><p><img src="/mysql-01/image-20230318143403192.png" alt="image-20230318143403192"></p><p>个人感觉DataGrip好用</p><h2 id="2-5-DML"><a href="#2-5-DML" class="headerlink" title="2.5 DML"></a>2.5 DML</h2><p>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进 行增、删、改操作。</p><ul><li>添加数据（INSERT）</li><li>修改数据（UPDATE） </li><li>删除数据（DELETE）</li></ul><h3 id="2-5-1-添加数据"><a href="#2-5-1-添加数据" class="headerlink" title="2.5.1 添加数据"></a>2.5.1 添加数据</h3><p> 1). 给指定字段添加数据</p><pre><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code></pre><p>给employee表所有的字段添加数据 ；</p><pre><code>insert into employee(id,workno,name,gender,age,idcard,entrydate)values(1,&#39;1&#39;,&#39;Itcast&#39;,&#39;男&#39;,10,&#39;123456789012345678&#39;,&#39;2000-01-01&#39;);</code></pre><p>2). 给全部字段添加数据</p><pre><code>INSERT INTO 表名 VALUES (值1, 值2, ...);</code></pre><p>插入数据到employee表，具体的SQL如下：</p><pre><code>insert into employee values(2,&#39;2&#39;,&#39;张无忌&#39;,&#39;男&#39;,18,&#39;123456789012345670&#39;,&#39;2005-01-01&#39;);</code></pre><p>3). 批量添加数据</p><pre><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;</code></pre><pre><code>INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;</code></pre><p>注意事项: </p><ul><li>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。</li><li>字符串和日期型数据应该包含在引号中。 </li><li>插入的数据大小，应该在字段的规定范围内。</li></ul><h3 id="2-5-2-修改数据"><a href="#2-5-2-修改数据" class="headerlink" title="2.5.2 修改数据"></a>2.5.2 修改数据</h3><p>修改数据的具体语法为:</p><pre><code>UPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ] ;</code></pre><p>案例:</p><p>A. 修改id为1的数据，将name修改为nametest</p><pre><code>update employee set name = &#39;nametest&#39; where id = 1;</code></pre><p>B. 修改id为1的数据, 将name修改为小昭, gender修改为 女</p><pre><code>update employee set name = &#39;小昭&#39; , gender = &#39;女&#39; where id = 1;</code></pre><p>C. 将所有的员工入职日期修改为 2008-01-01</p><pre><code> update employee set entrydate = &#39;2008-01-01&#39;;</code></pre><p>注意事项: 修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。</p><h3 id="2-5-3-删除数据"><a href="#2-5-3-删除数据" class="headerlink" title="2.5.3 删除数据"></a>2.5.3 删除数据</h3><p>删除数据的具体语法为：</p><pre><code> DELETE FROM 表名 [ WHERE 条件 ] ;</code></pre><p>案例: A. 删除gender为女的员工</p><pre><code> delete from employee where gender = &#39;女&#39;;</code></pre><p>B. 删除所有员工</p><pre><code>delete from employee</code></pre><p>注意事项:</p><ul><li>DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数 据。</li><li>DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即 可)。 </li><li>当进行删除全部数据操作时，datagrip会提示，询问是否确认删除，直接点击 Execute即可。</li></ul><h2 id="2-6-DQL"><a href="#2-6-DQL" class="headerlink" title="2.6 DQL"></a>2.6 DQL</h2><p>DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记 录。</p><p>查询关键字: SELECT</p><p>数据准备</p><pre><code>drop table if exists employee;create table emp(id int comment &#39;编号&#39;,workno varchar(10) comment &#39;工号&#39;,name varchar(10) comment &#39;姓名&#39;,gender char(1) comment &#39;性别&#39;,age tinyint unsigned comment &#39;年龄&#39;,idcard char(18) comment &#39;身份证号&#39;,workaddress varchar(50) comment &#39;工作地址&#39;,entrydate date comment &#39;入职时间&#39;)comment &#39;员工表&#39;;INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (1, &#39;00001&#39;, &#39;柳岩666&#39;, &#39;女&#39;, 20, &#39;123456789012345678&#39;, &#39;北京&#39;, &#39;2000-01-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (2, &#39;00002&#39;, &#39;张无忌&#39;, &#39;男&#39;, 18, &#39;123456789012345670&#39;, &#39;北京&#39;, &#39;2005-09-01&#39;)INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (3, &#39;00003&#39;, &#39;韦一笑&#39;, &#39;男&#39;, 38, &#39;123456789712345670&#39;, &#39;上海&#39;, &#39;2005-08-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (4, &#39;00004&#39;, &#39;赵敏&#39;, &#39;女&#39;, 18, &#39;123456757123845670&#39;, &#39;北京&#39;, &#39;2009-12-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (5, &#39;00005&#39;, &#39;小昭&#39;, &#39;女&#39;, 16, &#39;123456769012345678&#39;, &#39;上海&#39;, &#39;2007-07-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (6, &#39;00006&#39;, &#39;杨逍&#39;, &#39;男&#39;, 28, &#39;12345678931234567X&#39;, &#39;北京&#39;, &#39;2006-01-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (7, &#39;00007&#39;, &#39;范瑶&#39;, &#39;男&#39;, 40, &#39;123456789212345670&#39;, &#39;北京&#39;, &#39;2005-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (8, &#39;00008&#39;, &#39;黛绮丝&#39;, &#39;女&#39;, 38, &#39;123456157123645670&#39;, &#39;天津&#39;, &#39;2015-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (9, &#39;00009&#39;, &#39;范凉凉&#39;, &#39;女&#39;, 45, &#39;123156789012345678&#39;, &#39;北京&#39;, &#39;2010-04-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (10, &#39;00010&#39;, &#39;陈友谅&#39;, &#39;男&#39;, 53, &#39;123456789012345670&#39;, &#39;上海&#39;, &#39;2011-01-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (11, &#39;00011&#39;, &#39;张士诚&#39;, &#39;男&#39;, 55, &#39;123567897123465670&#39;, &#39;江苏&#39;, &#39;2015-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (12, &#39;00012&#39;, &#39;常遇春&#39;, &#39;男&#39;, 32, &#39;123446757152345670&#39;, &#39;北京&#39;, &#39;2004-02-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (13, &#39;00013&#39;, &#39;张三丰&#39;, &#39;男&#39;, 88, &#39;123656789012345678&#39;, &#39;江苏&#39;, &#39;2020-11-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (14, &#39;00014&#39;, &#39;灭绝&#39;, &#39;女&#39;, 65, &#39;123456719012345670&#39;, &#39;西安&#39;, &#39;2019-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (15, &#39;00015&#39;, &#39;胡青牛&#39;, &#39;男&#39;, 70, &#39;12345674971234567X&#39;, &#39;西安&#39;, &#39;2018-04-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (16, &#39;00016&#39;, &#39;周芷若&#39;, &#39;女&#39;, 18, null, &#39;北京&#39;, &#39;2012-06-01&#39;);</code></pre><h3 id="2-6-1-基本语法"><a href="#2-6-1-基本语法" class="headerlink" title="2.6.1 基本语法"></a>2.6.1 基本语法</h3><p>DQL 查询语句，语法结构如下：</p><pre><code>SELECT    字段列表FROM    表名列表WHERE    条件列表GROUP BY    分组字段列表HAVING    分组后条件列表ORDER BY    排序字段列表LIMIT    分页参数</code></pre><h3 id="2-6-2-基础查询"><a href="#2-6-2-基础查询" class="headerlink" title="2.6.2 基础查询"></a>2.6.2 基础查询</h3><p>1). 查询多个字段</p><pre><code>SELECT 字段1, 字段2, 字段3 ... FROM 表名 ;</code></pre><pre><code>SELECT * FROM 表名 ；</code></pre><p>注意 : * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。</p><p>2). 字段设置别名</p><pre><code> SELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名;</code></pre><pre><code> SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;</code></pre><p>3). 去除重复记录</p><pre><code>SELECT DISTINCT 字段列表 FROM 表名;</code></pre><h3 id="2-6-3-条件查询"><a href="#2-6-3-条件查询" class="headerlink" title="2.6.3 条件查询"></a>2.6.3 条件查询</h3><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 WHERE 条件列表 ;</code></pre><p>2). 条件</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">等号，检测两个值是否相等，如果相等返回true</td><td align="left">(A = B) 返回false。</td></tr><tr><td align="left">&lt;&gt;, !=</td><td align="left">不等于，检测两个值是否相等，如果不相等返回true</td><td align="left">(A != B) 返回 true。</td></tr><tr><td align="left">&gt;</td><td align="left">大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true</td><td align="left">(A &gt; B) 返回false。</td></tr><tr><td align="left">&lt;</td><td align="left">小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true</td><td align="left">(A &lt; B) 返回 true。</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true</td><td align="left">(A &gt;= B) 返回false。</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于号，检测左边的值是否小于或等于右边的值, 如果左边的值小于或等于右边的值返回true</td><td align="left">(A &lt;= B) 返回 true。</td></tr><tr><td align="left">BETWEEN … AND …</td><td align="left">在某个范围之内(含最小、最大值)</td><td align="left">(between15 and 20) 返回15到20之间</td></tr><tr><td align="left">IN(…)</td><td align="left">在in之后的列表中的值，多选一</td><td align="left">[in(18,80,40) ] 返回18，20，40</td></tr><tr><td align="left">LIKE 占位符</td><td align="left">模糊匹配(_匹配单个字符, %匹配任意个字符)</td><td align="left"></td></tr><tr><td align="left">IS NULL</td><td align="left">是NULL</td><td align="left"></td></tr></tbody></table><h3 id="2-6-4-聚合函数"><a href="#2-6-4-聚合函数" class="headerlink" title="2.6.4 聚合函数"></a>2.6.4 聚合函数</h3><p>1). 介绍</p><p>将一列数据作为一个整体，进行纵向计算 。</p><p>2). 常见的聚合函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p>3). 语法</p><pre><code> SELECT 聚合函数(字段列表) FROM 表名 ;</code></pre><p>注意 : NULL值是不参与所有聚合函数运算的。</p><p>案例：</p><p>A. 统计该企业员工数量</p><pre><code>select count(*) from emp; -- 统计的是总记录数select count(idcard) from emp; -- 统计的是idcard字段不为null的记录数</code></pre><p>对于count聚合函数，统计符合条件的总记录数，还可以通过 count(数字/字符串)的形式进行统计 查询，比如：</p><pre><code> select count(1) from emp;</code></pre><h3 id="2-6-5-分组查询"><a href="#2-6-5-分组查询" class="headerlink" title="2.6.5 分组查询"></a>2.6.5 分组查询</h3><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后过滤条件 ];</code></pre><p>2). where与having区别 执行时机不同：</p><ul><li>where是分组之前进行过滤，不满足where条件，不参与分组；</li><li>而having是分组 之后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><p>案例:</p><p>A. 根据性别分组 , 统计男性员工 和 女性员工的数量</p><pre><code>select gender, count(*) from emp group by gender ;</code></pre><p>B. 根据性别分组 , 统计男性员工 和 女性员工的平均年龄</p><pre><code> select gender, avg(age) from emp group by gender ;</code></pre><p>C. 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址</p><pre><code>select workaddress, count(*) address_count from emp where age &lt; 45 group byworkaddress having address_count &gt;= 3;</code></pre><p>D. 统计各个工作地址上班的男性及女性员工的数量</p><pre><code>select workaddress, gender, count(*) &#39;数量&#39; from emp group by gender , workaddress;</code></pre><h3 id="2-6-6-排序查询"><a href="#2-6-6-排序查询" class="headerlink" title="2.6.6 排序查询"></a>2.6.6 排序查询</h3><p>排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序</p><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ;</code></pre><p>2). 排序方式</p><ul><li>ASC : 升序(默认值) </li><li>DESC: 降序</li></ul><p>注意事项：</p><ul><li>如果是升序, 可以不指定排序方式ASC ; </li><li>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;</li></ul><h3 id="2-6-7-分页查询"><a href="#2-6-7-分页查询" class="headerlink" title="2.6.7 分页查询"></a>2.6.7 分页查询</h3><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;</code></pre><p>注意事项: </p><p>起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数。 </p><p>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。 </p><p>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</p><p>案例: </p><p>A. 查询第1页员工数据, 每页展示10条记录</p><pre><code>select * from emp limit 0,10;select * from emp limit 10;</code></pre><p>B. 查询第2页员工数据, 每页展示10条记录 ——–&gt; (页码-1)*页展示记录数</p><pre><code> select * from emp limit 10,10;</code></pre><h3 id="2-6-9-执行顺序"><a href="#2-6-9-执行顺序" class="headerlink" title="2.6.9 执行顺序"></a>2.6.9 执行顺序</h3><p><img src="/mysql-01/image-20230318153026758.png" alt="image-20230318153026758"></p><p>执行顺序为</p><p>from … where … group by … having … select … order by … limit …</p><h2 id="2-7-DCL"><a href="#2-7-DCL" class="headerlink" title="2.7 DCL"></a>2.7 DCL</h2><p>DCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访 问权限。</p><h3 id="2-7-1-管理用户"><a href="#2-7-1-管理用户" class="headerlink" title="2.7.1 管理用户"></a>2.7.1 管理用户</h3><p>1). 查询用户</p><pre><code>select * from mysql.user;</code></pre><p><img src="/mysql-01/image-20230318153333941.png" alt="image-20230318153333941"></p><p>其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以 远程访问的。 User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一 个用户。</p><p>2). 创建用户</p><pre><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></pre><p>3). 修改用户密码</p><pre><code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39; ;</code></pre><p>4). 删除用户</p><pre><code>DROP USER &#39;用户名&#39;@&#39;主机名&#39; ;</code></pre><p>注意事项:</p><ul><li>在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。</li><li>主机名可以使用 % 通配。 </li></ul><h3 id="2-7-2-权限控制"><a href="#2-7-2-权限控制" class="headerlink" title="2.7.2 权限控制"></a>2.7.2 权限控制</h3><p>Mysql中常用的的权限</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库/表/视图</td></tr><tr><td>CREATE</td><td>创建数据库/表</td></tr></tbody></table><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" target="_blank" rel="noopener">MySQL :: MySQL 8.0 Reference Manual :: 6.2.2 Privileges Provided by MySQL</a></p><p>1). 查询权限</p><pre><code> SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39; ;</code></pre><p>2). 授予权限</p><pre><code> GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>3). 撤销权限</p><pre><code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>注意事项： • 多个权限之间，使用逗号分隔 • 授权时， 数据库名和表名可以使用 * 进行通配，代表所有。</p><h1 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h1><p>函数 是指一段可以直接被另一段程序调用的程序或代码。 也就意味着，这一段程序或代码在MySQL中 已经给我们提供了，我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可</p><p>MySQL中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数。</p><h2 id="3-1-字符串函数"><a href="#3-1-字符串函数" class="headerlink" title="3.1 字符串函数"></a>3.1 字符串函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(S1,S2,…Sn)</td><td>字符串拼接，将S1，S2，… Sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串str全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串str全部转为大写</td></tr><tr><td>LPAD(str,n,pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符 串长度</td></tr><tr><td>RPAD(str,n,pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符 串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str,start,len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><p>lpad : 左填充</p><pre><code>select lpad(&#39;01&#39;, 5, &#39;-&#39;);</code></pre><p>trim : 去除空格</p><pre><code>select trim(&#39; Hello MySQL &#39;)</code></pre><p>substring : 截取子字符串</p><pre><code> select substring(&#39;Hello MySQL&#39;,1,5);</code></pre><h2 id="3-2-数值函数"><a href="#3-2-数值函数" class="headerlink" title="3.2 数值函数"></a>3.2 数值函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x,y)</td><td>返回x/y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x,y)</td><td>求参数x的四舍五入的值，保留y位小数</td></tr></tbody></table><h2 id="3-3-日期函数"><a href="#3-3-日期函数" class="headerlink" title="3.3 日期函数"></a>3.3 日期函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期/时间值加上一个时间间隔expr后的 时间值</td></tr><tr><td>DATEDIFF(date1,date2)</td><td>返回起始时间date1 和 结束时间date2之间的天 数</td></tr></tbody></table><h2 id="3-4-流程函数"><a href="#3-4-流程函数" class="headerlink" title="3.4 流程函数"></a>3.4 流程函数</h2><p>流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value , t , f)</td><td>如果value为true，则返回t，否则返回 f</td></tr><tr><td>IFNULL(value1 , value2)</td><td>如果value1不为空，返回value1，否则 返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否 则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td><td>如果expr的值等于val1，返回 res1，… 否则返回default默认值</td></tr></tbody></table><p>需求: 查询emp表的员工姓名和工作地址 (北京/上海 —-&gt; 一线城市 , 其他 —-&gt; 二线城市)</p><pre><code>selectname,( case workaddress when &#39;北京&#39; then &#39;一线城市&#39; when &#39;上海&#39; then &#39;一线城市&#39; else&#39;二线城市&#39; end ) as &#39;工作地址&#39;from emp;</code></pre><h1 id="4-约束"><a href="#4-约束" class="headerlink" title="4.约束"></a>4.约束</h1><p>概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。</p><p> 目的：保证数据库中数据的正确、有效性和完整性。</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束(8.0.16版本 之后)</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张表的数据之间建立连接，保证数据的一致 性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><p>注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。</p><h2 id="4-3-外键约束"><a href="#4-3-外键约束" class="headerlink" title="4.3 外键约束"></a>4.3 外键约束</h2><p>外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</p><p><img src="/mysql-01/image-20230318161258249.png" alt="image-20230318161258249"></p><p>左侧的emp表是员工表，里面存储员工的基本信息，包含员工的ID、姓名、年龄、职位、薪资、入职日 期、上级主管ID、部门ID，在员工的信息中存储的是部门的ID dept_id，而这个部门的ID是关联的 部门表dept的主键id，那emp表的dept_id就是外键,关联的是另一张表的主键。</p><p>注意：目前上述两张表，只是在逻辑上存在这样一层关系；在数据库层面，并未建立外键关联， 所以是无法保证数据的一致性和完整性的。</p><h3 id="4-3-2-语法"><a href="#4-3-2-语法" class="headerlink" title="4.3.2 语法"></a>4.3.2 语法</h3><p>1). 添加外键</p><pre><code>CREATE TABLE 表名(    字段名 数据类型,    ...    [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名));</code></pre><pre><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名)REFERENCES 主表 (主表列名) ;</code></pre><p>为emp表的dept_id字段添加外键约束,关联dept表的主键id。</p><pre><code>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id);</code></pre><p><img src="/mysql-01/image-20230318161641788.png" alt="image-20230318161641788"></p><p>添加了外键约束之后，到dept表(父表)删除id为1的记录。 此时 将会报错，不能删除或更新父表记录，因为存在外键约束。</p><p>2). 删除外键</p><pre><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</code></pre><p>案例： 删除emp表的外键fk_emp_dept_id。</p><pre><code>alter table emp drop foreign key fk_emp_dept_id;</code></pre><h3 id="4-3-3-删除-更新行为"><a href="#4-3-3-删除-更新行为" class="headerlink" title="4.3.3 删除/更新行为"></a>4.3.3 删除/更新行为</h3><p>添加了外键之后，再删除父表数据时产生的约束行为，称为删除/更新行为。具体的删除/更新行 为有以下几种</p><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 RESTRICT 一致) 默认行为</td></tr><tr><td>RESTRICT</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 NO ACTION 一致) 默认行为</td></tr><tr><td>CASCADE</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则 也删除/更新外键在子表中的记录。</td></tr><tr><td>SET NULL</td><td>当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表 中该外键值为null（这就要求该外键允许取null）。</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)</td></tr></tbody></table><p>具体语法为:</p><pre><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;</code></pre><p>演示如下：</p><p>1). CASCADE</p><pre><code>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id) on update cascade on delete cascade ;</code></pre><p>A. 修改父表id为1的记录，将id修改为6</p><p><img src="/mysql-01/image-20230318162417947.png" alt="image-20230318162417947"></p><p>原来在子表中dept_id值为1的记录，现在也变为6了，这就是cascade级联的效果。</p><p>在一般的业务系统中，不会修改一张表的主键值。</p><p>B. 删除父表id为6的记录</p><p><img src="/mysql-01/image-20230318162446703.png" alt="image-20230318162446703"></p><p>父表的数据删除成功了，但是子表中关联的记录也被级联删除了。</p><p>2). SET NULL</p><pre><code>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id) on update set null on delete set null ;</code></pre><p><img src="/mysql-01/image-20230318162633853.png" alt="image-20230318162633853"></p><p>父表的记录是可以正常的删除的，父表的数据删除之后，再打开子表 emp，发现子表emp 的dept_id字段，原来dept_id为1的数据，现在都被置为NULL了。</p><p><img src="/mysql-01/image-20230318162649038.png" alt="image-20230318162649038"></p><h1 id="5-多表查询"><a href="#5-多表查询" class="headerlink" title="5.多表查询"></a>5.多表查询</h1><h2 id="5-1-多表关系"><a href="#5-1-多表关系" class="headerlink" title="5.1 多表关系"></a>5.1 多表关系</h2><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结 构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：</p><ul><li>一对多(多对一)</li><li>多对多</li><li>一对一</li></ul><h3 id="5-1-1-一对多"><a href="#5-1-1-一对多" class="headerlink" title="5.1.1 一对多"></a>5.1.1 一对多</h3><ul><li>案例: 部门 与 员工的关系</li><li>关系: 一个部门对应多个员工，一个员工对应一个部门 </li><li>实现: 在多的一方建立外键，指向一的一方的主键</li></ul><p><img src="/mysql-01/image-20230318163215620.png" alt="image-20230318163215620"></p><h3 id="5-1-2-多对多"><a href="#5-1-2-多对多" class="headerlink" title="5.1.2 多对多"></a>5.1.2 多对多</h3><ul><li>案例: 学生 与 课程的关系 </li><li>关系: 一个学生可以选修多门课程，一门课程也可以供多个学生选择 </li><li>实现: 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</li></ul><p><img src="/mysql-01/image-20230318163305957.png" alt="image-20230318163305957"></p><p>约束语句：</p><pre><code>constraint fk_courseid foreign key (courseid) references course (id),constraint fk_studentid foreign key (studentid) references student (id)</code></pre><h3 id="5-1-3-一对一"><a href="#5-1-3-一对一" class="headerlink" title="5.1.3 一对一"></a>5.1.3 一对一</h3><p>案例: 用户 与 用户详情的关系 关系:</p><p> 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另 一张表中，以提升操作效率 </p><p>实现: 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</p><p><img src="/mysql-01/image-20230318163537120.png" alt="image-20230318163537120"></p><h2 id="5-2-多表查询"><a href="#5-2-多表查询" class="headerlink" title="5.2 多表查询"></a>5.2 多表查询</h2><h3 id="5-2-2-概述"><a href="#5-2-2-概述" class="headerlink" title="5.2.2 概述"></a>5.2.2 概述</h3><p>多表查询就是指从多张表中查询数据。</p><p>原来查询单表数据，执行的SQL形式为：select * from emp;</p><p>那么我们要执行多表查询，就只需要使用逗号分隔多张表即可，如： select * from emp , dept ; 具体的执行结果如下:</p><p><img src="/mysql-01/image-20230318163656019.png" alt="image-20230318163656019"></p><p>此时,查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录 (17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。</p><p>笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况。</p><p><img src="/mysql-01/image-20230318163727372.png" alt="image-20230318163727372"></p><p>而在多表查询中，是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。</p><p><img src="/mysql-01/image-20230318163744086.png" alt="image-20230318163744086"></p><p>给多表查询加上连接查询的条件，消除笛卡尔集。</p><pre><code>select * from emp , dept where emp.dept_id = dept.id;</code></pre><p><img src="/mysql-01/image-20230318163821696.png" alt="image-20230318163821696"></p><p>而由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询 到。</p><h3 id="5-2-3-分类"><a href="#5-2-3-分类" class="headerlink" title="5.2.3 分类"></a>5.2.3 分类</h3><p>连接查询 </p><p>​    内连接：相当于查询A、B交集部分数据     </p><p>​    外连接：     </p><p>​        左外连接：查询左表所有数据，以及两张表交集部分数据     </p><p>​        右外连接：查询右表所有数据，以及两张表交集部分数据     </p><p>​    自连接：当前表与自身的连接查询，自连接必须使用表别名</p><ul><li>子查询</li></ul><p><img src="/mysql-01/image-20230318164141106.png" alt="image-20230318164141106"></p><h2 id="5-3-内连接"><a href="#5-3-内连接" class="headerlink" title="5.3 内连接"></a>5.3 内连接</h2><p><img src="/mysql-01/image-20230318164353496.png" alt="image-20230318164353496"></p><p>内连接查询的是两张表交集部分的数 据。(也就是绿色部分的数据) 内连接的语法分为两种: 隐式内连接、显式内连接。</p><p>1). 隐式内连接</p><pre><code>SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;</code></pre><p>2). 显式内连接</p><pre><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;</code></pre><p>案例: </p><p>A. 查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现) </p><p>表结构: emp , dept </p><p>连接条件: emp.dept_id = dept.id</p><pre><code>select emp.name , dept.name from emp , dept where emp.dept_id = dept.id ;-- 为每一张表起别名,简化SQL编写select e.name,d.name from emp e , dept d where e.dept_id = d.id;</code></pre><p>B. 查询每一个员工的姓名 , 及关联的部门的名称 (显式内连接实现) — INNER JOIN … ON …</p><p>​    表结构: emp , dept </p><p>​    连接条件: emp.dept_id = dept.id</p><pre><code>select e.name, d.name from emp e inner join dept d on e.dept_id = d.id;-- 为每一张表起别名,简化SQL编写select e.name, d.name from emp e join dept d on e.dept_id = d.id;</code></pre><p>注意事项:一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字 段。</p><h2 id="5-4-外连接"><a href="#5-4-外连接" class="headerlink" title="5.4 外连接"></a>5.4 外连接</h2><p><img src="/mysql-01/image-20230318165025944.png" alt="image-20230318165025944"></p><p>外连接分为两种，分别是：左外连接 和 右外连接。具体的语法结构为：</p><p>1). 左外连接</p><pre><code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;</code></pre><p>左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。</p><p>2). 右外连接</p><pre><code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ... ;</code></pre><p>右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。</p><p>案例:</p><p>A.     查询emp表的所有数据, 和对应的部门信息 </p><p>​        由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。         表结构: emp, dept 连接条件: emp.dept_id = dept.id</p><p>​        连接条件: emp.dept_id = dept.id</p><pre><code>select e.*, d.name from emp e left outer join dept d on e.dept_id = d.id;select e.*, d.name from emp e left join dept d on e.dept_id = d.id;</code></pre><p>​    B. 查询dept表的所有数据, 和对应的员工信息(右外连接)</p><p>由于需求中提到，要查询dept表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查 询。 </p><p>​    表结构: emp, dept </p><p>​    连接条件: emp.dept_id = dept.id</p><pre><code>select d.*, e.* from emp e right outer join dept d on e.dept_id = d.id;select d.*, e.* from dept d left outer join emp e on e.dept_id = d.id;</code></pre><p>注意事项： 左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺 序就可以了。日常开发使用时，更偏向于左外连接。</p><h2 id="5-5-自连接"><a href="#5-5-自连接" class="headerlink" title="5.5 自连接"></a>5.5 自连接</h2><h3 id="5-5-1-自连接查询"><a href="#5-5-1-自连接查询" class="headerlink" title="5.5.1 自连接查询"></a>5.5.1 自连接查询</h3><p>自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。</p><pre><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ... ;</code></pre><p>而对于自连接查询，可以是内连接查询，也可以是外连接查询。</p><p>案例： </p><p>A. 查询员工 及其 所属领导的名字 </p><p>表结构: emp</p><pre><code>select a.name , b.name from emp a , emp b where a.managerid = b.id;</code></pre><p>B. 查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来 </p><p>表结构: emp a , emp b</p><p>注意事项: 在自连接查询中，必须要为表起别名，要不然不清楚所指定的条件、返回的字段，到底 是哪一张表的字段</p><h3 id="5-5-2-联合查询"><a href="#5-5-2-联合查询" class="headerlink" title="5.5.2 联合查询"></a>5.5.2 联合查询</h3><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p><pre><code>SELECT 字段列表 FROM 表A ...UNION [ ALL ]SELECT 字段列表 FROM 表B ....;</code></pre><ul><li>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</li><li>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。</li></ul><p>案例: A. 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来. </p><p>当前对于这个需求，可以直接使用多条件查询，使用逻辑运算符 or 连接即可。 也可以通过union/union all来联合查询.</p><p><img src="/mysql-01/image-20230318171722519.png" alt="image-20230318171722519"></p><p>union all查询出来的结果，仅仅进行简单的合并，并未去重</p><pre><code>select * from emp where salary &lt; 5000unionselect * from emp where age &gt; 50;</code></pre><p><img src="/mysql-01/image-20230318171749423.png" alt="image-20230318171749423"></p><p>union 联合查询，会对查询出来的结果进行去重处理。</p><p>注意： 如果多条查询语句查询出来的结果，字段数量不一致，在进行union/union all联合查询时，将会报错。如：</p><p><img src="/mysql-01/image-20230318171808521.png" alt="image-20230318171808521"></p><h2 id="5-6-子查询"><a href="#5-6-子查询" class="headerlink" title="5.6 子查询"></a>5.6 子查询</h2><h3 id="5-6-1-概述"><a href="#5-6-1-概述" class="headerlink" title="5.6.1 概述"></a>5.6.1 概述</h3><p>1). 概念</p><p>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p><pre><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 );</code></pre><p>子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。</p><p>2). 分类</p><p>根据子查询结果不同，分为：</p><p>A. 标量子查询（子查询结果为单个值）</p><p>B. 列子查询(子查询结果为一列) </p><p>C. 行子查询(子查询结果为一行) </p><p>D. 表子查询(子查询结果为多行多列)</p><p>根据子查询位置，分为： </p><p>A. WHERE之后 </p><p>B. FROM之后 </p><p>C. SELECT之后</p><h3 id="5-6-2-标量子查询"><a href="#5-6-2-标量子查询" class="headerlink" title="5.6.2 标量子查询"></a>5.6.2 标量子查询</h3><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。 常用的操作符：= &lt;&gt; &gt; &gt;= &lt; &lt;= </p><p>案例: </p><p>A. 查询 “销售部” 的所有员工信息 </p><p>完成这个需求时，可以将需求分解为两步：</p><p>①. 查询 “销售部” 部门ID</p><pre><code>select id from dept where name = &#39;销售部&#39;;</code></pre><p>②. 根据 “销售部” 部门ID, 查询员工信息</p><pre><code>select * from emp where dept_id = (select id from dept where name = &#39;销售部&#39;);</code></pre><p>B. 查询在 “方东白” 入职之后的员工信息 </p><p>完成这个需求时，可以将需求分解为两步：</p><p>①. 查询 方东白 的入职日期</p><pre><code>select entrydate from emp where name = &#39;方东白&#39;;</code></pre><p>②. 查询指定入职日期之后入职的员工信息</p><pre><code>select * from emp where entrydate &gt; (select entrydate from emp where name = &#39;方东白&#39;);</code></pre><h3 id="5-6-3-列子查询"><a href="#5-6-3-列子查询" class="headerlink" title="5.6.3 列子查询"></a>5.6.3 列子查询</h3><p>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。</p><p>常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围之内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围之内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><p>案例: </p><p>A. 查询 “销售部” 和 “市场部” 的所有员工信息</p><p>分解为以下两步:</p><p> ①. 查询 “销售部” 和 “市场部” 的部门ID</p><pre><code>select id from dept where name = &#39;销售部&#39; or name = &#39;市场部&#39;;</code></pre><p>②. 根据部门ID, 查询员工信息</p><pre><code>select * from emp where dept_id in (select id from dept where name = &#39;销售部&#39; orname = &#39;市场部&#39;);</code></pre><p>B. 查询比 财务部 所有人工资都高的员工信息</p><p>分解为以下两步: ①. 查询所有 财务部 人员工资</p><pre><code>select id from dept where name = &#39;财务部&#39;;select salary from emp where dept_id = (select id from dept where name = &#39;财务部&#39;);</code></pre><p>②. 比 财务部 所有人工资都高的员工信息</p><pre><code>select * from emp where salary &gt; all ( select salary from emp where dept_id =(select id from dept where name = &#39;财务部&#39;) );</code></pre><p>C. 查询比研发部其中任意一人工资高的员工信息</p><p>分解为以下两步:</p><p>①. 查询研发部所有人工资</p><pre><code>select salary from emp where dept_id = (select id from dept where name = &#39;研发部&#39;);</code></pre><p>②. 比研发部其中任意一人工资高的员工信息</p><pre><code>select * from emp where salary &gt; any ( select salary from emp where dept_id =(select id from dept where name = &#39;研发部&#39;) );</code></pre><h3 id="5-6-4-行子查询"><a href="#5-6-4-行子查询" class="headerlink" title="5.6.4 行子查询"></a>5.6.4 行子查询</h3><p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。</p><p> 常用的操作符：= 、&lt;&gt; 、IN 、NOT IN</p><p>案例: </p><p>A. 查询与 “张无忌” 的薪资及直属领导相同的员工信息 ; </p><p>这个需求同样可以拆解为两步进行: </p><p>①. 查询 “张无忌” 的薪资及直属领导</p><pre><code> select salary, managerid from emp where name = &#39;张无忌&#39;;</code></pre><p>②. 查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;</p><pre><code>select * from emp where (salary,managerid) = (select salary, managerid from empwhere name = &#39;张无忌&#39;);</code></pre><h3 id="5-6-5-表子查询"><a href="#5-6-5-表子查询" class="headerlink" title="5.6.5 表子查询"></a>5.6.5 表子查询</h3><p>子查询返回的结果是多行多列，这种子查询称为表子查询。 </p><p>常用的操作符：IN</p><p>案例: </p><p>A. 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><p> 分解为两步执行:</p><p>①. 查询 “鹿杖客” , “宋远桥” 的职位和薪资</p><pre><code>select job, salary from emp where name = &#39;鹿杖客&#39; or name = &#39;宋远桥&#39;;</code></pre><p>②. 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><pre><code>select * from emp where (job,salary) in ( select job, salary from emp where name =&#39;鹿杖客&#39; or name = &#39;宋远桥&#39; );</code></pre><p>B. 查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息</p><p>分解为两步执行:</p><p>①. 入职日期是 “2006-01-01” 之后的员工信息</p><pre><code>select * from emp where entrydate &gt; &#39;2006-01-01&#39;;</code></pre><p>②. 查询这部分员工, 对应的部门信息;</p><pre><code>select e.*, d.* from (select * from emp where entrydate &gt; &#39;2006-01-01&#39;) e leftjoin dept d on e.dept_id = d.id ;</code></pre><h1 id="6-事务"><a href="#6-事务" class="headerlink" title="6.事务"></a>6.事务</h1><h2 id="6-1-事务简介"><a href="#6-1-事务简介" class="headerlink" title="6.1 事务简介"></a>6.1 事务简介</h2><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>就比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加 1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。</p><p><img src="/mysql-01/image-20230318175145463.png" alt="image-20230318175145463"></p><p>正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四 增加1000, 转账成功 :</p><p><img src="/mysql-01/image-20230318175413465.png" alt="image-20230318175413465"></p><p>异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张 三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了。</p><p><img src="/mysql-01/image-20230318175427146.png" alt="image-20230318175427146"></p><p>为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行 完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。</p><p><img src="/mysql-01/image-20230318175441174.png" alt="image-20230318175441174"></p><p>注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐 式的提交事务。</p><h2 id="6-2-事务操作"><a href="#6-2-事务操作" class="headerlink" title="6.2 事务操作"></a>6.2 事务操作</h2><h3 id="6-2-1-未控制事务"><a href="#6-2-1-未控制事务" class="headerlink" title="6.2.1 未控制事务"></a>6.2.1 未控制事务</h3><p>正常执行</p><p><img src="/mysql-01/image-20230318175558427.png" alt="image-20230318175558427"></p><p> 测试异常情况</p><pre><code>-- 1. 查询张三余额select * from account where name = &#39;张三&#39;;-- 2. 张三的余额减少1000update account set money = money - 1000 where name = &#39;张三&#39;;出错了....-- 3. 李四的余额增加1000update account set money = money + 1000 where name = &#39;李四&#39;;</code></pre><p><img src="/mysql-01/image-20230318175542807.png" alt="image-20230318175542807"></p><p>检查最终的数据情况, 发现数据在操作前后不一致了。</p><h3 id="6-2-2-控制事务一"><a href="#6-2-2-控制事务一" class="headerlink" title="6.2.2 控制事务一"></a>6.2.2 控制事务一</h3><p>1). 查看/设置事务提交方式</p><pre><code>SELECT @@autocommit ;SET @@autocommit = 0 ;</code></pre><p>2). 提交事务</p><pre><code>COMMIT;</code></pre><p>3). 回滚事务</p><pre><code>ROLLBACK;</code></pre><p>注意：上述的这种方式，是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提 交, 此时执行的DML语句都不会提交, 需要手动的执行commit进行提交。</p><h3 id="6-2-3-控制事务二"><a href="#6-2-3-控制事务二" class="headerlink" title="6.2.3 控制事务二"></a>6.2.3 控制事务二</h3><p>1). 开启事务</p><pre><code>START TRANSACTION 或 BEGIN ;</code></pre><p>2). 提交事务</p><pre><code>COMMIT;</code></pre><p>3). 回滚事务</p><pre><code>ROLLBACK;</code></pre><p>转账案例：</p><pre><code>-- 开启事务start transaction-- 1. 查询张三余额select * from account where name = &#39;张三&#39;;-- 2. 张三的余额减少1000update account set money = money - 1000 where name = &#39;张三&#39;;-- 3. 李四的余额增加1000update account set money = money + 1000 where name = &#39;李四&#39;;-- 如果正常执行完毕, 则提交事务commit;-- 如果执行过程中报错, 则回滚事务-- rollback;</code></pre><h3 id="6-3-事务四大特性"><a href="#6-3-事务四大特性" class="headerlink" title="6.3 事务四大特性"></a>6.3 事务四大特性</h3><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 </li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><p><img src="/mysql-01/image-20230318180214740.png" alt="image-20230318180214740"></p><h3 id="6-4-并发事务问题"><a href="#6-4-并发事务问题" class="headerlink" title="6.4 并发事务问题"></a>6.4 并发事务问题</h3><p>1). 赃读：一个事务读到另外一个事务还没有提交的数据。</p><p><img src="/mysql-01/image-20230318180237160.png" alt="image-20230318180237160"></p><p>比如B读取到了A未提交的数据。</p><p>2). 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p><p><img src="/mysql-01/image-20230318180253685.png" alt="image-20230318180253685"></p><p> 事务A两次读取同一条记录，但是读取到的数据却是不一样的。</p><p>3). 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 “幻影”。</p><p><img src="/mysql-01/image-20230318180423731.png" alt="image-20230318180423731"></p><h3 id="6-5-事务隔离级别"><a href="#6-5-事务隔离级别" class="headerlink" title="6.5 事务隔离级别"></a>6.5 事务隔离级别</h3><p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>1). 查看事务隔离级别</p><pre><code>SELECT @@TRANSACTION_ISOLATION;</code></pre><p>2). 设置事务隔离级别</p><pre><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED |READ COMMITTED | REPEATABLE READ | SERIALIZABLE }</code></pre><p>注意：事务隔离级别越高，数据越安全，但是性能越低。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
