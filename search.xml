<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql-02</title>
      <link href="/mysql-02.html"/>
      <url>/mysql-02.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1.存储引擎"></a>1.存储引擎</h1><h2 id="1-1-MySQL体系结构"><a href="#1-1-MySQL体系结构" class="headerlink" title="1.1 MySQL体系结构"></a>1.1 MySQL体系结构</h2><p><img src="/mysql-02/image-20230318181430255.png" alt="image-20230318181430255"></p><p>1). 连接层</p><p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务 器也会为安全接入的每个客户端验证它所具有的操作权限。</p><p>2). 服务层</p><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部 分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解 析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大， 这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><p>3). 引擎层</p><p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通 信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库 中的索引是在存储引擎层实现的。</p><p>4). 存储层</p><p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</p><p>和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要 体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。 这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><h2 id="1-2-存储引擎介绍"><a href="#1-2-存储引擎介绍" class="headerlink" title="1.2 存储引擎介绍"></a>1.2 存储引擎介绍</h2><p>对于存储引擎，也是一样，他是mysql数据库的核心，需要在合适的场景选择合适的存储引 擎。接下来就来介绍一下存储引擎。 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是 基于库的，所以存储引擎也可被称为表类型。可以在创建表的时候，来指定选择的存储引擎，如果 没有指定将自动选择默认的存储引擎。</p><p>1). 建表时指定存储引擎</p><pre><code>CREATE TABLE 表名(字段1 字段1类型 [ COMMENT 字段1注释 ] ,......字段n 字段n类型 [COMMENT 字段n注释 ]) ENGINE = INNODB [ COMMENT 表注释 ] ;</code></pre><p>2). 查询当前数据库支持的存储引擎</p><pre><code> show engines;</code></pre><p>示例演示:</p><p>A. 查询建表语句 — 默认存储引擎: InnoDB</p><pre><code> show create table account;</code></pre><p><img src="/mysql-02/image-20230318182248843.png" alt="image-20230318182248843"></p><p>创建表时，即使没有指定存储疫情，数据库也会自动选择默认的存储引擎。</p><p>B. 查询当前数据库支持的存储引擎</p><pre><code>show engines ;</code></pre><p><img src="/mysql-02/image-20230318182342529.png" alt="image-20230318182342529"></p><p>C. 创建表 my_myisam , 并指定MyISAM存储引擎</p><pre><code>create table my_myisam(id int,name varchar(10)) engine = MyISAM ;</code></pre><h2 id="1-3-存储引擎特点"><a href="#1-3-存储引擎特点" class="headerlink" title="1.3 存储引擎特点"></a>1.3 存储引擎特点</h2><h3 id="1-3-1-InnoDB"><a href="#1-3-1-InnoDB" class="headerlink" title="1.3.1 InnoDB"></a>1.3.1 InnoDB</h3><p>1). 介绍</p><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。</p><p>2). 特点</p><ul><li>DML操作遵循ACID模型，支持事务； </li><li>行级锁，提高并发访问性能； </li><li>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</li></ul><p>3). 文件</p><p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结 构（frm-早期的 、sdi-新版的）、数据和索引。</p><p>参数：innodb_file_per_table</p><pre><code>show variables like &#39;innodb_file_per_table&#39;</code></pre><p><img src="/mysql-02/image-20230318182528184.png" alt="image-20230318182528184"></p><p>如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 直接打开MySQL的 数据存放目录： C:\ProgramData\MySQL\MySQL Server 8.0\Data ， 这个目录下有很多文件 夹，不同的文件夹代表不同的数据库。</p><p><img src="/mysql-02/image-20230318182600816.png" alt="image-20230318182600816"></p><p>可以看到里面有很多的ibd文件，每一个ibd文件就对应一张表，比如：有一张表 account，就 有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的 索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一 个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。</p><p><img src="/mysql-02/image-20230318182704471.png" alt="image-20230318182704471"></p><p>4). 逻辑存储结构</p><p><img src="/mysql-02/image-20230318182718828.png" alt="image-20230318182718828"></p><ul><li>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以 包含多个Segment段。 </li><li>段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管 理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。 </li><li>区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为 16K， 即一个区中一共有64个连续的页。</li><li>页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默 认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li><li>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时 所指定的字段以外，还包含两个隐藏字段。</li></ul><h3 id="1-3-2-MyISAM"><a href="#1-3-2-MyISAM" class="headerlink" title="1.3.2 MyISAM"></a>1.3.2 MyISAM</h3><p>1). 介绍</p><p>MyISAM是MySQL早期的默认存储引擎</p><p>2). 特点 </p><p>不支持事务，</p><p>不支持外键</p><p> 支持表锁，不支持行锁 </p><p>访问速度快</p><p>3). 文件</p><p>xxx.sdi：存储表结构信息</p><p> xxx.MYD: 存储数据 </p><p>xxx.MYI: 存储索引</p><p><img src="/mysql-02/image-20230318182949362.png" alt="image-20230318182949362"></p><h3 id="1-3-3-Memory"><a href="#1-3-3-Memory" class="headerlink" title="1.3.3 Memory"></a>1.3.3 Memory</h3><p>1). 介绍</p><p>Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为 临时表或缓存使用。</p><p>2). 特点</p><p> 内存存放</p><p> hash索引（默认）</p><p>3).文件</p><p>xxx.sdi：存储表结构信息</p><h3 id="1-3-4-区别及特点"><a href="#1-3-4-区别及特点" class="headerlink" title="1.3.4 区别及特点"></a>1.3.4 区别及特点</h3><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持(5.6版本之后)</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N/A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table><p>InnoDB引擎与MyISAM引擎的区别 ? </p><p>①. InnoDB引擎, 支持事务, 而MyISAM不支持。 </p><p>②. InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。 </p><p>③. InnoDB引擎, 支持外键, 而MyISAM是不支持的。 </p><p>主要是上述三点区别，当然也可以从索引结构、存储限制等方面，更加深入的回答，具体参 考如下官方文档：</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html</a></p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html</a></p><h3 id="1-4-存储引擎选择"><a href="#1-4-存储引擎选择" class="headerlink" title="1.4 存储引擎选择"></a>1.4 存储引擎选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据 实际情况选择多种存储引擎进行组合。 </p><p>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要 求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操 作，那么InnoDB存储引擎是比较合适的选择。 </p><p>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完 整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。 </p><p>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是 对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</p><h1 id="2-索引"><a href="#2-索引" class="headerlink" title="2.索引"></a>2.索引</h1><h3 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h3><h4 id="2-1-1-介绍"><a href="#2-1-1-介绍" class="headerlink" title="2.1.1 介绍"></a>2.1.1 介绍</h4><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足 特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。</p><h4 id="2-2-演示"><a href="#2-2-演示" class="headerlink" title="2.2 演示"></a>2.2 演示</h4><p>表结构及其数据如下：</p><p><img src="/mysql-02/image-20230318194855504.png" alt="image-20230318194855504"></p><p>假如要执行的SQL语句为 ： select * from user where age = 45</p><p>1). 无索引情况</p><p><img src="/mysql-02/image-20230318194914129.png" alt="image-20230318194914129"></p><p>在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为 全表扫描，性能很 低。</p><p>2). 有索引情况</p><p>如果针对于这张表建立了索引，假设索引结构就是二叉树，那么也就意味着，会对age这个字段建 立一个二叉树的索引结构。</p><p><img src="/mysql-02/image-20230318194942971.png" alt="image-20230318194942971"></p><p>此时进行查询时，只需要扫描三次就可以找到数据了，极大的提高的查询的效率。</p><h4 id="2-3-特点"><a href="#2-3-特点" class="headerlink" title="2.3 特点"></a>2.3 特点</h4><table><thead><tr><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>提高数据检索的效率，降低数据库 的IO成本</td><td>索引列也是要占用空间的。</td></tr><tr><td>通过索引列对数据进行排序，降低 数据排序的成本，降低CPU的消 耗。</td><td>索引大大提高了查询效率，同时却也降低更新表的速度， 如对表进行INSERT、UPDATE、DELETE时，效率降低。</td></tr></tbody></table><h3 id="2-2-索引结构"><a href="#2-2-索引结构" class="headerlink" title="2.2 索引结构"></a>2.2 索引结构</h3><h4 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1 概述"></a>2.2.1 概述</h4><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td></tr><tr><td>Hash索引</td><td>底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不 支持范围查询</td></tr><tr><td>R-tree(空间索 引）</td><td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类 型，通常使用较少</td></tr><tr><td>Full-text(全文 索引)</td><td>是一种通过建立倒排索引,快速匹配文档的方式。类似于 Lucene,Solr,ES</td></tr></tbody></table><p>上述是MySQL中所支持的所有的索引结构.</p><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h4 id="2-2-2-二叉树"><a href="#2-2-2-二叉树" class="headerlink" title="2.2.2 二叉树"></a>2.2.2 二叉树</h4><p>假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下:</p><p><img src="/mysql-02/image-20230318195506632.png" alt="image-20230318195506632"></p><p>如果主键是顺序插入的，则会形成一个单向链表，结构如下：</p><p><img src="/mysql-02/image-20230318195523470.png" alt="image-20230318195523470"></p><p>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p><ul><li>顺序插入时，会形成一个链表，查询性能大大降低。 </li><li>大数据量情况下，层级较深，检索速度慢。</li></ul><p>可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数 据，最终形成的数据结构也是一颗平衡的二叉树,结构如下</p><p><img src="/mysql-02/image-20230318195600407.png" alt="image-20230318195600407"></p><p>但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：</p><ul><li>大数据量情况下，层级较深，检索速度慢。</li></ul><p>所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree.</p><h4 id="2-2-3-B-Tree"><a href="#2-2-3-B-Tree" class="headerlink" title="2.2.3 B-Tree"></a>2.2.3 B-Tree</h4><p>B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。</p><p>以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5 个指针：</p><p><img src="/mysql-02/image-20230318200101312.png" alt="image-20230318200101312"></p><p>树的度数指的是一个节点的子节点个数。</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html" target="_blank" rel="noopener">B-Tree Visualization (usfca.edu)</a></p><p>演示</p><p><img src="/mysql-02/image-20230318200153552.png" alt="image-20230318200153552"></p><p><img src="/mysql-02/image-20230318200233820.png" alt="image-20230318200233820"></p><p>特点：</p><ul><li>5阶的B树，每一个节点最多存储4个key，对应5个指针。 </li><li>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。 </li><li>在B树中，非叶子节点和叶子节点都会存放数据。</li></ul><h4 id="2-2-4-B-Tree"><a href="#2-2-4-B-Tree" class="headerlink" title="2.2.4 B+Tree"></a>2.2.4 B+Tree</h4><p>B+Tree是B-Tree的变种，以一颗最大度数（max-degree）为4（4阶）的b+tree为例，</p><p><img src="/mysql-02/image-20230318201225101.png" alt="image-20230318201225101"></p><p>可以看到，两部分： </p><p>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。 </p><p>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</p><p><img src="/mysql-02/image-20230318201257821.png" alt="image-20230318201257821"></p><p>B+Tree 与 B-Tree相比，主要有以下三点区别： </p><ul><li>所有的数据都会出现在叶子节点。 </li><li>叶子节点形成一个单向链表。 </li><li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</li></ul><p>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点 的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</p><p><img src="/mysql-02/image-20230318201350644.png" alt="image-20230318201350644"></p><h4 id="2-2-5-Hash"><a href="#2-2-5-Hash" class="headerlink" title="2.2.5 Hash"></a>2.2.5 Hash</h4><p>MySQL中除了支持B+Tree索引，还支持一种索引类型—Hash索引。</p><p>1). 结构 哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash表中。</p><p><img src="/mysql-02/image-20230318201435838.png" alt="image-20230318201435838"></p><p>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可 以通过链表来解决。</p><p><img src="/mysql-02/image-20230318201504428.png" alt="image-20230318201504428"></p><p>2). 特点 </p><p>A. Hash索引只能用于对等比较(=，in)，不支持范围查询（between，&gt;，&lt; ，…）</p><p>B. 无法利用索引完成排序操作 C. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</p><p>3). 存储引擎支持</p><p> 在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。</p><h3 id="2-3-索引分类"><a href="#2-3-索引分类" class="headerlink" title="2.3 索引分类"></a>2.3 索引分类</h3><h4 id="2-3-1-索引分类"><a href="#2-3-1-索引分类" class="headerlink" title="2.3.1 索引分类"></a>2.3.1 索引分类</h4><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键 索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建, 只能 有一个</td><td>PRIMARY</td></tr><tr><td>唯一 索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规 索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文 索引</td><td>全文索引查找的是文本中的关键词，而不是比 较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><h4 id="2-3-2-聚集索引-amp-二级索引"><a href="#2-3-2-聚集索引-amp-二级索引" class="headerlink" title="2.3.2 聚集索引&amp;二级索引"></a>2.3.2 聚集索引&amp;二级索引</h4><p>而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据</td><td>必须有,而且只 有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>聚集索引选取规则:</p><ul><li>如果存在主键，主键索引就是聚集索引。</li></ul><ul><li><p>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p></li><li><p>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p></li></ul><p>聚集索引选取规则:</p><ul><li>如果存在主键，主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索 引。</li></ul><p>聚集索引和二级索引的具体结构如下：</p><p><img src="/mysql-02/image-20230318221645990.png" alt="image-20230318221645990"></p><ul><li>聚集索引的叶子节点下挂的是这一行的数据 。 </li><li>二级索引的叶子节点下挂的是该字段值对应的主键值。</li></ul><p>执行如下的SQL语句时，具体的查找过程是什么样子的。</p><p><img src="/mysql-02/image-20230318221907869.png" alt="image-20230318221907869"></p><p>具体过程如下:</p><p>①. 由于是根据name字段进行查询，所以先根据name=’Arm’到name字段的二级索引中进行匹配查 找。但是在二级索引中只能查找到 Arm 对应的主键值10</p><p>②. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最 终找到10对应的行row。</p><p>③. 最终拿到这一行的数据，直接返回即可。</p><p>回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取 数据的方式，就称之为回表查询。</p><p><img src="/mysql-02/image-20230318222059039.png" alt="image-20230318222059039"></p><p>假设:</p><p>一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空 间，主键即使为bigint，占用字节数为8。</p><p>高度为2：</p><p>​        n * 8 + (n + 1) * 6 = 16*1024 , 算出n约为 1170</p><p>​        1171* 16 = 18736</p><p>也就是说，如果树的高度为2，则可以存储 18000 多条记录。</p><p>高度为3：</p><p>1171 * 1171 * 16 = 21939856</p><p>也就是说，如果树的高度为3，则可以存储 2200w 左右的记录。</p><h3 id="2-4-索引语法"><a href="#2-4-索引语法" class="headerlink" title="2.4 索引语法"></a>2.4 索引语法</h3><p>1). 创建索引</p><pre><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,... ) ;</code></pre><p>2). 查看索引</p><pre><code> SHOW INDEX FROM table_name ;</code></pre><p>3). 删除索引</p><pre><code>DROP INDEX index_name ON table_name ;</code></pre><p>演示表</p><pre><code>create table tb_user(id int primary key auto_increment comment &#39;主键&#39;,name varchar(50) not null comment &#39;用户名&#39;,phone varchar(11) not null comment &#39;手机号&#39;,email varchar(100) comment &#39;邮箱&#39;,profession varchar(11) comment &#39;专业&#39;,age tinyint unsigned comment &#39;年龄&#39;,gender char(1) comment &#39;性别 , 1: 男, 2: 女&#39;,status char(1) comment &#39;状态&#39;,createtime datetime comment &#39;创建时间&#39;) comment &#39;系统用户表&#39;</code></pre><p><img src="/mysql-02/image-20230318222406413.png" alt="image-20230318222406413"></p><p>A. name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。</p><pre><code>CREATE INDEX idx_user_name ON tb_user(name);</code></pre><p>B. phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引。</p><pre><code>CREATE UNIQUE INDEX idx_user_phone ON tb_user(phone);</code></pre><p>C. 为profession、age、status创建联合索引。</p><pre><code>CREATE INDEX idx_user_pro_age_sta ON tb_user(profession,age,status);</code></pre><p>D. 为email建立合适的索引来提升查询效率</p><pre><code>CREATE INDEX idx_email ON tb_user(email)</code></pre><p><img src="/mysql-02/image-20230318222612965.png" alt="image-20230318222612965"></p><h3 id="2-5-SQL性能分析"><a href="#2-5-SQL性能分析" class="headerlink" title="2.5 SQL性能分析"></a>2.5 SQL性能分析</h3><h4 id="2-5-1-SQL执行频率"><a href="#2-5-1-SQL执行频率" class="headerlink" title="2.5.1 SQL执行频率"></a>2.5.1 SQL执行频率</h4><p>通过 show [session|global] status 命令可以提供服务器状态信 息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：</p><pre><code>-- session 是查看当前会话 ;-- global 是查询全局数据 ;SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;;</code></pre><p><img src="/mysql-02/image-20230318222752012.png" alt="image-20230318222752012"></p><p>查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，可以考虑不对其进行索引的优化。 如果是以查询为主，那么就要考虑对数据库的索引进行优化了。</p><h4 id="2-5-2-慢查询日志"><a href="#2-5-2-慢查询日志" class="headerlink" title="2.5.2 慢查询日志"></a>2.5.2 慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志</p><p>MySQL的慢查询日志默认没有开启，</p><p><img src="/mysql-02/image-20230318224609961.png" alt="image-20230318224609961"></p><p>如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p><pre><code># 开启MySQL慢日志查询开关slow_query_log=1# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志long_query_time=2</code></pre><p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息</p><p>/var/lib/mysql/localhost-slow.log。</p><pre><code>systemctl restart mysqld</code></pre><p>然后，再次查看开关情况，慢查询日志就已经打开了。</p><p><img src="/mysql-02/image-20230318224945351.png" alt="image-20230318224945351"></p><p>A. 执行如下SQL语句 ：</p><pre><code>select * from tb_user; -- 这条SQL执行效率比较高, 执行耗时 0.00secselect count(*) from tb_sku; -- 由于tb_sku表中, 预先存入了1000w的记录, count一次,耗时13.35sec</code></pre><p>B. 检查慢查询日志 ：在慢查询日志中，只会记录执行时间超多预设时间（2s）的SQL，执行较快的SQL 是不会记录的。</p><p><img src="/mysql-02/image-20230318225343630.png" alt="image-20230318225343630"></p><h4 id="2-5-3-profile详情"><a href="#2-5-3-profile详情" class="headerlink" title="2.5.3 profile详情"></a>2.5.3 profile详情</h4><p>show profiles 能够在做SQL优化时帮助了解时间都耗费到哪里去了。通过have_profiling 参数，能够看到当前MySQL是否支持profile操作：</p><pre><code>SELECT @@have_profiling ;</code></pre><p><img src="/mysql-02/image-20230318225426205.png" alt="image-20230318225426205"></p><p>可以看到，当前MySQL是支持 profile操作的，但是开关是关闭的。可以通过set语句在 session/global级别开启profiling：</p><pre><code>SET profiling = 1;</code></pre><p>开关已经打开了，接下来，执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去 了。 </p><p>执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：</p><pre><code>-- 查看每一条SQL的耗时基本情况show profiles;-- 查看指定query_id的SQL语句各个阶段的耗时情况show profile for query query_id;-- 查看指定query_id的SQL语句CPU的使用情况show profile cpu for query query_id;</code></pre><p><img src="/mysql-02/image-20230318225648176.png" alt="image-20230318225648176"></p><p>查看指定SQL各个阶段的耗时情况 :  query_id为16的情况</p><p><img src="/mysql-02/image-20230318225705567.png" alt="image-20230318225705567"></p><h4 id="2-5-4-explain"><a href="#2-5-4-explain" class="headerlink" title="2.5.4 explain"></a>2.5.4 explain</h4><p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行 过程中表如何连接和连接的顺序。</p><p>语法:</p><pre><code>-- 直接在select语句之前加上关键字 explain / descEXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;</code></pre><p><img src="/mysql-02/image-20230318225806472.png" alt="image-20230318225806472"></p><p>Explain 执行计划中各个字段的含义:</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序 (id相同，执行顺序从上到下；id不同，值越大，越先执行)。</td></tr><tr><td>select_type</td><td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接 或者子查询）、PRIMARY（主查询，即外层的查询）、 UNION（UNION 中的第二个或者后面的查询语句）、 SUBQUERY（SELECT/WHERE之后包含了子查询）等</td></tr><tr><td>type</td><td>表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。</td></tr><tr><td>possible_key</td><td>显示可能应用在这张表上的索引，一个或多个。</td></tr><tr><td>key</td><td>实际使用的索引，如果为NULL，则没有使用索引。</td></tr><tr><td>key_len</td><td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。</td></tr><tr><td>rows</td><td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值， 可能并不总是准确的。</td></tr><tr><td>filtered</td><td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td></tr></tbody></table><h3 id="2-6-索引使用"><a href="#2-6-索引使用" class="headerlink" title="2.6 索引使用"></a>2.6 索引使用</h3><h4 id="2-6-1-验证索引效率"><a href="#2-6-1-验证索引效率" class="headerlink" title="2.6.1 验证索引效率"></a>2.6.1 验证索引效率</h4><p>这表中有1000W的记录</p><p>这张表中id为主键，有主键索引，而其他字段是没有建立索引的。 先来查询其中的一条记录，看 看里面的字段情况，执行如下SQL：</p><pre><code>select * from tb_sku where id = 1\G;\G是垂直显示</code></pre><p><img src="/mysql-02/image-20230318230447872.png" alt="image-20230318230447872"></p><p>可以看到即使有1000w的数据,根据id进行数据查询,性能依然很快，因为主键id是有索引的。</p><pre><code>SELECT * FROM tb_sku WHERE sn = &#39;100000003145001&#39;;</code></pre><p><img src="/mysql-02/image-20230318230511242.png" alt="image-20230318230511242"></p><p>可以看到根据sn字段进行查询，查询返回了一条数据，结果耗时 20.78sec，就是因为sn没有索 引，而造成查询效率很低。 可以针对于sn字段，建立一个索引，建立了索引之后，再次根据sn进行查询，再来看一 下查询耗时情况。</p><p>创建索引：</p><pre><code>create index idx_sku_sn on tb_sku(sn) ;</code></pre><p><img src="/mysql-02/image-20230318230652231.png" alt="image-20230318230652231"></p><p>然后再次执行相同的SQL语句，再次查看SQL的耗时。</p><pre><code>SELECT * FROM tb_sku WHERE sn = &#39;100000003145001&#39;;</code></pre><p><img src="/mysql-02/image-20230318230724284.png" alt="image-20230318230724284"></p><p>明显会看到，sn字段建立了索引之后，查询性能大大提升。建立索引前后，查询耗时都不是一个数 量级的。</p><h4 id="2-6-2-最左前缀法则"><a href="#2-6-2-最左前缀法则" class="headerlink" title="2.6.2 最左前缀法则"></a>2.6.2 最左前缀法则</h4><p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。</p><p>以 tb_user 表为例，</p><p><img src="/mysql-02/image-20230318230807101.png" alt="image-20230318230807101"></p><p>在 tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession， age，status。 对于最左前缀法则指的是，查询时，最左变的列，也就是profession必须存在，否则索引全部失效。 而且中间不能跳过某一列，否则该列后面的字段索引将失效。</p><p>当执行SQL语句: explain select * from tb_user where age = 31 and status = ‘0’ and profession = ‘软件工程’； 时，是否满足最左前缀法则，走不走 上述的联合索引，索引长度？</p><p><img src="/mysql-02/image-20230318230911191.png" alt="image-20230318230911191"></p><p>可以看到，是完全满足最左前缀法则的，索引长度54，联合索引是生效的。</p><p>注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是 第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p><h4 id="2-6-3-范围查询"><a href="#2-6-3-范围查询" class="headerlink" title="2.6.3 范围查询"></a>2.6.3 范围查询</h4><p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效。</p><pre><code>explain select * from tb_user where profession = &#39;软件工程&#39; and age &gt; 30 and status= &#39;0&#39;;</code></pre><p><img src="/mysql-02/image-20230318231120926.png" alt="image-20230318231120926"></p><p>当范围查询使用&gt; 或 &lt; 时，走联合索引了，但是索引的长度为49，就说明范围查询右边的status字 段是没有走索引的。</p><pre><code>explain select * from tb_user where profession = &#39;软件工程&#39; and age &gt;= 30 andstatus = &#39;0&#39;;</code></pre><p><img src="/mysql-02/image-20230318231212418.png" alt="image-20230318231212418"></p><p>当范围查询使用&gt;= 或 &lt;= 时，走联合索引了，但是索引的长度为54，就说明所有的字段都是走索引 的。 所以，在业务允许的情况下，尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，而避免使用 &gt; 或 &lt; 。</p><h4 id="2-6-4-索引失效情况"><a href="#2-6-4-索引失效情况" class="headerlink" title="2.6.4 索引失效情况"></a>2.6.4 索引失效情况</h4><h5 id="2-6-4-1-索引列运算"><a href="#2-6-4-1-索引列运算" class="headerlink" title="2.6.4.1 索引列运算"></a>2.6.4.1 索引列运算</h5><p>不要在索引列上进行运算操作， 索引将失效。</p><p>在tb_user表中，除了前面介绍的联合索引之外，还有一个索引，是phone字段的单列索引。</p><p><img src="/mysql-02/image-20230318231259493.png" alt="image-20230318231259493"></p><p>A. 当根据phone字段进行等值匹配查询时, 索引生效。</p><pre><code>explain select * from tb_user where phone = &#39;17799990015&#39;;</code></pre><p>B. 当根据phone字段进行函数运算操作之后，索引失效。</p><pre><code>explain select * from tb_user where substring(phone,10,2) = &#39;15&#39;</code></pre><p><img src="/mysql-02/image-20230318231423997.png" alt="image-20230318231423997"></p><h5 id="2-6-4-2-字符串不加引号"><a href="#2-6-4-2-字符串不加引号" class="headerlink" title="2.6.4.2 字符串不加引号"></a>2.6.4.2 字符串不加引号</h5><p>字符串类型字段使用时，不加引号，索引将失效。</p><pre><code>explain select * from tb_user where profession = &#39;软件工程&#39; and age = 31 and status= &#39;0&#39;;explain select * from tb_user where profession = &#39;软件工程&#39; and age = 31 and status= 0;</code></pre><p><img src="/mysql-02/image-20230318231630498.png" alt="image-20230318231630498"></p><pre><code>explain select * from tb_user where phone = &#39;17799990015&#39;;explain select * from tb_user where phone = 17799990015;</code></pre><p><img src="/mysql-02/image-20230318231652044.png" alt="image-20230318231652044"></p><p>经过上面两组示例，会明显的发现，如果字符串不加单引号，对于查询结果，没什么影响，但是数 据库存在隐式类型转换，索引将失效。</p><h5 id="2-6-4-3-模糊查询"><a href="#2-6-4-3-模糊查询" class="headerlink" title="2.6.4.3 模糊查询"></a>2.6.4.3 模糊查询</h5><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><p>由于下面查询语句中，都是根据profession字段查询，符合最左前缀法则，联合索引是可以生效的， 主要看一下，模糊查询时，%加在关键字之前，和加在关键字之后的影响。</p><pre><code>explain select * from tb_user where profession like &#39;软件%&#39;;explain select * from tb_user where profession like &#39;%工程&#39;;explain select * from tb_user where profession like &#39;%工%&#39;;</code></pre><p><img src="/mysql-02/image-20230318231758572.png" alt="image-20230318231758572"></p><p>经过上述的测试，在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字 前面加了%，索引将会失效。</p><h5 id="3-6-4-4-or连接条件"><a href="#3-6-4-4-or连接条件" class="headerlink" title="3.6.4.4 or连接条件"></a>3.6.4.4 or连接条件</h5><p>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会 被用到。</p><pre><code>xplain select * from tb_user where id = 10 or age = 23;explain select * from tb_user where phone = &#39;17799990017&#39; or age = 23;</code></pre><p><img src="/mysql-02/image-20230318231912002.png" alt="image-20230318231912002"></p><p>由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。</p><p>然后，可以对age字段建立索引。</p><pre><code>create index idx_user_age on tb_user(age)</code></pre><p><img src="/mysql-02/image-20230318231942043.png" alt="image-20230318231942043"></p><p>建立了索引之后，再次执行上述的SQL语句，看看前后执行计划的变化。</p><p><img src="/mysql-02/image-20230318231954670.png" alt="image-20230318231954670"></p><p>当or连接的条件，左右两侧字段都有索引时，索引才会生效。</p><h5 id="3-6-4-5-数据分布影响"><a href="#3-6-4-5-数据分布影响" class="headerlink" title="3.6.4.5 数据分布影响"></a>3.6.4.5 数据分布影响</h5><pre><code>select * from tb_user where phone &gt;= &#39;17799990005&#39;;select * from tb_user where phone &gt;= &#39;17799990015&#39;;</code></pre><p><img src="/mysql-02/image-20230318232049614.png" alt="image-20230318232049614"></p><p>相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样</p><p>因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃 索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不 如走全表扫描来的快，此时索引就会失效。</p><p> is null 与 is not null 操作是否走索引。</p><p>执行如下两条语句 ：</p><pre><code>explain select * from tb_user where profession is null;explain select * from tb_user where profession is not null;</code></pre><p><img src="/mysql-02/image-20230318232202493.png" alt="image-20230318232202493"></p><p>将profession字段值全部更新为null。</p><p><img src="/mysql-02/image-20230318232214786.png" alt="image-20230318232214786"></p><p>然后，再次执行上述的两条SQL，查看SQL语句的执行计划。</p><p>最终看到，一模一样的SQL语句，先后执行了两次，结果查询计划是不一样的，为什么会出现这种 现象，这是和数据库的数据分布有关系。查询时MySQL会评估，走索引快，还是全表扫描快，如果全表 扫描更快，则放弃索引走全表扫描。 因此，is null 、is not null是否走索引，得具体情况具体 分析，并不是固定的。</p><h5 id="2-6-5-SQL提示"><a href="#2-6-5-SQL提示" class="headerlink" title="2.6.5 SQL提示"></a>2.6.5 SQL提示</h5><p>目前tb_user表的数据情况如下:</p><p><img src="/mysql-02/image-20230318232304149.png" alt="image-20230318232304149"></p><p>索引情况如下:</p><p><img src="/mysql-02/image-20230318232313580.png" alt="image-20230318232313580"></p><p>把上述的 idx_user_age, idx_email 这两个之前测试使用过的索引直接删除。</p><pre><code>drop index idx_user_age on tb_user;drop index idx_email on tb_user;</code></pre><p>A. 执行SQL : explain select * from tb_user where profession = ‘软件工程’;</p><p><img src="/mysql-02/image-20230318232402315.png" alt="image-20230318232402315"></p><p>查询走了联合索引。</p><p>B. 执行SQL，创建profession的单列索引：create index idx_user_pro on tb_user(profession);</p><p><img src="/mysql-02/image-20230318232418417.png" alt="image-20230318232418417"></p><p>C. 创建单列索引后，再次执行A中的SQL语句，查看执行计划，看看到底走哪个索引。</p><p><img src="/mysql-02/image-20230318232427617.png" alt="image-20230318232427617"></p><p>可以看到，possible_keys中 idx_user_pro_age_sta,idx_user_pro 这两个 索引都可能用到，最终MySQL选择了idx_user_pro_age_sta索引。这是MySQL自动选择的结果。</p><p>手动指定使用索引</p><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优 化操作的目的。</p><p>1). use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进 行评估）。</p><pre><code>explain select * from tb_user use index(idx_user_pro) where profession = &#39;软件工程&#39;;</code></pre><p>2). ignore index ： 忽略指定的索引。</p><pre><code>explain select * from tb_user ignore index(idx_user_pro) where profession = &#39;软件工程&#39;;</code></pre><p>3). force index ： 强制使用索引。</p><pre><code>explain select * from tb_user force index(idx_user_pro) where profession = &#39;软件工程&#39;;</code></pre><h5 id="2-6-6-覆盖索引"><a href="#2-6-6-覆盖索引" class="headerlink" title="2.6.6 覆盖索引"></a>2.6.6 覆盖索引</h5><p>尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ 覆盖索引是指 查询使用了索引，并 且需要返回的列，在该索引中已经全部能够找到 。</p><p>执行下述sql语句</p><pre><code>explain select id, profession from tb_user where profession = &#39;软件工程&#39; and age =31 and status = &#39;0&#39; ;explain select id,profession,age, status from tb_user where profession = &#39;软件工程&#39;and age = 31 and status = &#39;0&#39; ;explain select id,profession,age, status, name from tb_user where profession = &#39;软件工程&#39; and age = 31 and status = &#39;0&#39; ;explain select * from tb_user where profession = &#39;软件工程&#39; and age = 31 and status= &#39;0&#39;;</code></pre><p>上述这几条SQL的执行结果为:</p><p><img src="/mysql-02/image-20230318232641116.png" alt="image-20230318232641116"></p><p>从上述的执行计划我们可以看到，这四条SQL语句的执行计划前面所有的指标都是一样的，看不出来差 异。但是此时主要关注的是后面的Extra，前面两天SQL的结果为 Using where; Using Index ; 而后面两条SQL的结果为: Using index condition 。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-01</title>
      <link href="/mysql-01.html"/>
      <url>/mysql-01.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-MySQL概述"><a href="#1-MySQL概述" class="headerlink" title="1.MySQL概述"></a>1.MySQL概述</h1><h2 id="1-1-数据库相关概念"><a href="#1-1-数据库相关概念" class="headerlink" title="1.1 数据库相关概念"></a>1.1 数据库相关概念</h2><table><thead><tr><th>名称</th><th>全称</th><th>简称</th></tr></thead><tbody><tr><td>数据库</td><td>存储数据的仓库，数据是有组织的进行存储</td><td>DataBase（DB）</td></tr><tr><td>数据库管理系统</td><td>操纵和管理数据库的大型软件</td><td>DataBase Management System (DBMS)</td></tr><tr><td>SQL</td><td>操作关系型数据库的编程语言，定义了一套操作 关系型数据库统一标准</td><td>Structured Query Language (SQL)</td></tr></tbody></table><h3 id="1-1-1mysql数据库连接"><a href="#1-1-1mysql数据库连接" class="headerlink" title="1.1.1mysql数据库连接"></a>1.1.1mysql数据库连接</h3><ol><li>使用MySQL提供的客户端命令行工具</li><li>使用系统自带的命令行工具执行指令</li></ol><pre><code>mysql [-h 127.0.0.1] [-P 3306] -u root -p参数：-h : MySQL服务所在的主机IP-P : MySQL服务端口号， 默认3306-u : MySQL数据库用户名-p ： MySQL数据库用户名对应的密码</code></pre><p>[]内为可选参数，如果需要连接远程的MySQL，需要加上这两个参数来指定远程主机IP、端口，如果 连接本地的MySQL，则无需指定这两个参数。</p><h3 id="1-1-2-数据模型"><a href="#1-1-2-数据模型" class="headerlink" title="1.1.2 数据模型"></a>1.1.2 数据模型</h3><p>1). 关系型数据库（RDBMS） 概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。 而所谓二维表，指的是由行和列组成的表，如下图（就类似于Excel表格数据，有表头、有列、有行， 还可以通过一列关联另外一个表格中的某一列数据）。MySQL、Oracle、DB2、 SQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。简单说，基于二维表存储 数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库。</p><p><img src="/mysql-01/image-20230317200345320.png" alt="image-20230317200345320"></p><p>特点： A. 使用表存储数据，格式统一，便于维护。 </p><p>​            B. 使用SQL语言操作，标准统一，使用方便。</p><p>2). 数据模型 MySQL是关系型数据库，是基于二维表进行数据存储的，具体的结构图下:</p><p><img src="/mysql-01/image-20230317200415240.png" alt="image-20230317200415240"></p><p>可以通过MySQL客户端连接数据库管理系统DBMS，然后通过DBMS操作数据库。 </p><p>可以使用SQL语句，通过数据库管理系统操作数据库，以及操作数据库中的表结构及数据。 一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包 含多行记录。</p><h1 id="2-SQL"><a href="#2-SQL" class="headerlink" title="2.SQL"></a>2.SQL</h1><p>全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了 一套操作关系型数据库统一标准 。</p><h2 id="2-1-SQL通用语法"><a href="#2-1-SQL通用语法" class="headerlink" title="2.1 SQL通用语法"></a>2.1 SQL通用语法</h2><ol><li>SQL语句可以单行或多行书写，以分号结尾。</li><li>SQL语句可以使用空格/缩进来增强语句的可读性。</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</li><li>注释： 单行注释：– 注释内容 或 # 注释内容 多行注释：/* 注释内容 */</li></ol><h2 id="2-2-sql分类"><a href="#2-2-sql分类" class="headerlink" title="2.2 sql分类"></a>2.2 sql分类</h2><p>SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL。</p><table><thead><tr><th>分类</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>数据定义语言，用来定义数据库对象(数据库，表， 字段)</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>数据操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据查询语言，用来查询数据库中表的记录</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>数据控制语言，用来创建数据库用户、控制数据库的 访问权限</td></tr></tbody></table><h2 id="2-3-DDL"><a href="#2-3-DDL" class="headerlink" title="2.3 DDL"></a>2.3 DDL</h2><p>Data Definition Language，数据定义语言，用来定义数据库对象(数据库，表，字段) 。</p><h3 id="2-3-1-数据库操作"><a href="#2-3-1-数据库操作" class="headerlink" title="2.3.1 数据库操作"></a>2.3.1 数据库操作</h3><p>1). 查询所有数据库</p><pre><code>show databases ;</code></pre><p>2). 查询当前数据库</p><pre><code>select database() ;</code></pre><p>3). 创建数据库</p><pre><code>create database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ;</code></pre><p>在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。</p><p>可以通过if not exists 参数来解决这个问题，数据库不存在, 则创建该数据库，如果存在，则不 创建。</p><pre><code>create database if not extists itcast;</code></pre><p>B. 创建一个itheima数据库，并且指定字符集</p><pre><code>create database 数据库名称 default charset utf8mb4;</code></pre><p>4). 删除数据库</p><pre><code> drop database [ if exists ] 数据库名 ;</code></pre><p>如果删除一个不存在的数据库，将会报错。此时，可以加上参数 if exists ，如果数据库存在，再 执行删除，否则不执行删除。</p><p>5). 切换数据库</p><pre><code>use 数据库名 ;</code></pre><p>要操作某一个数据库下的表时，就需要通过该指令，切换到对应的数据库下，否则是不能操作的。</p><h3 id="2-3-2-表操作"><a href="#2-3-2-表操作" class="headerlink" title="2.3.2 表操作"></a>2.3.2 表操作</h3><h4 id="2-3-2-1-表操作-查询创建"><a href="#2-3-2-1-表操作-查询创建" class="headerlink" title="2.3.2.1 表操作-查询创建"></a>2.3.2.1 表操作-查询创建</h4><p>1). 查询当前数据库所有表</p><pre><code>show tables;</code></pre><p>2). 查看指定表结构</p><pre><code>desc 表名 ;</code></pre><p>3). 查询指定表的建表语句</p><pre><code>show create table 表名 ;</code></pre><p>4). 创建表结构</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE 表名(字段1 字段1类型 [ COMMENT 字段1注释 ],字段2 字段2类型 [COMMENT 字段2注释 ],字段3 字段3类型 [COMMENT 字段3注释 ],......字段n 字段n类型 [COMMENT 字段n注释 ]) [ COMMENT 表注释 ] ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意: […] 内为可选参数，最后一个字段后面没有逗号</p><p>比如，创建一张表 tb_user ，对应的结构如下，那么建表语句为：</p><p><img src="/mysql-01/image-20230318122920257.png" alt="image-20230318122920257"></p><pre class="line-numbers language-mysql"><code class="language-mysql">create table tb_user(id int comment '编号',name varchar(50) comment '姓名',age int comment '年龄',gender varchar(1) comment '性别') comment '用户表';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-2-2-表操作-数据类型"><a href="#2-3-2-2-表操作-数据类型" class="headerlink" title="2.3.2.2 表操作-数据类型"></a>2.3.2.2 表操作-数据类型</h4><p> MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。</p><p>1). 数值类型</p><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">范围（有符号）</th><th align="left">范围（无符号）</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1 Bytes</td><td align="left">(-128，127)</td><td align="left">(0，255)</td><td align="left">小整数值</td></tr><tr><td align="left">SMALLINT</td><td align="left">2 Bytes</td><td align="left">(-32 768，32 767)</td><td align="left">(0，65 535)</td><td align="left">大整数值</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3 Bytes</td><td align="left">(-8 388 608，8 388 607)</td><td align="left">(0，16 777 215)</td><td align="left">大整数值</td></tr><tr><td align="left">INT或INTEGER</td><td align="left">4 Bytes</td><td align="left">(-2 147 483 648，2 147 483 647)</td><td align="left">(0，4 294 967 295)</td><td align="left">大整数值</td></tr><tr><td align="left">BIGINT</td><td align="left">8 Bytes</td><td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td align="left">(0，18 446 744 073 709 551 615)</td><td align="left">极大整数值</td></tr><tr><td align="left">FLOAT</td><td align="left">4 Bytes</td><td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="left">单精度 浮点数值</td></tr><tr><td align="left">DOUBLE</td><td align="left">8 Bytes</td><td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">双精度 浮点数值</td></tr><tr><td align="left">DECIMAL</td><td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="left">依赖于M和D的值</td><td align="left">依赖于M和D的值</td><td align="left">小数值</td></tr></tbody></table><pre><code>如:1). 年龄字段 -- 不会出现负数, 而且人的年龄不会太大age tinyint unsigned2). 分数 -- 总分100分, 最多出现一位小数score double(4,1)</code></pre><p>2). 字符串类型</p><table><thead><tr><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 bytes</td><td>定长字符串(需要指定长度)</td></tr><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串(需要指定长度)</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过255个字符的二进制数据</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table><p>char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和 字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性 能会更高些。</p><pre><code>如：1). 用户名 username ------&gt; 长度不定, 最长不会超过50username varchar(50)2). 性别 gender ---------&gt; 存储值, 不是男,就是女gender char(1)3). 手机号 phone --------&gt; 固定长度为11phone char(11)</code></pre><p>3). 日期时间类型</p><table><thead><tr><th align="left">类型</th><th align="left">大小 ( bytes)</th><th align="left">范围</th><th align="left">格式</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01/9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="left">日期值</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’/‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="left">时间值或持续时间</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901/2155</td><td align="left">YYYY</td><td align="left">年份值</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="left">混合日期和时间值</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="left">混合日期和时间值，时间戳</td></tr></tbody></table><pre><code>1). 生日字段 birthdaybirthday date2). 创建时间 createtimecreatetime datetime</code></pre><p>2.3.2.3 表操作-案例 设计一张员工信息表，要求如下：</p><ol><li>编号（纯数字） </li><li>员工工号 (字符串类型，长度不超过10位) </li><li>员工姓名（字符串类型，长度不超过10位）</li><li>性别（男/女，存储一个汉字） </li><li>年龄（正常人年龄，不可能存储负数）</li><li>身份证号（二代身份证号均为18位，身份证中有X这样的字符） </li><li>入职时间（取值年月日即可）</li></ol><pre><code>create table emp(    id int comment &quot;编号&quot;,    workno varchar(10) comment&#39;工号&#39;,    name varchar(10) comment&#39;姓名&#39;,    gender char(1) comment &#39;性别&#39;,    age tinyint unsigned comment &#39;年龄&#39;,    idcard char(10) comment &#39;身份证号&#39;,    entrydate date comment &#39;入职时间&#39;)comment &#39;员工表&#39;,</code></pre><h4 id="2-3-2-4-表操作-修改"><a href="#2-3-2-4-表操作-修改" class="headerlink" title="2.3.2.4 表操作-修改"></a>2.3.2.4 表操作-修改</h4><p>1). 添加字段</p><pre><code>ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</code></pre><p>案例:</p><p>为emp表增加一个新的字段”昵称”为nickname，类型为varchar(20)</p><pre><code>ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;</code></pre><p>2). 修改数据类型</p><pre><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型（长度);</code></pre><p>3). 修改字段名和字段类型</p><pre><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</code></pre><p>案例: 将emp表的nickname字段修改为username，类型为varchar(30)</p><pre><code>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;</code></pre><p>4). 删除字段</p><pre><code>ALTER TABLE 表名 DROP 字段名</code></pre><p>案例: </p><p>将emp表的字段username删除</p><pre><code>ALTER TABLE emp DROP username</code></pre><p>5). 修改表名</p><pre><code>ALTER TABLE 表名 RENAME TO 新表名;</code></pre><p>案例: </p><p>将emp表的表名修改为 employee</p><pre><code> ALTER TABLE emp RENAME TO employee;</code></pre><h4 id="2-3-2-5-表操作-删除"><a href="#2-3-2-5-表操作-删除" class="headerlink" title="2.3.2.5 表操作-删除"></a>2.3.2.5 表操作-删除</h4><pre><code>DROP TABLE [ IF EXISTS ] 表名;</code></pre><p>可选项 IF EXISTS 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不 加该参数项，删除一张不存在的表，执行将会报错)。 案例: 如果tb_user表存在，则删除tb_user表</p><pre><code>DROP TABLE IF EXISTS tb_user;</code></pre><p>2). 删除指定表, 并重新创建表</p><pre><code>TRUNCATE TABLE 表名</code></pre><p>注意: 在删除表的时候，表中的全部数据也都会被删除。</p><h2 id="2-4-图形化界面工具"><a href="#2-4-图形化界面工具" class="headerlink" title="2.4 图形化界面工具"></a>2.4 图形化界面工具</h2><p><img src="/mysql-01/image-20230318143403192.png" alt="image-20230318143403192"></p><p>个人感觉DataGrip好用</p><h2 id="2-5-DML"><a href="#2-5-DML" class="headerlink" title="2.5 DML"></a>2.5 DML</h2><p>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进 行增、删、改操作。</p><ul><li>添加数据（INSERT）</li><li>修改数据（UPDATE） </li><li>删除数据（DELETE）</li></ul><h3 id="2-5-1-添加数据"><a href="#2-5-1-添加数据" class="headerlink" title="2.5.1 添加数据"></a>2.5.1 添加数据</h3><p> 1). 给指定字段添加数据</p><pre><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code></pre><p>给employee表所有的字段添加数据 ；</p><pre><code>insert into employee(id,workno,name,gender,age,idcard,entrydate)values(1,&#39;1&#39;,&#39;Itcast&#39;,&#39;男&#39;,10,&#39;123456789012345678&#39;,&#39;2000-01-01&#39;);</code></pre><p>2). 给全部字段添加数据</p><pre><code>INSERT INTO 表名 VALUES (值1, 值2, ...);</code></pre><p>插入数据到employee表，具体的SQL如下：</p><pre><code>insert into employee values(2,&#39;2&#39;,&#39;张无忌&#39;,&#39;男&#39;,18,&#39;123456789012345670&#39;,&#39;2005-01-01&#39;);</code></pre><p>3). 批量添加数据</p><pre><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;</code></pre><pre><code>INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;</code></pre><p>注意事项: </p><ul><li>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。</li><li>字符串和日期型数据应该包含在引号中。 </li><li>插入的数据大小，应该在字段的规定范围内。</li></ul><h3 id="2-5-2-修改数据"><a href="#2-5-2-修改数据" class="headerlink" title="2.5.2 修改数据"></a>2.5.2 修改数据</h3><p>修改数据的具体语法为:</p><pre><code>UPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ] ;</code></pre><p>案例:</p><p>A. 修改id为1的数据，将name修改为nametest</p><pre><code>update employee set name = &#39;nametest&#39; where id = 1;</code></pre><p>B. 修改id为1的数据, 将name修改为小昭, gender修改为 女</p><pre><code>update employee set name = &#39;小昭&#39; , gender = &#39;女&#39; where id = 1;</code></pre><p>C. 将所有的员工入职日期修改为 2008-01-01</p><pre><code> update employee set entrydate = &#39;2008-01-01&#39;;</code></pre><p>注意事项: 修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。</p><h3 id="2-5-3-删除数据"><a href="#2-5-3-删除数据" class="headerlink" title="2.5.3 删除数据"></a>2.5.3 删除数据</h3><p>删除数据的具体语法为：</p><pre><code> DELETE FROM 表名 [ WHERE 条件 ] ;</code></pre><p>案例: A. 删除gender为女的员工</p><pre><code> delete from employee where gender = &#39;女&#39;;</code></pre><p>B. 删除所有员工</p><pre><code>delete from employee</code></pre><p>注意事项:</p><ul><li>DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数 据。</li><li>DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即 可)。 </li><li>当进行删除全部数据操作时，datagrip会提示，询问是否确认删除，直接点击 Execute即可。</li></ul><h2 id="2-6-DQL"><a href="#2-6-DQL" class="headerlink" title="2.6 DQL"></a>2.6 DQL</h2><p>DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记 录。</p><p>查询关键字: SELECT</p><p>数据准备</p><pre><code>drop table if exists employee;create table emp(id int comment &#39;编号&#39;,workno varchar(10) comment &#39;工号&#39;,name varchar(10) comment &#39;姓名&#39;,gender char(1) comment &#39;性别&#39;,age tinyint unsigned comment &#39;年龄&#39;,idcard char(18) comment &#39;身份证号&#39;,workaddress varchar(50) comment &#39;工作地址&#39;,entrydate date comment &#39;入职时间&#39;)comment &#39;员工表&#39;;INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (1, &#39;00001&#39;, &#39;柳岩666&#39;, &#39;女&#39;, 20, &#39;123456789012345678&#39;, &#39;北京&#39;, &#39;2000-01-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (2, &#39;00002&#39;, &#39;张无忌&#39;, &#39;男&#39;, 18, &#39;123456789012345670&#39;, &#39;北京&#39;, &#39;2005-09-01&#39;)INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (3, &#39;00003&#39;, &#39;韦一笑&#39;, &#39;男&#39;, 38, &#39;123456789712345670&#39;, &#39;上海&#39;, &#39;2005-08-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (4, &#39;00004&#39;, &#39;赵敏&#39;, &#39;女&#39;, 18, &#39;123456757123845670&#39;, &#39;北京&#39;, &#39;2009-12-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (5, &#39;00005&#39;, &#39;小昭&#39;, &#39;女&#39;, 16, &#39;123456769012345678&#39;, &#39;上海&#39;, &#39;2007-07-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (6, &#39;00006&#39;, &#39;杨逍&#39;, &#39;男&#39;, 28, &#39;12345678931234567X&#39;, &#39;北京&#39;, &#39;2006-01-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (7, &#39;00007&#39;, &#39;范瑶&#39;, &#39;男&#39;, 40, &#39;123456789212345670&#39;, &#39;北京&#39;, &#39;2005-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (8, &#39;00008&#39;, &#39;黛绮丝&#39;, &#39;女&#39;, 38, &#39;123456157123645670&#39;, &#39;天津&#39;, &#39;2015-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (9, &#39;00009&#39;, &#39;范凉凉&#39;, &#39;女&#39;, 45, &#39;123156789012345678&#39;, &#39;北京&#39;, &#39;2010-04-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (10, &#39;00010&#39;, &#39;陈友谅&#39;, &#39;男&#39;, 53, &#39;123456789012345670&#39;, &#39;上海&#39;, &#39;2011-01-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (11, &#39;00011&#39;, &#39;张士诚&#39;, &#39;男&#39;, 55, &#39;123567897123465670&#39;, &#39;江苏&#39;, &#39;2015-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (12, &#39;00012&#39;, &#39;常遇春&#39;, &#39;男&#39;, 32, &#39;123446757152345670&#39;, &#39;北京&#39;, &#39;2004-02-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (13, &#39;00013&#39;, &#39;张三丰&#39;, &#39;男&#39;, 88, &#39;123656789012345678&#39;, &#39;江苏&#39;, &#39;2020-11-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (14, &#39;00014&#39;, &#39;灭绝&#39;, &#39;女&#39;, 65, &#39;123456719012345670&#39;, &#39;西安&#39;, &#39;2019-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (15, &#39;00015&#39;, &#39;胡青牛&#39;, &#39;男&#39;, 70, &#39;12345674971234567X&#39;, &#39;西安&#39;, &#39;2018-04-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (16, &#39;00016&#39;, &#39;周芷若&#39;, &#39;女&#39;, 18, null, &#39;北京&#39;, &#39;2012-06-01&#39;);</code></pre><h3 id="2-6-1-基本语法"><a href="#2-6-1-基本语法" class="headerlink" title="2.6.1 基本语法"></a>2.6.1 基本语法</h3><p>DQL 查询语句，语法结构如下：</p><pre><code>SELECT    字段列表FROM    表名列表WHERE    条件列表GROUP BY    分组字段列表HAVING    分组后条件列表ORDER BY    排序字段列表LIMIT    分页参数</code></pre><h3 id="2-6-2-基础查询"><a href="#2-6-2-基础查询" class="headerlink" title="2.6.2 基础查询"></a>2.6.2 基础查询</h3><p>1). 查询多个字段</p><pre><code>SELECT 字段1, 字段2, 字段3 ... FROM 表名 ;</code></pre><pre><code>SELECT * FROM 表名 ；</code></pre><p>注意 : * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。</p><p>2). 字段设置别名</p><pre><code> SELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名;</code></pre><pre><code> SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;</code></pre><p>3). 去除重复记录</p><pre><code>SELECT DISTINCT 字段列表 FROM 表名;</code></pre><h3 id="2-6-3-条件查询"><a href="#2-6-3-条件查询" class="headerlink" title="2.6.3 条件查询"></a>2.6.3 条件查询</h3><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 WHERE 条件列表 ;</code></pre><p>2). 条件</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">等号，检测两个值是否相等，如果相等返回true</td><td align="left">(A = B) 返回false。</td></tr><tr><td align="left">&lt;&gt;, !=</td><td align="left">不等于，检测两个值是否相等，如果不相等返回true</td><td align="left">(A != B) 返回 true。</td></tr><tr><td align="left">&gt;</td><td align="left">大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true</td><td align="left">(A &gt; B) 返回false。</td></tr><tr><td align="left">&lt;</td><td align="left">小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true</td><td align="left">(A &lt; B) 返回 true。</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true</td><td align="left">(A &gt;= B) 返回false。</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于号，检测左边的值是否小于或等于右边的值, 如果左边的值小于或等于右边的值返回true</td><td align="left">(A &lt;= B) 返回 true。</td></tr><tr><td align="left">BETWEEN … AND …</td><td align="left">在某个范围之内(含最小、最大值)</td><td align="left">(between15 and 20) 返回15到20之间</td></tr><tr><td align="left">IN(…)</td><td align="left">在in之后的列表中的值，多选一</td><td align="left">[in(18,80,40) ] 返回18，20，40</td></tr><tr><td align="left">LIKE 占位符</td><td align="left">模糊匹配(_匹配单个字符, %匹配任意个字符)</td><td align="left"></td></tr><tr><td align="left">IS NULL</td><td align="left">是NULL</td><td align="left"></td></tr></tbody></table><h3 id="2-6-4-聚合函数"><a href="#2-6-4-聚合函数" class="headerlink" title="2.6.4 聚合函数"></a>2.6.4 聚合函数</h3><p>1). 介绍</p><p>将一列数据作为一个整体，进行纵向计算 。</p><p>2). 常见的聚合函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p>3). 语法</p><pre><code> SELECT 聚合函数(字段列表) FROM 表名 ;</code></pre><p>注意 : NULL值是不参与所有聚合函数运算的。</p><p>案例：</p><p>A. 统计该企业员工数量</p><pre><code>select count(*) from emp; -- 统计的是总记录数select count(idcard) from emp; -- 统计的是idcard字段不为null的记录数</code></pre><p>对于count聚合函数，统计符合条件的总记录数，还可以通过 count(数字/字符串)的形式进行统计 查询，比如：</p><pre><code> select count(1) from emp;</code></pre><h3 id="2-6-5-分组查询"><a href="#2-6-5-分组查询" class="headerlink" title="2.6.5 分组查询"></a>2.6.5 分组查询</h3><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后过滤条件 ];</code></pre><p>2). where与having区别 执行时机不同：</p><ul><li>where是分组之前进行过滤，不满足where条件，不参与分组；</li><li>而having是分组 之后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><p>案例:</p><p>A. 根据性别分组 , 统计男性员工 和 女性员工的数量</p><pre><code>select gender, count(*) from emp group by gender ;</code></pre><p>B. 根据性别分组 , 统计男性员工 和 女性员工的平均年龄</p><pre><code> select gender, avg(age) from emp group by gender ;</code></pre><p>C. 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址</p><pre><code>select workaddress, count(*) address_count from emp where age &lt; 45 group byworkaddress having address_count &gt;= 3;</code></pre><p>D. 统计各个工作地址上班的男性及女性员工的数量</p><pre><code>select workaddress, gender, count(*) &#39;数量&#39; from emp group by gender , workaddress;</code></pre><h3 id="2-6-6-排序查询"><a href="#2-6-6-排序查询" class="headerlink" title="2.6.6 排序查询"></a>2.6.6 排序查询</h3><p>排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序</p><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ;</code></pre><p>2). 排序方式</p><ul><li>ASC : 升序(默认值) </li><li>DESC: 降序</li></ul><p>注意事项：</p><ul><li>如果是升序, 可以不指定排序方式ASC ; </li><li>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;</li></ul><h3 id="2-6-7-分页查询"><a href="#2-6-7-分页查询" class="headerlink" title="2.6.7 分页查询"></a>2.6.7 分页查询</h3><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;</code></pre><p>注意事项: </p><p>起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数。 </p><p>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。 </p><p>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</p><p>案例: </p><p>A. 查询第1页员工数据, 每页展示10条记录</p><pre><code>select * from emp limit 0,10;select * from emp limit 10;</code></pre><p>B. 查询第2页员工数据, 每页展示10条记录 ——–&gt; (页码-1)*页展示记录数</p><pre><code> select * from emp limit 10,10;</code></pre><h3 id="2-6-9-执行顺序"><a href="#2-6-9-执行顺序" class="headerlink" title="2.6.9 执行顺序"></a>2.6.9 执行顺序</h3><p><img src="/mysql-01/image-20230318153026758.png" alt="image-20230318153026758"></p><p>执行顺序为</p><p>from … where … group by … having … select … order by … limit …</p><h2 id="2-7-DCL"><a href="#2-7-DCL" class="headerlink" title="2.7 DCL"></a>2.7 DCL</h2><p>DCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访 问权限。</p><h3 id="2-7-1-管理用户"><a href="#2-7-1-管理用户" class="headerlink" title="2.7.1 管理用户"></a>2.7.1 管理用户</h3><p>1). 查询用户</p><pre><code>select * from mysql.user;</code></pre><p><img src="/mysql-01/image-20230318153333941.png" alt="image-20230318153333941"></p><p>其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以 远程访问的。 User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一 个用户。</p><p>2). 创建用户</p><pre><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></pre><p>3). 修改用户密码</p><pre><code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39; ;</code></pre><p>4). 删除用户</p><pre><code>DROP USER &#39;用户名&#39;@&#39;主机名&#39; ;</code></pre><p>注意事项:</p><ul><li>在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。</li><li>主机名可以使用 % 通配。 </li></ul><h3 id="2-7-2-权限控制"><a href="#2-7-2-权限控制" class="headerlink" title="2.7.2 权限控制"></a>2.7.2 权限控制</h3><p>Mysql中常用的的权限</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库/表/视图</td></tr><tr><td>CREATE</td><td>创建数据库/表</td></tr></tbody></table><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" target="_blank" rel="noopener">MySQL :: MySQL 8.0 Reference Manual :: 6.2.2 Privileges Provided by MySQL</a></p><p>1). 查询权限</p><pre><code> SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39; ;</code></pre><p>2). 授予权限</p><pre><code> GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>3). 撤销权限</p><pre><code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>注意事项： • 多个权限之间，使用逗号分隔 • 授权时， 数据库名和表名可以使用 * 进行通配，代表所有。</p><h1 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h1><p>函数 是指一段可以直接被另一段程序调用的程序或代码。 也就意味着，这一段程序或代码在MySQL中 已经给我们提供了，我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可</p><p>MySQL中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数。</p><h2 id="3-1-字符串函数"><a href="#3-1-字符串函数" class="headerlink" title="3.1 字符串函数"></a>3.1 字符串函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(S1,S2,…Sn)</td><td>字符串拼接，将S1，S2，… Sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串str全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串str全部转为大写</td></tr><tr><td>LPAD(str,n,pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符 串长度</td></tr><tr><td>RPAD(str,n,pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符 串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str,start,len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><p>lpad : 左填充</p><pre><code>select lpad(&#39;01&#39;, 5, &#39;-&#39;);</code></pre><p>trim : 去除空格</p><pre><code>select trim(&#39; Hello MySQL &#39;)</code></pre><p>substring : 截取子字符串</p><pre><code> select substring(&#39;Hello MySQL&#39;,1,5);</code></pre><h2 id="3-2-数值函数"><a href="#3-2-数值函数" class="headerlink" title="3.2 数值函数"></a>3.2 数值函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x,y)</td><td>返回x/y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x,y)</td><td>求参数x的四舍五入的值，保留y位小数</td></tr></tbody></table><h2 id="3-3-日期函数"><a href="#3-3-日期函数" class="headerlink" title="3.3 日期函数"></a>3.3 日期函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期/时间值加上一个时间间隔expr后的 时间值</td></tr><tr><td>DATEDIFF(date1,date2)</td><td>返回起始时间date1 和 结束时间date2之间的天 数</td></tr></tbody></table><h2 id="3-4-流程函数"><a href="#3-4-流程函数" class="headerlink" title="3.4 流程函数"></a>3.4 流程函数</h2><p>流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value , t , f)</td><td>如果value为true，则返回t，否则返回 f</td></tr><tr><td>IFNULL(value1 , value2)</td><td>如果value1不为空，返回value1，否则 返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否 则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td><td>如果expr的值等于val1，返回 res1，… 否则返回default默认值</td></tr></tbody></table><p>需求: 查询emp表的员工姓名和工作地址 (北京/上海 —-&gt; 一线城市 , 其他 —-&gt; 二线城市)</p><pre><code>selectname,( case workaddress when &#39;北京&#39; then &#39;一线城市&#39; when &#39;上海&#39; then &#39;一线城市&#39; else&#39;二线城市&#39; end ) as &#39;工作地址&#39;from emp;</code></pre><h1 id="4-约束"><a href="#4-约束" class="headerlink" title="4.约束"></a>4.约束</h1><p>概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。</p><p> 目的：保证数据库中数据的正确、有效性和完整性。</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束(8.0.16版本 之后)</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张表的数据之间建立连接，保证数据的一致 性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><p>注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。</p><h2 id="4-3-外键约束"><a href="#4-3-外键约束" class="headerlink" title="4.3 外键约束"></a>4.3 外键约束</h2><p>外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</p><p><img src="/mysql-01/image-20230318161258249.png" alt="image-20230318161258249"></p><p>左侧的emp表是员工表，里面存储员工的基本信息，包含员工的ID、姓名、年龄、职位、薪资、入职日 期、上级主管ID、部门ID，在员工的信息中存储的是部门的ID dept_id，而这个部门的ID是关联的 部门表dept的主键id，那emp表的dept_id就是外键,关联的是另一张表的主键。</p><p>注意：目前上述两张表，只是在逻辑上存在这样一层关系；在数据库层面，并未建立外键关联， 所以是无法保证数据的一致性和完整性的。</p><h3 id="4-3-2-语法"><a href="#4-3-2-语法" class="headerlink" title="4.3.2 语法"></a>4.3.2 语法</h3><p>1). 添加外键</p><pre><code>CREATE TABLE 表名(    字段名 数据类型,    ...    [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名));</code></pre><pre><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名)REFERENCES 主表 (主表列名) ;</code></pre><p>为emp表的dept_id字段添加外键约束,关联dept表的主键id。</p><pre><code>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id);</code></pre><p><img src="/mysql-01/image-20230318161641788.png" alt="image-20230318161641788"></p><p>添加了外键约束之后，到dept表(父表)删除id为1的记录。 此时 将会报错，不能删除或更新父表记录，因为存在外键约束。</p><p>2). 删除外键</p><pre><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</code></pre><p>案例： 删除emp表的外键fk_emp_dept_id。</p><pre><code>alter table emp drop foreign key fk_emp_dept_id;</code></pre><h3 id="4-3-3-删除-更新行为"><a href="#4-3-3-删除-更新行为" class="headerlink" title="4.3.3 删除/更新行为"></a>4.3.3 删除/更新行为</h3><p>添加了外键之后，再删除父表数据时产生的约束行为，称为删除/更新行为。具体的删除/更新行 为有以下几种</p><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 RESTRICT 一致) 默认行为</td></tr><tr><td>RESTRICT</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 NO ACTION 一致) 默认行为</td></tr><tr><td>CASCADE</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则 也删除/更新外键在子表中的记录。</td></tr><tr><td>SET NULL</td><td>当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表 中该外键值为null（这就要求该外键允许取null）。</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)</td></tr></tbody></table><p>具体语法为:</p><pre><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;</code></pre><p>演示如下：</p><p>1). CASCADE</p><pre><code>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id) on update cascade on delete cascade ;</code></pre><p>A. 修改父表id为1的记录，将id修改为6</p><p><img src="/mysql-01/image-20230318162417947.png" alt="image-20230318162417947"></p><p>原来在子表中dept_id值为1的记录，现在也变为6了，这就是cascade级联的效果。</p><p>在一般的业务系统中，不会修改一张表的主键值。</p><p>B. 删除父表id为6的记录</p><p><img src="/mysql-01/image-20230318162446703.png" alt="image-20230318162446703"></p><p>父表的数据删除成功了，但是子表中关联的记录也被级联删除了。</p><p>2). SET NULL</p><pre><code>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id) on update set null on delete set null ;</code></pre><p><img src="/mysql-01/image-20230318162633853.png" alt="image-20230318162633853"></p><p>父表的记录是可以正常的删除的，父表的数据删除之后，再打开子表 emp，发现子表emp 的dept_id字段，原来dept_id为1的数据，现在都被置为NULL了。</p><p><img src="/mysql-01/image-20230318162649038.png" alt="image-20230318162649038"></p><h1 id="5-多表查询"><a href="#5-多表查询" class="headerlink" title="5.多表查询"></a>5.多表查询</h1><h2 id="5-1-多表关系"><a href="#5-1-多表关系" class="headerlink" title="5.1 多表关系"></a>5.1 多表关系</h2><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结 构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：</p><ul><li>一对多(多对一)</li><li>多对多</li><li>一对一</li></ul><h3 id="5-1-1-一对多"><a href="#5-1-1-一对多" class="headerlink" title="5.1.1 一对多"></a>5.1.1 一对多</h3><ul><li>案例: 部门 与 员工的关系</li><li>关系: 一个部门对应多个员工，一个员工对应一个部门 </li><li>实现: 在多的一方建立外键，指向一的一方的主键</li></ul><p><img src="/mysql-01/image-20230318163215620.png" alt="image-20230318163215620"></p><h3 id="5-1-2-多对多"><a href="#5-1-2-多对多" class="headerlink" title="5.1.2 多对多"></a>5.1.2 多对多</h3><ul><li>案例: 学生 与 课程的关系 </li><li>关系: 一个学生可以选修多门课程，一门课程也可以供多个学生选择 </li><li>实现: 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</li></ul><p><img src="/mysql-01/image-20230318163305957.png" alt="image-20230318163305957"></p><p>约束语句：</p><pre><code>constraint fk_courseid foreign key (courseid) references course (id),constraint fk_studentid foreign key (studentid) references student (id)</code></pre><h3 id="5-1-3-一对一"><a href="#5-1-3-一对一" class="headerlink" title="5.1.3 一对一"></a>5.1.3 一对一</h3><p>案例: 用户 与 用户详情的关系 关系:</p><p> 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另 一张表中，以提升操作效率 </p><p>实现: 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</p><p><img src="/mysql-01/image-20230318163537120.png" alt="image-20230318163537120"></p><h2 id="5-2-多表查询"><a href="#5-2-多表查询" class="headerlink" title="5.2 多表查询"></a>5.2 多表查询</h2><h3 id="5-2-2-概述"><a href="#5-2-2-概述" class="headerlink" title="5.2.2 概述"></a>5.2.2 概述</h3><p>多表查询就是指从多张表中查询数据。</p><p>原来查询单表数据，执行的SQL形式为：select * from emp;</p><p>那么我们要执行多表查询，就只需要使用逗号分隔多张表即可，如： select * from emp , dept ; 具体的执行结果如下:</p><p><img src="/mysql-01/image-20230318163656019.png" alt="image-20230318163656019"></p><p>此时,查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录 (17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。</p><p>笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况。</p><p><img src="/mysql-01/image-20230318163727372.png" alt="image-20230318163727372"></p><p>而在多表查询中，是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。</p><p><img src="/mysql-01/image-20230318163744086.png" alt="image-20230318163744086"></p><p>给多表查询加上连接查询的条件，消除笛卡尔集。</p><pre><code>select * from emp , dept where emp.dept_id = dept.id;</code></pre><p><img src="/mysql-01/image-20230318163821696.png" alt="image-20230318163821696"></p><p>而由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询 到。</p><h3 id="5-2-3-分类"><a href="#5-2-3-分类" class="headerlink" title="5.2.3 分类"></a>5.2.3 分类</h3><p>连接查询 </p><p>​    内连接：相当于查询A、B交集部分数据     </p><p>​    外连接：     </p><p>​        左外连接：查询左表所有数据，以及两张表交集部分数据     </p><p>​        右外连接：查询右表所有数据，以及两张表交集部分数据     </p><p>​    自连接：当前表与自身的连接查询，自连接必须使用表别名</p><ul><li>子查询</li></ul><p><img src="/mysql-01/image-20230318164141106.png" alt="image-20230318164141106"></p><h2 id="5-3-内连接"><a href="#5-3-内连接" class="headerlink" title="5.3 内连接"></a>5.3 内连接</h2><p><img src="/mysql-01/image-20230318164353496.png" alt="image-20230318164353496"></p><p>内连接查询的是两张表交集部分的数 据。(也就是绿色部分的数据) 内连接的语法分为两种: 隐式内连接、显式内连接。</p><p>1). 隐式内连接</p><pre><code>SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;</code></pre><p>2). 显式内连接</p><pre><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;</code></pre><p>案例: </p><p>A. 查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现) </p><p>表结构: emp , dept </p><p>连接条件: emp.dept_id = dept.id</p><pre><code>select emp.name , dept.name from emp , dept where emp.dept_id = dept.id ;-- 为每一张表起别名,简化SQL编写select e.name,d.name from emp e , dept d where e.dept_id = d.id;</code></pre><p>B. 查询每一个员工的姓名 , 及关联的部门的名称 (显式内连接实现) — INNER JOIN … ON …</p><p>​    表结构: emp , dept </p><p>​    连接条件: emp.dept_id = dept.id</p><pre><code>select e.name, d.name from emp e inner join dept d on e.dept_id = d.id;-- 为每一张表起别名,简化SQL编写select e.name, d.name from emp e join dept d on e.dept_id = d.id;</code></pre><p>注意事项:一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字 段。</p><h2 id="5-4-外连接"><a href="#5-4-外连接" class="headerlink" title="5.4 外连接"></a>5.4 外连接</h2><p><img src="/mysql-01/image-20230318165025944.png" alt="image-20230318165025944"></p><p>外连接分为两种，分别是：左外连接 和 右外连接。具体的语法结构为：</p><p>1). 左外连接</p><pre><code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;</code></pre><p>左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。</p><p>2). 右外连接</p><pre><code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ... ;</code></pre><p>右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。</p><p>案例:</p><p>A.     查询emp表的所有数据, 和对应的部门信息 </p><p>​        由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。         表结构: emp, dept 连接条件: emp.dept_id = dept.id</p><p>​        连接条件: emp.dept_id = dept.id</p><pre><code>select e.*, d.name from emp e left outer join dept d on e.dept_id = d.id;select e.*, d.name from emp e left join dept d on e.dept_id = d.id;</code></pre><p>​    B. 查询dept表的所有数据, 和对应的员工信息(右外连接)</p><p>由于需求中提到，要查询dept表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查 询。 </p><p>​    表结构: emp, dept </p><p>​    连接条件: emp.dept_id = dept.id</p><pre><code>select d.*, e.* from emp e right outer join dept d on e.dept_id = d.id;select d.*, e.* from dept d left outer join emp e on e.dept_id = d.id;</code></pre><p>注意事项： 左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺 序就可以了。日常开发使用时，更偏向于左外连接。</p><h2 id="5-5-自连接"><a href="#5-5-自连接" class="headerlink" title="5.5 自连接"></a>5.5 自连接</h2><h3 id="5-5-1-自连接查询"><a href="#5-5-1-自连接查询" class="headerlink" title="5.5.1 自连接查询"></a>5.5.1 自连接查询</h3><p>自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。</p><pre><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ... ;</code></pre><p>而对于自连接查询，可以是内连接查询，也可以是外连接查询。</p><p>案例： </p><p>A. 查询员工 及其 所属领导的名字 </p><p>表结构: emp</p><pre><code>select a.name , b.name from emp a , emp b where a.managerid = b.id;</code></pre><p>B. 查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来 </p><p>表结构: emp a , emp b</p><p>注意事项: 在自连接查询中，必须要为表起别名，要不然不清楚所指定的条件、返回的字段，到底 是哪一张表的字段</p><h3 id="5-5-2-联合查询"><a href="#5-5-2-联合查询" class="headerlink" title="5.5.2 联合查询"></a>5.5.2 联合查询</h3><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p><pre><code>SELECT 字段列表 FROM 表A ...UNION [ ALL ]SELECT 字段列表 FROM 表B ....;</code></pre><ul><li>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</li><li>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。</li></ul><p>案例: A. 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来. </p><p>当前对于这个需求，可以直接使用多条件查询，使用逻辑运算符 or 连接即可。 也可以通过union/union all来联合查询.</p><p><img src="/mysql-01/image-20230318171722519.png" alt="image-20230318171722519"></p><p>union all查询出来的结果，仅仅进行简单的合并，并未去重</p><pre><code>select * from emp where salary &lt; 5000unionselect * from emp where age &gt; 50;</code></pre><p><img src="/mysql-01/image-20230318171749423.png" alt="image-20230318171749423"></p><p>union 联合查询，会对查询出来的结果进行去重处理。</p><p>注意： 如果多条查询语句查询出来的结果，字段数量不一致，在进行union/union all联合查询时，将会报错。如：</p><p><img src="/mysql-01/image-20230318171808521.png" alt="image-20230318171808521"></p><h2 id="5-6-子查询"><a href="#5-6-子查询" class="headerlink" title="5.6 子查询"></a>5.6 子查询</h2><h3 id="5-6-1-概述"><a href="#5-6-1-概述" class="headerlink" title="5.6.1 概述"></a>5.6.1 概述</h3><p>1). 概念</p><p>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p><pre><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 );</code></pre><p>子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。</p><p>2). 分类</p><p>根据子查询结果不同，分为：</p><p>A. 标量子查询（子查询结果为单个值）</p><p>B. 列子查询(子查询结果为一列) </p><p>C. 行子查询(子查询结果为一行) </p><p>D. 表子查询(子查询结果为多行多列)</p><p>根据子查询位置，分为： </p><p>A. WHERE之后 </p><p>B. FROM之后 </p><p>C. SELECT之后</p><h3 id="5-6-2-标量子查询"><a href="#5-6-2-标量子查询" class="headerlink" title="5.6.2 标量子查询"></a>5.6.2 标量子查询</h3><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。 常用的操作符：= &lt;&gt; &gt; &gt;= &lt; &lt;= </p><p>案例: </p><p>A. 查询 “销售部” 的所有员工信息 </p><p>完成这个需求时，可以将需求分解为两步：</p><p>①. 查询 “销售部” 部门ID</p><pre><code>select id from dept where name = &#39;销售部&#39;;</code></pre><p>②. 根据 “销售部” 部门ID, 查询员工信息</p><pre><code>select * from emp where dept_id = (select id from dept where name = &#39;销售部&#39;);</code></pre><p>B. 查询在 “方东白” 入职之后的员工信息 </p><p>完成这个需求时，可以将需求分解为两步：</p><p>①. 查询 方东白 的入职日期</p><pre><code>select entrydate from emp where name = &#39;方东白&#39;;</code></pre><p>②. 查询指定入职日期之后入职的员工信息</p><pre><code>select * from emp where entrydate &gt; (select entrydate from emp where name = &#39;方东白&#39;);</code></pre><h3 id="5-6-3-列子查询"><a href="#5-6-3-列子查询" class="headerlink" title="5.6.3 列子查询"></a>5.6.3 列子查询</h3><p>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。</p><p>常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围之内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围之内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><p>案例: </p><p>A. 查询 “销售部” 和 “市场部” 的所有员工信息</p><p>分解为以下两步:</p><p> ①. 查询 “销售部” 和 “市场部” 的部门ID</p><pre><code>select id from dept where name = &#39;销售部&#39; or name = &#39;市场部&#39;;</code></pre><p>②. 根据部门ID, 查询员工信息</p><pre><code>select * from emp where dept_id in (select id from dept where name = &#39;销售部&#39; orname = &#39;市场部&#39;);</code></pre><p>B. 查询比 财务部 所有人工资都高的员工信息</p><p>分解为以下两步: ①. 查询所有 财务部 人员工资</p><pre><code>select id from dept where name = &#39;财务部&#39;;select salary from emp where dept_id = (select id from dept where name = &#39;财务部&#39;);</code></pre><p>②. 比 财务部 所有人工资都高的员工信息</p><pre><code>select * from emp where salary &gt; all ( select salary from emp where dept_id =(select id from dept where name = &#39;财务部&#39;) );</code></pre><p>C. 查询比研发部其中任意一人工资高的员工信息</p><p>分解为以下两步:</p><p>①. 查询研发部所有人工资</p><pre><code>select salary from emp where dept_id = (select id from dept where name = &#39;研发部&#39;);</code></pre><p>②. 比研发部其中任意一人工资高的员工信息</p><pre><code>select * from emp where salary &gt; any ( select salary from emp where dept_id =(select id from dept where name = &#39;研发部&#39;) );</code></pre><h3 id="5-6-4-行子查询"><a href="#5-6-4-行子查询" class="headerlink" title="5.6.4 行子查询"></a>5.6.4 行子查询</h3><p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。</p><p> 常用的操作符：= 、&lt;&gt; 、IN 、NOT IN</p><p>案例: </p><p>A. 查询与 “张无忌” 的薪资及直属领导相同的员工信息 ; </p><p>这个需求同样可以拆解为两步进行: </p><p>①. 查询 “张无忌” 的薪资及直属领导</p><pre><code> select salary, managerid from emp where name = &#39;张无忌&#39;;</code></pre><p>②. 查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;</p><pre><code>select * from emp where (salary,managerid) = (select salary, managerid from empwhere name = &#39;张无忌&#39;);</code></pre><h3 id="5-6-5-表子查询"><a href="#5-6-5-表子查询" class="headerlink" title="5.6.5 表子查询"></a>5.6.5 表子查询</h3><p>子查询返回的结果是多行多列，这种子查询称为表子查询。 </p><p>常用的操作符：IN</p><p>案例: </p><p>A. 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><p> 分解为两步执行:</p><p>①. 查询 “鹿杖客” , “宋远桥” 的职位和薪资</p><pre><code>select job, salary from emp where name = &#39;鹿杖客&#39; or name = &#39;宋远桥&#39;;</code></pre><p>②. 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><pre><code>select * from emp where (job,salary) in ( select job, salary from emp where name =&#39;鹿杖客&#39; or name = &#39;宋远桥&#39; );</code></pre><p>B. 查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息</p><p>分解为两步执行:</p><p>①. 入职日期是 “2006-01-01” 之后的员工信息</p><pre><code>select * from emp where entrydate &gt; &#39;2006-01-01&#39;;</code></pre><p>②. 查询这部分员工, 对应的部门信息;</p><pre><code>select e.*, d.* from (select * from emp where entrydate &gt; &#39;2006-01-01&#39;) e leftjoin dept d on e.dept_id = d.id ;</code></pre><h1 id="6-事务"><a href="#6-事务" class="headerlink" title="6.事务"></a>6.事务</h1><h2 id="6-1-事务简介"><a href="#6-1-事务简介" class="headerlink" title="6.1 事务简介"></a>6.1 事务简介</h2><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>就比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加 1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。</p><p><img src="/mysql-01/image-20230318175145463.png" alt="image-20230318175145463"></p><p>正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四 增加1000, 转账成功 :</p><p><img src="/mysql-01/image-20230318175413465.png" alt="image-20230318175413465"></p><p>异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张 三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了。</p><p><img src="/mysql-01/image-20230318175427146.png" alt="image-20230318175427146"></p><p>为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行 完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。</p><p><img src="/mysql-01/image-20230318175441174.png" alt="image-20230318175441174"></p><p>注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐 式的提交事务。</p><h2 id="6-2-事务操作"><a href="#6-2-事务操作" class="headerlink" title="6.2 事务操作"></a>6.2 事务操作</h2><h3 id="6-2-1-未控制事务"><a href="#6-2-1-未控制事务" class="headerlink" title="6.2.1 未控制事务"></a>6.2.1 未控制事务</h3><p>正常执行</p><p><img src="/mysql-01/image-20230318175558427.png" alt="image-20230318175558427"></p><p> 测试异常情况</p><pre><code>-- 1. 查询张三余额select * from account where name = &#39;张三&#39;;-- 2. 张三的余额减少1000update account set money = money - 1000 where name = &#39;张三&#39;;出错了....-- 3. 李四的余额增加1000update account set money = money + 1000 where name = &#39;李四&#39;;</code></pre><p><img src="/mysql-01/image-20230318175542807.png" alt="image-20230318175542807"></p><p>检查最终的数据情况, 发现数据在操作前后不一致了。</p><h3 id="6-2-2-控制事务一"><a href="#6-2-2-控制事务一" class="headerlink" title="6.2.2 控制事务一"></a>6.2.2 控制事务一</h3><p>1). 查看/设置事务提交方式</p><pre><code>SELECT @@autocommit ;SET @@autocommit = 0 ;</code></pre><p>2). 提交事务</p><pre><code>COMMIT;</code></pre><p>3). 回滚事务</p><pre><code>ROLLBACK;</code></pre><p>注意：上述的这种方式，是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提 交, 此时执行的DML语句都不会提交, 需要手动的执行commit进行提交。</p><h3 id="6-2-3-控制事务二"><a href="#6-2-3-控制事务二" class="headerlink" title="6.2.3 控制事务二"></a>6.2.3 控制事务二</h3><p>1). 开启事务</p><pre><code>START TRANSACTION 或 BEGIN ;</code></pre><p>2). 提交事务</p><pre><code>COMMIT;</code></pre><p>3). 回滚事务</p><pre><code>ROLLBACK;</code></pre><p>转账案例：</p><pre><code>-- 开启事务start transaction-- 1. 查询张三余额select * from account where name = &#39;张三&#39;;-- 2. 张三的余额减少1000update account set money = money - 1000 where name = &#39;张三&#39;;-- 3. 李四的余额增加1000update account set money = money + 1000 where name = &#39;李四&#39;;-- 如果正常执行完毕, 则提交事务commit;-- 如果执行过程中报错, 则回滚事务-- rollback;</code></pre><h3 id="6-3-事务四大特性"><a href="#6-3-事务四大特性" class="headerlink" title="6.3 事务四大特性"></a>6.3 事务四大特性</h3><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 </li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><p><img src="/mysql-01/image-20230318180214740.png" alt="image-20230318180214740"></p><h3 id="6-4-并发事务问题"><a href="#6-4-并发事务问题" class="headerlink" title="6.4 并发事务问题"></a>6.4 并发事务问题</h3><p>1). 赃读：一个事务读到另外一个事务还没有提交的数据。</p><p><img src="/mysql-01/image-20230318180237160.png" alt="image-20230318180237160"></p><p>比如B读取到了A未提交的数据。</p><p>2). 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p><p><img src="/mysql-01/image-20230318180253685.png" alt="image-20230318180253685"></p><p> 事务A两次读取同一条记录，但是读取到的数据却是不一样的。</p><p>3). 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 “幻影”。</p><p><img src="/mysql-01/image-20230318180423731.png" alt="image-20230318180423731"></p><h3 id="6-5-事务隔离级别"><a href="#6-5-事务隔离级别" class="headerlink" title="6.5 事务隔离级别"></a>6.5 事务隔离级别</h3><p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>1). 查看事务隔离级别</p><pre><code>SELECT @@TRANSACTION_ISOLATION;</code></pre><p>2). 设置事务隔离级别</p><pre><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED |READ COMMITTED | REPEATABLE READ | SERIALIZABLE }</code></pre><p>注意：事务隔离级别越高，数据越安全，但是性能越低。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
