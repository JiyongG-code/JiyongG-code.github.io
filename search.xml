<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql-03</title>
      <link href="/mysql-03.html"/>
      <url>/mysql-03.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-日志"><a href="#1-日志" class="headerlink" title="1.日志"></a>1.日志</h1><h2 id="1-1-错误日志"><a href="#1-1-错误日志" class="headerlink" title="1.1 错误日志"></a>1.1 错误日志</h2><p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过 程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，建议首先查看此日 志。 该日志是默认开启的，默认存放目录 /var/log/，默认的日志文件名为 mysqld.log 。查看日志 位置：</p><pre><code>show variables like &#39;%log_error%&#39;;</code></pre><p><img src="/mysql-03/image-20230320140656699.png" alt="image-20230320140656699"></p><h2 id="1-2-二进制日志"><a href="#1-2-二进制日志" class="headerlink" title="1.2 二进制日志"></a>1.2 二进制日志</h2><h3 id="1-2-1-介绍"><a href="#1-2-1-介绍" class="headerlink" title="1.2.1 介绍"></a>1.2.1 介绍</h3><p>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但 不包括数据查询（SELECT、SHOW）语句。</p><p> 作用：①. 灾难时的数据恢复；②. MySQL的主从复制。在MySQL8版本中，默认二进制日志是开启着 的，涉及到的参数如下：</p><pre><code> show variables like &#39;%log_bin%&#39;;</code></pre><p><img src="/mysql-03/image-20230320140852143.png" alt="image-20230320140852143"></p><p>参数说明：</p><ul><li>log_bin_basename：当前数据库服务器的binlog日志的基础名称(前缀)，具体的binlog文 件名需要再该basename的基础上加上编号(编号从000001开始)。</li><li>log_bin_index：binlog的索引文件，里面记录了当前服务器关联的binlog文件有哪些。</li></ul><h3 id="1-2-2-格式"><a href="#1-2-2-格式" class="headerlink" title="1.2.2 格式"></a>1.2.2 格式</h3><p>MySQL服务器中提供了多种格式来记录二进制日志，具体格式及特点如下：</p><table><thead><tr><th>日志格式</th><th>含义</th></tr></thead><tbody><tr><td>STATEMENT</td><td>基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在 日志文件中。</td></tr><tr><td>ROW</td><td>基于行的日志记录，记录的是每一行的数据变更。（默认）</td></tr><tr><td>MIXED</td><td>混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会 自动切换为ROW进行记录。</td></tr></tbody></table><pre><code>show variables like &#39;%binlog_format%&#39;;</code></pre><p><img src="/mysql-03/image-20230320141427815.png" alt="image-20230320141427815"></p><p>需要配置二进制日志的格式，只需要在 /etc/my.cnf 中配置 binlog_format 参数即 可。</p><h3 id="1-2-3-查看"><a href="#1-2-3-查看" class="headerlink" title="1.2.3 查看"></a>1.2.3 查看</h3><p>由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具 mysqlbinlog 来查 看，具体语法：</p><pre><code>mysqlbinlog [ 参数选项 ] logfilename参数选项：-d 指定数据库名称，只列出指定的数据库相关操作。-o 忽略掉日志中的前n行命令。-v 将行事件(数据变更)重构为SQL语句-vv 将行事件(数据变更)重构为SQL语句，并输出注释信息</code></pre><h3 id="1-2-4-删除"><a href="#1-2-4-删除" class="headerlink" title="1.2.4 删除"></a>1.2.4 删除</h3><p>对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空 间。可以通过以下几种方式清理日志：</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>reset master</td><td>删除全部 binlog 日志，删除之后，日志编号，将 从 binlog.000001重新开始</td></tr><tr><td>purge master logs to ‘binlog.*’</td><td>删除 * 编号之前的所有日志</td></tr><tr><td>purge master logs before ‘yyyy-mm-dd hh24:mi:ss’</td><td>删除日志为 “yyyy-mm-dd hh24:mi:ss” 之前 产生的所有日志</td></tr></tbody></table><p>也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除。</p><pre><code>show variables like &#39;%binlog_expire_logs_seconds%&#39;;</code></pre><h2 id="1-3-查询日志"><a href="#1-3-查询日志" class="headerlink" title="1.3 查询日志"></a>1.3 查询日志</h2><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下， 查询日志是未开启的。</p><p><img src="/mysql-03/image-20230320141813340.png" alt="image-20230320141813340"></p><p>如果需要开启查询日志，可以修改MySQL的配置文件 /etc/my.cnf 文件，添加如下内容：</p><pre><code>#该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启general_log=1#设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.loggeneral_log_file=mysql_query.log</code></pre><p>开启了查询日志之后，在MySQL的数据存放目录，也就是 /var/lib/mysql/ 目录下就会出现 mysql_query.log 文件。之后所有的客户端的增删改查操作都会记录在该日志文件之中，长时间运 行后，该日志文件将会非常大。</p><h2 id="1-4-慢查询日志"><a href="#1-4-慢查询日志" class="headerlink" title="1.4 慢查询日志"></a>1.4 慢查询日志</h2><p>慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的SQL语句的日志，默认未开启。long_query_time 默认为 10 秒，最小为 0， 精度可以到微秒。 如果需要开启慢查询日志，需要在MySQL的配置文件 /etc/my.cnf 中配置如下参数：</p><pre><code>#慢查询日志slow_query_log=1#执行时间参数long_query_time=2</code></pre><p>默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用 log_slow_admin_statements和 更改此行为 log_queries_not_using_indexes，如下所 述。</p><pre><code>#记录执行较慢的管理语句log_slow_admin_statements =1#记录执行较慢的未使用索引的语句log_queries_not_using_indexes = 1</code></pre><p>上述所有的参数配置完成之后，都需要重新启动MySQL服务器才可以生效。</p><h1 id="2-主从复制"><a href="#2-主从复制" class="headerlink" title="2.主从复制"></a>2.主从复制</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这 些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。 MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状 复制。</p><p><img src="/mysql-03/image-20230320142319910.png" alt="image-20230320142319910"></p><p>MySQL 复制的优点主要包含以下三个方面：</p><ul><li>主库出现问题，可以快速切换到从库提供服务。</li><li>实现读写分离，降低主库的访问压力。</li><li>可以在从库中执行备份，以避免备份期间影响主库服务。</li></ul><h2 id="2-2-原理"><a href="#2-2-原理" class="headerlink" title="2.2 原理"></a>2.2 原理</h2><p>MySQL主从复制的核心就是 二进制日志，具体的过程如下:</p><p><img src="/mysql-03/image-20230320142705600.png" alt="image-20230320142705600"></p><p>从上图来看，复制分成三步：</p><ol><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li><li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ol><h2 id="2-3-搭建"><a href="#2-3-搭建" class="headerlink" title="2.3 搭建"></a>2.3 搭建</h2><h3 id="2-3-2-主库配置"><a href="#2-3-2-主库配置" class="headerlink" title="2.3.2 主库配置"></a>2.3.2 主库配置</h3><ol><li>修改配置文件 /etc/my.cnf</li></ol><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 232-1，默认为1server-id=1#是否只读,1 代表只读, 0 代表读写read-only=0#忽略的数据, 指不需要同步的数据库#binlog-ignore-db=mysql#指定同步的数据库#binlog-do-db=db01</code></pre><ol start="2"><li>重启MySQL服务器</li></ol><pre><code>systemctl restart mysqld</code></pre><ol start="3"><li>登录mysql，创建远程连接的账号，并授予主从复制权限</li></ol><pre><code>#创建用户，并设置密码，该用户可在任意主机连接该MySQL服务CREATE USER &#39;用户名&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;Root@123456&#39;;#为 &#39;用户名&#39;@&#39;%&#39; 用户分配主从复制权限GRANT REPLICATION SLAVE ON *.* TO &#39;用户名&#39;@&#39;%&#39;;</code></pre><ol start="4"><li>通过指令，查看二进制日志坐标</li></ol><pre><code>show master status ;</code></pre><p><img src="/mysql-03/image-20230320143411901.png" alt="image-20230320143411901"></p><p>字段含义说明：</p><p>file : 从哪个日志文件开始推送日志文件 </p><p>position ： 从哪个位置开始推送日志 </p><p>binlog_ignore_db : 指定不需要同步的数据库</p><h3 id="2-3-3-从库配置"><a href="#2-3-3-从库配置" class="headerlink" title="2.3.3 从库配置"></a>2.3.3 从库配置</h3><ol><li>修改配置文件 /etc/my.cnf</li></ol><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，和主库不一样即可server-id=2#是否只读,1 代表只读, 0 代表读写read-only=1</code></pre><ol start="2"><li>重新启动MySQL服务</li></ol><pre><code>systemctl restart mysqld</code></pre><ol start="3"><li>登录mysql，设置主库配置</li></ol><pre><code>CHANGE REPLICATION SOURCE TO SOURCE_HOST=&#39;192.168.200.200（主的IP）&#39;, SOURCE_USER=&#39;主机配置的主从权限的用户名&#39;,SOURCE_PASSWORD=&#39;Root@123456&#39;, SOURCE_LOG_FILE=&#39;binlog.000004&#39;,SOURCE_LOG_POS=663;</code></pre><p>上述是8.0.23中的语法。如果mysql是 8.0.23 之前的版本，执行如下SQL：</p><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.200.200&#39;, MASTER_USER=&#39;主机配置的主从权限的用户名&#39;,MASTER_PASSWORD=&#39;Root@123456&#39;, MASTER_LOG_FILE=&#39;binlog.000004&#39;,MASTER_LOG_POS=663;</code></pre><table><thead><tr><th>参数名</th><th>含义</th><th>8.0.23之前</th></tr></thead><tbody><tr><td>SOURCE_HOST</td><td>主库IP地址</td><td>MASTER_HOST</td></tr><tr><td>SOURCE_USER</td><td>连接主库的用户名</td><td>MASTER_USER</td></tr><tr><td>SOURCE_PASSWORD</td><td>连接主库的密码</td><td>MASTER_PASSWORD</td></tr><tr><td>SOURCE_LOG_FILE</td><td>binlog日志文件名</td><td>MASTER_LOG_FILE</td></tr><tr><td>SOURCE_LOG_POS</td><td>binlog日志文件位置</td><td>MASTER_LOG_POS</td></tr></tbody></table><ol start="4"><li>开启同步操作</li></ol><pre><code>start replica ; #8.0.22之后start slave ; #8.0.22之前</code></pre><ol start="5"><li>查看主从同步状态</li></ol><pre><code>show replica status ; #8.0.22之后show slave status ; #8.0.22之前</code></pre><p><img src="/mysql-03/image-20230320144151638.png" alt="image-20230320144151638"></p><h1 id="3-分库分表"><a href="#3-分库分表" class="headerlink" title="3.分库分表"></a>3.分库分表</h1><h2 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h2><h3 id="3-1-1-问题分析"><a href="#3-1-1-问题分析" class="headerlink" title="3.1.1 问题分析"></a>3.1.1 问题分析</h3><p><img src="/mysql-03/image-20230320144250086.png" alt="image-20230320144250086"></p><p>随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存 储，存在以下性能瓶颈：</p><ol><li>IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。 请求数据太多，带宽 不够，网络IO瓶颈。</li><li>CPU瓶颈：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出 现瓶颈。</li></ol><p>为了解决上述问题，需要对数据库进行分库分表处理。</p><p><img src="/mysql-03/image-20230320144509133.png" alt="image-20230320144509133"></p><p>分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能 问题，从而达到提升数据库性能的目的。</p><h3 id="3-1-2-拆分策略"><a href="#3-1-2-拆分策略" class="headerlink" title="3.1.2 拆分策略"></a>3.1.2 拆分策略</h3><p>分库分表的形式，主要是两种：垂直拆分和水平拆分。而拆分的粒度，一般又分为分库和分表，所以组 成的拆分策略最终如下:</p><p><img src="/mysql-03/image-20230320145312892.png" alt="image-20230320145312892"></p><h3 id="3-1-3-垂直拆分"><a href="#3-1-3-垂直拆分" class="headerlink" title="3.1.3 垂直拆分"></a>3.1.3 垂直拆分</h3><ol><li>垂直分库</li></ol><p><img src="/mysql-03/image-20230320145342887.png" alt="image-20230320145342887"></p><p>垂直分库：以表为依据，根据业务将不同表拆分到不同库中。</p><p>特点：</p><ul><li>每个库的表结构都不一样。 </li><li>每个库的数据也不一样。</li><li>所有库的并集是全量数据。</li></ul><ol start="2"><li>垂直分表</li></ol><p><img src="/mysql-03/image-20230320145429454.png" alt="image-20230320145429454"></p><p>垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中。</p><p>特点： </p><ul><li>每个表的结构都不一样。</li><li>每个表的数据也不一样，一般通过一列（主键/外键）关联。</li><li>所有表的并集是全量数据。</li></ul><h3 id="3-1-4-水平拆分"><a href="#3-1-4-水平拆分" class="headerlink" title="3.1.4 水平拆分"></a>3.1.4 水平拆分</h3><ol><li>水平分库</li></ol><p><img src="/mysql-03/image-20230320145608750.png" alt="image-20230320145608750"></p><p>水平分库：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。</p><p>特点：</p><ul><li>每个库的表结构都一样。 </li><li>每个库的数据都不一样。 </li><li>所有库的并集是全量数据。</li></ul><ol start="2"><li>水平分表</li></ol><p><img src="/mysql-03/image-20230320145849506.png" alt="image-20230320145849506"></p><p>水平分表：以字段为依据，按照一定策略，将一个表的数据拆分到多个表中。</p><p>特点：</p><ul><li>每个表的表结构都一样。</li><li>每个表的数据都不一样。 </li><li>所有表的并集是全量数据。</li></ul><p>在业务系统中，为了缓解磁盘IO及CPU的性能瓶颈，到底是垂直拆分，还是水平拆分；具体是分 库，还是分表，都需要根据具体的业务需求具体分析。</p><h3 id="3-1-5-实现技术"><a href="#3-1-5-实现技术" class="headerlink" title="3.1.5 实现技术"></a>3.1.5 实现技术</h3><ul><li>shardingJDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处 理。需要自行编码配置实现，只支持java语言，性能较高。</li><li>MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者</li></ul><p><img src="/mysql-03/image-20230320150320070.png" alt="image-20230320150320070"></p><h2 id="3-2-MyCat概述"><a href="#3-2-MyCat概述" class="headerlink" title="3.2 MyCat概述"></a>3.2 MyCat概述</h2><h3 id="3-2-1-介绍"><a href="#3-2-1-介绍" class="headerlink" title="3.2.1 介绍"></a>3.2.1 介绍</h3><p>Mycat是开源的、活跃的、基于Java语言编写的MySQL数据库中间件。可以像使用mysql一样来使用 mycat，对于开发人员来说根本感觉不到mycat的存在。 开发人员只需要连接MyCat即可，而具体底层用到几台数据库，每一台数据库服务器里面存储了什么数 据，都无需关心。 具体的分库分表的策略，只需要在MyCat中配置即可。</p><p><img src="/mysql-03/image-20230320150523355.png" alt="image-20230320150523355"></p><h3 id="3-2-2-下载"><a href="#3-2-2-下载" class="headerlink" title="3.2.2 下载"></a>3.2.2 下载</h3><p><a href="http://dl.mycat.org.cn/" target="_blank" rel="noopener">Index of / (mycat.org.cn)</a></p><p><a href="http://www.mycat.org.cn/" target="_blank" rel="noopener">上海云业网络科技有限公司 (mycat.org.cn)</a></p><h3 id="3-2-3-安装"><a href="#3-2-3-安装" class="headerlink" title="3.2.3 安装"></a>3.2.3 安装</h3><p>Mycat是采用java语言开发的开源的数据库中间件，支持Windows和Linux运行环境，下面介绍 MyCat的Linux中的环境搭建。</p><h3 id="3-2-4-目录介绍"><a href="#3-2-4-目录介绍" class="headerlink" title="3.2.4 目录介绍"></a>3.2.4 目录介绍</h3><p><img src="/mysql-03/image-20230320150737718.png" alt="image-20230320150737718"></p><p>bin : 存放可执行文件，用于启动停止mycat </p><p>conf：存放mycat的配置文件 </p><p>lib：存放mycat的项目依赖包（jar）</p><p> logs：存放mycat的日志文件</p><h3 id="3-2-5-概念介绍"><a href="#3-2-5-概念介绍" class="headerlink" title="3.2.5 概念介绍"></a>3.2.5 概念介绍</h3><p>在MyCat的整体结构中，分为两个部分：上面的逻辑结构、下面的物理结构。</p><p><img src="/mysql-03/image-20230320150825985.png" alt="image-20230320150825985"></p><p>在MyCat的逻辑结构主要负责逻辑库、逻辑表、分片规则、分片节点等逻辑结构的处理，而具体的数据 存储还是在物理结构，也就是数据库服务器中存储的。</p><h2 id="3-3-MyCat入门"><a href="#3-3-MyCat入门" class="headerlink" title="3.3 MyCat入门"></a>3.3 MyCat入门</h2><h3 id="3-3-1-需求"><a href="#3-3-1-需求" class="headerlink" title="3.3.1 需求"></a>3.3.1 需求</h3><p>由于 tb_order 表中数据量很大，磁盘IO及容量都到达了瓶颈，现在需要对 tb_order 表进行数 据分片，分为三个数据节点，每一个节点主机位于不同的服务器上, 具体的结构，参考下图:</p><p><img src="/mysql-03/image-20230320150915592.png" alt="image-20230320150915592"></p><h3 id="3-3-2-环境准备"><a href="#3-3-2-环境准备" class="headerlink" title="3.3.2 环境准备"></a>3.3.2 环境准备</h3><p>准备3台服务器</p><p>192.168.200.210：MyCat中间件服务器，同时也是第一个分片服务器。 </p><p>192.168.200.213：第二个分片服务器。 </p><p>192.168.200.214：第三个分片服务器</p><p><img src="/mysql-03/image-20230320150949987.png" alt="image-20230320150949987"></p><h3 id="3-3-3-配置"><a href="#3-3-3-配置" class="headerlink" title="3.3.3 配置"></a>3.3.3 配置</h3><p>1). schema.xml</p><p>在schema.xml中配置逻辑库、逻辑表、数据节点、节点主机等相关信息。具体的配置如下：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?></span><span class="token doctype">&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mycat:</span>schema</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>mycat</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://io.mycat/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>schema</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>DB01<span class="token punctuation">"</span></span> <span class="token attr-name">checkSQLschema</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">sqlMaxLimit</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>TB_ORDER<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1,dn2,dn3<span class="token punctuation">"</span></span> <span class="token attr-name">rule</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>auto-sharding-long<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>schema</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost1<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>db01<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn2<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost2<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>db01<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost3<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>db01<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    &lt;dataHost name="dhost1" maxCon="1000" minCon="10" balance="0"writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"slaveThreshold="100">        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.210:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span>    &lt;dataHost name="dhost2" maxCon="1000" minCon="10" balance="0"writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"slaveThreshold="100">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.213:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span>    &lt;dataHost name="dhost3" maxCon="1000" minCon="10" balance="0"writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"slaveThreshold="100">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.214:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mycat:</span>schema</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2). server.xml</p><p>需要在server.xml中配置用户名、密码，以及用户的访问权限信息，具体的配置如下：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">defaultAccount</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>DB01<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 表级 DML 权限设置 --></span><span class="token comment" spellcheck="true">&lt;!--&lt;privileges check="true">&lt;schema name="DB01" dml="0110" >&lt;table name="TB_ORDER" dml="1110">&lt;/table>&lt;/schema>&lt;/privileges>--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>DB01<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>readOnly<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述的配置表示，定义了两个用户 root 和 user ，这两个用户都可以访问 DB01 这个逻辑库，访 问密码都是123456，但是root用户访问DB01逻辑库，既可以读，又可以写，但是 user用户访问 DB01逻辑库是只读的。</p><h3 id="3-3-4-测试"><a href="#3-3-4-测试" class="headerlink" title="3.3.4 测试"></a>3.3.4 测试</h3><h5 id="3-3-4-1-启动"><a href="#3-3-4-1-启动" class="headerlink" title="3.3.4.1 启动"></a>3.3.4.1 启动</h5><p>配置完毕后，先启动涉及到的3台分片服务器，然后启动MyCat服务器。切换到Mycat的安装目录，执 行如下指令，启动Mycat：</p><pre><code>#启动bin/mycat start#停止bin/mycat stop</code></pre><p>Mycat启动之后，占用端口号 8066。 启动完毕之后，可以查看logs目录下的启动日志，查看Mycat是否启动完成。</p><p><img src="/mysql-03/image-20230320151743184.png" alt="image-20230320151743184"></p><h5 id="3-3-4-2-测试"><a href="#3-3-4-2-测试" class="headerlink" title="3.3.4.2 测试"></a>3.3.4.2 测试</h5><p>1). 连接MyCat 通过如下指令，就可以连接并登陆MyCat。</p><pre><code>mysql -h 192.168.200.210 -P 8066 -uroot -p123456</code></pre><p>通过MySQL的指令来连接的MyCat，因为MyCat在底层实际上是模拟了MySQL的协议。</p><h2 id="3-4-MyCat配置"><a href="#3-4-MyCat配置" class="headerlink" title="3.4 MyCat配置"></a>3.4 MyCat配置</h2><h3 id="3-4-1-schema-xml"><a href="#3-4-1-schema-xml" class="headerlink" title="3.4.1 schema.xml"></a>3.4.1 schema.xml</h3><p>schema.xml 作为MyCat中最重要的配置文件之一 , 涵盖了MyCat的逻辑库 、 逻辑表 、 分片规 则、分片节点及数据源的配置。</p><p><img src="/mysql-03/image-20230320155347462.png" alt="image-20230320155347462"></p><p>主要包含以下三组标签：</p><ul><li>schema标签 </li><li>datanode标签 </li><li>datahost标签</li></ul><h4 id="3-4-1-1-schema标签"><a href="#3-4-1-1-schema标签" class="headerlink" title="3.4.1.1 schema标签"></a>3.4.1.1 schema标签</h4><p>1). schema 定义逻辑库</p><p><img src="/mysql-03/image-20230320155440593.png" alt="image-20230320155440593"></p><p>schema 标签用于定义 MyCat实例中的逻辑库 , 一个MyCat实例中, 可以有多个逻辑库 , 可以通 过 schema 标签来划分不同的逻辑库。MyCat中的逻辑库的概念，等同于MySQL中的database概念 , 需要操作某个逻辑库下的表时, 也需要切换逻辑库(use xxx)。</p><p>核心属性：</p><ul><li>name：指定自定义的逻辑库库名 </li><li>checkSQLschema：在SQL语句操作时指定了数据库名称，执行时是否自动去除；true：自动去 除，false：不自动去除 </li><li>sqlMaxLimit：如果未指定limit进行查询，列表查询模式查询多少条记录</li></ul><p>2). schema 中的table定义逻辑表</p><p><img src="/mysql-03/image-20230320155722222.png" alt="image-20230320155722222"></p><ul><li>table 标签定义了MyCat中逻辑库schema下的逻辑表 , 所有需要拆分的表都需要在table标签中定义 </li><li>name：定义逻辑表表名，在该逻辑库下唯一 </li><li>dataNode：定义逻辑表所属的dataNode，该属性需要与dataNode标签中name对应；多个 dataNode逗号分隔 </li><li>rule：分片规则的名字，分片规则名字是在rule.xml中定义的</li><li>primaryKey：逻辑表对应真实表的主键</li><li>type：逻辑表的类型，目前逻辑表只有全局表和普通表，如果未配置，就是普通表；全局表，配 置为 global</li></ul><h4 id="3-4-1-2-datanode标签"><a href="#3-4-1-2-datanode标签" class="headerlink" title="3.4.1.2 datanode标签"></a>3.4.1.2 datanode标签</h4><p><img src="/mysql-03/image-20230320155909258.png" alt="image-20230320155909258"></p><p>核心属性：</p><ul><li>name：定义数据节点名称 </li><li>dataHost：数据库实例主机名称，引用自 dataHost 标签中name属性 </li><li>database：定义分片所属数据库</li></ul><h4 id="3-4-1-3-datahost标签"><a href="#3-4-1-3-datahost标签" class="headerlink" title="3.4.1.3 datahost标签"></a>3.4.1.3 datahost标签</h4><p><img src="/mysql-03/image-20230320160009277.png" alt="image-20230320160009277"></p><p>该标签在MyCat逻辑库中作为底层标签存在, 直接定义了具体的数据库实例、读写分离、心跳语句。</p><p>核心属性：</p><ul><li>name：唯一标识，供上层标签使用 </li><li>maxCon/minCon：最大连接数/最小连接数 </li><li>balance：负载均衡策略，取值 0,1,2,3 </li><li>writeType：写操作分发方式（0：写操作转发到第一个writeHost，第一个挂了，切换到第二 个；1：写操作随机分发到配置的writeHost） </li><li>dbDriver：数据库驱动，支持 native、jdbc</li></ul><h3 id="3-4-2-rule-xml"><a href="#3-4-2-rule-xml" class="headerlink" title="3.4.2 rule.xml"></a>3.4.2 rule.xml</h3><p>rule.xml中定义所有拆分表的规则, 在使用过程中可以灵活的使用分片算法, 或者对同一个分片算法 使用不同的参数, 它让分片过程可配置化。主要包含两类标签：tableRule、Function。</p><p><img src="/mysql-03/image-20230320161120658.png" alt="image-20230320161120658"></p><h3 id="3-4-3-server-xml"><a href="#3-4-3-server-xml" class="headerlink" title="3.4.3 server.xml"></a>3.4.3 server.xml</h3><p>server.xml配置文件包含了MyCat的系统配置信息，主要有两个重要的标签：system、user。</p><p>1). system标签</p><p><img src="/mysql-03/image-20230320161144281.png" alt="image-20230320161144281"></p><p>主要配置MyCat中的系统配置信息，对应的系统配置项及其含义，如下：</p><p><img src="/mysql-03/image-20230320161525830.png" alt="image-20230320161525830"></p><p><img src="/mysql-03/image-20230320161540434.png" alt="image-20230320161540434"></p><p><img src="/mysql-03/image-20230320161552677.png" alt="image-20230320161552677"></p><p><img src="/mysql-03/image-20230320161602557.png" alt="image-20230320161602557"></p><p><img src="/mysql-03/image-20230320161610512.png" alt="image-20230320161610512"></p><p>2). user标签 配置MyCat中的用户、访问密码，以及用户针对于逻辑库、逻辑表的权限信息，具体的权限描述方式及 配置说明如下：</p><p><img src="/mysql-03/image-20230320161624635.png" alt="image-20230320161624635"></p><p>在测试权限操作时，只需要将 privileges 标签的注释放开。 在 privileges 下的schema 标签中配置的dml属性配置的是逻辑库的权限。 在privileges的schema下的table标签的dml属性 中配置逻辑表的权限。</p><h2 id="3-5-MyCat分片"><a href="#3-5-MyCat分片" class="headerlink" title="3.5 MyCat分片"></a>3.5 MyCat分片</h2><h3 id="3-5-1-垂直拆分"><a href="#3-5-1-垂直拆分" class="headerlink" title="3.5.1 垂直拆分"></a>3.5.1 垂直拆分</h3><h4 id="3-5-1-1-场景"><a href="#3-5-1-1-场景" class="headerlink" title="3.5.1.1 场景"></a>3.5.1.1 场景</h4><p>在业务系统中, 涉及以下表结构 ,但是由于用户与订单每天都会产生大量的数据, 单台服务器的数据 存储及处理能力是有限的, 可以对数据库表进行拆分, 原有的数据库表如下。</p><p><img src="/mysql-03/image-20230320161732844.png" alt="image-20230320161732844"></p><p>现在考虑将其进行垂直分库操作，将商品相关的表拆分到一个数据库服务器，订单表拆分的一个数据库 服务器，用户及省市区表拆分到一个服务器。最终结构如下：</p><p><img src="/mysql-03/image-20230320161813202.png" alt="image-20230320161813202"></p><h4 id="3-5-1-2-准备"><a href="#3-5-1-2-准备" class="headerlink" title="3.5.1.2 准备"></a>3.5.1.2 准备</h4><p><img src="/mysql-03/image-20230320161837383.png" alt="image-20230320161837383"></p><p>并且在192.168.200.210，192.168.200.213, 192.168.200.214上面创建数据库 shopping。</p><h4 id="3-5-1-3-配置"><a href="#3-5-1-3-配置" class="headerlink" title="3.5.1.3 配置"></a>3.5.1.3 配置</h4><p>1). schema.xml</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>schema</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>SHOPPING<span class="token punctuation">"</span></span> <span class="token attr-name">checkSQLschema</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">sqlMaxLimit</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_goods_base<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_goods_brand<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_goods_cat<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_goods_desc<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>goods_id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_goods_item<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_order_item<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn2<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_order_master<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn2<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>order_id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_order_pay_log<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn2<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>out_trade_no<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_user<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_user_address<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_areas_provinces<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_areas_city<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_areas_region<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>schema</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost1<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>shopping<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn2<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost2<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>shopping<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost3<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>shopping<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataHost</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost1<span class="token punctuation">"</span></span> <span class="token attr-name">maxCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span> <span class="token attr-name">minCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">balance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token attr-name">writeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">dbType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span> <span class="token attr-name">dbDriver</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc<span class="token punctuation">"</span></span> <span class="token attr-name">switchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token attr-name">slaveThreshold</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.210:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataHost</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost2<span class="token punctuation">"</span></span> <span class="token attr-name">maxCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span> <span class="token attr-name">minCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">balance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token attr-name">writeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">dbType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span> <span class="token attr-name">dbDriver</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc<span class="token punctuation">"</span></span> <span class="token attr-name">switchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token attr-name">slaveThreshold</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.213:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataHost</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost3<span class="token punctuation">"</span></span> <span class="token attr-name">maxCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span> <span class="token attr-name">minCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">balance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token attr-name">writeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">dbType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span> <span class="token attr-name">dbDriver</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc<span class="token punctuation">"</span></span> <span class="token attr-name">switchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token attr-name">slaveThreshold</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.214:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2). server.xml</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">defaultAccount</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>SHOPPING<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 表级 DML 权限设置 --></span><span class="token comment" spellcheck="true">&lt;!--&lt;privileges check="true">&lt;schema name="DB01" dml="0110" >&lt;table name="TB_ORDER" dml="1110">&lt;/table>&lt;/schema>&lt;/privileges>--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>SHOPPING<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>readOnly<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-5-1-4-测试"><a href="#3-5-1-4-测试" class="headerlink" title="3.5.1.4 测试"></a>3.5.1.4 测试</h4><p>重新启动MyCat后，在mycat的命令行中，通过source指令导入表结构，以及对应的数据，查看数据 分布情况。</p><pre><code>source /root/shopping-table.sqlsource /root/shopping-insert.sql</code></pre><p>将表结构及对应的测试数据导入之后，可以检查一下各个数据库服务器中的表结构分布情况。 检查是 否和我们准备工作中规划的服务器一致。</p><p><img src="/mysql-03/image-20230320162038225.png" alt="image-20230320162038225"></p><p>订单相关的表结构是在 192.168.200.213 数据库服务器中，而省市区的数 据库表是在 192.168.200.214 数据库服务器中。会出现问题</p><p>因为MyCat在执行该SQL语句时，需要往具体的数 据库服务器中路由，而当前没有一个数据库服务器完全包含了订单以及省市区的表结构，造成SQL语句失败报错。</p><p>可以使用全局表</p><h4 id="3-5-1-5-全局表"><a href="#3-5-1-5-全局表" class="headerlink" title="3.5.1.5 全局表"></a>3.5.1.5 全局表</h4><p>对于省、市、区/县表tb_areas_provinces , tb_areas_city , tb_areas_region，是属于 数据字典表，在多个业务模块中都可能会遇到，可以将其设置为全局表，利于业务操作。</p><p>修改schema.xml中的逻辑表的配置，修改 tb_areas_provinces、tb_areas_city、 tb_areas_region 三个逻辑表，增加 type 属性，配置为global，就代表该表是全局表，就会在 所涉及到的dataNode中创建给表。对于当前配置来说，也就意味着所有的节点中都有该表了。</p><pre><code>&lt;table name=&quot;tb_areas_provinces&quot; dataNode=&quot;dn1,dn2,dn3&quot; primaryKey=&quot;id&quot;type=&quot;global&quot;/&gt;&lt;table name=&quot;tb_areas_city&quot; dataNode=&quot;dn1,dn2,dn3&quot; primaryKey=&quot;id&quot;type=&quot;global&quot;/&gt;&lt;table name=&quot;tb_areas_region&quot; dataNode=&quot;dn1,dn2,dn3&quot; primaryKey=&quot;id&quot;type=&quot;global&quot;/&gt;</code></pre><p><img src="/mysql-03/image-20230320162458936.png" alt="image-20230320162458936"></p><p>配置完毕后，重新启动MyCat。</p><p>1). 删除原来每一个数据库服务器中的所有表结构</p><p>2). 通过source指令，导入表及数据</p><pre><code>source /root/shopping-table.sqlsource /root/shopping-insert.sql</code></pre><p>3). 检查每一个数据库服务器中的表及数据分布，看到三个节点中都有这三张全局表 4). 然后再次执行上面的多表联查的SQL语句</p><pre><code>SELECT order_id , payment ,receiver, province , city , area FROM tb_order_master o, tb_areas_provinces p , tb_areas_city c , tb_areas_region r WHEREo.receiver_province = p.provinceid AND o.receiver_city = c.cityid ANDo.receiver_region = r.areaid ;</code></pre><p><img src="/mysql-03/image-20230320162600231.png" alt="image-20230320162600231"></p><p>是可以正常执行成功的。</p><p> 5). 当在MyCat中更新全局表的时候，我们可以看到，所有分片节点中的数据都发生了变化，每个节 点的全局表数据时刻保持一致。</p><h3 id="3-5-2-水平拆分"><a href="#3-5-2-水平拆分" class="headerlink" title="3.5.2 水平拆分"></a>3.5.2 水平拆分</h3><h4 id="3-5-2-1-场景"><a href="#3-5-2-1-场景" class="headerlink" title="3.5.2.1 场景"></a>3.5.2.1 场景</h4><p>在业务系统中, 有一张表(日志表), 业务系统每天都会产生大量的日志数据 , 单台服务器的数据存 储及处理能力是有限的, 可以对数据库表进行拆分。</p><p><img src="/mysql-03/image-20230320162710396.png" alt="image-20230320162710396"></p><h4 id="3-5-2-2-准备"><a href="#3-5-2-2-准备" class="headerlink" title="3.5.2.2 准备"></a>3.5.2.2 准备</h4><p>准备三台服务器，具体的结构如下：</p><p><img src="/mysql-03/image-20230320162730435.png" alt="image-20230320162730435"></p><h4 id="3-5-2-3-配置"><a href="#3-5-2-3-配置" class="headerlink" title="3.5.2.3 配置"></a>3.5.2.3 配置</h4><p>1). schema.xml</p><pre><code>&lt;schema name=&quot;ITCAST&quot; checkSQLschema=&quot;true&quot; sqlMaxLimit=&quot;100&quot;&gt;&lt;table name=&quot;tb_log&quot; dataNode=&quot;dn4,dn5,dn6&quot; primaryKey=&quot;id&quot; rule=&quot;mod-long&quot; /&gt;&lt;/schema&gt;&lt;dataNode name=&quot;dn4&quot; dataHost=&quot;dhost1&quot; database=&quot;itcast&quot; /&gt;&lt;dataNode name=&quot;dn5&quot; dataHost=&quot;dhost2&quot; database=&quot;itcast&quot; /&gt;&lt;dataNode name=&quot;dn6&quot; dataHost=&quot;dhost3&quot; database=&quot;itcast&quot; /&gt;</code></pre><p>tb_log表最终落在3个节点中，分别是 dn4、dn5、dn6 ，而具体的数据分别存储在 dhost1、 dhost2、dhost3的itcast数据库中。</p><p>2). server.xml</p><p>配置root用户既可以访问 SHOPPING 逻辑库，又可以访问ITCAST逻辑库。</p><pre><code>&lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;&lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;&lt;property name=&quot;schemas&quot;&gt;SHOPPING,ITCAST&lt;/property&gt;&lt;!-- 表级 DML 权限设置 --&gt;&lt;!--&lt;privileges check=&quot;true&quot;&gt;&lt;schema name=&quot;DB01&quot; dml=&quot;0110&quot; &gt;&lt;table name=&quot;TB_ORDER&quot; dml=&quot;1110&quot;&gt;&lt;/table&gt;&lt;/schema&gt;&lt;/privileges&gt;--&gt;&lt;/user&gt;</code></pre><h3 id="3-5-3-分片规则"><a href="#3-5-3-分片规则" class="headerlink" title="3.5.3 分片规则"></a>3.5.3 分片规则</h3><h4 id="3-5-3-1-范围分片"><a href="#3-5-3-1-范围分片" class="headerlink" title="3.5.3.1 范围分片"></a>3.5.3.1 范围分片</h4><p>1). 介绍</p><p>根据指定的字段及其配置的范围与数据节点的对应情况， 来决定该数据属于哪一个分片。</p><p><img src="/mysql-03/image-20230320164124963.png" alt="image-20230320164124963"></p><p>2). 配置</p><p>schema.xml逻辑表配置：</p><pre><code>&lt;table name=&quot;TB_ORDER&quot; dataNode=&quot;dn1,dn2,dn3&quot; rule=&quot;auto-sharding-long&quot; /&gt;</code></pre><p>schema.xml数据节点配置：</p><pre><code>&lt;dataNode name=&quot;dn1&quot; dataHost=&quot;dhost1&quot; database=&quot;db01&quot; /&gt;&lt;dataNode name=&quot;dn2&quot; dataHost=&quot;dhost2&quot; database=&quot;db01&quot; /&gt;&lt;dataNode name=&quot;dn3&quot; dataHost=&quot;dhost3&quot; database=&quot;db01&quot; /&gt;</code></pre><p>rule.xml分片规则配置：</p><pre><code>&lt;tableRule name=&quot;auto-sharding-long&quot;&gt;&lt;rule&gt;&lt;columns&gt;id&lt;/columns&gt;&lt;algorithm&gt;rang-long&lt;/algorithm&gt;&lt;/rule&gt;&lt;/tableRule&gt;&lt;function name=&quot;rang-long&quot; class=&quot;io.mycat.route.function.AutoPartitionByLong&quot;&gt;&lt;property name=&quot;mapFile&quot;&gt;autopartition-long.txt&lt;/property&gt;&lt;property name=&quot;defaultNode&quot;&gt;0&lt;/property&gt;&lt;/function&gt;</code></pre><p>分片规则配置属性含义：</p><p><img src="/mysql-03/image-20230320164320830.png" alt="image-20230320164320830"></p><p>在rule.xml中配置分片规则时，关联了一个映射配置文件 autopartition-long.txt，该配置文 件的配置如下：</p><pre><code># range start-end ,data node index# K=1000,M=10000.0-500M=0500M-1000M=11000M-1500M=2</code></pre><p>含义：0-500万之间的值，存储在0号数据节点(数据节点的索引从0开始) ； 500万-1000万之间的 数据存储在1号数据节点 ； 1000万-1500万的数据节点存储在2号节点 ；该分片规则，主要是针对于数字类型的字段适用。 </p><h4 id="3-5-3-2-取模分片"><a href="#3-5-3-2-取模分片" class="headerlink" title="3.5.3.2 取模分片"></a>3.5.3.2 取模分片</h4><p>1). 介绍</p><p>根据指定的字段值与节点数量进行求模运算，根据运算结果， 来决定该数据属于哪一个分片。</p><p><img src="/mysql-03/image-20230320164524561.png" alt="image-20230320164524561"></p><p>2). 配置</p><p>schema.xml逻辑表配置：</p><pre><code>&lt;table name=&quot;tb_log&quot; dataNode=&quot;dn4,dn5,dn6&quot; primaryKey=&quot;id&quot; rule=&quot;mod-long&quot; /&gt;</code></pre><p>schema.xml数据节点配置：</p><pre><code>&lt;dataNode name=&quot;dn4&quot; dataHost=&quot;dhost1&quot; database=&quot;itcast&quot; /&gt;&lt;dataNode name=&quot;dn5&quot; dataHost=&quot;dhost2&quot; database=&quot;itcast&quot; /&gt;&lt;dataNode name=&quot;dn6&quot; dataHost=&quot;dhost3&quot; database=&quot;itcast&quot; /&gt;</code></pre><p>rule.xml分片规则配置：</p><pre><code>&lt;tableRule name=&quot;mod-long&quot;&gt;&lt;rule&gt;&lt;columns&gt;id&lt;/columns&gt;&lt;algorithm&gt;mod-long&lt;/algorithm&gt;&lt;/rule&gt;&lt;/tableRule&gt;&lt;function name=&quot;mod-long&quot; class=&quot;io.mycat.route.function.PartitionByMod&quot;&gt;&lt;property name=&quot;count&quot;&gt;3&lt;/property&gt;&lt;/function&gt;</code></pre><p>分片规则属性说明如下：</p><p><img src="/mysql-03/image-20230320164606426.png" alt="image-20230320164606426"></p><p>该分片规则，主要是针对于数字类型的字段适用。 在前面水平拆分的演示中，我们选择的就是取模分 片。</p><p>更多规则可看管网</p><p><a href="https://www.yuque.com/ccazhw/ml3nkf/fd9bb7d92f18138725bd53bae67d1d98" target="_blank" rel="noopener">分片算法简介 (yuque.com)</a></p><h2 id="3-6-MyCat管理及监控"><a href="#3-6-MyCat管理及监控" class="headerlink" title="3.6 MyCat管理及监控"></a>3.6 MyCat管理及监控</h2><h3 id="3-6-1-MyCat原理"><a href="#3-6-1-MyCat原理" class="headerlink" title="3.6.1 MyCat原理"></a>3.6.1 MyCat原理</h3><p><img src="/mysql-03/image-20230320164824809.png" alt="image-20230320164824809"></p><p>在MyCat中，当执行一条SQL语句时，MyCat需要进行SQL解析、分片分析、路由分析、读写分离分析 等操作，最终经过一系列的分析决定将当前的SQL语句到底路由到那几个(或哪一个)节点数据库，数据 库将数据执行完毕后，如果有返回的结果，则将结果返回给MyCat，最终还需要在MyCat中进行结果合 并、聚合处理、排序处理、分页处理等操作，最终再将结果返回给客户端。 而在MyCat的使用过程中，MyCat官方也提供了一个管理监控平台MyCat-Web（MyCat-eye）。 Mycat-web 是 Mycat 可视化运维的管理和监控平台，弥补了 Mycat 在监控上的空白。帮 Mycat 分担统计任务和配置管理任务。Mycat-web 引入了 ZooKeeper 作为配置中心，可以管理多个节 点。Mycat-web 主要管理和监控 Mycat 的流量、连接、活动线程和内存等，具备 IP 白名单、邮 件告警等模块，还可以统计 SQL 并分析慢 SQL 和高频 SQL 等。为优化 SQL 提供依据。</p><h3 id="3-6-2-MyCat管理"><a href="#3-6-2-MyCat管理" class="headerlink" title="3.6.2 MyCat管理"></a>3.6.2 MyCat管理</h3><p>Mycat默认开通2个端口，可以在server.xml中进行修改。 </p><p>8066 数据访问端口，即进行 DML 和 DDL 操作。 </p><p>9066 数据库管理端口，即 mycat 服务管理控制功能，用于管理mycat的整个集群状态 </p><p>连接MyCat的管理控制台：</p><pre><code>1 mysql -h 192.168.200.210 -p 9066 -uroot -p123456</code></pre><p><img src="/mysql-03/image-20230320164926322.png" alt="image-20230320164926322"></p><h3 id="3-6-3-MyCat-eye"><a href="#3-6-3-MyCat-eye" class="headerlink" title="3.6.3 MyCat-eye"></a>3.6.3 MyCat-eye</h3><h4 id="3-6-3-1-介绍"><a href="#3-6-3-1-介绍" class="headerlink" title="3.6.3.1 介绍"></a>3.6.3.1 介绍</h4><p>Mycat-web(Mycat-eye)是对mycat-server提供监控服务，功能不局限于对mycat-server使 用。他通过JDBC连接对Mycat、Mysql监控，监控远程服务器(目前仅限于linux系统)的cpu、内 存、网络、磁盘。 Mycat-eye运行过程中需要依赖zookeeper，因此需要先安装zookeeper。</p><h1 id="4-读写分离"><a href="#4-读写分离" class="headerlink" title="4.读写分离"></a>4.读写分离</h1><h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h2><p>读写分离,简单地说是把对数据库的读和写操作分开,以对应不同的数据库服务器。主数据库提供写操 作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。 通过MyCat即可轻易实现上述功能，不仅可以支持MySQL，也可以支持Oracle和SQL Server。</p><p><img src="/mysql-03/image-20230320165609781.png" alt="image-20230320165609781"></p><h2 id="4-2-一主一从"><a href="#4-2-一主一从" class="headerlink" title="4.2 一主一从"></a>4.2 一主一从</h2><h3 id="4-2-1-原理"><a href="#4-2-1-原理" class="headerlink" title="4.2.1 原理"></a>4.2.1 原理</h3><p>MySQL的主从复制，是基于二进制日志（binlog）实现的。</p><p><img src="/mysql-03/image-20230320165744188.png" alt="image-20230320165744188"></p><p>4.2.2 准备</p><p><img src="/mysql-03/image-20230320165754344.png" alt="image-20230320165754344"></p><p>主从复制的搭建，可以参考前面课程中 主从复制 章节讲解的步骤操作。</p><h2 id="4-3-一主一从读写分离"><a href="#4-3-一主一从读写分离" class="headerlink" title="4.3 一主一从读写分离"></a>4.3 一主一从读写分离</h2><p>MyCat控制后台数据库的读写分离和负载均衡由schema.xml文件datahost标签的balance属性控制。</p><h4 id="4-3-1-schema-xml配置"><a href="#4-3-1-schema-xml配置" class="headerlink" title="4.3.1 schema.xml配置"></a>4.3.1 schema.xml配置</h4><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置逻辑库 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>schema</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ITCAST_RW<span class="token punctuation">"</span></span> <span class="token attr-name">checkSQLschema</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">sqlMaxLimit</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn7<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>schema</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn7<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost7<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>itcast<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataHost</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost7<span class="token punctuation">"</span></span> <span class="token attr-name">maxCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span> <span class="token attr-name">minCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">balance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">writeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token attr-name">dbType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span> <span class="token attr-name">dbDriver</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc<span class="token punctuation">"</span></span> <span class="token attr-name">switchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">slaveThreshold</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master1<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.211:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>readHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>slave1<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.212:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>writeHost</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述配置的具体关联对应情况如下：</p><p><img src="/mysql-03/image-20230320165949477.png" alt="image-20230320165949477"></p><p>writeHost代表的是写操作对应的数据库，readHost代表的是读操作对应的数据库。 所以要想 实现读写分离，就得配置writeHost关联的是主库，readHost关联的是从库。 而仅仅配置好了writeHost以及readHost还不能完成读写分离，还需要配置一个非常重要的负责均衡 的参数 balance，取值有4种，具体含义如下：</p><p><img src="/mysql-03/image-20230320170029317.png" alt="image-20230320170029317"></p><p>所以，在一主一从模式的读写分离中，balance配置1或3都是可以完成读写分离的。</p><h4 id="4-3-2-server-xml配置"><a href="#4-3-2-server-xml配置" class="headerlink" title="4.3.2 server.xml配置"></a>4.3.2 server.xml配置</h4><p>配置root用户可以访问SHOPPING、ITCAST 以及 ITCAST_RW逻辑库。</p><pre><code>&lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;&lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;&lt;property name=&quot;schemas&quot;&gt;SHOPPING,ITCAST,ITCAST_RW&lt;/property&gt;&lt;!-- 表级 DML 权限设置 --&gt;&lt;!--&lt;privileges check=&quot;true&quot;&gt;&lt;schema name=&quot;DB01&quot; dml=&quot;0110&quot; &gt;&lt;table name=&quot;TB_ORDER&quot; dml=&quot;1110&quot;&gt;&lt;/table&gt;&lt;/schema&gt;&lt;/privileges&gt;--&gt;&lt;/user&gt;</code></pre><h2 id="4-4-双主双从"><a href="#4-4-双主双从" class="headerlink" title="4.4 双主双从"></a>4.4 双主双从</h2><h3 id="4-4-1-介绍"><a href="#4-4-1-介绍" class="headerlink" title="4.4.1 介绍"></a>4.4.1 介绍</h3><p>一个主机 Master1 用于处理所有写请求，它的从机 Slave1 和另一台主机 Master2 还有它的从 机 Slave2 负责所有读请求。当 Master1 主机宕机后，Master2 主机负责写请求，Master1 、 Master2 互为备机。架构图如下:</p><p><img src="/mysql-03/image-20230320170501362.png" alt="image-20230320170501362"></p><h3 id="4-4-2-准备"><a href="#4-4-2-准备" class="headerlink" title="4.4.2 准备"></a>4.4.2 准备</h3><p>需要准备5台服务器，具体的服务器及软件安装情况如下：</p><p><img src="/mysql-03/image-20230320170523699.png" alt="image-20230320170523699"></p><h3 id="4-4-3-搭建"><a href="#4-4-3-搭建" class="headerlink" title="4.4.3 搭建"></a>4.4.3 搭建</h3><h4 id="4-4-3-1-主库配置"><a href="#4-4-3-1-主库配置" class="headerlink" title="4.4.3.1 主库配置"></a>4.4.3.1 主库配置</h4><p>1). Master1(192.168.200.211)</p><p><img src="/mysql-03/image-20230320170609174.png" alt="image-20230320170609174"></p><p>A. 修改配置文件 /etc/my.cnf</p><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，默认为1server-id=1#指定同步的数据库binlog-do-db=db01binlog-do-db=db02binlog-do-db=db03# 在作为从数据库的时候，有写入操作也要更新二进制日志文件log-slave-update</code></pre><p>B. 重启MySQL服务器</p><pre><code>systemctl restart mysqld</code></pre><p>C. 创建账户并授权</p><pre><code>#创建itcast用户，并设置密码，该用户可在任意主机连接该MySQL服务CREATE USER &#39;itcast&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;Root@123456&#39;;#为 &#39;itcast&#39;@&#39;%&#39; 用户分配主从复制权限GRANT REPLICATION SLAVE ON *.* TO &#39;itcast&#39;@&#39;%&#39;;</code></pre><p>通过指令，查看两台主库的二进制日志坐标</p><pre><code>show master status ;</code></pre><p><img src="/mysql-03/image-20230320170857167.png" alt="image-20230320170857167"></p><p>2). Master2(192.168.200.213)</p><p><img src="/mysql-03/image-20230320170926570.png" alt="image-20230320170926570"></p><p>A. 修改配置文件 /etc/my.cnf</p><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，默认为1server-id=3#指定同步的数据库binlog-do-db=db01binlog-do-db=db02binlog-do-db=db03# 在作为从数据库的时候，有写入操作也要更新二进制日志文件log-slave-updates</code></pre><p>B. 重启MySQL服务器</p><p>C. 创建账户并授权</p><p>通过指令，查看两台主库的二进制日志坐标</p><h4 id="4-4-3-2-从库配置"><a href="#4-4-3-2-从库配置" class="headerlink" title="4.4.3.2 从库配置"></a>4.4.3.2 从库配置</h4><p><img src="/mysql-03/image-20230320171028146.png" alt="image-20230320171028146"></p><p>A. 修改配置文件 /etc/my.cnf</p><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 232-1，默认为1server-id=2</code></pre><p>B. 重新启动MySQL服务器</p><p>2). Slave2(192.168.200.214)</p><p><img src="/mysql-03/image-20230320171052260.png" alt="image-20230320171052260"></p><p>A. 修改配置文件 /etc/my.cnf</p><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 232-1，默认为1server-id=4</code></pre><p>B. 重新启动MySQL服务器</p><h4 id="4-4-3-3-从库关联主库"><a href="#4-4-3-3-从库关联主库" class="headerlink" title="4.4.3.3 从库关联主库"></a>4.4.3.3 从库关联主库</h4><p>1). 两台从库配置关联的主库</p><p><img src="/mysql-03/image-20230320171126319.png" alt="image-20230320171126319"></p><p>slave1绑的是master1，slave2绑的是master2。</p><p>A. 在 slave1(192.168.200.212)上执行</p><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.200.211&#39;, MASTER_USER=&#39;itcast&#39;,MASTER_PASSWORD=&#39;Root@123456&#39;, MASTER_LOG_FILE=&#39;binlog.000002&#39;,MASTER_LOG_POS=663;</code></pre><p>B. 在 slave2(192.168.200.214)上执行</p><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.200.213&#39;, MASTER_USER=&#39;itcast&#39;,MASTER_PASSWORD=&#39;Root@123456&#39;, MASTER_LOG_FILE=&#39;binlog.000002&#39;,MASTER_LOG_POS=663;</code></pre><p>C. 启动两台从库主从复制，查看从库状态</p><pre><code>start slave;show slave status \G;</code></pre><p><img src="/mysql-03/image-20230320171537700.png" alt="image-20230320171537700"></p><p>2). 两台主库相互复</p><p><img src="/mysql-03/image-20230320171552428.png" alt="image-20230320171552428"></p><p>Master2 复制 Master1，Master1 复制 Master2。</p><p>A. 在 Master1(192.168.200.211)上执行</p><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.200.213&#39;, MASTER_USER=&#39;itcast&#39;,MASTER_PASSWORD=&#39;Root@123456&#39;, MASTER_LOG_FILE=&#39;binlog.000002&#39;,MASTER_LOG_POS=663;</code></pre><p>B. 在 Master2(192.168.200.213)上执行</p><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.200.211&#39;, MASTER_USER=&#39;itcast&#39;,MASTER_PASSWORD=&#39;Root@123456&#39;, MASTER_LOG_FILE=&#39;binlog.000002&#39;,MASTER_LOG_POS=663;</code></pre><p>C. 启动两台从库主从复制，查看从库状态</p><pre><code>start slave;show slave status \G;</code></pre><p><img src="/mysql-03/image-20230320171650604.png" alt="image-20230320171650604"></p><h2 id="4-5-双主双从读写分离"><a href="#4-5-双主双从读写分离" class="headerlink" title="4.5 双主双从读写分离"></a>4.5 双主双从读写分离</h2><h3 id="4-5-1-配置"><a href="#4-5-1-配置" class="headerlink" title="4.5.1 配置"></a>4.5.1 配置</h3><p>MyCat控制后台数据库的读写分离和负载均衡由schema.xml文件datahost标签的balance属性控 制，通过writeType及switchType来完成失败自动切换的。</p><p>1). schema.xml</p><p>配置逻辑库：</p><pre><code>&lt;schema name=&quot;ITCAST_RW2&quot; checkSQLschema=&quot;true&quot; sqlMaxLimit=&quot;100&quot; dataNode=&quot;dn7&quot;&gt;&lt;/schema</code></pre><p>配置数据节点：</p><pre><code>&lt;dataNode name=&quot;dn7&quot; dataHost=&quot;dhost7&quot; database=&quot;db01&quot; /&gt;</code></pre><p>配置节点主机：</p><pre><code>&lt;dataHost name=&quot;dhost7&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;1&quot; writeType=&quot;0&quot;dbType=&quot;mysql&quot; dbDriver=&quot;jdbc&quot; switchType=&quot;1&quot; slaveThreshold=&quot;100&quot;&gt;&lt;heartbeat&gt;select user()&lt;/heartbeat&gt;&lt;writeHost host=&quot;master1&quot; url=&quot;jdbc:mysql://192.168.200.211:3306?useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf8&quot;user=&quot;root&quot; password=&quot;1234&quot; &gt;&lt;readHost host=&quot;slave1&quot; url=&quot;jdbc:mysql://192.168.200.212:3306?useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf8&quot;user=&quot;root&quot; password=&quot;1234&quot; /&gt;&lt;/writeHost&gt;&lt;writeHost host=&quot;master2&quot; url=&quot;jdbc:mysql://192.168.200.213:3306?useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf8&quot;user=&quot;root&quot; password=&quot;1234&quot; &gt;&lt;readHost host=&quot;slave2&quot; url=&quot;jdbc:mysql://192.168.200.214:3306?useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf8&quot;user=&quot;root&quot; password=&quot;1234&quot; /&gt;&lt;/writeHost&gt;&lt;/dataHost&gt;</code></pre><p>具体的对应情况如下：</p><p><img src="/mysql-03/image-20230320172202322.png" alt="image-20230320172202322"></p><p>属性说明：</p><p>balance=”1” 代表全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡，简 单的说，当双主双从模式(M1-&gt;S1，M2-&gt;S2，并且 M1 与 M2 互为主备)，正常情况下， M2,S1,S2 都参与 select 语句的负载均衡 </p><p>writeType 0 : 写操作都转发到第1台writeHost, writeHost1挂了, 会切换到writeHost2上; 1 : 所有的写操作都随机地发送到配置的writeHost上 ;</p><p>switchType -1 : 不自动切换 1 : 自动切换</p><p>2). user.xml</p><p>配置root用户也可以访问到逻辑库 ITCAST_RW2。</p><pre><code>&lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;&lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;&lt;property name=&quot;schemas&quot;&gt;SHOPPING,ITCAST,ITCAST_RW2&lt;/property&gt;&lt;!-- 表级 DML 权限设置 --&gt;&lt;!--&lt;privileges check=&quot;true&quot;&gt;&lt;schema name=&quot;DB01&quot; dml=&quot;0110&quot; &gt;&lt;table name=&quot;TB_ORDER&quot; dml=&quot;1110&quot;&gt;&lt;/table&gt;&lt;/schema&gt;&lt;/privileges&gt;--&gt;&lt;/user&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-02</title>
      <link href="/mysql-02.html"/>
      <url>/mysql-02.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1.存储引擎"></a>1.存储引擎</h1><h2 id="1-1-MySQL体系结构"><a href="#1-1-MySQL体系结构" class="headerlink" title="1.1 MySQL体系结构"></a>1.1 MySQL体系结构</h2><p><img src="/mysql-02/image-20230318181430255.png" alt="image-20230318181430255"></p><p>1). 连接层</p><p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务 器也会为安全接入的每个客户端验证它所具有的操作权限。</p><p>2). 服务层</p><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部 分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解 析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大， 这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><p>3). 引擎层</p><p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通 信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库 中的索引是在存储引擎层实现的。</p><p>4). 存储层</p><p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</p><p>和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要 体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。 这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><h2 id="1-2-存储引擎介绍"><a href="#1-2-存储引擎介绍" class="headerlink" title="1.2 存储引擎介绍"></a>1.2 存储引擎介绍</h2><p>对于存储引擎，也是一样，他是mysql数据库的核心，需要在合适的场景选择合适的存储引 擎。接下来就来介绍一下存储引擎。 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是 基于库的，所以存储引擎也可被称为表类型。可以在创建表的时候，来指定选择的存储引擎，如果 没有指定将自动选择默认的存储引擎。</p><p>1). 建表时指定存储引擎</p><pre><code>CREATE TABLE 表名(字段1 字段1类型 [ COMMENT 字段1注释 ] ,......字段n 字段n类型 [COMMENT 字段n注释 ]) ENGINE = INNODB [ COMMENT 表注释 ] ;</code></pre><p>2). 查询当前数据库支持的存储引擎</p><pre><code> show engines;</code></pre><p>示例演示:</p><p>A. 查询建表语句 — 默认存储引擎: InnoDB</p><pre><code> show create table account;</code></pre><p><img src="/mysql-02/image-20230318182248843.png" alt="image-20230318182248843"></p><p>创建表时，即使没有指定存储疫情，数据库也会自动选择默认的存储引擎。</p><p>B. 查询当前数据库支持的存储引擎</p><pre><code>show engines ;</code></pre><p><img src="/mysql-02/image-20230318182342529.png" alt="image-20230318182342529"></p><p>C. 创建表 my_myisam , 并指定MyISAM存储引擎</p><pre><code>create table my_myisam(id int,name varchar(10)) engine = MyISAM ;</code></pre><h2 id="1-3-存储引擎特点"><a href="#1-3-存储引擎特点" class="headerlink" title="1.3 存储引擎特点"></a>1.3 存储引擎特点</h2><h3 id="1-3-1-InnoDB"><a href="#1-3-1-InnoDB" class="headerlink" title="1.3.1 InnoDB"></a>1.3.1 InnoDB</h3><p>1). 介绍</p><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。</p><p>2). 特点</p><ul><li>DML操作遵循ACID模型，支持事务； </li><li>行级锁，提高并发访问性能； </li><li>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</li></ul><p>3). 文件</p><p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结 构（frm-早期的 、sdi-新版的）、数据和索引。</p><p>参数：innodb_file_per_table</p><pre><code>show variables like &#39;innodb_file_per_table&#39;</code></pre><p><img src="/mysql-02/image-20230318182528184.png" alt="image-20230318182528184"></p><p>如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 直接打开MySQL的 数据存放目录： C:\ProgramData\MySQL\MySQL Server 8.0\Data ， 这个目录下有很多文件 夹，不同的文件夹代表不同的数据库。</p><p><img src="/mysql-02/image-20230318182600816.png" alt="image-20230318182600816"></p><p>可以看到里面有很多的ibd文件，每一个ibd文件就对应一张表，比如：有一张表 account，就 有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的 索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一 个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。</p><p><img src="/mysql-02/image-20230318182704471.png" alt="image-20230318182704471"></p><p>4). 逻辑存储结构</p><p><img src="/mysql-02/image-20230318182718828.png" alt="image-20230318182718828"></p><ul><li>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以 包含多个Segment段。 </li><li>段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管 理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。 </li><li>区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为 16K， 即一个区中一共有64个连续的页。</li><li>页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默 认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li><li>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时 所指定的字段以外，还包含两个隐藏字段。</li></ul><h3 id="1-3-2-MyISAM"><a href="#1-3-2-MyISAM" class="headerlink" title="1.3.2 MyISAM"></a>1.3.2 MyISAM</h3><p>1). 介绍</p><p>MyISAM是MySQL早期的默认存储引擎</p><p>2). 特点 </p><p>不支持事务，</p><p>不支持外键</p><p> 支持表锁，不支持行锁 </p><p>访问速度快</p><p>3). 文件</p><p>xxx.sdi：存储表结构信息</p><p> xxx.MYD: 存储数据 </p><p>xxx.MYI: 存储索引</p><p><img src="/mysql-02/image-20230318182949362.png" alt="image-20230318182949362"></p><h3 id="1-3-3-Memory"><a href="#1-3-3-Memory" class="headerlink" title="1.3.3 Memory"></a>1.3.3 Memory</h3><p>1). 介绍</p><p>Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为 临时表或缓存使用。</p><p>2). 特点</p><p> 内存存放</p><p> hash索引（默认）</p><p>3).文件</p><p>xxx.sdi：存储表结构信息</p><h3 id="1-3-4-区别及特点"><a href="#1-3-4-区别及特点" class="headerlink" title="1.3.4 区别及特点"></a>1.3.4 区别及特点</h3><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持(5.6版本之后)</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N/A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table><p>InnoDB引擎与MyISAM引擎的区别 ? </p><p>①. InnoDB引擎, 支持事务, 而MyISAM不支持。 </p><p>②. InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。 </p><p>③. InnoDB引擎, 支持外键, 而MyISAM是不支持的。 </p><p>主要是上述三点区别，当然也可以从索引结构、存储限制等方面，更加深入的回答，具体参 考如下官方文档：</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html</a></p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html</a></p><h3 id="1-4-存储引擎选择"><a href="#1-4-存储引擎选择" class="headerlink" title="1.4 存储引擎选择"></a>1.4 存储引擎选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据 实际情况选择多种存储引擎进行组合。 </p><p>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要 求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操 作，那么InnoDB存储引擎是比较合适的选择。 </p><p>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完 整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。 </p><p>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是 对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</p><h1 id="2-索引"><a href="#2-索引" class="headerlink" title="2.索引"></a>2.索引</h1><h3 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h3><h4 id="2-1-1-介绍"><a href="#2-1-1-介绍" class="headerlink" title="2.1.1 介绍"></a>2.1.1 介绍</h4><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足 特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。</p><h4 id="2-2-演示"><a href="#2-2-演示" class="headerlink" title="2.2 演示"></a>2.2 演示</h4><p>表结构及其数据如下：</p><p><img src="/mysql-02/image-20230318194855504.png" alt="image-20230318194855504"></p><p>假如要执行的SQL语句为 ： select * from user where age = 45</p><p>1). 无索引情况</p><p><img src="/mysql-02/image-20230318194914129.png" alt="image-20230318194914129"></p><p>在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为 全表扫描，性能很 低。</p><p>2). 有索引情况</p><p>如果针对于这张表建立了索引，假设索引结构就是二叉树，那么也就意味着，会对age这个字段建 立一个二叉树的索引结构。</p><p><img src="/mysql-02/image-20230318194942971.png" alt="image-20230318194942971"></p><p>此时进行查询时，只需要扫描三次就可以找到数据了，极大的提高的查询的效率。</p><h4 id="2-3-特点"><a href="#2-3-特点" class="headerlink" title="2.3 特点"></a>2.3 特点</h4><table><thead><tr><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>提高数据检索的效率，降低数据库 的IO成本</td><td>索引列也是要占用空间的。</td></tr><tr><td>通过索引列对数据进行排序，降低 数据排序的成本，降低CPU的消 耗。</td><td>索引大大提高了查询效率，同时却也降低更新表的速度， 如对表进行INSERT、UPDATE、DELETE时，效率降低。</td></tr></tbody></table><h3 id="2-2-索引结构"><a href="#2-2-索引结构" class="headerlink" title="2.2 索引结构"></a>2.2 索引结构</h3><h4 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1 概述"></a>2.2.1 概述</h4><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td></tr><tr><td>Hash索引</td><td>底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不 支持范围查询</td></tr><tr><td>R-tree(空间索 引）</td><td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类 型，通常使用较少</td></tr><tr><td>Full-text(全文 索引)</td><td>是一种通过建立倒排索引,快速匹配文档的方式。类似于 Lucene,Solr,ES</td></tr></tbody></table><p>上述是MySQL中所支持的所有的索引结构.</p><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h4 id="2-2-2-二叉树"><a href="#2-2-2-二叉树" class="headerlink" title="2.2.2 二叉树"></a>2.2.2 二叉树</h4><p>假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下:</p><p><img src="/mysql-02/image-20230318195506632.png" alt="image-20230318195506632"></p><p>如果主键是顺序插入的，则会形成一个单向链表，结构如下：</p><p><img src="/mysql-02/image-20230318195523470.png" alt="image-20230318195523470"></p><p>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p><ul><li>顺序插入时，会形成一个链表，查询性能大大降低。 </li><li>大数据量情况下，层级较深，检索速度慢。</li></ul><p>可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数 据，最终形成的数据结构也是一颗平衡的二叉树,结构如下</p><p><img src="/mysql-02/image-20230318195600407.png" alt="image-20230318195600407"></p><p>但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：</p><ul><li>大数据量情况下，层级较深，检索速度慢。</li></ul><p>所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree.</p><h4 id="2-2-3-B-Tree"><a href="#2-2-3-B-Tree" class="headerlink" title="2.2.3 B-Tree"></a>2.2.3 B-Tree</h4><p>B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。</p><p>以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5 个指针：</p><p><img src="/mysql-02/image-20230318200101312.png" alt="image-20230318200101312"></p><p>树的度数指的是一个节点的子节点个数。</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html" target="_blank" rel="noopener">B-Tree Visualization (usfca.edu)</a></p><p>演示</p><p><img src="/mysql-02/image-20230318200153552.png" alt="image-20230318200153552"></p><p><img src="/mysql-02/image-20230318200233820.png" alt="image-20230318200233820"></p><p>特点：</p><ul><li>5阶的B树，每一个节点最多存储4个key，对应5个指针。 </li><li>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。 </li><li>在B树中，非叶子节点和叶子节点都会存放数据。</li></ul><h4 id="2-2-4-B-Tree"><a href="#2-2-4-B-Tree" class="headerlink" title="2.2.4 B+Tree"></a>2.2.4 B+Tree</h4><p>B+Tree是B-Tree的变种，以一颗最大度数（max-degree）为4（4阶）的b+tree为例，</p><p><img src="/mysql-02/image-20230318201225101.png" alt="image-20230318201225101"></p><p>可以看到，两部分： </p><p>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。 </p><p>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</p><p><img src="/mysql-02/image-20230318201257821.png" alt="image-20230318201257821"></p><p>B+Tree 与 B-Tree相比，主要有以下三点区别： </p><ul><li>所有的数据都会出现在叶子节点。 </li><li>叶子节点形成一个单向链表。 </li><li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</li></ul><p>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点 的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</p><p><img src="/mysql-02/image-20230318201350644.png" alt="image-20230318201350644"></p><h4 id="2-2-5-Hash"><a href="#2-2-5-Hash" class="headerlink" title="2.2.5 Hash"></a>2.2.5 Hash</h4><p>MySQL中除了支持B+Tree索引，还支持一种索引类型—Hash索引。</p><p>1). 结构 哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash表中。</p><p><img src="/mysql-02/image-20230318201435838.png" alt="image-20230318201435838"></p><p>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可 以通过链表来解决。</p><p><img src="/mysql-02/image-20230318201504428.png" alt="image-20230318201504428"></p><p>2). 特点 </p><p>A. Hash索引只能用于对等比较(=，in)，不支持范围查询（between，&gt;，&lt; ，…）</p><p>B. 无法利用索引完成排序操作 C. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</p><p>3). 存储引擎支持</p><p> 在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。</p><h3 id="2-3-索引分类"><a href="#2-3-索引分类" class="headerlink" title="2.3 索引分类"></a>2.3 索引分类</h3><h4 id="2-3-1-索引分类"><a href="#2-3-1-索引分类" class="headerlink" title="2.3.1 索引分类"></a>2.3.1 索引分类</h4><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键 索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建, 只能 有一个</td><td>PRIMARY</td></tr><tr><td>唯一 索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规 索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文 索引</td><td>全文索引查找的是文本中的关键词，而不是比 较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><h4 id="2-3-2-聚集索引-amp-二级索引"><a href="#2-3-2-聚集索引-amp-二级索引" class="headerlink" title="2.3.2 聚集索引&amp;二级索引"></a>2.3.2 聚集索引&amp;二级索引</h4><p>而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据</td><td>必须有,而且只 有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>聚集索引选取规则:</p><ul><li>如果存在主键，主键索引就是聚集索引。</li></ul><ul><li><p>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p></li><li><p>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p></li></ul><p>聚集索引选取规则:</p><ul><li>如果存在主键，主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索 引。</li></ul><p>聚集索引和二级索引的具体结构如下：</p><p><img src="/mysql-02/image-20230318221645990.png" alt="image-20230318221645990"></p><ul><li>聚集索引的叶子节点下挂的是这一行的数据 。 </li><li>二级索引的叶子节点下挂的是该字段值对应的主键值。</li></ul><p>执行如下的SQL语句时，具体的查找过程是什么样子的。</p><p><img src="/mysql-02/image-20230318221907869.png" alt="image-20230318221907869"></p><p>具体过程如下:</p><p>①. 由于是根据name字段进行查询，所以先根据name=’Arm’到name字段的二级索引中进行匹配查 找。但是在二级索引中只能查找到 Arm 对应的主键值10</p><p>②. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最 终找到10对应的行row。</p><p>③. 最终拿到这一行的数据，直接返回即可。</p><p>回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取 数据的方式，就称之为回表查询。</p><p><img src="/mysql-02/image-20230318222059039.png" alt="image-20230318222059039"></p><p>假设:</p><p>一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空 间，主键即使为bigint，占用字节数为8。</p><p>高度为2：</p><p>​        n * 8 + (n + 1) * 6 = 16*1024 , 算出n约为 1170</p><p>​        1171* 16 = 18736</p><p>也就是说，如果树的高度为2，则可以存储 18000 多条记录。</p><p>高度为3：</p><p>1171 * 1171 * 16 = 21939856</p><p>也就是说，如果树的高度为3，则可以存储 2200w 左右的记录。</p><h3 id="2-4-索引语法"><a href="#2-4-索引语法" class="headerlink" title="2.4 索引语法"></a>2.4 索引语法</h3><p>1). 创建索引</p><pre><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,... ) ;</code></pre><p>2). 查看索引</p><pre><code> SHOW INDEX FROM table_name ;</code></pre><p>3). 删除索引</p><pre><code>DROP INDEX index_name ON table_name ;</code></pre><p>演示表</p><pre><code>create table tb_user(id int primary key auto_increment comment &#39;主键&#39;,name varchar(50) not null comment &#39;用户名&#39;,phone varchar(11) not null comment &#39;手机号&#39;,email varchar(100) comment &#39;邮箱&#39;,profession varchar(11) comment &#39;专业&#39;,age tinyint unsigned comment &#39;年龄&#39;,gender char(1) comment &#39;性别 , 1: 男, 2: 女&#39;,status char(1) comment &#39;状态&#39;,createtime datetime comment &#39;创建时间&#39;) comment &#39;系统用户表&#39;</code></pre><p><img src="/mysql-02/image-20230318222406413.png" alt="image-20230318222406413"></p><p>A. name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。</p><pre><code>CREATE INDEX idx_user_name ON tb_user(name);</code></pre><p>B. phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引。</p><pre><code>CREATE UNIQUE INDEX idx_user_phone ON tb_user(phone);</code></pre><p>C. 为profession、age、status创建联合索引。</p><pre><code>CREATE INDEX idx_user_pro_age_sta ON tb_user(profession,age,status);</code></pre><p>D. 为email建立合适的索引来提升查询效率</p><pre><code>CREATE INDEX idx_email ON tb_user(email)</code></pre><p><img src="/mysql-02/image-20230318222612965.png" alt="image-20230318222612965"></p><h3 id="2-5-SQL性能分析"><a href="#2-5-SQL性能分析" class="headerlink" title="2.5 SQL性能分析"></a>2.5 SQL性能分析</h3><h4 id="2-5-1-SQL执行频率"><a href="#2-5-1-SQL执行频率" class="headerlink" title="2.5.1 SQL执行频率"></a>2.5.1 SQL执行频率</h4><p>通过 show [session|global] status 命令可以提供服务器状态信 息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：</p><pre><code>-- session 是查看当前会话 ;-- global 是查询全局数据 ;SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;;</code></pre><p><img src="/mysql-02/image-20230318222752012.png" alt="image-20230318222752012"></p><p>查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，可以考虑不对其进行索引的优化。 如果是以查询为主，那么就要考虑对数据库的索引进行优化了。</p><h4 id="2-5-2-慢查询日志"><a href="#2-5-2-慢查询日志" class="headerlink" title="2.5.2 慢查询日志"></a>2.5.2 慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志</p><p>MySQL的慢查询日志默认没有开启，</p><p><img src="/mysql-02/image-20230318224609961.png" alt="image-20230318224609961"></p><p>如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p><pre><code># 开启MySQL慢日志查询开关slow_query_log=1# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志long_query_time=2</code></pre><p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息</p><p>/var/lib/mysql/localhost-slow.log。</p><pre><code>systemctl restart mysqld</code></pre><p>然后，再次查看开关情况，慢查询日志就已经打开了。</p><p><img src="/mysql-02/image-20230318224945351.png" alt="image-20230318224945351"></p><p>A. 执行如下SQL语句 ：</p><pre><code>select * from tb_user; -- 这条SQL执行效率比较高, 执行耗时 0.00secselect count(*) from tb_sku; -- 由于tb_sku表中, 预先存入了1000w的记录, count一次,耗时13.35sec</code></pre><p>B. 检查慢查询日志 ：在慢查询日志中，只会记录执行时间超多预设时间（2s）的SQL，执行较快的SQL 是不会记录的。</p><p><img src="/mysql-02/image-20230318225343630.png" alt="image-20230318225343630"></p><h4 id="2-5-3-profile详情"><a href="#2-5-3-profile详情" class="headerlink" title="2.5.3 profile详情"></a>2.5.3 profile详情</h4><p>show profiles 能够在做SQL优化时帮助了解时间都耗费到哪里去了。通过have_profiling 参数，能够看到当前MySQL是否支持profile操作：</p><pre><code>SELECT @@have_profiling ;</code></pre><p><img src="/mysql-02/image-20230318225426205.png" alt="image-20230318225426205"></p><p>可以看到，当前MySQL是支持 profile操作的，但是开关是关闭的。可以通过set语句在 session/global级别开启profiling：</p><pre><code>SET profiling = 1;</code></pre><p>开关已经打开了，接下来，执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去 了。 </p><p>执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：</p><pre><code>-- 查看每一条SQL的耗时基本情况show profiles;-- 查看指定query_id的SQL语句各个阶段的耗时情况show profile for query query_id;-- 查看指定query_id的SQL语句CPU的使用情况show profile cpu for query query_id;</code></pre><p><img src="/mysql-02/image-20230318225648176.png" alt="image-20230318225648176"></p><p>查看指定SQL各个阶段的耗时情况 :  query_id为16的情况</p><p><img src="/mysql-02/image-20230318225705567.png" alt="image-20230318225705567"></p><h4 id="2-5-4-explain"><a href="#2-5-4-explain" class="headerlink" title="2.5.4 explain"></a>2.5.4 explain</h4><p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行 过程中表如何连接和连接的顺序。</p><p>语法:</p><pre><code>-- 直接在select语句之前加上关键字 explain / descEXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;</code></pre><p><img src="/mysql-02/image-20230318225806472.png" alt="image-20230318225806472"></p><p>Explain 执行计划中各个字段的含义:</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序 (id相同，执行顺序从上到下；id不同，值越大，越先执行)。</td></tr><tr><td>select_type</td><td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接 或者子查询）、PRIMARY（主查询，即外层的查询）、 UNION（UNION 中的第二个或者后面的查询语句）、 SUBQUERY（SELECT/WHERE之后包含了子查询）等</td></tr><tr><td>type</td><td>表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。</td></tr><tr><td>possible_key</td><td>显示可能应用在这张表上的索引，一个或多个。</td></tr><tr><td>key</td><td>实际使用的索引，如果为NULL，则没有使用索引。</td></tr><tr><td>key_len</td><td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。</td></tr><tr><td>rows</td><td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值， 可能并不总是准确的。</td></tr><tr><td>filtered</td><td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td></tr></tbody></table><h3 id="2-6-索引使用"><a href="#2-6-索引使用" class="headerlink" title="2.6 索引使用"></a>2.6 索引使用</h3><h4 id="2-6-1-验证索引效率"><a href="#2-6-1-验证索引效率" class="headerlink" title="2.6.1 验证索引效率"></a>2.6.1 验证索引效率</h4><p>这表中有1000W的记录</p><p>这张表中id为主键，有主键索引，而其他字段是没有建立索引的。 先来查询其中的一条记录，看 看里面的字段情况，执行如下SQL：</p><pre><code>select * from tb_sku where id = 1\G;\G是垂直显示</code></pre><p><img src="/mysql-02/image-20230318230447872.png" alt="image-20230318230447872"></p><p>可以看到即使有1000w的数据,根据id进行数据查询,性能依然很快，因为主键id是有索引的。</p><pre><code>SELECT * FROM tb_sku WHERE sn = &#39;100000003145001&#39;;</code></pre><p><img src="/mysql-02/image-20230318230511242.png" alt="image-20230318230511242"></p><p>可以看到根据sn字段进行查询，查询返回了一条数据，结果耗时 20.78sec，就是因为sn没有索 引，而造成查询效率很低。 可以针对于sn字段，建立一个索引，建立了索引之后，再次根据sn进行查询，再来看一 下查询耗时情况。</p><p>创建索引：</p><pre><code>create index idx_sku_sn on tb_sku(sn) ;</code></pre><p><img src="/mysql-02/image-20230318230652231.png" alt="image-20230318230652231"></p><p>然后再次执行相同的SQL语句，再次查看SQL的耗时。</p><pre><code>SELECT * FROM tb_sku WHERE sn = &#39;100000003145001&#39;;</code></pre><p><img src="/mysql-02/image-20230318230724284.png" alt="image-20230318230724284"></p><p>明显会看到，sn字段建立了索引之后，查询性能大大提升。建立索引前后，查询耗时都不是一个数 量级的。</p><h4 id="2-6-2-最左前缀法则"><a href="#2-6-2-最左前缀法则" class="headerlink" title="2.6.2 最左前缀法则"></a>2.6.2 最左前缀法则</h4><p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。</p><p>以 tb_user 表为例，</p><p><img src="/mysql-02/image-20230318230807101.png" alt="image-20230318230807101"></p><p>在 tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession， age，status。 对于最左前缀法则指的是，查询时，最左边的列，也就是profession必须存在，否则索引全部失效。 而且中间不能跳过某一列，否则该列后面的字段索引将失效。</p><p>当执行SQL语句: explain select * from tb_user where age = 31 and status = ‘0’ and profession = ‘软件工程’； 时，是否满足最左前缀法则，走不走 上述的联合索引，索引长度？</p><p><img src="/mysql-02/image-20230318230911191.png" alt="image-20230318230911191"></p><p>可以看到，是完全满足最左前缀法则的，索引长度54，联合索引是生效的。</p><p>注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是 第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p><h4 id="2-6-3-范围查询"><a href="#2-6-3-范围查询" class="headerlink" title="2.6.3 范围查询"></a>2.6.3 范围查询</h4><p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效。</p><pre><code>explain select * from tb_user where profession = &#39;软件工程&#39; and age &gt; 30 and status= &#39;0&#39;;</code></pre><p><img src="/mysql-02/image-20230318231120926.png" alt="image-20230318231120926"></p><p>当范围查询使用&gt; 或 &lt; 时，走联合索引了，但是索引的长度为49，就说明范围查询右边的status字 段是没有走索引的。</p><pre><code>explain select * from tb_user where profession = &#39;软件工程&#39; and age &gt;= 30 andstatus = &#39;0&#39;;</code></pre><p><img src="/mysql-02/image-20230318231212418.png" alt="image-20230318231212418"></p><p>当范围查询使用&gt;= 或 &lt;= 时，走联合索引了，但是索引的长度为54，就说明所有的字段都是走索引 的。 所以，在业务允许的情况下，尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，而避免使用 &gt; 或 &lt; 。</p><h4 id="2-6-4-索引失效情况"><a href="#2-6-4-索引失效情况" class="headerlink" title="2.6.4 索引失效情况"></a>2.6.4 索引失效情况</h4><h5 id="2-6-4-1-索引列运算"><a href="#2-6-4-1-索引列运算" class="headerlink" title="2.6.4.1 索引列运算"></a>2.6.4.1 索引列运算</h5><p>不要在索引列上进行运算操作， 索引将失效。</p><p>在tb_user表中，除了前面介绍的联合索引之外，还有一个索引，是phone字段的单列索引。</p><p><img src="/mysql-02/image-20230318231259493.png" alt="image-20230318231259493"></p><p>A. 当根据phone字段进行等值匹配查询时, 索引生效。</p><pre><code>explain select * from tb_user where phone = &#39;17799990015&#39;;</code></pre><p>B. 当根据phone字段进行函数运算操作之后，索引失效。</p><pre><code>explain select * from tb_user where substring(phone,10,2) = &#39;15&#39;</code></pre><p><img src="/mysql-02/image-20230318231423997.png" alt="image-20230318231423997"></p><h5 id="2-6-4-2-字符串不加引号"><a href="#2-6-4-2-字符串不加引号" class="headerlink" title="2.6.4.2 字符串不加引号"></a>2.6.4.2 字符串不加引号</h5><p>字符串类型字段使用时，不加引号，索引将失效。</p><pre><code>explain select * from tb_user where profession = &#39;软件工程&#39; and age = 31 and status= &#39;0&#39;;explain select * from tb_user where profession = &#39;软件工程&#39; and age = 31 and status= 0;</code></pre><p><img src="/mysql-02/image-20230318231630498.png" alt="image-20230318231630498"></p><pre><code>explain select * from tb_user where phone = &#39;17799990015&#39;;explain select * from tb_user where phone = 17799990015;</code></pre><p><img src="/mysql-02/image-20230318231652044.png" alt="image-20230318231652044"></p><p>经过上面两组示例，会明显的发现，如果字符串不加单引号，对于查询结果，没什么影响，但是数 据库存在隐式类型转换，索引将失效。</p><h5 id="2-6-4-3-模糊查询"><a href="#2-6-4-3-模糊查询" class="headerlink" title="2.6.4.3 模糊查询"></a>2.6.4.3 模糊查询</h5><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><p>由于下面查询语句中，都是根据profession字段查询，符合最左前缀法则，联合索引是可以生效的， 主要看一下，模糊查询时，%加在关键字之前，和加在关键字之后的影响。</p><pre><code>explain select * from tb_user where profession like &#39;软件%&#39;;explain select * from tb_user where profession like &#39;%工程&#39;;explain select * from tb_user where profession like &#39;%工%&#39;;</code></pre><p><img src="/mysql-02/image-20230318231758572.png" alt="image-20230318231758572"></p><p>经过上述的测试，在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字 前面加了%，索引将会失效。</p><h5 id="3-6-4-4-or连接条件"><a href="#3-6-4-4-or连接条件" class="headerlink" title="3.6.4.4 or连接条件"></a>3.6.4.4 or连接条件</h5><p>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会 被用到。</p><pre><code>xplain select * from tb_user where id = 10 or age = 23;explain select * from tb_user where phone = &#39;17799990017&#39; or age = 23;</code></pre><p><img src="/mysql-02/image-20230318231912002.png" alt="image-20230318231912002"></p><p>由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。</p><p>然后，可以对age字段建立索引。</p><pre><code>create index idx_user_age on tb_user(age)</code></pre><p><img src="/mysql-02/image-20230318231942043.png" alt="image-20230318231942043"></p><p>建立了索引之后，再次执行上述的SQL语句，看看前后执行计划的变化。</p><p><img src="/mysql-02/image-20230318231954670.png" alt="image-20230318231954670"></p><p>当or连接的条件，左右两侧字段都有索引时，索引才会生效。</p><h5 id="3-6-4-5-数据分布影响"><a href="#3-6-4-5-数据分布影响" class="headerlink" title="3.6.4.5 数据分布影响"></a>3.6.4.5 数据分布影响</h5><pre><code>select * from tb_user where phone &gt;= &#39;17799990005&#39;;select * from tb_user where phone &gt;= &#39;17799990015&#39;;</code></pre><p><img src="/mysql-02/image-20230318232049614.png" alt="image-20230318232049614"></p><p>相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样</p><p>因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃 索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不 如走全表扫描来的快，此时索引就会失效。</p><p> is null 与 is not null 操作是否走索引。</p><p>执行如下两条语句 ：</p><pre><code>explain select * from tb_user where profession is null;explain select * from tb_user where profession is not null;</code></pre><p><img src="/mysql-02/image-20230318232202493.png" alt="image-20230318232202493"></p><p>将profession字段值全部更新为null。</p><p><img src="/mysql-02/image-20230318232214786.png" alt="image-20230318232214786"></p><p>然后，再次执行上述的两条SQL，查看SQL语句的执行计划。</p><p>最终看到，一模一样的SQL语句，先后执行了两次，结果查询计划是不一样的，为什么会出现这种 现象，这是和数据库的数据分布有关系。查询时MySQL会评估，走索引快，还是全表扫描快，如果全表 扫描更快，则放弃索引走全表扫描。 因此，is null 、is not null是否走索引，得具体情况具体 分析，并不是固定的。</p><h5 id="2-6-5-SQL提示"><a href="#2-6-5-SQL提示" class="headerlink" title="2.6.5 SQL提示"></a>2.6.5 SQL提示</h5><p>目前tb_user表的数据情况如下:</p><p><img src="/mysql-02/image-20230318232304149.png" alt="image-20230318232304149"></p><p>索引情况如下:</p><p><img src="/mysql-02/image-20230318232313580.png" alt="image-20230318232313580"></p><p>把上述的 idx_user_age, idx_email 这两个之前测试使用过的索引直接删除。</p><pre><code>drop index idx_user_age on tb_user;drop index idx_email on tb_user;</code></pre><p>A. 执行SQL : explain select * from tb_user where profession = ‘软件工程’;</p><p><img src="/mysql-02/image-20230318232402315.png" alt="image-20230318232402315"></p><p>查询走了联合索引。</p><p>B. 执行SQL，创建profession的单列索引：create index idx_user_pro on tb_user(profession);</p><p><img src="/mysql-02/image-20230318232418417.png" alt="image-20230318232418417"></p><p>C. 创建单列索引后，再次执行A中的SQL语句，查看执行计划，看看到底走哪个索引。</p><p><img src="/mysql-02/image-20230318232427617.png" alt="image-20230318232427617"></p><p>可以看到，possible_keys中 idx_user_pro_age_sta,idx_user_pro 这两个 索引都可能用到，最终MySQL选择了idx_user_pro_age_sta索引。这是MySQL自动选择的结果。</p><p>手动指定使用索引</p><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优 化操作的目的。</p><p>1). use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进 行评估）。</p><pre><code>explain select * from tb_user use index(idx_user_pro) where profession = &#39;软件工程&#39;;</code></pre><p>2). ignore index ： 忽略指定的索引。</p><pre><code>explain select * from tb_user ignore index(idx_user_pro) where profession = &#39;软件工程&#39;;</code></pre><p>3). force index ： 强制使用索引。</p><pre><code>explain select * from tb_user force index(idx_user_pro) where profession = &#39;软件工程&#39;;</code></pre><h5 id="2-6-6-覆盖索引"><a href="#2-6-6-覆盖索引" class="headerlink" title="2.6.6 覆盖索引"></a>2.6.6 覆盖索引</h5><p>尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ 覆盖索引是指 查询使用了索引，并 且需要返回的列，在该索引中已经全部能够找到 。</p><p>执行下述sql语句</p><pre><code>explain select id, profession from tb_user where profession = &#39;软件工程&#39; and age =31 and status = &#39;0&#39; ;explain select id,profession,age, status from tb_user where profession = &#39;软件工程&#39;and age = 31 and status = &#39;0&#39; ;explain select id,profession,age, status, name from tb_user where profession = &#39;软件工程&#39; and age = 31 and status = &#39;0&#39; ;explain select * from tb_user where profession = &#39;软件工程&#39; and age = 31 and status= &#39;0&#39;;</code></pre><p>上述这几条SQL的执行结果为:</p><p><img src="/mysql-02/image-20230318232641116.png" alt="image-20230318232641116"></p><p>从上述的执行计划我们可以看到，这四条SQL语句的执行计划前面所有的指标都是一样的，看不出来差 异。但是此时主要关注的是后面的Extra，前面两天SQL的结果为 Using where; Using Index ; 而后面两条SQL的结果为: Using index condition 。</p><table><thead><tr><th>Extra</th><th>含义</th></tr></thead><tbody><tr><td>Using where; Using Index</td><td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需 要回表查询数据</td></tr><tr><td>Using index condition</td><td>查找使用了索引，但是需要回表查询数据</td></tr></tbody></table><p>因为，在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段 profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主 键id。</p><p> 所以当查询返回的数据在 id、profession、age、status 之中，则直接走二级索引 直接返回数据了。 如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据 ，这个过程就是回表。 而如果一直使用select * 查询返回所有字段值，很容易就会造成回表 查询（除非是根据主键查询，此时只会扫描聚集索引）。</p><p>A. 表结构及索引示意图:</p><p><img src="/mysql-02/image-20230319123949489.png" alt="image-20230319123949489"></p><p><img src="/mysql-02/image-20230319123957065.png" alt="image-20230319123957065"></p><p>id是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）。</p><p>B. 执行SQL : select * from tb_user where id = 2;</p><p><img src="/mysql-02/image-20230319124138268.png" alt="image-20230319124138268"></p><p>根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p><p>C. 执行SQL：selet id,name from tb_user where name = ‘Arm’</p><p><img src="/mysql-02/image-20230319124238772.png" alt="image-20230319124238772"></p><p>虽然是根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在name的二级索 引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。</p><p>D. 执行SQL：selet id,name,gender from tb_user where name = ‘Arm’;</p><p><img src="/mysql-02/image-20230319124305169.png" alt="image-20230319124305169"></p><p>由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相 对较差一点。</p><p>例如</p><p>一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对 以下SQL语句进行优化, </p><p> select id,username,password from tb_user where username = ‘itcast’; </p><p>针对于 username, password建立联合索引, sql为: create index idx_user_name_pass on tb_user(username,password); </p><p>这样可以避免上述的SQL语句，在查询的过程中，出现回表查询</p><h5 id="2-6-7-前缀索引"><a href="#2-6-7-前缀索引" class="headerlink" title="2.6.7 前缀索引"></a>2.6.7 前缀索引</h5><p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让 索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建 立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>1). 语法</p><pre><code>create index idx_xxxx on table_name(column(n)) ;</code></pre><p>示例:</p><p>为tb_user表的email字段，建立长度为5的前缀索引。</p><pre><code>create index idx_email_5 on tb_user(email(5));</code></pre><p><img src="/mysql-02/image-20230319125857546.png" alt="image-20230319125857546"></p><p>2). 前缀长度</p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值， 索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><pre><code>select count(distinct email) / count(*) from tb_user ;select count(distinct substring(email,1,5)) / count(*) from tb_user ;</code></pre><p>3). 前缀索引的查询流程</p><p><img src="/mysql-02/image-20230319130224881.png" alt="image-20230319130224881"></p><h5 id="2-6-8-单列索引与联合索引"><a href="#2-6-8-单列索引与联合索引" class="headerlink" title="2.6.8 单列索引与联合索引"></a>2.6.8 单列索引与联合索引</h5><p>单列索引：即一个索引只包含单个列。</p><p>联合索引：即一个索引包含了多个列。</p><p><img src="/mysql-02/image-20230319130401139.png" alt="image-20230319130401139"></p><p>在查询出来的索引中，既有单列索引，又有联合索引。</p><p><img src="/mysql-02/image-20230319130514769.png" alt="image-20230319130514769"></p><p>通过上述执行计划可以看出来，在and连接的两个字段 phone、name上都是有单列索引的，但是 最终mysql只会选择一个索引，也就是说，只能走一个字段的索引，此时是会回表查询的。</p><p>紧接着，再来创建一个phone和name字段的联合索引来查询一下执行计划。</p><pre><code>create unique index idx_user_phone_name on tb_user(phone,name)</code></pre><p><img src="/mysql-02/image-20230319130604210.png" alt="image-20230319130604210"></p><p>此时，查询时，就走了联合索引，而在联合索引中包含 phone、name的信息，在叶子节点下挂的是对 应的主键id，所以查询是无需回表查询的。</p><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。</p><p>如果查询使用的是联合索引，具体的结构示意图如下：</p><p><img src="/mysql-02/image-20230319130818720.png" alt="image-20230319130818720"></p><h3 id="2-7-索引设计原则"><a href="#2-7-索引设计原则" class="headerlink" title="2.7 索引设计原则"></a>2.7 索引设计原则</h3><p>1). 针对于数据量较大，且查询比较频繁的表建立索引。</p><p>2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索 引。</p><p>3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p><p>4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p><p>5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。</p><p>6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增 删改的效率。</p><p>7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p><h1 id="3-SQL优化"><a href="#3-SQL优化" class="headerlink" title="3.SQL优化"></a>3.SQL优化</h1><h2 id="3-1-插入数据"><a href="#3-1-插入数据" class="headerlink" title="3.1 插入数据"></a>3.1 插入数据</h2><h3 id="3-1-1-insert"><a href="#3-1-1-insert" class="headerlink" title="3.1.1 insert"></a>3.1.1 insert</h3><p>如果需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。</p><pre><code>insert into tb_test values(1,&#39;tom&#39;);insert into tb_test values(2,&#39;cat&#39;);insert into tb_test values(3,&#39;jerry&#39;);.....</code></pre><p>1). 优化方案一</p><p>批量插入数据</p><pre><code>Insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;);</code></pre><p>2). 优化方案二</p><p>手动控制事务</p><pre><code>start transaction;insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;);insert into tb_test values(4,&#39;Tom&#39;),(5,&#39;Cat&#39;),(6,&#39;Jerry&#39;);insert into tb_test values(7,&#39;Tom&#39;),(8,&#39;Cat&#39;),(9,&#39;Jerry&#39;);commit;</code></pre><p>3). 优化方案三</p><p>主键顺序插入，性能要高于乱序插入。</p><pre><code>主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89</code></pre><h3 id="3-1-2-大批量插入数据"><a href="#3-1-2-大批量插入数据" class="headerlink" title="3.1.2 大批量插入数据"></a>3.1.2 大批量插入数据</h3><p>如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使 用MySQL数据库提供的load指令进行插入。操作如下：</p><p><img src="/mysql-02/image-20230319131426081.png" alt="image-20230319131426081"></p><p>可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</p><pre><code>-- 客户端连接服务端时，加上参数 -–local-infilemysql –-local-infile -u root -p-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关set global local_infile = 1;-- 执行load指令将准备好的数据，加载到表结构中load data local infile &#39;/root/sql1.log&#39; into table tb_user fieldsterminated by &#39;,&#39; lines terminated by &#39;\n&#39; ;</code></pre><p>主键顺序插入性能高于乱序插入</p><p>在load时，主键顺序插入性能高于乱序插入</p><h2 id="3-2-主键优化"><a href="#3-2-主键优化" class="headerlink" title="3.2 主键优化"></a>3.2 主键优化</h2><p>1). 数据组织方式</p><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表 (index organized table IOT)。</p><p><img src="/mysql-02/image-20230319131635559.png" alt="image-20230319131635559"></p><p>行数据，都是存储在聚集索引的叶子节点上的。</p><p><img src="/mysql-02/image-20230319131651509.png" alt="image-20230319131651509"></p><p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。 那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储 到下一个页中，页与页之间会通过指针连接。</p><p>2). 页分裂</p><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行 溢出)，根据主键排列。</p><p>A. 主键顺序插入效果</p><p>①. 从磁盘中申请页， 主键顺序插</p><p><img src="/mysql-02/image-20230319131730097.png" alt="image-20230319131730097"></p><p>②. 第一个页没有满，继续往第一页插入</p><p><img src="/mysql-02/image-20230319131743300.png" alt="image-20230319131743300"></p><p>③. 当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</p><p><img src="/mysql-02/image-20230319131755919.png" alt="image-20230319131755919"></p><p>④. 当第二页写满了，再往第三页写入</p><p><img src="/mysql-02/image-20230319131808096.png" alt="image-20230319131808096"></p><p>B. 主键乱序插入效果</p><p>①. 加入1#,2#页都已经写满了，存放了如图所示的数据</p><p><img src="/mysql-02/image-20230319131820529.png" alt="image-20230319131820529"></p><p>②. 此时再插入id为50的记录，会发生什么现象</p><p><img src="/mysql-02/image-20230319131849019.png" alt="image-20230319131849019"></p><p>不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。</p><p><img src="/mysql-02/image-20230319131901394.png" alt="image-20230319131901394"></p><p>但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。</p><p><img src="/mysql-02/image-20230319131913267.png" alt="image-20230319131913267"></p><p>但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。</p><p><img src="/mysql-02/image-20230319131934335.png" alt="image-20230319131934335"></p><p><img src="/mysql-02/image-20230319131941911.png" alt="image-20230319131941911"></p><p>移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个 页，应该是3#， 3#的下一个页是2#。 所以，此时，需要重新设置链表指针。</p><p>上述的这种现象，称之为 “页分裂”，是比较耗费性能的操作。</p><p>3). 页合并</p><p>目前表中已有数据的索引结构(叶子节点)如下：</p><p><img src="/mysql-02/image-20230319132139676.png" alt="image-20230319132139676"></p><p>对已有数据进行删除时，具体的效果如下: 当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间 变得允许被其他记录声明使用。</p><p><img src="/mysql-02/image-20230319132202748.png" alt="image-20230319132202748"></p><p>继续删除2#的数据记录</p><p><img src="/mysql-02/image-20230319132214171.png" alt="image-20230319132214171"></p><p><img src="/mysql-02/image-20230319132310575.png" alt="image-20230319132310575"></p><p>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前 或后）看看是否可以将两个页合并以优化空间使用。</p><p><img src="/mysql-02/image-20230319132502279.png" alt="image-20230319132502279"></p><p>删除数据，并将页合并之后，再次插入新的数据21，则直接插入3#页</p><p><img src="/mysql-02/image-20230319132513231.png" alt="image-20230319132513231"></p><p>这个里面所发生的合并页的这个现象，就称之为 “页合并”。</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</p><p>4). 索引设计原则</p><ul><li><p>满足业务需求的情况下，尽量降低主键的长度。</p></li><li><p>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键</p></li><li><p>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</p></li><li><p>业务操作时，避免对主键的修改。</p></li></ul><p><img src="/mysql-02/image-20230319132620948.png" alt="image-20230319132620948"></p><h2 id="3-3-order-by优化"><a href="#3-3-order-by优化" class="headerlink" title="3.3 order by优化"></a>3.3 order by优化</h2><p>MySQL的排序，有两种方式：</p><p>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p><p>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要 额外排序，操作效率高。</p><p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，在优化排序 操作时，尽量要优化为 Using index。</p><p>C. 创建索引</p><pre><code>-- 创建索引create index idx_user_age_phone_aa on tb_user(age,phone);</code></pre><p>D. 创建索引后，根据age, phone进行升序排序</p><pre><code>explain select id,age,phone from tb_user order by age;</code></pre><p><img src="/mysql-02/image-20230319133656461.png" alt="image-20230319133656461"></p><p><img src="/mysql-02/image-20230319133721578.png" alt="image-20230319133721578"></p><p>建立索引之后，再次进行排序查询，就由原来的Using filesort， 变为了 Using index，性能 就是比较高的了。</p><p>E. 创建索引后，根据age, phone进行降序排序</p><pre><code>explain select id,age,phone from tb_user order by age desc , phone desc ;</code></pre><p><img src="/mysql-02/image-20230319133749616.png" alt="image-20230319133749616"></p><p>也出现 Using index， 但是此时Extra中出现了 Backward index scan，这个代表反向扫描索 引，因为在MySQL中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序 时，是从大到小，所以，在扫描时，就是反向扫描，就会出现 Backward index scan。 在 MySQL8版本中，支持降序索引，我们也可以创建降序索引。</p><p>F. 根据phone，age进行升序排序，phone在前，age在后。</p><pre><code>explain select id,age,phone from tb_user order by phone , age</code></pre><p><img src="/mysql-02/image-20230319133818129.png" alt="image-20230319133818129"></p><p>排序时,也需要满足最左前缀法则,否则也会出现 filesort。因为在创建索引的时候， age是第一个 字段，phone是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现 Using filesort。</p><p>F. 根据age, phone进行降序一个升序，一个降序</p><pre><code>explain select id,age,phone from tb_user order by age asc , phone desc ;</code></pre><p><img src="/mysql-02/image-20230319133847158.png" alt="image-20230319133847158"></p><p>因为创建索引时，如果未指定顺序，默认都是按照升序排序的，而查询时，一个升序，一个降序，此时 就会出现Using filesort。</p><p><img src="/mysql-02/image-20230319133858645.png" alt="image-20230319133858645"></p><p>G. 创建联合索引(age 升序排序，phone 倒序排序)</p><pre><code>create index idx_user_age_phone_ad on tb_user(age asc ,phone desc);</code></pre><p><img src="/mysql-02/image-20230319134002511.png" alt="image-20230319134002511"></p><p>H. 然后再次执行如下SQL</p><pre><code>explain select id,age,phone from tb_user order by age asc , phone desc ;</code></pre><p><img src="/mysql-02/image-20230319134017143.png" alt="image-20230319134017143"></p><p>升序/降序联合索引结构图示:</p><p><img src="/mysql-02/image-20230319155114654.png" alt="image-20230319155114654"></p><p><img src="/mysql-02/image-20230319155120751.png" alt="image-20230319155120751"></p><p>由上述的测试,我们得出order by优化原则:</p><p>A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p><p>B. 尽量使用覆盖索引。</p><p>C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</p><p>D. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。</p><h2 id="3-4-group-by优化"><a href="#3-4-group-by优化" class="headerlink" title="3.4 group by优化"></a>3.4 group by优化</h2><p>在没有索引的情况下，执行如下SQL，查询执行计划：</p><pre><code>explain select profession , count(*) from tb_user group by profession ;</code></pre><p><img src="/mysql-02/image-20230319155255946.png" alt="image-20230319155255946"></p><p>针对于 profession ， age， status 创建一个联合索引。</p><pre><code>create index idx_user_pro_age_sta on tb_user(profession , age , status);</code></pre><p>再执行前面相同的SQL查看执行计划。</p><pre><code>explain select profession , count(*) from tb_user group by profession ;</code></pre><p><img src="/mysql-02/image-20230319155359691.png" alt="image-20230319155359691"></p><p><img src="/mysql-02/image-20230319155546400.png" alt="image-20230319155546400"></p><p><img src="/mysql-02/image-20230319155556578.png" alt="image-20230319155556578"></p><p>如果仅仅根据age分组，就会出现 Using temporary ；而如果是 根据 profession,age两个字段同时分组，则不会出现 Using temporary。原因是因为对于分组操作， 在联合索引中，也是符合最左前缀法则的。</p><p>所以，在分组操作中需要通过以下两点进行优化，以提升性能： </p><p>A. 在分组操作时，可以通过索引来提高效率。 </p><p>B. 分组操作时，索引的使用也是满足最左前缀法则的。</p><h2 id="3-5-limit优化"><a href="#3-5-limit优化" class="headerlink" title="3.5 limit优化"></a>3.5 limit优化</h2><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p><p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查 询形式进行优化。</p><pre><code> select * from tb_sku t , (select id from tb_sku order by idlimit 2000000,10) a where t.id = a.id;</code></pre><h2 id="3-6-count优化"><a href="#3-6-count优化" class="headerlink" title="3.6 count优化"></a>3.6 count优化</h2><h3 id="3-6-1-概述"><a href="#3-6-1-概述" class="headerlink" title="3.6.1 概述"></a>3.6.1 概述</h3><pre><code>select count(*) from tb_user ;</code></pre><ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(<em>) 的时候会直接返回这个 数，效率很高； 但是如果是带条件的count，MyISAM也慢。 I</em></li><li><em>nnoDB 引擎就麻烦了，它执行 count(</em>) 的时候，需要把数据一行一行地从引擎里面读出 来，然后累积计数。 </li></ul><p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数 据库进行,但是如果是带条件的count又比较麻烦了)。</p><h3 id="3-6-2-count用法"><a href="#3-6-2-count用法" class="headerlink" title="3.6.2 count用法"></a>3.6.2 count用法</h3><p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加，最后返回累计值。</p><p>用法：count（*）、count（主键）、count（字段）、count（数字）</p><table><thead><tr><th>count用 法</th><th>含义</th></tr></thead><tbody><tr><td>count(主 键)</td><td>InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。 服务层拿到主键后，直接按行进行累加(主键不可能为null)</td></tr><tr><td>count(字 段)</td><td>没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出 来，返回给服务层，服务层判断是否为null，不为null，计数累加。 有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返 回给服务层，直接按行进行累加。</td></tr><tr><td>count(数 字)</td><td>InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1” 进去，直接按行进行累加。</td></tr><tr><td>count(*)</td><td>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接 按行进行累加。</td></tr></tbody></table><p>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(<em>)，所以尽 量使用 count(</em>)。</p><h2 id="3-7-update优化"><a href="#3-7-update优化" class="headerlink" title="3.7 update优化"></a>3.7 update优化</h2><pre><code>update course set name = &#39;javaEE&#39; where id = 1 ;</code></pre><p>在执行删除的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放</p><p>但是当在执行如下SQL时:</p><pre><code>update course set name = &#39;SpringBoot&#39; where name = &#39;PHP&#39; </code></pre><p>开启多个事务，在执行上述的SQL时，行锁升级为了表锁。 导致该update语句的性能 大大降低。</p><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁 升级为表锁 。</p><h1 id="4-视图-存储过程-触发器"><a href="#4-视图-存储过程-触发器" class="headerlink" title="4.视图/存储过程/触发器"></a>4.视图/存储过程/触发器</h1><h2 id="4-1-视图"><a href="#4-1-视图" class="headerlink" title="4.1 视图"></a>4.1 视图</h2><h3 id="4-1-1-介绍"><a href="#4-1-1-介绍" class="headerlink" title="4.1.1 介绍"></a>4.1.1 介绍</h3><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视 图的查询中使用的表，并且是在使用视图时动态生成的。 通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><h3 id="4-1-2-语法"><a href="#4-1-2-语法" class="headerlink" title="4.1.2 语法"></a>4.1.2 语法</h3><p>1). 创建</p><pre><code>CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [CASCADED | LOCAL ] CHECK OPTION ]</code></pre><p>2). 查询</p><pre><code>查看创建视图语句：SHOW CREATE VIEW 视图名称;查看视图数据：SELECT * FROM 视图名称 ...... ;</code></pre><p>3). 修改</p><pre><code>方式一：CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH[ CASCADED | LOCAL ] CHECK OPTION ]方式二：ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED |LOCAL ] CHECK OPTION ]</code></pre><p>4). 删除</p><pre><code>DROP VIEW [IF EXISTS] 视图名称 [,视图名称] ..</code></pre><p>演示示例：</p><pre><code>-- 创建视图create or replace view stu_v_1 as select id,name from student where id &lt;= 10;-- 查询视图show create view stu_v_1;-- 修改视图create or replace view stu_v_1 as select id,name,no from student where id &lt;= 10;alter view stu_v_1 as select id,name from student where id &lt;= 10;-- 删除视图drop view if exists stu_v_1;</code></pre><p>通过视图来插入、更新数据</p><pre><code>create or replace view stu_v_1 as select id,name from student where id &lt;= 10 ;select * from stu_v_1;insert into stu_v_1 values(6,&#39;Tom&#39;);insert into stu_v_1 values(17,&#39;Tom22&#39;);</code></pre><p><img src="/mysql-02/image-20230319162630797.png" alt="image-20230319162630797"></p><p>因为在创建视图的时候，指定的条件为 id&lt;=10, id为17的数据，是不符合条件的，所以没有查 询出来，但是这条数据确实是已经成功的插入到了基表中。  </p><p>如果在定义视图时，如果指定了条件，然后在插入、修改、删除数据时，是否可以做到必须满足 条件才能操作，否则不能够操作呢？ 答案是可以的，这就需要借助于视图的检查选项了。</p><h3 id="4-1-3-检查选项"><a href="#4-1-3-检查选项" class="headerlink" title="4.1.3 检查选项"></a>4.1.3 检查选项</h3><p>当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插 入，更新，删除，以使其符合视图的定义。 MySQL允许基于另一个视图创建视图，它还会检查依赖视 图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项： CASCADED 和 LOCAL ，默认值为 CASCADED 。</p><p>1). CASCADED</p><p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 cascaded，但是v1视图 创建时未指定检查选项。 则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1。</p><p><img src="/mysql-02/image-20230319162933805.png" alt="image-20230319162933805"></p><p>2). LOCAL</p><p>本地。 </p><p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创 建时未指定检查选项。 则在执行检查时，只会检查v2，不会检查v2的关联视图v1。</p><p><img src="/mysql-02/image-20230319163019438.png" alt="image-20230319163019438"></p><h3 id="4-1-4-视图的更新"><a href="#4-1-4-视图的更新" class="headerlink" title="4.1.4 视图的更新"></a>4.1.4 视图的更新</h3><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一 项，则该视图不可更新：</p><p>A. 聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等） </p><p>B. DISTINCT</p><p> C. GROUP BY </p><p>D. HAVING </p><p>E. UNION 或者 UNION ALL</p><p>示例演示:</p><pre><code>create view stu_v_count as select count(*) from student;</code></pre><p>上述的视图中，就只有一个单行单列的数据，如果对这个视图进行更新或插入的，将会报错。</p><p><img src="/mysql-02/image-20230319163324871.png" alt="image-20230319163324871"></p><p><img src="/mysql-02/image-20230319163331287.png" alt="image-20230319163331287"></p><h3 id="4-1-5-视图作用"><a href="#4-1-5-视图作用" class="headerlink" title="4.1.5 视图作用"></a>4.1.5 视图作用</h3><p>1). 简单</p><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视 图，从而使得用户不必为以后的操作每次指定全部的条件。</p><h4 id="2-安全"><a href="#2-安全" class="headerlink" title="2). 安全"></a>2). 安全</h4><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见 到的数据</p><h4 id="3-数据独立"><a href="#3-数据独立" class="headerlink" title="3). 数据独立"></a>3). 数据独立</h4><p>视图可帮助用户屏蔽真实表结构变化带来的影响。</p><h3 id="4-1-6-案例"><a href="#4-1-6-案例" class="headerlink" title="4.1.6 案例"></a>4.1.6 案例</h3><p>1). 为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽 手机号和邮箱两个字段。</p><pre><code>create view tb_user_view as select id,name,profession,age,gender,status,createtimefrom tb_user;select * from tb_user_view;</code></pre><p>2). 查询每个学生所选修的课程（三张表联查），这个功能在很多的业务中都有使用到，为了简化操 作，定义一个视图。</p><pre><code>create view tb_stu_course_view as select s.name student_name , s.no student_no ,c.name course_name from student s, student_course sc , course c where s.id =sc.studentid and sc.courseid = c.id;select * from tb_stu_course_view;</code></pre><h2 id="4-2-存储过程"><a href="#4-2-存储过程" class="headerlink" title="4.2 存储过程"></a>4.2 存储过程</h2><h3 id="4-2-1-介绍"><a href="#4-2-1-介绍" class="headerlink" title="4.2.1 介绍"></a>4.2.1 介绍</h3><p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发 人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p><p><img src="/mysql-02/image-20230319164940096.png" alt="image-20230319164940096"></p><p>特点:</p><ul><li>封装，复用 ———————–&gt; 可以把某一业务SQL封装在存储过程中，需要用到 的时候直接调用即可。 </li><li>可以接收参数，也可以返回数据 ——–&gt; 再存储过程中，可以传递参数，也可以接收返回 值。 </li><li>减少网络交互，效率提升 ————-&gt; 如果涉及到多条SQL，每执行一次都是一次网络传 输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</li></ul><h3 id="4-2-2-基本语法"><a href="#4-2-2-基本语法" class="headerlink" title="4.2.2 基本语法"></a>4.2.2 基本语法</h3><p>1). 创建</p><pre><code>CREATE PROCEDURE 存储过程名称 ([ 参数列表 ])BEGIN-- SQL语句END ;</code></pre><p>2). 调用</p><pre><code>CALL 名称 ([ 参数 ]);</code></pre><p>3). 查看</p><pre><code>SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#39;xxx&#39;; -- 查询指定数据库的存储过程及状态信息SHOW CREATE PROCEDURE 存储过程名称 ; -- 查询某个存储过程的定义</code></pre><p>4). 删除</p><pre><code>DROP PROCEDURE [ IF EXISTS ] 存储过程名称 ；</code></pre><pre><code>在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的结束符。</code></pre><p>演示示例:</p><pre><code>-- 存储过程基本语法-- 创建create procedure p1()beginselect count(*) from student;end;-- 调用call p1();-- 查看select * from information_schema.ROUTINES where ROUTINE_SCHEMA = &#39;数据库名字&#39;;show create procedure p1;-- 删除drop procedure if exists p1;</code></pre><h3 id="4-2-3-变量"><a href="#4-2-3-变量" class="headerlink" title="4.2.3 变量"></a>4.2.3 变量</h3><p>在MySQL中变量分为三种类型: 系统变量、用户定义变量、局部变量。</p><h4 id="4-2-3-1-系统变量"><a href="#4-2-3-1-系统变量" class="headerlink" title="4.2.3.1 系统变量"></a>4.2.3.1 系统变量</h4><p>系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话 变量（SESSION）。</p><p>1). 查看系统变量</p><pre><code>SHOW [ SESSION | GLOBAL ] VARIABLES ; -- 查看所有系统变量SHOW [ SESSION | GLOBAL ] VARIABLES LIKE &#39;......&#39;; -- 可以通过LIKE模糊匹配方式查找变量SELECT @@[SESSION | GLOBAL] 系统变量名; -- 查看指定变量的值</code></pre><p>2). 设置系统变量</p><pre><code>SET [ SESSION | GLOBAL ] 系统变量名 = 值 ;SET @@[SESSION | GLOBAL]系统变量名 = 值 ;</code></pre><p>如果没有指定SESSION/GLOBAL，默认是SESSION，会话变量。</p><p>mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 /etc/my.cnf 中配置。</p><p>A. 全局变量(GLOBAL): 全局变量针对于所有的会话。 B. 会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。</p><p>演示示例:</p><pre><code>-- 查看系统变量show session variables ;show session variables like &#39;auto%&#39;;show global variables like &#39;auto%&#39;;select @@global.autocommit;select @@session.autocommit;-- 设置系统变量set session autocommit = 1;insert into course(id, name) VALUES (6, &#39;ES&#39;);set global autocommit = 0;select @@global.autocommit;</code></pre><h4 id="4-2-3-2-用户定义变量"><a href="#4-2-3-2-用户定义变量" class="headerlink" title="4.2.3.2 用户定义变量"></a>4.2.3.2 用户定义变量</h4><p>用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 “@变量 名” 使用就可以。其作用域为当前连接。 </p><p>1). 赋值 </p><p>方式一:</p><pre><code>SET @var_name = expr [, @var_name = expr] ... ;SET @var_name := expr [, @var_name := expr] ... ;</code></pre><p>赋值时，可以使用 = ，也可以使用 := 。</p><p>方式二:</p><pre><code>SELECT @var_name := expr [, @var_name := expr] ... ;SELECT 字段名 INTO @var_name FROM 表名;</code></pre><p>2). 使用</p><pre><code>SELECT @var_name ;</code></pre><p>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</p><p>演示示例:</p><pre><code>-- 赋值set @myname = &#39;ccc&#39;;set @myage := 10;set @mygender := &#39;男&#39;,@myhobby := &#39;java&#39;;select @mycolor := &#39;red&#39;;select count(*) into @mycount from tb_user;-- 使用select @myname,@myage,@mygender,@myhobby;select @mycolor , @mycount;</code></pre><h4 id="4-2-3-3-局部变量"><a href="#4-2-3-3-局部变量" class="headerlink" title="4.2.3.3 局部变量"></a>4.2.3.3 局部变量</h4><p>局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的 局部变量和输入参数，局部变量的范围是在其内声明的BEGIN … END块。</p><p>1). 声明</p><pre><code>DECLARE 变量名 变量类型 [DEFAULT ... ] ;</code></pre><p>变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。</p><p>2). 赋值</p><pre><code>SET 变量名 = 值 ;SET 变量名 := 值 ;SELECT 字段名 INTO 变量名 FROM 表名 ... ;</code></pre><p>演示示例:</p><pre><code>-- 声明局部变量 - declare-- 赋值create procedure p2()begindeclare stu_count int default 0;select count(*) into stu_count from student;select stu_count;end;call p2();</code></pre><h4 id="4-2-4-if"><a href="#4-2-4-if" class="headerlink" title="4.2.4 if"></a>4.2.4 if</h4><p>1). 介绍</p><p>if 用于做条件判断，具体的语法结构为：</p><pre><code>IF 条件1 THEN.....ELSEIF 条件2 THEN -- 可选.....ELSE -- 可选.....END IF;</code></pre><p>在if条件判断的结构中，ELSE IF 结构可以有多个，也可以没有。 ELSE结构可以有，也可以没有。</p><p>2). 案例</p><p> 根据定义的分数score变量，判定当前分数对应的分数等级。</p><p> score &gt;= 85分，等级为优秀。 </p><p>score &gt;= 60分 且 score &lt; 85分，等级为及格。</p><p> score &lt; 60分，等级为不及格。</p><pre><code>create procedure p3()begindeclare score int default 58;declare result varchar(10);if score &gt;= 85 thenset result := &#39;优秀&#39;;elseif score &gt;= 60 thenset result := &#39;及格&#39;;elseset result := &#39;不及格&#39;;end if;select result;end;call p3();</code></pre><h4 id="4-2-5-参数"><a href="#4-2-5-参数" class="headerlink" title="4.2.5 参数"></a>4.2.5 参数</h4><p>1). 介绍</p><p>参数的类型，主要分为以下三种：IN、OUT、INOUT。 具体的含义如下：</p><table><thead><tr><th>类型</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>IN</td><td>该类参数作为输入，也就是需要调用时传入值</td><td>默认</td></tr><tr><td>OUT</td><td>该类参数作为输出，也就是该参数可以作为返回值</td><td></td></tr><tr><td>INOUT</td><td>既可以作为输入参数，也可以作为输出参数</td><td></td></tr></tbody></table><p>用法：</p><pre><code>CREATE PROCEDURE 存储过程名称 ([ IN/OUT/INOUT 参数名 参数类型 ])BEGIN-- SQL语句END ;</code></pre><p>2). 案例</p><p>将传入的200分制的分数，进行换算，换算成百分制，然后返回。</p><pre><code>create procedure p5(inout score double)beginset score := score * 0.5;end;set @score = 198;call p5(@score);select @score;</code></pre><p>根据传入参数score，判定当前分数对应的分数等级，并返回。 </p><p>score &gt;= 85分，等级为优秀。 </p><p>score &gt;= 60分 且 score &lt; 85分，等级为及格。 </p><p>score &lt; 60分，等级为不及格。</p><pre><code>create procedure p4(in score int, out result varchar(10))beginif score &gt;= 85 thenset result := &#39;优秀&#39;;elseif score &gt;= 60 thenset result := &#39;及格&#39;;elseset result := &#39;不及格&#39;;end if;end;-- 定义用户变量 @result来接收返回的数据, 用户变量可以不用声明call p4(18, @result);select @result;</code></pre><h4 id="4-2-6-case"><a href="#4-2-6-case" class="headerlink" title="4.2.6 case"></a>4.2.6 case</h4><p>1). 介绍 case结构及作用。有两种语法格式： 语法1：</p><pre><code>-- 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，执行statement_list2， 否则就执行 statement_listCASE case_valueWHEN when_value1 THEN statement_list1[ WHEN when_value2 THEN statement_list2] ...[ ELSE statement_list ]END CASE;</code></pre><p>语法2：</p><pre><code>-- 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成立时，执行statement_list2， 否则就执行 statement_listCASEWHEN search_condition1 THEN statement_list1[WHEN search_condition2 THEN statement_list2] ...[ELSE statement_list]END CASE;</code></pre><p>如果判定条件有多个，多个条件之间，可以使用 and 或 or 进行连接。</p><h4 id="4-2-7-while"><a href="#4-2-7-while" class="headerlink" title="4.2.7 while"></a>4.2.7 while</h4><p>1). 介绍</p><p>while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</p><pre><code>-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑WHILE 条件 DOSQL逻辑...END WHILE;</code></pre><h4 id="4-2-8-repeat"><a href="#4-2-8-repeat" class="headerlink" title="4.2.8 repeat"></a>4.2.8 repeat</h4><p>1). 介绍</p><p>repeat是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环 。具体语法为：</p><pre><code>-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环REPEATSQL逻辑...UNTIL 条件END REPEAT;</code></pre><h4 id="4-2-9-loop"><a href="#4-2-9-loop" class="headerlink" title="4.2.9 loop"></a>4.2.9 loop</h4><p>1). 介绍</p><p>LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。 LOOP可以配合一下两个语句使用： </p><p>LEAVE ：配合循环使用，退出循环。 </p><p>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</p><pre><code>[begin_label:] LOOPSQL逻辑...END LOOP [end_label];</code></pre><pre><code>LEAVE label; -- 退出指定标记的循环体ITERATE label; -- 直接进入下一次循环</code></pre><p>上述语法中出现的 begin_label，end_label，label 指的都是自定义的标记。</p><p>2). 案例一</p><p>计算从1累加到n的值，n为传入的参数值。</p><pre><code>-- A. 定义局部变量, 记录累加之后的值;-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xxcreate procedure p9(in n int)begindeclare total int default 0;sum:loopif n&lt;=0 thenleave sum;end if;set total := total + n;set n := n - 1;end loop sum;select total;end;call p9(100);</code></pre><p>3). 案例二</p><p>计算从1到n之间的偶数累加的值，n为传入的参数值。</p><pre><code>-- A. 定义局部变量, 记录累加之后的值;-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xx-- C. 如果当次累加的数据是奇数, 则直接进入下一次循环. --------&gt; iterate xxcreate procedure p10(in n int)begindeclare total int default 0;sum:loopif n&lt;=0 thenleave sum;end if;if n%2 = 1 thenset n := n - 1;iterate sum;end if;set total := total + n;set n := n - 1;end loop sum;select total;end;call p10(100);</code></pre><h4 id="4-2-10-游标"><a href="#4-2-10-游标" class="headerlink" title="4.2.10 游标"></a>4.2.10 游标</h4><p>1). 介绍 游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进 行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p><p>A. 声明游标</p><pre><code>DECLARE 游标名称 CURSOR FOR 查询语句 ;</code></pre><p>B. 打开游标</p><pre><code> OPEN 游标名称 ;</code></pre><p>C. 获取游标记录</p><pre><code>FETCH 游标名称 INTO 变量 [, 变量 ] ;</code></pre><p>D. 关闭游标</p><pre><code>CLOSE 游标名称 ;</code></pre><p>2). 案例</p><p>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名 （name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表 (id,name,profession)中。</p><pre><code>-- 逻辑:-- A. 声明游标, 存储查询结果集-- B. 准备: 创建表结构-- C. 开启游标-- D. 获取游标中的记录-- E. 插入数据到新表中-- F. 关闭游标create procedure p11(in uage int)begindeclare uname varchar(100);declare upro varchar(100);declare u_cursor cursor for select name,profession from tb_user where age &lt;=uage;drop table if exists tb_user_pro;create table if not exists tb_user_pro(id int primary key auto_increment,name varchar(100),profession varchar(100));open u_cursor;while true dofetch u_cursor into uname,upro;insert into tb_user_pro values (null, uname, upro);end while;close u_cursor;end;call p11(30)；</code></pre><p>上述的存储过程，最终我们在调用的过程中，会报错，之所以报错是因为上面的while循环中，并没有 退出条件。当游标的数据集获取完毕之后，再次获取数据，就会报错，从而终止了程序的执行。</p><p><img src="/mysql-02/image-20230319172816754.png" alt="image-20230319172816754"></p><p>但是此时，tb_user_pro表结构及其数据都已经插入成功了，可以直接刷新表结构，检查表结构 中的数据。</p><p><img src="/mysql-02/image-20230319172837052.png" alt="image-20230319172837052"></p><p>要想解决这个问题，就需要通过MySQL中提供的 条件处理程序 Handle（条件处理程序）来解决。</p><h4 id="4-2-11-条件处理程序"><a href="#4-2-11-条件处理程序" class="headerlink" title="4.2.11 条件处理程序"></a>4.2.11 条件处理程序</h4><p>1). 介绍</p><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体 语法为</p><pre><code>DECLARE handler_action HANDLER FOR condition_value [, condition_value]... statement ;handler_action 的取值：CONTINUE: 继续执行当前程序EXIT: 终止执行当前程序condition_value 的取值：SQLSTATE sqlstate_value: 状态码，如 02000SQLWARNING: 所有以01开头的SQLSTATE代码的简写NOT FOUND: 所有以02开头的SQLSTATE代码的简写SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写</code></pre><p>2). 案例</p><p>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名 （name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表 (id,name,profession)中。</p><p>A. 通过SQLSTATE指定具体的状态码</p><pre><code>-- 逻辑:-- A. 声明游标, 存储查询结果集-- B. 准备: 创建表结构-- C. 开启游标-- D. 获取游标中的记录-- E. 插入数据到新表中-- F. 关闭游标create procedure p11(in uage int)begindeclare uname varchar(100);declare upro varchar(100);declare u_cursor cursor for select name,profession from tb_user where age &lt;=uage;-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02000时，将关闭游标u_cursor，并退出declare exit handler for SQLSTATE &#39;02000&#39; close u_cursor;drop table if exists tb_user_pro;create table if not exists tb_user_pro(id int primary key auto_increment,name varchar(100),profession varchar(100));open u_cursor;while true dofetch u_cursor into uname,upro;insert into tb_user_pro values (null, uname, upro);end while;close u_cursor;end;call p11(30);</code></pre><p>B. 通过SQLSTATE的代码简写方式 NOT FOUND</p><p>02 开头的状态码，代码简写为 NOT FOUND</p><pre><code>create procedure p12(in uage int)begindeclare uname varchar(100);declare upro varchar(100);declare u_cursor cursor for select name,profession from tb_user where age &lt;=uage;-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02开头时，将关闭游标u_cursor，并退出declare exit handler for not found close u_cursor;drop table if exists tb_user_pro;create table if not exists tb_user_pro(id int primary key auto_increment,name varchar(100),profession varchar(100));open u_cursor;while true dofetch u_cursor into uname,upro;insert into tb_user_pro values (null, uname, upro);end while;close u_cursor;end;call p12(30);</code></pre><p>具体的错误状态码，可以参考官方文档：</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html" target="_blank" rel="noopener">MySQL :: MySQL 8.0 Reference Manual :: 13.6.7.2 DECLARE … HANDLER Statement</a></p><p><a href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html" target="_blank" rel="noopener">MySQL :: MySQL 8.0 Error Reference :: 2 Server Error Message Reference</a></p><h2 id="4-3-存储函数"><a href="#4-3-存储函数" class="headerlink" title="4.3 存储函数"></a>4.3 存储函数</h2><p>1). 介绍 存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：</p><pre><code>CREATE FUNCTION 存储函数名称 ([ 参数列表 ])RETURNS type [characteristic ...]BEGIN-- SQL语句RETURN ...;END ;</code></pre><p>characteristic说明： </p><ul><li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li><li>NO SQL ：不包含 SQL 语句。 </li><li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。</li></ul><p>2). 案例</p><p>计算从1累加到n的值，n为传入的参数值。</p><pre><code>create function fun1(n int)returns int deterministicbegindeclare total int default 0;while n&gt;0 doset total := total + n;set n := n - 1;end while;return total;end;select fun1(50)</code></pre><p>在mysql8.0版本中binlog默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定 characteristic特性，否则就会报如下错误：</p><p><img src="/mysql-02/image-20230319174608555.png" alt="image-20230319174608555"></p><h2 id="4-4-触发器"><a href="#4-4-触发器" class="headerlink" title="4.4 触发器"></a>4.4 触发器</h2><h3 id="4-4-1-介绍"><a href="#4-4-1-介绍" class="headerlink" title="4.4.1 介绍"></a>4.4.1 介绍</h3><p>触发器是与表有关的数据库对象，指在insert/update/delete之前(BEFORE)或之后(AFTER)，触 发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。 使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还 只支持行级触发，不支持语句级触发。</p><table><thead><tr><th>触发器类型</th><th>NEW 和 OLD</th></tr></thead><tbody><tr><td>INSERT 型触发器</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE 型触发器</td><td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td></tr><tr><td>DELETE 型触发器</td><td>OLD 表示将要或者已经删除的数据</td></tr></tbody></table><h3 id="4-4-2-语法"><a href="#4-4-2-语法" class="headerlink" title="4.4.2 语法"></a>4.4.2 语法</h3><p>1). 创建</p><pre><code>CREATE TRIGGER trigger_nameBEFORE/AFTER INSERT/UPDATE/DELETEON tbl_name FOR EACH ROW -- 行级触发器BEGINtrigger_stmt ;END;</code></pre><p>2). 查看</p><pre><code>SHOW TRIGGERS ;</code></pre><p>3). 删除</p><pre><code>DROP TRIGGER [schema_name.]trigger_name ; -- 如果没有指定 schema_name，默认为当前数据库 。</code></pre><h3 id="4-4-3-案例"><a href="#4-4-3-案例" class="headerlink" title="4.4.3 案例"></a>4.4.3 案例</h3><p>通过触发器记录 tb_user 表的数据变更日志，将变更日志插入到日志表user_logs中, 包含增加, 修改 , 删除 ; 表结构准备:</p><pre><code>-- 准备工作 : 日志表 user_logscreate table user_logs(id int(11) not null auto_increment,operation varchar(20) not null comment &#39;操作类型, insert/update/delete&#39;,operate_time datetime not null comment &#39;操作时间&#39;,operate_id int(11) not null comment &#39;操作的ID&#39;,operate_params varchar(500) comment &#39;操作参数&#39;,primary key(`id`))engine=innodb default charset=utf8;</code></pre><p>A. 插入数据触发器</p><pre><code>create trigger tb_user_insert_triggerafter insert on tb_user for each rowbegininsert into user_logs(id, operation, operate_time, operate_id, operate_params)VALUES(null, &#39;insert&#39;, now(), new.id, concat(&#39;插入的数据内容为:id=&#39;,new.id,&#39;,name=&#39;,new.name, &#39;, phone=&#39;, NEW.phone, &#39;, email=&#39;, NEW.email, &#39;,profession=&#39;, NEW.profession));end;</code></pre><p>测试:</p><pre><code>-- 查看show triggers ;-- 插入数据到tb_userinsert into tb_user(id, name, phone, email, profession, age, gender, status,createtime) VALUES (26,&#39;三皇子&#39;,&#39;18809091212&#39;,&#39;erhuangzi@163.com&#39;,&#39;软件工程&#39;,23,&#39;1&#39;,&#39;1&#39;,now());</code></pre><p>测试完毕之后，检查日志表中的数据是否可以正常插入，以及插入数据的正确性。</p><p>B. 修改数据触发器</p><pre><code>create trigger tb_user_update_triggerafter update on tb_user for each rowbegininsert into user_logs(id, operation, operate_time, operate_id, operate_params)VALUES(null, &#39;update&#39;, now(), new.id,concat(&#39;更新之前的数据: id=&#39;,old.id,&#39;,name=&#39;,old.name, &#39;, phone=&#39;,old.phone, &#39;, email=&#39;, old.email, &#39;, profession=&#39;, old.profession,&#39; | 更新之后的数据: id=&#39;,new.id,&#39;,name=&#39;,new.name, &#39;, phone=&#39;,NEW.phone, &#39;, email=&#39;, NEW.email, &#39;, profession=&#39;, NEW.profession));end;</code></pre><p>测试:</p><pre><code>-- 查看show triggers ;-- 更新update tb_user set profession = &#39;会计&#39; where id = 23;update tb_user set profession = &#39;会计&#39; where id &lt;= 5;</code></pre><p>测试完毕之后，检查日志表中的数据是否可以正常插入，以及插入数据的正确性。</p><p>C. 删除数据触发器</p><pre><code>create trigger tb_user_delete_triggerafter delete on tb_user for each rowbegininsert into user_logs(id, operation, operate_time, operate_id, operate_params)VALUES(null, &#39;delete&#39;, now(), old.id,concat(&#39;删除之前的数据: id=&#39;,old.id,&#39;,name=&#39;,old.name, &#39;, phone=&#39;,old.phone, &#39;, email=&#39;, old.email, &#39;, profession=&#39;, old.profession));end;</code></pre><p>测试:</p><pre><code>-- 查看show triggers ;-- 删除数据delete from tb_user where id = 26;</code></pre><h1 id="5-锁"><a href="#5-锁" class="headerlink" title="5.锁"></a>5.锁</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、 RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有 效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个 角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><pre><code>全局锁：锁定数据库中的所有表。表级锁：每次操作锁住整张表。行级锁：每次操作锁住对应的行数据。</code></pre><h2 id="5-2-全局锁"><a href="#5-2-全局锁" class="headerlink" title="5.2 全局锁"></a>5.2 全局锁</h2><h3 id="5-2-1-介绍"><a href="#5-2-1-介绍" class="headerlink" title="5.2.1 介绍"></a>5.2.1 介绍</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语 句，已经更新操作的事务提交语句都将被阻塞。 其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整 性。</p><p>不加全局锁，可能存在的问题。</p><p><img src="/mysql-02/image-20230319183403451.png" alt="image-20230319183403451"></p><ul><li>在进行数据备份时，先备份了tb_stock库存表。</li><li>然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入 tb_order表）。</li><li>然后再执行备份 tb_order表的逻辑。 </li><li>业务中执行插入订单日志操作。 </li><li>最后，又备份了tb_orderlog表。</li></ul><p>此时备份出来的数据，是存在问题的。因为备份出来的数据，tb_stock表与tb_order表的数据不一 致(有最新操作的订单信息,但是库存数没减)。</p><p>那如何来规避这种问题呢? 此时就可以借助于MySQL的全局锁来解决。</p><p>B. 再来分析一下加了全局锁后的情况</p><p><img src="/mysql-02/image-20230319184239125.png" alt="image-20230319184239125"></p><p>对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、 DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。 那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性 和完整性</p><h3 id="5-2-2-语法"><a href="#5-2-2-语法" class="headerlink" title="5.2.2 语法"></a>5.2.2 语法</h3><p>1). 加全局锁</p><pre><code>flush tables with read lock ;</code></pre><p>2). 数据备份</p><pre><code>mysqldump -uroot –p1234 备份的数据库名 &gt; 备份到的名称.sql</code></pre><p>3). 释放锁</p><pre><code>unlock tables ;</code></pre><h3 id="5-2-3-特点"><a href="#5-2-3-特点" class="headerlink" title="5.2.3 特点"></a>5.2.3 特点</h3><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导 致主从延迟。 </li></ul><p>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致 性数据备份。</p><pre><code>mysqldump --single-transaction -uroot –p123456 备份的数据库名 &gt; 备份到的名称.sql</code></pre><h2 id="5-3-表级锁"><a href="#5-3-表级锁" class="headerlink" title="5.3 表级锁"></a>5.3 表级锁</h2><h3 id="5-3-1-介绍"><a href="#5-3-1-介绍" class="headerlink" title="5.3.1 介绍"></a>5.3.1 介绍</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、 InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ul><li>表锁 </li><li>元数据锁（meta data lock，MDL） </li><li>意向锁</li></ul><h3 id="5-3-2-表锁"><a href="#5-3-2-表锁" class="headerlink" title="5.3.2 表锁"></a>5.3.2 表锁</h3><p>对于表锁，分为两类：</p><ul><li>表共享读锁（read lock） </li><li>表独占写锁（write lock）</li></ul><p>语法： </p><p>加锁：lock tables 表名… read/write。 </p><p>释放锁：unlock tables / 客户端断开连接 。</p><p>特点:</p><p>A. 读锁</p><p><img src="/mysql-02/image-20230319185630541.png" alt="image-20230319185630541"></p><p><img src="/mysql-02/image-20230319185720262.png" alt="image-20230319185720262"></p><p>B. 写锁</p><p><img src="/mysql-02/image-20230319185826564.png" alt="image-20230319185826564"></p><p>左侧为客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写。</p><p><img src="/mysql-02/image-20230319185842742.png" alt="image-20230319185842742"></p><p>读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞 其他客户端的写。</p><h3 id="5-3-3-元数据锁"><a href="#5-3-3-元数据锁" class="headerlink" title="5.3.3 元数据锁"></a>5.3.3 元数据锁</h3><p>meta data lock , 元数据锁，简写MDL。</p><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维 护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与 DDL冲突，保证读写的正确性。 </p><p>这里的元数据，可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务 时，是不能够修改这张表的表结构的。</p><p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变 更操作的时候，加MDL写锁(排他)</p><p>常见的SQL操作时，所添加的元数据锁</p><table><thead><tr><th>对应SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td>lock tables xxx read / write</td><td>SHARED_READ_ONLY / SHARED_NO_READ_WRITE</td><td></td></tr><tr><td>select 、select … lock in share mode</td><td>SHARED_READ</td><td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td></tr><tr><td>insert 、update、 delete、select … for update</td><td>SHARED_WRITE</td><td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td></tr><tr><td>alter table …</td><td>EXCLUSIVE</td><td>与其他的MDL都互斥</td></tr></tbody></table><p>演示：</p><p> 当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ / SHARED_WRITE），之间是兼容的。</p><p><img src="/mysql-02/image-20230319192508226.png" alt="image-20230319192508226"></p><p>当执行SELECT语句时，添加的是元数据共享锁（SHARED_READ），会阻塞元数据排他锁 （EXCLUSIVE），之间是互斥的。</p><p><strong><img src="/mysql-02/image-20230319210202353.png" alt="image-20230319210202353"></strong></p><h3 id="5-3-4-意向锁"><a href="#5-3-4-意向锁" class="headerlink" title="5.3.4 意向锁"></a>5.3.4 意向锁</h3><p>1). 介绍</p><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行 数据是否加锁，使用意向锁来减少表锁的检查。</p><p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一 下：</p><p>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。</p><p><img src="/mysql-02/image-20230319210333562.png" alt="image-20230319210333562"></p><p>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就 会从第一行数据，检查到最后一行数据，效率较低。</p><p><img src="/mysql-02/image-20230319210346840.png" alt="image-20230319210346840"></p><p>有了意向锁之后 :</p><p>客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。</p><p><img src="/mysql-02/image-20230319210406968.png" alt="image-20230319210406968"></p><p>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而 不用逐行判断行锁情况了。</p><p><img src="/mysql-02/image-20230319210613130.png" alt="image-20230319210613130"></p><p>2). 分类</p><ul><li>意向共享锁(IS): 由语句select … lock in share mode添加 。 与 表锁共享锁 (read)兼容，与表锁排他锁(write)互斥。</li><li>意向排他锁(IX): 由insert、update、delete、select…for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</li></ul><p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><pre><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data fromperformance_schema.data_locks;</code></pre><p>A. 意向共享锁与表读锁是兼容的</p><p><img src="/mysql-02/image-20230319210911250.png" alt="image-20230319210911250"></p><p>B. 意向排他锁与表读锁、写锁都是互斥的</p><p><img src="/mysql-02/image-20230319210922329.png" alt="image-20230319210922329"></p><h2 id="5-4-行级锁"><a href="#5-4-行级锁" class="headerlink" title="5.4 行级锁"></a>5.4 行级锁</h2><h3 id="5-4-1-介绍"><a href="#5-4-1-介绍" class="headerlink" title="5.4.1 介绍"></a>5.4.1 介绍</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的 锁。对于行级锁，主要分为以下三类</p><p>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在 RC、RR隔离级别下都支持。</p><p><img src="/mysql-02/image-20230319211512113.png" alt="image-20230319211512113"></p><p>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事 务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</p><p><img src="/mysql-02/image-20230319211522999.png" alt="image-20230319211522999"></p><p>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。 在RR隔离级别下支持。</p><p><img src="/mysql-02/image-20230319211611369.png" alt="image-20230319211611369"></p><h3 id="5-4-2-行锁"><a href="#5-4-2-行锁" class="headerlink" title="5.4.2 行锁"></a>5.4.2 行锁</h3><p>1). 介绍</p><p>InnoDB实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。 </li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他 锁。</li></ul><p>两种行锁的兼容情况如下:</p><p><img src="/mysql-02/image-20230319212308484.png" alt="image-20230319212308484"></p><p>常见的SQL语句，在执行时，所加的行锁如下：</p><table><thead><tr><th>SQL</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td>INSERT …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>UPDATE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>DELETE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>SELECT（正常）</td><td>不加任何 锁</td><td></td></tr><tr><td>SELECT … LOCK IN SHARE MODE</td><td>共享锁</td><td>需要手动在SELECT之后加LOCK IN SHARE MODE</td></tr><tr><td>SELECT … FOR UPDATE</td><td>排他锁</td><td>需要手动在SELECT之后加FOR UPDATE</td></tr></tbody></table><p>2). 演示</p><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜 索和索引扫描，以防止幻读。</p><ul><li><p>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p></li><li><p>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记 录加锁，此时 就会升级为表锁。</p></li></ul><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><pre><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data fromperformance_schema.data_locks;</code></pre><p>示例演示 数据准备:</p><pre><code>CREATE TABLE `stu` (`id` int NOT NULL PRIMARY KEY AUTO_INCREMENT,`name` varchar(255) DEFAULT NULL,`age` int NOT NULL) ENGINE = InnoDB CHARACTER SET = utf8mb4;INSERT INTO `stu` VALUES (1, &#39;tom&#39;, 1);INSERT INTO `stu` VALUES (3, &#39;cat&#39;, 3);INSERT INTO `stu` VALUES (8, &#39;rose&#39;, 8);INSERT INTO `stu` VALUES (11, &#39;jetty&#39;, 11);INSERT INTO `stu` VALUES (19, &#39;lily&#39;, 19);INSERT INTO `stu` VALUES (25, &#39;luci&#39;, 25);</code></pre><p>A. 普通的select语句，执行时，不会加锁。</p><p><img src="/mysql-02/image-20230319213654433.png" alt="image-20230319213654433"></p><p>B. select…lock in share mode，加共享锁，共享锁与共享锁之间兼容。</p><p><img src="/mysql-02/image-20230319213856151.png" alt="image-20230319213856151"></p><p>共享锁与排他锁之间互斥。</p><p><img src="/mysql-02/image-20230319213929646.png" alt="image-20230319213929646"></p><p>客户端一获取的是id为1这行的共享锁，客户端二是可以获取id为3这行的排它锁的，因为不是同一行 数据。 而如果客户端二想获取id为1这行的排他锁，会处于阻塞状态，以为共享锁与排他锁之间互 斥。</p><p>C. 排它锁与排他锁之间互斥</p><p><img src="/mysql-02/image-20230319213947892.png" alt="image-20230319213947892"></p><p>当客户端一，执行update语句，会为id为1的记录加排他锁； 客户端二，如果也执行update语句更 新id为1的数据，也要为id为1的数据加排他锁，但是客户端二会处于阻塞状态，因为排他锁之间是互 斥的。 直到客户端一，把事务提交了，才会把这一行的行锁释放，此时客户端二，解除阻塞。</p><p>D. 无索引行锁升级为表锁</p><p>stu表中数据如下:</p><p><img src="/mysql-02/image-20230319214028644.png" alt="image-20230319214028644"></p><p><img src="/mysql-02/image-20230319214319115.png" alt="image-20230319214319115"></p><p>在客户端一中，开启事务，并执行update语句，更新name为Lily的数据，也就是id为19的记录 。 然后在客户端二中更新id为3的记录，却不能直接执行，会处于阻塞状态，为什么呢？ 原因就是因为此时，客户端一，根据name字段进行更新时，name字段是没有索引的，如果没有索引， 此时行锁会升级为表锁(因为行锁是对索引项加的锁，而name没有索引)。</p><p>针对name字段建立索引，索引建立之后，再次做一个测试：</p><p><img src="/mysql-02/image-20230319214352192.png" alt="image-20230319214352192"></p><p>客户端一，开启事务，然后依然是根据name进行更新。而客户端二，在更新id为3 的数据时，更新成功，并未进入阻塞状态。 这样就说明，根据索引字段进行更新操作，就可以避 免行锁升级为表锁的情况。</p><h3 id="5-4-3-间隙锁-amp-临键锁"><a href="#5-4-3-间隙锁-amp-临键锁" class="headerlink" title="5.4.3 间隙锁&amp;临键锁"></a>5.4.3 间隙锁&amp;临键锁</h3><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key（临键锁） 锁进行搜 索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。 </li><li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。 </li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li></ul><p>间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会 阻止另一个事务在同一间隙上采用间隙锁。</p><p><img src="/mysql-02/image-20230319215902885.png" alt="image-20230319215902885"></p><p>B. 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。 </p><p>InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，要根据这个二级索引查询值 为18的数据，并加上共享锁，只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个 结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也 就是29）。此时会对18加临键锁，并对29之前的间隙加锁。</p><p><img src="/mysql-02/image-20230319220818787.png" alt="image-20230319220818787"></p><p><img src="/mysql-02/image-20230319220847147.png" alt="image-20230319220847147"></p><p>C. 索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</p><p><img src="/mysql-02/image-20230319221216040.png" alt="image-20230319221216040"></p><p>查询的条件为id&gt;=19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部 分：[19] (19,25] (25,+∞]</p><p>所以数据库数据在加锁是，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临 键锁(正无穷及之前的间隙)。</p><h1 id="6-InnoDB引擎"><a href="#6-InnoDB引擎" class="headerlink" title="6.InnoDB引擎"></a>6.InnoDB引擎</h1><h2 id="6-1-逻辑存储结构"><a href="#6-1-逻辑存储结构" class="headerlink" title="6.1 逻辑存储结构"></a>6.1 逻辑存储结构</h2><p>InnoDB的逻辑存储结构如下图所示:</p><p><img src="/mysql-02/image-20230319221704166.png" alt="image-20230319221704166"></p><p>1). 表空间</p><p>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在 8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空 间，用于存储记录、索引等数据。</p><p>2). 段</p><p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段 （Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的 非叶子节点。段用来管理多个Extent（区）。</p><p>3). 区</p><p>区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一 个区中一共有64个连续的页。</p><p>4). 页</p><p>页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性， InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p><p>5). 行</p><p>行，InnoDB 存储引擎数据是按行进行存放的。 在行中，默认有两个隐藏字段： Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。 Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个 隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p><h2 id="6-2-架构"><a href="#6-2-架构" class="headerlink" title="6.2 架构"></a>6.2 架构</h2><h3 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1 概述"></a>6.2.1 概述</h3><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发 中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p><p><img src="/mysql-02/image-20230319223436173.png" alt="image-20230319223436173"></p><h3 id="6-2-2-内存结构"><a href="#6-2-2-内存结构" class="headerlink" title="6.2.2 内存结构"></a>6.2.2 内存结构</h3><p><img src="/mysql-02/image-20230319223451003.png" alt="image-20230319223451003"></p><p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。</p><p>1). Buffer Pool</p><p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能 弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁 盘I/O。</p><p>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及 InnoDB的锁信息等等。</p><p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增 删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频 率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型： </p><p>• free page：空闲page，未被使用。</p><p> • clean page：被使用page，数据没有被修改过。</p><p> • dirty page：脏页，被使用page，数据被修改过，其中数据与磁盘的数据产生了不一致。</p><p>在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。参数设置： show variables like ‘innodb_buffer_pool_size’;</p><p><img src="/mysql-02/image-20230319225434479.png" alt="image-20230319225434479"></p><p>2). Change Buffer</p><p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page 没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer 中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p>Change Buffer的意义</p><p><img src="/mysql-02/image-20230319225518087.png" alt="image-20230319225518087"></p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新 可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了 ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p><p>3). Adaptive Hash Index</p><p>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持 hash索引，但是给我们提供了一个功能就是这个自适应hash索引。hash索引在 进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需 要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。 InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度， 则建立hash索引，称之为自适应hash索引</p><p>适应哈希索引，无需人工干预，是系统根据情况自动完成。</p><p>参数： adaptive_hash_index</p><p>4). Log Buffer</p><p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log）， 默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事 务，增加日志缓冲区的大小可以节省磁盘 I/O。 </p><p>参数: </p><p>innodb_log_buffer_size：缓冲区大小 </p><p>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：</p><p> 1: 日志在每次事务提交时写入并刷新到磁盘，默认值。</p><p> 0: 每秒将日志写入并刷新到磁盘一次</p><p>2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</p><h3 id="6-2-3-磁盘结构"><a href="#6-2-3-磁盘结构" class="headerlink" title="6.2.3 磁盘结构"></a>6.2.3 磁盘结构</h3><p><img src="/mysql-02/image-20230319225851507.png" alt="image-20230319225851507"></p><p>1). System Tablespace</p><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建 的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等) </p><p>参数：innodb_data_file_path</p><p><img src="/mysql-02/image-20230319225941139.png" alt="image-20230319225941139"></p><p>系统表空间，默认的文件名叫 ibdata1。</p><p>2). File-Per-Table Tablespaces</p><p>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索 引 ，并存储在文件系统上的单个数据文件中。 开关参数：innodb_file_per_table ，该参数默认开启。</p><p><img src="/mysql-02/image-20230319230007205.png" alt="image-20230319230007205"></p><p>那也就是说，每创建一个表，都会产生一个表空间文件，如图：</p><p><img src="/mysql-02/image-20230319230041529.png" alt="image-20230319230041529"></p><p>3). General Tablespaces</p><p>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空 间。</p><p>A. 创建表空间、</p><pre><code>CREATE TABLESPACE ts_name ADD DATAFILE &#39;file_name&#39; ENGINE = engine_name;</code></pre><p><img src="/mysql-02/image-20230319230149322.png" alt="image-20230319230149322"></p><p>B. 创建表时指定表空间</p><pre><code>CREATE TABLE xxx ... TABLESPACE ts_name；</code></pre><p><img src="/mysql-02/image-20230319230236014.png" alt="image-20230319230236014"></p><p>4). Undo Tablespaces</p><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储 undo log日志。</p><p>5). Temporary Tablespaces</p><p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><p>6). Doublewrite Buffer Files</p><p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件 中，便于系统异常时恢复数据。</p><p><img src="/mysql-02/image-20230319230341360.png" alt="image-20230319230341360"></p><p>7). Redo Log</p><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所 有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。 以循环方式写入重做日志文件，涉及两个文件：</p><p><img src="/mysql-02/image-20230319232634292.png" alt></p><p><img src="/mysql-02/image-20230319232657863.png" alt="image-20230319232657863"></p><h3 id="6-2-4-后台线程"><a href="#6-2-4-后台线程" class="headerlink" title="6.2.4 后台线程"></a>6.2.4 后台线程</h3><p><img src="/mysql-02/image-20230319232718514.png" alt="image-20230319232718514"></p><p>在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、 Page Cleaner Thread。</p><p>1). Master Thread 核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性， 还包括脏页的刷新、合并插入缓存、undo页的回收 。</p><p> 2). IO Thread 在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。</p><table><thead><tr><th>线程类型</th><th>默认个数</th><th>职责</th></tr></thead><tbody><tr><td>Read thread</td><td>4</td><td>负责读操作</td></tr><tr><td>Write thread</td><td>4</td><td>负责写操作</td></tr><tr><td>Log thread</td><td>1</td><td>负责将日志缓冲区刷新到磁盘</td></tr><tr><td>Insert buffer thread</td><td>1</td><td>负责将写缓冲区内容刷新到磁盘</td></tr></tbody></table><p>可以通过以下的这条指令，查看到InnoDB的状态信息，其中就包含IO Thread信息</p><pre><code>show engine innodb status \G;</code></pre><p><img src="/mysql-02/image-20230319233258967.png" alt="image-20230319233258967"></p><p>3). Purge Thread</p><p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回 收。</p><p>4). Page Cleaner Thread</p><p>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻 塞。</p><h2 id="6-3-事务原理"><a href="#6-3-事务原理" class="headerlink" title="6.3 事务原理"></a>6.3 事务原理</h2><p>1). 事务 事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>2). 特性</p><ul><li><p>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 </p></li><li><p>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</p></li><li><p>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。 </p></li><li><p>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p></li></ul><p>对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的 两份日志来保证的，一份是redo log日志，一份是undo log日志。 而持久性是通过数据库的锁， 加上MVCC来保证的。</p><p><img src="/mysql-02/image-20230320125859308.png" alt="image-20230320125859308"></p><h3 id="6-3-2-redo-log"><a href="#6-3-2-redo-log" class="headerlink" title="6.3.2 redo log"></a>6.3.2 redo log</h3><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。 </p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用 于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p>在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数 据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果 缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中 的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘 中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后 将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却 没有持久化下来，这就出现问题了，没有保证事务的持久性。</p><p><img src="/mysql-02/image-20230320130234652.png" alt="image-20230320130234652"></p><p>如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，</p><p><img src="/mysql-02/image-20230320130303560.png" alt="image-20230320130303560"></p><p>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。 过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据 恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此 时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。</p><p>为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新 到磁盘呢 ? 因为在业务操作中，操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这 种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p><h3 id="6-3-3-undo-log"><a href="#6-3-3-undo-log" class="headerlink" title="6.3.3 undo log"></a>6.3.3 undo log</h3><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和 MVCC(多版本并发控制) 。 undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的 update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些 日志可能还用于MVCC。</p><p>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment。</p><h3 id="6-4-MVCC"><a href="#6-4-MVCC" class="headerlink" title="6.4 MVCC"></a>6.4 MVCC</h3><h4 id="6-4-1-基本概念"><a href="#6-4-1-基本概念" class="headerlink" title="6.4.1 基本概念"></a>6.4.1 基本概念</h4><p>1). 当前读</p><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加 锁。对于我们日常的操作，如：select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读。</p><p>测试：</p><p><img src="/mysql-02/image-20230320132044636.png" alt="image-20230320132044636"></p><p>在测试中可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内 容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。</p><p>2). 快照读</p><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据， 不加锁，是非阻塞读。</p><ul><li><p>Read Committed：每次select，都生成一个快照读。</p></li><li><p>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</p></li><li><p>Serializable：快照读会退化为当前读。</p></li></ul><p><img src="/mysql-02/image-20230320132658484.png" alt="image-20230320132658484"></p><p>看到即使事务B提交了数据,事务A中也查询不到。 原因就是因为普通的select是快照 读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同 的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。</p><p>3). MVCC</p><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本， 使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需 要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><h4 id="6-4-2-隐藏字段"><a href="#6-4-2-隐藏字段" class="headerlink" title="6.4.2 隐藏字段"></a>6.4.2 隐藏字段</h4><h5 id="6-4-2-1-介绍"><a href="#6-4-2-1-介绍" class="headerlink" title="6.4.2.1 介绍"></a>6.4.2.1 介绍</h5><p><img src="/mysql-02/image-20230320132925148.png" alt="image-20230320132925148"></p><p>际上除了 这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p><table><thead><tr><th>隐藏字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</td></tr><tr><td>DB_ROLL_PTR</td><td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版 本。</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td></tr></tbody></table><h4 id="6-4-3-undolog"><a href="#6-4-3-undolog" class="headerlink" title="6.4.3 undolog"></a>6.4.3 undolog</h4><h5 id="6-4-3-1-介绍"><a href="#6-4-3-1-介绍" class="headerlink" title="6.4.3.1 介绍"></a>6.4.3.1 介绍</h5><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。 </p><p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即 被删除。</p><h5 id="6-4-3-2-版本链"><a href="#6-4-3-2-版本链" class="headerlink" title="6.4.3.2 版本链"></a>6.4.3.2 版本链</h5><p>有一张表原始数据为：</p><p><img src="/mysql-02/image-20230320133520301.png" alt="image-20230320133520301"></p><p>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是 自增的。 DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</p><p>然后，有四个并发事务同时在访问这张表。</p><p>A. 第一步</p><p><img src="/mysql-02/image-20230320133629860.png" alt="image-20230320133629860"></p><p>当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录， 并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/mysql-02/image-20230320133646700.png" alt="image-20230320133646700"></p><p>B.第二步</p><p><img src="/mysql-02/image-20230320133743966.png" alt="image-20230320133743966"></p><p>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记 录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/mysql-02/image-20230320133920671.png" alt="image-20230320133920671"></p><p>C. 第三步</p><p><img src="/mysql-02/image-20230320133931367.png" alt="image-20230320133931367"></p><p>当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记 录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/mysql-02/image-20230320133949503.png" alt="image-20230320133949503"></p><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条 记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><h4 id="6-4-4-readview"><a href="#6-4-4-readview" class="headerlink" title="6.4.4 readview"></a>6.4.4 readview</h4><p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务 （未提交的）id。</p><p>ReadView中包含了四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务ID集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务ID</td></tr><tr><td>max_trx_id</td><td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td></tr><tr><td>creator_trx_id</td><td>ReadView创建者的事务ID</td></tr></tbody></table><p>而在readview中就规定了版本链数据的访问规则：</p><p>trx_id 代表当前undolog版本链对应事务ID。</p><table><thead><tr><th>条件</th><th>是否可以访问</th><th>说明</th></tr></thead><tbody><tr><td>trx_id == creator_trx_id</td><td>可以访问该版本</td><td>成立，说明数据是当前这个事 务更改的。</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>可以访问该版本</td><td>成立，说明数据已经提交了。</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>不可以访问该版本</td><td>成立，说明该事务是在 ReadView生成后才开启。</td></tr><tr><td>min_trx_id &lt;= trx_id &lt;= max_trx_id</td><td>如果trx_id不在m_ids中， 是可以访问该版本的</td><td>成立，说明数据已经提交。</td></tr></tbody></table><p>不同的隔离级别，生成ReadView的时机不同：</p><ul><li><p>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。 </p></li><li><p>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</p></li></ul><h4 id="6-4-5-原理分析"><a href="#6-4-5-原理分析" class="headerlink" title="6.4.5 原理分析"></a>6.4.5 原理分析</h4><h5 id="6-4-5-1-RC隔离级别"><a href="#6-4-5-1-RC隔离级别" class="headerlink" title="6.4.5.1 RC隔离级别"></a>6.4.5.1 RC隔离级别</h5><p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView.</p><p>在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读 都会生成一个ReadView，那么两次生成的ReadView如下。</p><p><img src="/mysql-02/image-20230320135113643.png" alt="image-20230320135113643"></p><p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则， 到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p><p>A. 先来看第一次快照读具体的读取过程：</p><p><img src="/mysql-02/image-20230320135113643.png" alt="image-20230320135113643"></p><p><img src="/mysql-02/image-20230320135211340.png" alt="image-20230320135211340"></p><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><p>先匹配<img src="/mysql-02/image-20230320135227208.png" alt="image-20230320135227208"></p><p>这条记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</p><p>再匹配第二条<img src="/mysql-02/image-20230320135247714.png" alt="image-20230320135247714"></p><p>这条 记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也 不满足 ，都不满足，则继续匹配undo log版本链的下一条</p><p>再匹配第三条<img src="/mysql-02/image-20230320135302226.png" alt="image-20230320135302226"></p><p>这条记 录对应的trx_id为2，也就是将2带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照 读，返回的数据就是版本链中记录的这条数据。</p><p>B. 再来看第二次快照读具体的读取过程:</p><p><img src="/mysql-02/image-20230320135452732.png" alt="image-20230320135452732"></p><p><img src="/mysql-02/image-20230320135458225.png" alt="image-20230320135458225"></p><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><p>先匹配<img src="/mysql-02/image-20230320135516089.png" alt="image-20230320135516089"></p><p>这条记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</p><p>再匹配第二条<img src="/mysql-02/image-20230320135536540.png" alt="image-20230320135536540"></p><p>这条 记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次 快照读，返回的数据就是版本链中记录的这条数据。</p><h5 id="6-4-5-3-RR隔离级别"><a href="#6-4-5-3-RR隔离级别" class="headerlink" title="6.4.5.3 RR隔离级别"></a>6.4.5.3 RR隔离级别</h5><p>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可 重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p><p><img src="/mysql-02/image-20230320135625996.png" alt="image-20230320135625996"></p><p>在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该 ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返 回的结果也是一样的。 所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。 而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p><p><img src="/mysql-02/image-20230320135646957.png" alt="image-20230320135646957"></p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-01</title>
      <link href="/mysql-01.html"/>
      <url>/mysql-01.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-MySQL概述"><a href="#1-MySQL概述" class="headerlink" title="1.MySQL概述"></a>1.MySQL概述</h1><h2 id="1-1-数据库相关概念"><a href="#1-1-数据库相关概念" class="headerlink" title="1.1 数据库相关概念"></a>1.1 数据库相关概念</h2><table><thead><tr><th>名称</th><th>全称</th><th>简称</th></tr></thead><tbody><tr><td>数据库</td><td>存储数据的仓库，数据是有组织的进行存储</td><td>DataBase（DB）</td></tr><tr><td>数据库管理系统</td><td>操纵和管理数据库的大型软件</td><td>DataBase Management System (DBMS)</td></tr><tr><td>SQL</td><td>操作关系型数据库的编程语言，定义了一套操作 关系型数据库统一标准</td><td>Structured Query Language (SQL)</td></tr></tbody></table><h3 id="1-1-1mysql数据库连接"><a href="#1-1-1mysql数据库连接" class="headerlink" title="1.1.1mysql数据库连接"></a>1.1.1mysql数据库连接</h3><ol><li>使用MySQL提供的客户端命令行工具</li><li>使用系统自带的命令行工具执行指令</li></ol><pre><code>mysql [-h 127.0.0.1] [-P 3306] -u root -p参数：-h : MySQL服务所在的主机IP-P : MySQL服务端口号， 默认3306-u : MySQL数据库用户名-p ： MySQL数据库用户名对应的密码</code></pre><p>[]内为可选参数，如果需要连接远程的MySQL，需要加上这两个参数来指定远程主机IP、端口，如果 连接本地的MySQL，则无需指定这两个参数。</p><h3 id="1-1-2-数据模型"><a href="#1-1-2-数据模型" class="headerlink" title="1.1.2 数据模型"></a>1.1.2 数据模型</h3><p>1). 关系型数据库（RDBMS） 概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。 而所谓二维表，指的是由行和列组成的表，如下图（就类似于Excel表格数据，有表头、有列、有行， 还可以通过一列关联另外一个表格中的某一列数据）。MySQL、Oracle、DB2、 SQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。简单说，基于二维表存储 数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库。</p><p><img src="/mysql-01/image-20230317200345320.png" alt="image-20230317200345320"></p><p>特点： A. 使用表存储数据，格式统一，便于维护。 </p><p>​            B. 使用SQL语言操作，标准统一，使用方便。</p><p>2). 数据模型 MySQL是关系型数据库，是基于二维表进行数据存储的，具体的结构图下:</p><p><img src="/mysql-01/image-20230317200415240.png" alt="image-20230317200415240"></p><p>可以通过MySQL客户端连接数据库管理系统DBMS，然后通过DBMS操作数据库。 </p><p>可以使用SQL语句，通过数据库管理系统操作数据库，以及操作数据库中的表结构及数据。 一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包 含多行记录。</p><h1 id="2-SQL"><a href="#2-SQL" class="headerlink" title="2.SQL"></a>2.SQL</h1><p>全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了 一套操作关系型数据库统一标准 。</p><h2 id="2-1-SQL通用语法"><a href="#2-1-SQL通用语法" class="headerlink" title="2.1 SQL通用语法"></a>2.1 SQL通用语法</h2><ol><li>SQL语句可以单行或多行书写，以分号结尾。</li><li>SQL语句可以使用空格/缩进来增强语句的可读性。</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</li><li>注释： 单行注释：– 注释内容 或 # 注释内容 多行注释：/* 注释内容 */</li></ol><h2 id="2-2-sql分类"><a href="#2-2-sql分类" class="headerlink" title="2.2 sql分类"></a>2.2 sql分类</h2><p>SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL。</p><table><thead><tr><th>分类</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>数据定义语言，用来定义数据库对象(数据库，表， 字段)</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>数据操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据查询语言，用来查询数据库中表的记录</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>数据控制语言，用来创建数据库用户、控制数据库的 访问权限</td></tr></tbody></table><h2 id="2-3-DDL"><a href="#2-3-DDL" class="headerlink" title="2.3 DDL"></a>2.3 DDL</h2><p>Data Definition Language，数据定义语言，用来定义数据库对象(数据库，表，字段) 。</p><h3 id="2-3-1-数据库操作"><a href="#2-3-1-数据库操作" class="headerlink" title="2.3.1 数据库操作"></a>2.3.1 数据库操作</h3><p>1). 查询所有数据库</p><pre><code>show databases ;</code></pre><p>2). 查询当前数据库</p><pre><code>select database() ;</code></pre><p>3). 创建数据库</p><pre><code>create database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ;</code></pre><p>在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。</p><p>可以通过if not exists 参数来解决这个问题，数据库不存在, 则创建该数据库，如果存在，则不 创建。</p><pre><code>create database if not extists itcast;</code></pre><p>B. 创建一个itheima数据库，并且指定字符集</p><pre><code>create database 数据库名称 default charset utf8mb4;</code></pre><p>4). 删除数据库</p><pre><code> drop database [ if exists ] 数据库名 ;</code></pre><p>如果删除一个不存在的数据库，将会报错。此时，可以加上参数 if exists ，如果数据库存在，再 执行删除，否则不执行删除。</p><p>5). 切换数据库</p><pre><code>use 数据库名 ;</code></pre><p>要操作某一个数据库下的表时，就需要通过该指令，切换到对应的数据库下，否则是不能操作的。</p><h3 id="2-3-2-表操作"><a href="#2-3-2-表操作" class="headerlink" title="2.3.2 表操作"></a>2.3.2 表操作</h3><h4 id="2-3-2-1-表操作-查询创建"><a href="#2-3-2-1-表操作-查询创建" class="headerlink" title="2.3.2.1 表操作-查询创建"></a>2.3.2.1 表操作-查询创建</h4><p>1). 查询当前数据库所有表</p><pre><code>show tables;</code></pre><p>2). 查看指定表结构</p><pre><code>desc 表名 ;</code></pre><p>3). 查询指定表的建表语句</p><pre><code>show create table 表名 ;</code></pre><p>4). 创建表结构</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE 表名(字段1 字段1类型 [ COMMENT 字段1注释 ],字段2 字段2类型 [COMMENT 字段2注释 ],字段3 字段3类型 [COMMENT 字段3注释 ],......字段n 字段n类型 [COMMENT 字段n注释 ]) [ COMMENT 表注释 ] ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意: […] 内为可选参数，最后一个字段后面没有逗号</p><p>比如，创建一张表 tb_user ，对应的结构如下，那么建表语句为：</p><p><img src="/mysql-01/image-20230318122920257.png" alt="image-20230318122920257"></p><pre class="line-numbers language-mysql"><code class="language-mysql">create table tb_user(id int comment '编号',name varchar(50) comment '姓名',age int comment '年龄',gender varchar(1) comment '性别') comment '用户表';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-2-2-表操作-数据类型"><a href="#2-3-2-2-表操作-数据类型" class="headerlink" title="2.3.2.2 表操作-数据类型"></a>2.3.2.2 表操作-数据类型</h4><p> MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。</p><p>1). 数值类型</p><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">范围（有符号）</th><th align="left">范围（无符号）</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1 Bytes</td><td align="left">(-128，127)</td><td align="left">(0，255)</td><td align="left">小整数值</td></tr><tr><td align="left">SMALLINT</td><td align="left">2 Bytes</td><td align="left">(-32 768，32 767)</td><td align="left">(0，65 535)</td><td align="left">大整数值</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3 Bytes</td><td align="left">(-8 388 608，8 388 607)</td><td align="left">(0，16 777 215)</td><td align="left">大整数值</td></tr><tr><td align="left">INT或INTEGER</td><td align="left">4 Bytes</td><td align="left">(-2 147 483 648，2 147 483 647)</td><td align="left">(0，4 294 967 295)</td><td align="left">大整数值</td></tr><tr><td align="left">BIGINT</td><td align="left">8 Bytes</td><td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td align="left">(0，18 446 744 073 709 551 615)</td><td align="left">极大整数值</td></tr><tr><td align="left">FLOAT</td><td align="left">4 Bytes</td><td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="left">单精度 浮点数值</td></tr><tr><td align="left">DOUBLE</td><td align="left">8 Bytes</td><td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">双精度 浮点数值</td></tr><tr><td align="left">DECIMAL</td><td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="left">依赖于M和D的值</td><td align="left">依赖于M和D的值</td><td align="left">小数值</td></tr></tbody></table><pre><code>如:1). 年龄字段 -- 不会出现负数, 而且人的年龄不会太大age tinyint unsigned2). 分数 -- 总分100分, 最多出现一位小数score double(4,1)</code></pre><p>2). 字符串类型</p><table><thead><tr><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 bytes</td><td>定长字符串(需要指定长度)</td></tr><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串(需要指定长度)</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过255个字符的二进制数据</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table><p>char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和 字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性 能会更高些。</p><pre><code>如：1). 用户名 username ------&gt; 长度不定, 最长不会超过50username varchar(50)2). 性别 gender ---------&gt; 存储值, 不是男,就是女gender char(1)3). 手机号 phone --------&gt; 固定长度为11phone char(11)</code></pre><p>3). 日期时间类型</p><table><thead><tr><th align="left">类型</th><th align="left">大小 ( bytes)</th><th align="left">范围</th><th align="left">格式</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01/9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="left">日期值</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’/‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="left">时间值或持续时间</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901/2155</td><td align="left">YYYY</td><td align="left">年份值</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="left">混合日期和时间值</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="left">混合日期和时间值，时间戳</td></tr></tbody></table><pre><code>1). 生日字段 birthdaybirthday date2). 创建时间 createtimecreatetime datetime</code></pre><p>2.3.2.3 表操作-案例 设计一张员工信息表，要求如下：</p><ol><li>编号（纯数字） </li><li>员工工号 (字符串类型，长度不超过10位) </li><li>员工姓名（字符串类型，长度不超过10位）</li><li>性别（男/女，存储一个汉字） </li><li>年龄（正常人年龄，不可能存储负数）</li><li>身份证号（二代身份证号均为18位，身份证中有X这样的字符） </li><li>入职时间（取值年月日即可）</li></ol><pre><code>create table emp(    id int comment &quot;编号&quot;,    workno varchar(10) comment&#39;工号&#39;,    name varchar(10) comment&#39;姓名&#39;,    gender char(1) comment &#39;性别&#39;,    age tinyint unsigned comment &#39;年龄&#39;,    idcard char(10) comment &#39;身份证号&#39;,    entrydate date comment &#39;入职时间&#39;)comment &#39;员工表&#39;,</code></pre><h4 id="2-3-2-4-表操作-修改"><a href="#2-3-2-4-表操作-修改" class="headerlink" title="2.3.2.4 表操作-修改"></a>2.3.2.4 表操作-修改</h4><p>1). 添加字段</p><pre><code>ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</code></pre><p>案例:</p><p>为emp表增加一个新的字段”昵称”为nickname，类型为varchar(20)</p><pre><code>ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;</code></pre><p>2). 修改数据类型</p><pre><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型（长度);</code></pre><p>3). 修改字段名和字段类型</p><pre><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</code></pre><p>案例: 将emp表的nickname字段修改为username，类型为varchar(30)</p><pre><code>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;</code></pre><p>4). 删除字段</p><pre><code>ALTER TABLE 表名 DROP 字段名</code></pre><p>案例: </p><p>将emp表的字段username删除</p><pre><code>ALTER TABLE emp DROP username</code></pre><p>5). 修改表名</p><pre><code>ALTER TABLE 表名 RENAME TO 新表名;</code></pre><p>案例: </p><p>将emp表的表名修改为 employee</p><pre><code> ALTER TABLE emp RENAME TO employee;</code></pre><h4 id="2-3-2-5-表操作-删除"><a href="#2-3-2-5-表操作-删除" class="headerlink" title="2.3.2.5 表操作-删除"></a>2.3.2.5 表操作-删除</h4><pre><code>DROP TABLE [ IF EXISTS ] 表名;</code></pre><p>可选项 IF EXISTS 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不 加该参数项，删除一张不存在的表，执行将会报错)。 案例: 如果tb_user表存在，则删除tb_user表</p><pre><code>DROP TABLE IF EXISTS tb_user;</code></pre><p>2). 删除指定表, 并重新创建表</p><pre><code>TRUNCATE TABLE 表名</code></pre><p>注意: 在删除表的时候，表中的全部数据也都会被删除。</p><h2 id="2-4-图形化界面工具"><a href="#2-4-图形化界面工具" class="headerlink" title="2.4 图形化界面工具"></a>2.4 图形化界面工具</h2><p><img src="/mysql-01/image-20230318143403192.png" alt="image-20230318143403192"></p><p>个人感觉DataGrip好用</p><h2 id="2-5-DML"><a href="#2-5-DML" class="headerlink" title="2.5 DML"></a>2.5 DML</h2><p>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进 行增、删、改操作。</p><ul><li>添加数据（INSERT）</li><li>修改数据（UPDATE） </li><li>删除数据（DELETE）</li></ul><h3 id="2-5-1-添加数据"><a href="#2-5-1-添加数据" class="headerlink" title="2.5.1 添加数据"></a>2.5.1 添加数据</h3><p> 1). 给指定字段添加数据</p><pre><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code></pre><p>给employee表所有的字段添加数据 ；</p><pre><code>insert into employee(id,workno,name,gender,age,idcard,entrydate)values(1,&#39;1&#39;,&#39;Itcast&#39;,&#39;男&#39;,10,&#39;123456789012345678&#39;,&#39;2000-01-01&#39;);</code></pre><p>2). 给全部字段添加数据</p><pre><code>INSERT INTO 表名 VALUES (值1, 值2, ...);</code></pre><p>插入数据到employee表，具体的SQL如下：</p><pre><code>insert into employee values(2,&#39;2&#39;,&#39;张无忌&#39;,&#39;男&#39;,18,&#39;123456789012345670&#39;,&#39;2005-01-01&#39;);</code></pre><p>3). 批量添加数据</p><pre><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;</code></pre><pre><code>INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;</code></pre><p>注意事项: </p><ul><li>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。</li><li>字符串和日期型数据应该包含在引号中。 </li><li>插入的数据大小，应该在字段的规定范围内。</li></ul><h3 id="2-5-2-修改数据"><a href="#2-5-2-修改数据" class="headerlink" title="2.5.2 修改数据"></a>2.5.2 修改数据</h3><p>修改数据的具体语法为:</p><pre><code>UPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ] ;</code></pre><p>案例:</p><p>A. 修改id为1的数据，将name修改为nametest</p><pre><code>update employee set name = &#39;nametest&#39; where id = 1;</code></pre><p>B. 修改id为1的数据, 将name修改为小昭, gender修改为 女</p><pre><code>update employee set name = &#39;小昭&#39; , gender = &#39;女&#39; where id = 1;</code></pre><p>C. 将所有的员工入职日期修改为 2008-01-01</p><pre><code> update employee set entrydate = &#39;2008-01-01&#39;;</code></pre><p>注意事项: 修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。</p><h3 id="2-5-3-删除数据"><a href="#2-5-3-删除数据" class="headerlink" title="2.5.3 删除数据"></a>2.5.3 删除数据</h3><p>删除数据的具体语法为：</p><pre><code> DELETE FROM 表名 [ WHERE 条件 ] ;</code></pre><p>案例: A. 删除gender为女的员工</p><pre><code> delete from employee where gender = &#39;女&#39;;</code></pre><p>B. 删除所有员工</p><pre><code>delete from employee</code></pre><p>注意事项:</p><ul><li>DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数 据。</li><li>DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即 可)。 </li><li>当进行删除全部数据操作时，datagrip会提示，询问是否确认删除，直接点击 Execute即可。</li></ul><h2 id="2-6-DQL"><a href="#2-6-DQL" class="headerlink" title="2.6 DQL"></a>2.6 DQL</h2><p>DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记 录。</p><p>查询关键字: SELECT</p><p>数据准备</p><pre><code>drop table if exists employee;create table emp(id int comment &#39;编号&#39;,workno varchar(10) comment &#39;工号&#39;,name varchar(10) comment &#39;姓名&#39;,gender char(1) comment &#39;性别&#39;,age tinyint unsigned comment &#39;年龄&#39;,idcard char(18) comment &#39;身份证号&#39;,workaddress varchar(50) comment &#39;工作地址&#39;,entrydate date comment &#39;入职时间&#39;)comment &#39;员工表&#39;;INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (1, &#39;00001&#39;, &#39;柳岩666&#39;, &#39;女&#39;, 20, &#39;123456789012345678&#39;, &#39;北京&#39;, &#39;2000-01-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (2, &#39;00002&#39;, &#39;张无忌&#39;, &#39;男&#39;, 18, &#39;123456789012345670&#39;, &#39;北京&#39;, &#39;2005-09-01&#39;)INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (3, &#39;00003&#39;, &#39;韦一笑&#39;, &#39;男&#39;, 38, &#39;123456789712345670&#39;, &#39;上海&#39;, &#39;2005-08-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (4, &#39;00004&#39;, &#39;赵敏&#39;, &#39;女&#39;, 18, &#39;123456757123845670&#39;, &#39;北京&#39;, &#39;2009-12-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (5, &#39;00005&#39;, &#39;小昭&#39;, &#39;女&#39;, 16, &#39;123456769012345678&#39;, &#39;上海&#39;, &#39;2007-07-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (6, &#39;00006&#39;, &#39;杨逍&#39;, &#39;男&#39;, 28, &#39;12345678931234567X&#39;, &#39;北京&#39;, &#39;2006-01-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (7, &#39;00007&#39;, &#39;范瑶&#39;, &#39;男&#39;, 40, &#39;123456789212345670&#39;, &#39;北京&#39;, &#39;2005-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (8, &#39;00008&#39;, &#39;黛绮丝&#39;, &#39;女&#39;, 38, &#39;123456157123645670&#39;, &#39;天津&#39;, &#39;2015-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (9, &#39;00009&#39;, &#39;范凉凉&#39;, &#39;女&#39;, 45, &#39;123156789012345678&#39;, &#39;北京&#39;, &#39;2010-04-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (10, &#39;00010&#39;, &#39;陈友谅&#39;, &#39;男&#39;, 53, &#39;123456789012345670&#39;, &#39;上海&#39;, &#39;2011-01-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (11, &#39;00011&#39;, &#39;张士诚&#39;, &#39;男&#39;, 55, &#39;123567897123465670&#39;, &#39;江苏&#39;, &#39;2015-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (12, &#39;00012&#39;, &#39;常遇春&#39;, &#39;男&#39;, 32, &#39;123446757152345670&#39;, &#39;北京&#39;, &#39;2004-02-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (13, &#39;00013&#39;, &#39;张三丰&#39;, &#39;男&#39;, 88, &#39;123656789012345678&#39;, &#39;江苏&#39;, &#39;2020-11-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (14, &#39;00014&#39;, &#39;灭绝&#39;, &#39;女&#39;, 65, &#39;123456719012345670&#39;, &#39;西安&#39;, &#39;2019-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (15, &#39;00015&#39;, &#39;胡青牛&#39;, &#39;男&#39;, 70, &#39;12345674971234567X&#39;, &#39;西安&#39;, &#39;2018-04-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (16, &#39;00016&#39;, &#39;周芷若&#39;, &#39;女&#39;, 18, null, &#39;北京&#39;, &#39;2012-06-01&#39;);</code></pre><h3 id="2-6-1-基本语法"><a href="#2-6-1-基本语法" class="headerlink" title="2.6.1 基本语法"></a>2.6.1 基本语法</h3><p>DQL 查询语句，语法结构如下：</p><pre><code>SELECT    字段列表FROM    表名列表WHERE    条件列表GROUP BY    分组字段列表HAVING    分组后条件列表ORDER BY    排序字段列表LIMIT    分页参数</code></pre><h3 id="2-6-2-基础查询"><a href="#2-6-2-基础查询" class="headerlink" title="2.6.2 基础查询"></a>2.6.2 基础查询</h3><p>1). 查询多个字段</p><pre><code>SELECT 字段1, 字段2, 字段3 ... FROM 表名 ;</code></pre><pre><code>SELECT * FROM 表名 ；</code></pre><p>注意 : * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。</p><p>2). 字段设置别名</p><pre><code> SELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名;</code></pre><pre><code> SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;</code></pre><p>3). 去除重复记录</p><pre><code>SELECT DISTINCT 字段列表 FROM 表名;</code></pre><h3 id="2-6-3-条件查询"><a href="#2-6-3-条件查询" class="headerlink" title="2.6.3 条件查询"></a>2.6.3 条件查询</h3><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 WHERE 条件列表 ;</code></pre><p>2). 条件</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">等号，检测两个值是否相等，如果相等返回true</td><td align="left">(A = B) 返回false。</td></tr><tr><td align="left">&lt;&gt;, !=</td><td align="left">不等于，检测两个值是否相等，如果不相等返回true</td><td align="left">(A != B) 返回 true。</td></tr><tr><td align="left">&gt;</td><td align="left">大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true</td><td align="left">(A &gt; B) 返回false。</td></tr><tr><td align="left">&lt;</td><td align="left">小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true</td><td align="left">(A &lt; B) 返回 true。</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true</td><td align="left">(A &gt;= B) 返回false。</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于号，检测左边的值是否小于或等于右边的值, 如果左边的值小于或等于右边的值返回true</td><td align="left">(A &lt;= B) 返回 true。</td></tr><tr><td align="left">BETWEEN … AND …</td><td align="left">在某个范围之内(含最小、最大值)</td><td align="left">(between15 and 20) 返回15到20之间</td></tr><tr><td align="left">IN(…)</td><td align="left">在in之后的列表中的值，多选一</td><td align="left">[in(18,80,40) ] 返回18，20，40</td></tr><tr><td align="left">LIKE 占位符</td><td align="left">模糊匹配(_匹配单个字符, %匹配任意个字符)</td><td align="left"></td></tr><tr><td align="left">IS NULL</td><td align="left">是NULL</td><td align="left"></td></tr></tbody></table><h3 id="2-6-4-聚合函数"><a href="#2-6-4-聚合函数" class="headerlink" title="2.6.4 聚合函数"></a>2.6.4 聚合函数</h3><p>1). 介绍</p><p>将一列数据作为一个整体，进行纵向计算 。</p><p>2). 常见的聚合函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p>3). 语法</p><pre><code> SELECT 聚合函数(字段列表) FROM 表名 ;</code></pre><p>注意 : NULL值是不参与所有聚合函数运算的。</p><p>案例：</p><p>A. 统计该企业员工数量</p><pre><code>select count(*) from emp; -- 统计的是总记录数select count(idcard) from emp; -- 统计的是idcard字段不为null的记录数</code></pre><p>对于count聚合函数，统计符合条件的总记录数，还可以通过 count(数字/字符串)的形式进行统计 查询，比如：</p><pre><code> select count(1) from emp;</code></pre><h3 id="2-6-5-分组查询"><a href="#2-6-5-分组查询" class="headerlink" title="2.6.5 分组查询"></a>2.6.5 分组查询</h3><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后过滤条件 ];</code></pre><p>2). where与having区别 执行时机不同：</p><ul><li>where是分组之前进行过滤，不满足where条件，不参与分组；</li><li>而having是分组 之后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><p>案例:</p><p>A. 根据性别分组 , 统计男性员工 和 女性员工的数量</p><pre><code>select gender, count(*) from emp group by gender ;</code></pre><p>B. 根据性别分组 , 统计男性员工 和 女性员工的平均年龄</p><pre><code> select gender, avg(age) from emp group by gender ;</code></pre><p>C. 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址</p><pre><code>select workaddress, count(*) address_count from emp where age &lt; 45 group byworkaddress having address_count &gt;= 3;</code></pre><p>D. 统计各个工作地址上班的男性及女性员工的数量</p><pre><code>select workaddress, gender, count(*) &#39;数量&#39; from emp group by gender , workaddress;</code></pre><h3 id="2-6-6-排序查询"><a href="#2-6-6-排序查询" class="headerlink" title="2.6.6 排序查询"></a>2.6.6 排序查询</h3><p>排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序</p><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ;</code></pre><p>2). 排序方式</p><ul><li>ASC : 升序(默认值) </li><li>DESC: 降序</li></ul><p>注意事项：</p><ul><li>如果是升序, 可以不指定排序方式ASC ; </li><li>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;</li></ul><h3 id="2-6-7-分页查询"><a href="#2-6-7-分页查询" class="headerlink" title="2.6.7 分页查询"></a>2.6.7 分页查询</h3><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;</code></pre><p>注意事项: </p><p>起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数。 </p><p>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。 </p><p>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</p><p>案例: </p><p>A. 查询第1页员工数据, 每页展示10条记录</p><pre><code>select * from emp limit 0,10;select * from emp limit 10;</code></pre><p>B. 查询第2页员工数据, 每页展示10条记录 ——–&gt; (页码-1)*页展示记录数</p><pre><code> select * from emp limit 10,10;</code></pre><h3 id="2-6-9-执行顺序"><a href="#2-6-9-执行顺序" class="headerlink" title="2.6.9 执行顺序"></a>2.6.9 执行顺序</h3><p><img src="/mysql-01/image-20230318153026758.png" alt="image-20230318153026758"></p><p>执行顺序为</p><p>from … where … group by … having … select … order by … limit …</p><h2 id="2-7-DCL"><a href="#2-7-DCL" class="headerlink" title="2.7 DCL"></a>2.7 DCL</h2><p>DCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访 问权限。</p><h3 id="2-7-1-管理用户"><a href="#2-7-1-管理用户" class="headerlink" title="2.7.1 管理用户"></a>2.7.1 管理用户</h3><p>1). 查询用户</p><pre><code>select * from mysql.user;</code></pre><p><img src="/mysql-01/image-20230318153333941.png" alt="image-20230318153333941"></p><p>其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以 远程访问的。 User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一 个用户。</p><p>2). 创建用户</p><pre><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></pre><p>3). 修改用户密码</p><pre><code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39; ;</code></pre><p>4). 删除用户</p><pre><code>DROP USER &#39;用户名&#39;@&#39;主机名&#39; ;</code></pre><p>注意事项:</p><ul><li>在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。</li><li>主机名可以使用 % 通配。 </li></ul><h3 id="2-7-2-权限控制"><a href="#2-7-2-权限控制" class="headerlink" title="2.7.2 权限控制"></a>2.7.2 权限控制</h3><p>Mysql中常用的的权限</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库/表/视图</td></tr><tr><td>CREATE</td><td>创建数据库/表</td></tr></tbody></table><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" target="_blank" rel="noopener">MySQL :: MySQL 8.0 Reference Manual :: 6.2.2 Privileges Provided by MySQL</a></p><p>1). 查询权限</p><pre><code> SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39; ;</code></pre><p>2). 授予权限</p><pre><code> GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>3). 撤销权限</p><pre><code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>注意事项： • 多个权限之间，使用逗号分隔 • 授权时， 数据库名和表名可以使用 * 进行通配，代表所有。</p><h1 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h1><p>函数 是指一段可以直接被另一段程序调用的程序或代码。 也就意味着，这一段程序或代码在MySQL中 已经给我们提供了，我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可</p><p>MySQL中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数。</p><h2 id="3-1-字符串函数"><a href="#3-1-字符串函数" class="headerlink" title="3.1 字符串函数"></a>3.1 字符串函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(S1,S2,…Sn)</td><td>字符串拼接，将S1，S2，… Sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串str全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串str全部转为大写</td></tr><tr><td>LPAD(str,n,pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符 串长度</td></tr><tr><td>RPAD(str,n,pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符 串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str,start,len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><p>lpad : 左填充</p><pre><code>select lpad(&#39;01&#39;, 5, &#39;-&#39;);</code></pre><p>trim : 去除空格</p><pre><code>select trim(&#39; Hello MySQL &#39;)</code></pre><p>substring : 截取子字符串</p><pre><code> select substring(&#39;Hello MySQL&#39;,1,5);</code></pre><h2 id="3-2-数值函数"><a href="#3-2-数值函数" class="headerlink" title="3.2 数值函数"></a>3.2 数值函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x,y)</td><td>返回x/y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x,y)</td><td>求参数x的四舍五入的值，保留y位小数</td></tr></tbody></table><h2 id="3-3-日期函数"><a href="#3-3-日期函数" class="headerlink" title="3.3 日期函数"></a>3.3 日期函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期/时间值加上一个时间间隔expr后的 时间值</td></tr><tr><td>DATEDIFF(date1,date2)</td><td>返回起始时间date1 和 结束时间date2之间的天 数</td></tr></tbody></table><h2 id="3-4-流程函数"><a href="#3-4-流程函数" class="headerlink" title="3.4 流程函数"></a>3.4 流程函数</h2><p>流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value , t , f)</td><td>如果value为true，则返回t，否则返回 f</td></tr><tr><td>IFNULL(value1 , value2)</td><td>如果value1不为空，返回value1，否则 返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否 则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td><td>如果expr的值等于val1，返回 res1，… 否则返回default默认值</td></tr></tbody></table><p>需求: 查询emp表的员工姓名和工作地址 (北京/上海 —-&gt; 一线城市 , 其他 —-&gt; 二线城市)</p><pre><code>selectname,( case workaddress when &#39;北京&#39; then &#39;一线城市&#39; when &#39;上海&#39; then &#39;一线城市&#39; else&#39;二线城市&#39; end ) as &#39;工作地址&#39;from emp;</code></pre><h1 id="4-约束"><a href="#4-约束" class="headerlink" title="4.约束"></a>4.约束</h1><p>概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。</p><p> 目的：保证数据库中数据的正确、有效性和完整性。</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束(8.0.16版本 之后)</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张表的数据之间建立连接，保证数据的一致 性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><p>注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。</p><h2 id="4-3-外键约束"><a href="#4-3-外键约束" class="headerlink" title="4.3 外键约束"></a>4.3 外键约束</h2><p>外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</p><p><img src="/mysql-01/image-20230318161258249.png" alt="image-20230318161258249"></p><p>左侧的emp表是员工表，里面存储员工的基本信息，包含员工的ID、姓名、年龄、职位、薪资、入职日 期、上级主管ID、部门ID，在员工的信息中存储的是部门的ID dept_id，而这个部门的ID是关联的 部门表dept的主键id，那emp表的dept_id就是外键,关联的是另一张表的主键。</p><p>注意：目前上述两张表，只是在逻辑上存在这样一层关系；在数据库层面，并未建立外键关联， 所以是无法保证数据的一致性和完整性的。</p><h3 id="4-3-2-语法"><a href="#4-3-2-语法" class="headerlink" title="4.3.2 语法"></a>4.3.2 语法</h3><p>1). 添加外键</p><pre><code>CREATE TABLE 表名(    字段名 数据类型,    ...    [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名));</code></pre><pre><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名)REFERENCES 主表 (主表列名) ;</code></pre><p>为emp表的dept_id字段添加外键约束,关联dept表的主键id。</p><pre><code>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id);</code></pre><p><img src="/mysql-01/image-20230318161641788.png" alt="image-20230318161641788"></p><p>添加了外键约束之后，到dept表(父表)删除id为1的记录。 此时 将会报错，不能删除或更新父表记录，因为存在外键约束。</p><p>2). 删除外键</p><pre><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</code></pre><p>案例： 删除emp表的外键fk_emp_dept_id。</p><pre><code>alter table emp drop foreign key fk_emp_dept_id;</code></pre><h3 id="4-3-3-删除-更新行为"><a href="#4-3-3-删除-更新行为" class="headerlink" title="4.3.3 删除/更新行为"></a>4.3.3 删除/更新行为</h3><p>添加了外键之后，再删除父表数据时产生的约束行为，称为删除/更新行为。具体的删除/更新行 为有以下几种</p><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 RESTRICT 一致) 默认行为</td></tr><tr><td>RESTRICT</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 NO ACTION 一致) 默认行为</td></tr><tr><td>CASCADE</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则 也删除/更新外键在子表中的记录。</td></tr><tr><td>SET NULL</td><td>当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表 中该外键值为null（这就要求该外键允许取null）。</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)</td></tr></tbody></table><p>具体语法为:</p><pre><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;</code></pre><p>演示如下：</p><p>1). CASCADE</p><pre><code>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id) on update cascade on delete cascade ;</code></pre><p>A. 修改父表id为1的记录，将id修改为6</p><p><img src="/mysql-01/image-20230318162417947.png" alt="image-20230318162417947"></p><p>原来在子表中dept_id值为1的记录，现在也变为6了，这就是cascade级联的效果。</p><p>在一般的业务系统中，不会修改一张表的主键值。</p><p>B. 删除父表id为6的记录</p><p><img src="/mysql-01/image-20230318162446703.png" alt="image-20230318162446703"></p><p>父表的数据删除成功了，但是子表中关联的记录也被级联删除了。</p><p>2). SET NULL</p><pre><code>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id) on update set null on delete set null ;</code></pre><p><img src="/mysql-01/image-20230318162633853.png" alt="image-20230318162633853"></p><p>父表的记录是可以正常的删除的，父表的数据删除之后，再打开子表 emp，发现子表emp 的dept_id字段，原来dept_id为1的数据，现在都被置为NULL了。</p><p><img src="/mysql-01/image-20230318162649038.png" alt="image-20230318162649038"></p><h1 id="5-多表查询"><a href="#5-多表查询" class="headerlink" title="5.多表查询"></a>5.多表查询</h1><h2 id="5-1-多表关系"><a href="#5-1-多表关系" class="headerlink" title="5.1 多表关系"></a>5.1 多表关系</h2><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结 构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：</p><ul><li>一对多(多对一)</li><li>多对多</li><li>一对一</li></ul><h3 id="5-1-1-一对多"><a href="#5-1-1-一对多" class="headerlink" title="5.1.1 一对多"></a>5.1.1 一对多</h3><ul><li>案例: 部门 与 员工的关系</li><li>关系: 一个部门对应多个员工，一个员工对应一个部门 </li><li>实现: 在多的一方建立外键，指向一的一方的主键</li></ul><p><img src="/mysql-01/image-20230318163215620.png" alt="image-20230318163215620"></p><h3 id="5-1-2-多对多"><a href="#5-1-2-多对多" class="headerlink" title="5.1.2 多对多"></a>5.1.2 多对多</h3><ul><li>案例: 学生 与 课程的关系 </li><li>关系: 一个学生可以选修多门课程，一门课程也可以供多个学生选择 </li><li>实现: 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</li></ul><p><img src="/mysql-01/image-20230318163305957.png" alt="image-20230318163305957"></p><p>约束语句：</p><pre><code>constraint fk_courseid foreign key (courseid) references course (id),constraint fk_studentid foreign key (studentid) references student (id)</code></pre><h3 id="5-1-3-一对一"><a href="#5-1-3-一对一" class="headerlink" title="5.1.3 一对一"></a>5.1.3 一对一</h3><p>案例: 用户 与 用户详情的关系 关系:</p><p> 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另 一张表中，以提升操作效率 </p><p>实现: 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</p><p><img src="/mysql-01/image-20230318163537120.png" alt="image-20230318163537120"></p><h2 id="5-2-多表查询"><a href="#5-2-多表查询" class="headerlink" title="5.2 多表查询"></a>5.2 多表查询</h2><h3 id="5-2-2-概述"><a href="#5-2-2-概述" class="headerlink" title="5.2.2 概述"></a>5.2.2 概述</h3><p>多表查询就是指从多张表中查询数据。</p><p>原来查询单表数据，执行的SQL形式为：select * from emp;</p><p>那么我们要执行多表查询，就只需要使用逗号分隔多张表即可，如： select * from emp , dept ; 具体的执行结果如下:</p><p><img src="/mysql-01/image-20230318163656019.png" alt="image-20230318163656019"></p><p>此时,查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录 (17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。</p><p>笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况。</p><p><img src="/mysql-01/image-20230318163727372.png" alt="image-20230318163727372"></p><p>而在多表查询中，是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。</p><p><img src="/mysql-01/image-20230318163744086.png" alt="image-20230318163744086"></p><p>给多表查询加上连接查询的条件，消除笛卡尔集。</p><pre><code>select * from emp , dept where emp.dept_id = dept.id;</code></pre><p><img src="/mysql-01/image-20230318163821696.png" alt="image-20230318163821696"></p><p>而由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询 到。</p><h3 id="5-2-3-分类"><a href="#5-2-3-分类" class="headerlink" title="5.2.3 分类"></a>5.2.3 分类</h3><p>连接查询 </p><p>​    内连接：相当于查询A、B交集部分数据     </p><p>​    外连接：     </p><p>​        左外连接：查询左表所有数据，以及两张表交集部分数据     </p><p>​        右外连接：查询右表所有数据，以及两张表交集部分数据     </p><p>​    自连接：当前表与自身的连接查询，自连接必须使用表别名</p><ul><li>子查询</li></ul><p><img src="/mysql-01/image-20230318164141106.png" alt="image-20230318164141106"></p><h2 id="5-3-内连接"><a href="#5-3-内连接" class="headerlink" title="5.3 内连接"></a>5.3 内连接</h2><p><img src="/mysql-01/image-20230318164353496.png" alt="image-20230318164353496"></p><p>内连接查询的是两张表交集部分的数 据。(也就是绿色部分的数据) 内连接的语法分为两种: 隐式内连接、显式内连接。</p><p>1). 隐式内连接</p><pre><code>SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;</code></pre><p>2). 显式内连接</p><pre><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;</code></pre><p>案例: </p><p>A. 查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现) </p><p>表结构: emp , dept </p><p>连接条件: emp.dept_id = dept.id</p><pre><code>select emp.name , dept.name from emp , dept where emp.dept_id = dept.id ;-- 为每一张表起别名,简化SQL编写select e.name,d.name from emp e , dept d where e.dept_id = d.id;</code></pre><p>B. 查询每一个员工的姓名 , 及关联的部门的名称 (显式内连接实现) — INNER JOIN … ON …</p><p>​    表结构: emp , dept </p><p>​    连接条件: emp.dept_id = dept.id</p><pre><code>select e.name, d.name from emp e inner join dept d on e.dept_id = d.id;-- 为每一张表起别名,简化SQL编写select e.name, d.name from emp e join dept d on e.dept_id = d.id;</code></pre><p>注意事项:一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字 段。</p><h2 id="5-4-外连接"><a href="#5-4-外连接" class="headerlink" title="5.4 外连接"></a>5.4 外连接</h2><p><img src="/mysql-01/image-20230318165025944.png" alt="image-20230318165025944"></p><p>外连接分为两种，分别是：左外连接 和 右外连接。具体的语法结构为：</p><p>1). 左外连接</p><pre><code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;</code></pre><p>左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。</p><p>2). 右外连接</p><pre><code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ... ;</code></pre><p>右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。</p><p>案例:</p><p>A.     查询emp表的所有数据, 和对应的部门信息 </p><p>​        由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。         表结构: emp, dept 连接条件: emp.dept_id = dept.id</p><p>​        连接条件: emp.dept_id = dept.id</p><pre><code>select e.*, d.name from emp e left outer join dept d on e.dept_id = d.id;select e.*, d.name from emp e left join dept d on e.dept_id = d.id;</code></pre><p>​    B. 查询dept表的所有数据, 和对应的员工信息(右外连接)</p><p>由于需求中提到，要查询dept表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查 询。 </p><p>​    表结构: emp, dept </p><p>​    连接条件: emp.dept_id = dept.id</p><pre><code>select d.*, e.* from emp e right outer join dept d on e.dept_id = d.id;select d.*, e.* from dept d left outer join emp e on e.dept_id = d.id;</code></pre><p>注意事项： 左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺 序就可以了。日常开发使用时，更偏向于左外连接。</p><h2 id="5-5-自连接"><a href="#5-5-自连接" class="headerlink" title="5.5 自连接"></a>5.5 自连接</h2><h3 id="5-5-1-自连接查询"><a href="#5-5-1-自连接查询" class="headerlink" title="5.5.1 自连接查询"></a>5.5.1 自连接查询</h3><p>自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。</p><pre><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ... ;</code></pre><p>而对于自连接查询，可以是内连接查询，也可以是外连接查询。</p><p>案例： </p><p>A. 查询员工 及其 所属领导的名字 </p><p>表结构: emp</p><pre><code>select a.name , b.name from emp a , emp b where a.managerid = b.id;</code></pre><p>B. 查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来 </p><p>表结构: emp a , emp b</p><p>注意事项: 在自连接查询中，必须要为表起别名，要不然不清楚所指定的条件、返回的字段，到底 是哪一张表的字段</p><h3 id="5-5-2-联合查询"><a href="#5-5-2-联合查询" class="headerlink" title="5.5.2 联合查询"></a>5.5.2 联合查询</h3><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p><pre><code>SELECT 字段列表 FROM 表A ...UNION [ ALL ]SELECT 字段列表 FROM 表B ....;</code></pre><ul><li>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</li><li>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。</li></ul><p>案例: A. 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来. </p><p>当前对于这个需求，可以直接使用多条件查询，使用逻辑运算符 or 连接即可。 也可以通过union/union all来联合查询.</p><p><img src="/mysql-01/image-20230318171722519.png" alt="image-20230318171722519"></p><p>union all查询出来的结果，仅仅进行简单的合并，并未去重</p><pre><code>select * from emp where salary &lt; 5000unionselect * from emp where age &gt; 50;</code></pre><p><img src="/mysql-01/image-20230318171749423.png" alt="image-20230318171749423"></p><p>union 联合查询，会对查询出来的结果进行去重处理。</p><p>注意： 如果多条查询语句查询出来的结果，字段数量不一致，在进行union/union all联合查询时，将会报错。如：</p><p><img src="/mysql-01/image-20230318171808521.png" alt="image-20230318171808521"></p><h2 id="5-6-子查询"><a href="#5-6-子查询" class="headerlink" title="5.6 子查询"></a>5.6 子查询</h2><h3 id="5-6-1-概述"><a href="#5-6-1-概述" class="headerlink" title="5.6.1 概述"></a>5.6.1 概述</h3><p>1). 概念</p><p>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p><pre><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 );</code></pre><p>子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。</p><p>2). 分类</p><p>根据子查询结果不同，分为：</p><p>A. 标量子查询（子查询结果为单个值）</p><p>B. 列子查询(子查询结果为一列) </p><p>C. 行子查询(子查询结果为一行) </p><p>D. 表子查询(子查询结果为多行多列)</p><p>根据子查询位置，分为： </p><p>A. WHERE之后 </p><p>B. FROM之后 </p><p>C. SELECT之后</p><h3 id="5-6-2-标量子查询"><a href="#5-6-2-标量子查询" class="headerlink" title="5.6.2 标量子查询"></a>5.6.2 标量子查询</h3><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。 常用的操作符：= &lt;&gt; &gt; &gt;= &lt; &lt;= </p><p>案例: </p><p>A. 查询 “销售部” 的所有员工信息 </p><p>完成这个需求时，可以将需求分解为两步：</p><p>①. 查询 “销售部” 部门ID</p><pre><code>select id from dept where name = &#39;销售部&#39;;</code></pre><p>②. 根据 “销售部” 部门ID, 查询员工信息</p><pre><code>select * from emp where dept_id = (select id from dept where name = &#39;销售部&#39;);</code></pre><p>B. 查询在 “方东白” 入职之后的员工信息 </p><p>完成这个需求时，可以将需求分解为两步：</p><p>①. 查询 方东白 的入职日期</p><pre><code>select entrydate from emp where name = &#39;方东白&#39;;</code></pre><p>②. 查询指定入职日期之后入职的员工信息</p><pre><code>select * from emp where entrydate &gt; (select entrydate from emp where name = &#39;方东白&#39;);</code></pre><h3 id="5-6-3-列子查询"><a href="#5-6-3-列子查询" class="headerlink" title="5.6.3 列子查询"></a>5.6.3 列子查询</h3><p>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。</p><p>常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围之内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围之内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><p>案例: </p><p>A. 查询 “销售部” 和 “市场部” 的所有员工信息</p><p>分解为以下两步:</p><p> ①. 查询 “销售部” 和 “市场部” 的部门ID</p><pre><code>select id from dept where name = &#39;销售部&#39; or name = &#39;市场部&#39;;</code></pre><p>②. 根据部门ID, 查询员工信息</p><pre><code>select * from emp where dept_id in (select id from dept where name = &#39;销售部&#39; orname = &#39;市场部&#39;);</code></pre><p>B. 查询比 财务部 所有人工资都高的员工信息</p><p>分解为以下两步: ①. 查询所有 财务部 人员工资</p><pre><code>select id from dept where name = &#39;财务部&#39;;select salary from emp where dept_id = (select id from dept where name = &#39;财务部&#39;);</code></pre><p>②. 比 财务部 所有人工资都高的员工信息</p><pre><code>select * from emp where salary &gt; all ( select salary from emp where dept_id =(select id from dept where name = &#39;财务部&#39;) );</code></pre><p>C. 查询比研发部其中任意一人工资高的员工信息</p><p>分解为以下两步:</p><p>①. 查询研发部所有人工资</p><pre><code>select salary from emp where dept_id = (select id from dept where name = &#39;研发部&#39;);</code></pre><p>②. 比研发部其中任意一人工资高的员工信息</p><pre><code>select * from emp where salary &gt; any ( select salary from emp where dept_id =(select id from dept where name = &#39;研发部&#39;) );</code></pre><h3 id="5-6-4-行子查询"><a href="#5-6-4-行子查询" class="headerlink" title="5.6.4 行子查询"></a>5.6.4 行子查询</h3><p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。</p><p> 常用的操作符：= 、&lt;&gt; 、IN 、NOT IN</p><p>案例: </p><p>A. 查询与 “张无忌” 的薪资及直属领导相同的员工信息 ; </p><p>这个需求同样可以拆解为两步进行: </p><p>①. 查询 “张无忌” 的薪资及直属领导</p><pre><code> select salary, managerid from emp where name = &#39;张无忌&#39;;</code></pre><p>②. 查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;</p><pre><code>select * from emp where (salary,managerid) = (select salary, managerid from empwhere name = &#39;张无忌&#39;);</code></pre><h3 id="5-6-5-表子查询"><a href="#5-6-5-表子查询" class="headerlink" title="5.6.5 表子查询"></a>5.6.5 表子查询</h3><p>子查询返回的结果是多行多列，这种子查询称为表子查询。 </p><p>常用的操作符：IN</p><p>案例: </p><p>A. 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><p> 分解为两步执行:</p><p>①. 查询 “鹿杖客” , “宋远桥” 的职位和薪资</p><pre><code>select job, salary from emp where name = &#39;鹿杖客&#39; or name = &#39;宋远桥&#39;;</code></pre><p>②. 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><pre><code>select * from emp where (job,salary) in ( select job, salary from emp where name =&#39;鹿杖客&#39; or name = &#39;宋远桥&#39; );</code></pre><p>B. 查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息</p><p>分解为两步执行:</p><p>①. 入职日期是 “2006-01-01” 之后的员工信息</p><pre><code>select * from emp where entrydate &gt; &#39;2006-01-01&#39;;</code></pre><p>②. 查询这部分员工, 对应的部门信息;</p><pre><code>select e.*, d.* from (select * from emp where entrydate &gt; &#39;2006-01-01&#39;) e leftjoin dept d on e.dept_id = d.id ;</code></pre><h1 id="6-事务"><a href="#6-事务" class="headerlink" title="6.事务"></a>6.事务</h1><h2 id="6-1-事务简介"><a href="#6-1-事务简介" class="headerlink" title="6.1 事务简介"></a>6.1 事务简介</h2><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>就比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加 1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。</p><p><img src="/mysql-01/image-20230318175145463.png" alt="image-20230318175145463"></p><p>正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四 增加1000, 转账成功 :</p><p><img src="/mysql-01/image-20230318175413465.png" alt="image-20230318175413465"></p><p>异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张 三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了。</p><p><img src="/mysql-01/image-20230318175427146.png" alt="image-20230318175427146"></p><p>为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行 完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。</p><p><img src="/mysql-01/image-20230318175441174.png" alt="image-20230318175441174"></p><p>注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐 式的提交事务。</p><h2 id="6-2-事务操作"><a href="#6-2-事务操作" class="headerlink" title="6.2 事务操作"></a>6.2 事务操作</h2><h3 id="6-2-1-未控制事务"><a href="#6-2-1-未控制事务" class="headerlink" title="6.2.1 未控制事务"></a>6.2.1 未控制事务</h3><p>正常执行</p><p><img src="/mysql-01/image-20230318175558427.png" alt="image-20230318175558427"></p><p> 测试异常情况</p><pre><code>-- 1. 查询张三余额select * from account where name = &#39;张三&#39;;-- 2. 张三的余额减少1000update account set money = money - 1000 where name = &#39;张三&#39;;出错了....-- 3. 李四的余额增加1000update account set money = money + 1000 where name = &#39;李四&#39;;</code></pre><p><img src="/mysql-01/image-20230318175542807.png" alt="image-20230318175542807"></p><p>检查最终的数据情况, 发现数据在操作前后不一致了。</p><h3 id="6-2-2-控制事务一"><a href="#6-2-2-控制事务一" class="headerlink" title="6.2.2 控制事务一"></a>6.2.2 控制事务一</h3><p>1). 查看/设置事务提交方式</p><pre><code>SELECT @@autocommit ;SET @@autocommit = 0 ;</code></pre><p>2). 提交事务</p><pre><code>COMMIT;</code></pre><p>3). 回滚事务</p><pre><code>ROLLBACK;</code></pre><p>注意：上述的这种方式，是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提 交, 此时执行的DML语句都不会提交, 需要手动的执行commit进行提交。</p><h3 id="6-2-3-控制事务二"><a href="#6-2-3-控制事务二" class="headerlink" title="6.2.3 控制事务二"></a>6.2.3 控制事务二</h3><p>1). 开启事务</p><pre><code>START TRANSACTION 或 BEGIN ;</code></pre><p>2). 提交事务</p><pre><code>COMMIT;</code></pre><p>3). 回滚事务</p><pre><code>ROLLBACK;</code></pre><p>转账案例：</p><pre><code>-- 开启事务start transaction-- 1. 查询张三余额select * from account where name = &#39;张三&#39;;-- 2. 张三的余额减少1000update account set money = money - 1000 where name = &#39;张三&#39;;-- 3. 李四的余额增加1000update account set money = money + 1000 where name = &#39;李四&#39;;-- 如果正常执行完毕, 则提交事务commit;-- 如果执行过程中报错, 则回滚事务-- rollback;</code></pre><h3 id="6-3-事务四大特性"><a href="#6-3-事务四大特性" class="headerlink" title="6.3 事务四大特性"></a>6.3 事务四大特性</h3><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 </li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><p><img src="/mysql-01/image-20230318180214740.png" alt="image-20230318180214740"></p><h3 id="6-4-并发事务问题"><a href="#6-4-并发事务问题" class="headerlink" title="6.4 并发事务问题"></a>6.4 并发事务问题</h3><p>1). 赃读：一个事务读到另外一个事务还没有提交的数据。</p><p><img src="/mysql-01/image-20230318180237160.png" alt="image-20230318180237160"></p><p>比如B读取到了A未提交的数据。</p><p>2). 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p><p><img src="/mysql-01/image-20230318180253685.png" alt="image-20230318180253685"></p><p> 事务A两次读取同一条记录，但是读取到的数据却是不一样的。</p><p>3). 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 “幻影”。</p><p><img src="/mysql-01/image-20230318180423731.png" alt="image-20230318180423731"></p><h3 id="6-5-事务隔离级别"><a href="#6-5-事务隔离级别" class="headerlink" title="6.5 事务隔离级别"></a>6.5 事务隔离级别</h3><p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>1). 查看事务隔离级别</p><pre><code>SELECT @@TRANSACTION_ISOLATION;</code></pre><p>2). 设置事务隔离级别</p><pre><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED |READ COMMITTED | REPEATABLE READ | SERIALIZABLE }</code></pre><p>注意：事务隔离级别越高，数据越安全，但是性能越低。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
