<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Feign</title>
      <link href="/feign.html"/>
      <url>/feign.html</url>
      
        <content type="html"><![CDATA[<h1 id="Feign远程调用"><a href="#Feign远程调用" class="headerlink" title="Feign远程调用"></a>Feign远程调用</h1><p>以前利用RestTemplate发起远程调用的代码：</p><p><img src="/feign/image-20210714174814204.png" alt="image-20210714174814204"></p><p>存在下面的问题：</p><p>•代码可读性差，编程体验不统一</p><p>•参数复杂URL难以维护</p><p>Feign是一个声明式的http客户端，官方地址：<a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">https://github.com/OpenFeign/feign</a></p><p>其作用就是帮助我们的实现http请求的发送，解决上面提到的问题。</p><p><img src="/feign/image-20210714174918088.png" alt="image-20210714174918088"></p><h2 id="Feign替代RestTemplate"><a href="#Feign替代RestTemplate" class="headerlink" title="Feign替代RestTemplate"></a>Feign替代RestTemplate</h2><p>Fegin的使用步骤如下：</p><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>我们在order-service服务的pom文件中引入feign的依赖：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2）添加注解"><a href="#2）添加注解" class="headerlink" title="2）添加注解"></a>2）添加注解</h3><p>在order-service的启动类添加注解开启Feign的功能：</p><p><img src="/feign/image-20210714175102524.png" alt="image-20210714175102524"></p><h3 id="3）编写Feign的客户端"><a href="#3）编写Feign的客户端" class="headerlink" title="3）编写Feign的客户端"></a>3）编写Feign的客户端</h3><p>在order-service中新建一个接口，内容如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>order<span class="token punctuation">.</span>client<span class="token punctuation">;</span><span class="token keyword">import</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>order<span class="token punctuation">.</span>pojo<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>openfeign<span class="token punctuation">.</span>FeignClient<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>GetMapping<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>PathVariable<span class="token punctuation">;</span><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span><span class="token string">"userservice"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserClient</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/user/{id}"</span><span class="token punctuation">)</span>    User <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> Long id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p><ul><li>服务名称：userservice</li><li>请求方式：GET</li><li>请求路径：/user/{id}</li><li>请求参数：Long id</li><li>返回值类型：User</li></ul><p>这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</p><h3 id="4）测试"><a href="#4）测试" class="headerlink" title="4）测试"></a>4）测试</h3><p>修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：</p><p><img src="/feign/image-20210714175415087.png" alt="image-20210714175415087"></p><h3 id="5）总结"><a href="#5）总结" class="headerlink" title="5）总结"></a>5）总结</h3><p>使用Feign的步骤：</p><p>① 引入依赖</p><p>② 添加@EnableFeignClients注解</p><p>③ 编写FeignClient接口</p><p>④ 使用FeignClient中定义的方法代替RestTemplate</p><h2 id="2-2-自定义配置"><a href="#2-2-自定义配置" class="headerlink" title="2.2.自定义配置"></a>2.2.自定义配置</h2><p>Feign可以支持很多的自定义配置，如下表所示：</p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.Logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign. Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign. Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。</p><p>下面以日志为例来演示如何自定义配置。</p><h3 id="2-2-1-配置文件方式"><a href="#2-2-1-配置文件方式" class="headerlink" title="2.2.1.配置文件方式"></a>2.2.1.配置文件方式</h3><p>基于配置文件修改feign的日志级别可以针对单个服务：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>    <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>       <span class="token key atrule">userservice</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 针对某个微服务的配置</span>        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> FULL <span class="token comment" spellcheck="true">#  日志级别 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以针对所有服务：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>    <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>       <span class="token key atrule">default</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span>        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> FULL <span class="token comment" spellcheck="true">#  日志级别 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><h3 id="2-2-2-Java代码方式"><a href="#2-2-2-Java代码方式" class="headerlink" title="2.2.2.Java代码方式"></a>2.2.2.Java代码方式</h3><p>也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultFeignConfiguration</span>  <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Logger<span class="token punctuation">.</span>Level <span class="token function">feignLogLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> Logger<span class="token punctuation">.</span>Level<span class="token punctuation">.</span>BASIC<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 日志级别为BASIC</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>defaultConfiguration <span class="token operator">=</span> DefaultFeignConfiguration <span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"userservice"</span><span class="token punctuation">,</span> configuration <span class="token operator">=</span> DefaultFeignConfiguration <span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-3-Feign使用优化"><a href="#2-3-Feign使用优化" class="headerlink" title="2.3.Feign使用优化"></a>2.3.Feign使用优化</h2><p>Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：</p><p>•URLConnection：默认实现，不支持连接池</p><p>•Apache HttpClient ：支持连接池</p><p>•OKHttp：支持连接池</p><p>因此提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。</p><p>这里我们用Apache的HttpClient来演示。</p><p>1）引入依赖</p><p>在order-service的pom文件中引入Apache的HttpClient依赖：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--httpClient的依赖 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.github.openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>feign-httpclient<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）配置连接池</p><p>在order-service的application.yml中添加配置：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>      <span class="token key atrule">default</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># default全局的配置</span>        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> BASIC <span class="token comment" spellcheck="true"># 日志级别，BASIC就是基本的请求和响应信息</span>  <span class="token key atrule">httpclient</span><span class="token punctuation">:</span>    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 开启feign对HttpClient的支持</span>    <span class="token key atrule">max-connections</span><span class="token punctuation">:</span> <span class="token number">200 </span><span class="token comment" spellcheck="true"># 最大的连接数</span>    <span class="token key atrule">max-connections-per-route</span><span class="token punctuation">:</span> <span class="token number">50 </span><span class="token comment" spellcheck="true"># 每个路径的最大连接数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，在FeignClientFactoryBean中的loadBalance方法中打断点：</p><p><img src="/feign/image-20210714185925910.png" alt="image-20210714185925910"></p><p>Debug方式启动order-service服务，可以看到这里的client，底层就是Apache HttpClient：</p><p><img src="/feign/image-20210714190041542.png" alt="image-20210714190041542"></p><p>总结，Feign的优化：</p><p>1.日志级别尽量用basic</p><p>2.使用HttpClient或OKHttp代替URLConnection</p><p>①  引入feign-httpClient依赖</p><p>②  配置文件开启httpClient功能，设置连接池参数</p><h2 id="2-4-最佳实践"><a href="#2-4-最佳实践" class="headerlink" title="2.4.最佳实践"></a>2.4.最佳实践</h2><p>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。</p><p>自习观察可以发现，Feign的客户端与服务提供者的controller代码非常相似：</p><p>feign客户端：</p><p><img src="/feign/image-20210714190542730.png" alt="image-20210714190542730"></p><p>UserController：</p><p><img src="/feign/image-20210714190528450.png" alt="image-20210714190528450"></p><h3 id="2-4-1-继承方式"><a href="#2-4-1-继承方式" class="headerlink" title="2.4.1.继承方式"></a>2.4.1.继承方式</h3><p>一样的代码可以通过继承来共享：</p><p>1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。</p><p>2）Feign客户端和Controller都集成改接口</p><p><img src="/feign/image-20210714190640857.png" alt="image-20210714190640857"></p><p>优点：</p><ul><li>简单</li><li>实现了代码共享</li></ul><p>缺点：</p><ul><li><p>服务提供方、服务消费方紧耦合</p></li><li><p>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解</p></li></ul><h3 id="2-4-2-抽取方式"><a href="#2-4-2-抽取方式" class="headerlink" title="2.4.2.抽取方式"></a>2.4.2.抽取方式</h3><p>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。</p><p>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。</p><p><img src="/feign/image-20210714214041796.png" alt="image-20210714214041796"></p><h3 id="2-4-3-实现基于抽取的最佳实践"><a href="#2-4-3-实现基于抽取的最佳实践" class="headerlink" title="2.4.3.实现基于抽取的最佳实践"></a>2.4.3.实现基于抽取的最佳实践</h3><h4 id="1）抽取"><a href="#1）抽取" class="headerlink" title="1）抽取"></a>1）抽取</h4><p>首先创建一个module，命名为feign-api：</p><p><img src="/feign/image-20210714204557771.png" alt="image-20210714204557771"></p><p>项目结构：</p><p><img src="/feign/image-20210714204656214.png" alt="image-20210714204656214"></p><p>在feign-api中然后引入feign的starter依赖</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中</p><p><img src="/feign/image-20210714205221970.png" alt="image-20210714205221970"></p><h4 id="2）在order-service中使用feign-api"><a href="#2）在order-service中使用feign-api" class="headerlink" title="2）在order-service中使用feign-api"></a>2）在order-service中使用feign-api</h4><p>首先，删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口。</p><p>在order-service的pom文件中中引入feign-api的依赖：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>cn.itcast.demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>feign-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包</p><h4 id="3）重启测试"><a href="#3）重启测试" class="headerlink" title="3）重启测试"></a>3）重启测试</h4><p>重启后，发现服务报错了：</p><p><img src="/feign/image-20210714205623048.png" alt="image-20210714205623048"></p><p>这是因为UserClient现在在cn.itcast.feign.clients包下，</p><p>而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。</p><h4 id="4）解决扫描包问题"><a href="#4）解决扫描包问题" class="headerlink" title="4）解决扫描包问题"></a>4）解决扫描包问题</h4><p>方式一：</p><p>指定Feign应该扫描的包：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token string">"cn.itcast.feign.clients"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方式二：</p><p>指定需要加载的Client接口：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>clients <span class="token operator">=</span> <span class="token punctuation">{</span>UserClient<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gateway</title>
      <link href="/gateway.html"/>
      <url>/gateway.html</url>
      
        <content type="html"><![CDATA[<h1 id="Gateway服务网关"><a href="#Gateway服务网关" class="headerlink" title="Gateway服务网关"></a>Gateway服务网关</h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><h2 id="为什么需要网关"><a href="#为什么需要网关" class="headerlink" title="为什么需要网关"></a>为什么需要网关</h2><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。</p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p>架构图：</p><p><img src="/gateway/image-20210714210131152.png" alt="image-20210714210131152"></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="gateway快速入门"><a href="#gateway快速入门" class="headerlink" title="gateway快速入门"></a>gateway快速入门</h2><p>下面，我们就演示下网关的基本路由功能。基本步骤如下：</p><ol><li>创建SpringBoot工程gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><h3 id="1）创建gateway服务，引入依赖"><a href="#1）创建gateway服务，引入依赖" class="headerlink" title="1）创建gateway服务，引入依赖"></a>1）创建gateway服务，引入依赖</h3><p>创建服务：</p><p><img src="/gateway/image-20210714210919458.png" alt="image-20210714210919458"></p><p>引入依赖：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--网关--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-gateway<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--nacos服务发现依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2）编写启动类"><a href="#2）编写启动类" class="headerlink" title="2）编写启动类"></a>2）编写启动类</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>gateway<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>SpringBootApplication<span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GatewayApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>GatewayApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3）编写基础配置和路由规则"><a href="#3）编写基础配置和路由规则" class="headerlink" title="3）编写基础配置和路由规则"></a>3）编写基础配置和路由规则</h3><p>创建application.yml文件，内容如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10010 </span><span class="token comment" spellcheck="true"># 网关端口</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> gateway <span class="token comment" spellcheck="true"># 服务名称</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848 </span><span class="token comment" spellcheck="true"># nacos地址</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 网关路由配置</span>        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> user<span class="token punctuation">-</span>service <span class="token comment" spellcheck="true"># 路由id，自定义，只要唯一即可</span>          <span class="token comment" spellcheck="true"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span>          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//userservice <span class="token comment" spellcheck="true"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span>          <span class="token key atrule">predicates</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 路由断言，也就是判断请求是否符合路由规则的条件</span>            <span class="token punctuation">-</span> Path=/user/** <span class="token comment" spellcheck="true"># 这个是按照路径匹配，只要以/user/开头就符合要求</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>本例中，将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p><h3 id="4）重启测试"><a href="#4）重启测试" class="headerlink" title="4）重启测试"></a>4）重启测试</h3><p>重启网关，访问<a href="http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：" target="_blank" rel="noopener">http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：</a></p><p><img src="/gateway/image-20210714211908341.png" alt="image-20210714211908341"></p><h3 id="5）网关路由的流程图"><a href="#5）网关路由的流程图" class="headerlink" title="5）网关路由的流程图"></a>5）网关路由的流程图</h3><p>整个访问的流程如下：</p><p><img src="/gateway/image-20210714211742956.png" alt="image-20210714211742956"></p><p>总结：</p><p>网关搭建步骤：</p><ol><li><p>创建项目，引入nacos服务发现和gateway依赖</p></li><li><p>配置application.yml，包括服务基本信息、nacos地址、路由</p></li></ol><p>路由配置包括：</p><ol><li><p>路由id：路由的唯一标示</p></li><li><p>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</p></li><li><p>路由断言（predicates）：判断路由的规则，</p></li><li><p>路由过滤器（filters）：对请求或响应做处理</p></li></ol><h2 id="断言工厂"><a href="#断言工厂" class="headerlink" title="断言工厂"></a>断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p><p>例如Path=/user/**是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来</p><p>处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>-  After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>-  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>-  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie=chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header=X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>-  Host=<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method=GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path=/red/{segment},/blue/**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query=name, Jack或者-  Query=name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr=192.168.1.1/24</td></tr><tr><td>Weight</td><td>权重处理</td><td></td></tr></tbody></table><h2 id="过滤器工厂"><a href="#过滤器工厂" class="headerlink" title="过滤器工厂"></a>过滤器工厂</h2><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p><p><img src="/gateway/image-20210714212312871.png" alt="image-20210714212312871"></p><h3 id="3-4-1-路由过滤器的种类"><a href="#3-4-1-路由过滤器的种类" class="headerlink" title="3.4.1.路由过滤器的种类"></a>3.4.1.路由过滤器的种类</h3><p>Spring提供了31种不同的路由过滤器工厂。例如：</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr><tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr></tbody></table><h3 id="3-4-2-请求头过滤器"><a href="#3-4-2-请求头过滤器" class="headerlink" title="3.4.2.请求头过滤器"></a>3.4.2.请求头过滤器</h3><p>下面以AddRequestHeader 为例。</p><blockquote><p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!</p></blockquote><p>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> user<span class="token punctuation">-</span>service         <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//userservice         <span class="token key atrule">predicates</span><span class="token punctuation">:</span>         <span class="token punctuation">-</span> Path=/user/**         <span class="token key atrule">filters</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 过滤器</span>        <span class="token punctuation">-</span> AddRequestHeader=Truth<span class="token punctuation">,</span> Itcast is freaking awesome! <span class="token comment" spellcheck="true"># 添加请求头</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。</p><h3 id="3-4-3-默认过滤器"><a href="#3-4-3-默认过滤器" class="headerlink" title="3.4.3.默认过滤器"></a>3.4.3.默认过滤器</h3><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token key atrule">routes</span><span class="token punctuation">:</span>      <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> user<span class="token punctuation">-</span>service         <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//userservice         <span class="token key atrule">predicates</span><span class="token punctuation">:</span>         <span class="token punctuation">-</span> Path=/user/**      <span class="token key atrule">default-filters</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 默认过滤项</span>      <span class="token punctuation">-</span> AddRequestHeader=Truth<span class="token punctuation">,</span> Itcast is freaking awesome! <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-4-总结"><a href="#3-4-4-总结" class="headerlink" title="3.4.4.总结"></a>3.4.4.总结</h3><p>过滤器的作用是什么？</p><p>① 对路由的请求或响应做加工处理，比如添加请求头</p><p>② 配置在路由下的过滤器只对当前路由的请求生效</p><p>defaultFilters的作用是什么？</p><p>① 对所有路由都生效的过滤器</p><h2 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h2><p>上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</p><h3 id="3-5-1-全局过滤器作用"><a href="#3-5-1-全局过滤器作用" class="headerlink" title="3.5.1.全局过滤器作用"></a>3.5.1.全局过滤器作用</h3><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</p><p>定义方式是实现GlobalFilter接口。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">GlobalFilter</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     *  处理当前请求，有必要的话通过{@link GatewayFilterChain}将请求交给下一个过滤器处理     *     * @param exchange 请求上下文，里面可以获取Request、Response等信息     * @param chain 用来把请求委托给下一个过滤器      * @return {@code Mono&lt;Void>} 返回标示当前过滤器业务结束     */</span>    Mono<span class="token operator">&lt;</span>Void<span class="token operator">></span> <span class="token function">filter</span><span class="token punctuation">(</span>ServerWebExchange exchange<span class="token punctuation">,</span> GatewayFilterChain chain<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在filter中编写自定义逻辑，可以实现下列功能：</p><ul><li>登录状态判断</li><li>权限校验</li><li>请求限流等</li></ul><h3 id="3-5-2-自定义全局过滤器"><a href="#3-5-2-自定义全局过滤器" class="headerlink" title="3.5.2.自定义全局过滤器"></a>3.5.2.自定义全局过滤器</h3><p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p><ul><li><p>参数中是否有authorization，</p></li><li><p>authorization参数值是否为admin</p></li></ul><p>如果同时满足则放行，否则拦截</p><p>实现：</p><p>在gateway中定义一个过滤器：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>gateway<span class="token punctuation">.</span>filters<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>gateway<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>GatewayFilterChain<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>gateway<span class="token punctuation">.</span>filter<span class="token punctuation">.</span>GlobalFilter<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Order<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpStatus<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Component<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>server<span class="token punctuation">.</span>ServerWebExchange<span class="token punctuation">;</span><span class="token keyword">import</span> reactor<span class="token punctuation">.</span>core<span class="token punctuation">.</span>publisher<span class="token punctuation">.</span>Mono<span class="token punctuation">;</span><span class="token annotation punctuation">@Order</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AuthorizeFilter</span> <span class="token keyword">implements</span> <span class="token class-name">GlobalFilter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Mono<span class="token operator">&lt;</span>Void<span class="token operator">></span> <span class="token function">filter</span><span class="token punctuation">(</span>ServerWebExchange exchange<span class="token punctuation">,</span> GatewayFilterChain chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1.获取请求参数</span>        MultiValueMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> params <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQueryParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2.获取authorization参数</span>        String auth <span class="token operator">=</span> params<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token string">"authorization"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.校验</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>auth<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 放行</span>            <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 4.拦截</span>        <span class="token comment" spellcheck="true">// 4.1.禁止访问，设置状态码</span>        exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setStatusCode</span><span class="token punctuation">(</span>HttpStatus<span class="token punctuation">.</span>FORBIDDEN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 4.2.结束处理</span>        <span class="token keyword">return</span> exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-3-过滤器执行顺序"><a href="#3-5-3-过滤器执行顺序" class="headerlink" title="3.5.3.过滤器执行顺序"></a>3.5.3.过滤器执行顺序</h3><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p><p><img src="/gateway/image-20210714214228409.png" alt="image-20210714214228409"></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li><li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li></ul><p>详细内容，可以查看源码：</p><p><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code>方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。</p><p><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code>方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链</p><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><h3 id="3-6-1-什么是跨域问题"><a href="#3-6-1-什么是跨域问题" class="headerlink" title="3.6.1.什么是跨域问题"></a>3.6.1.什么是跨域问题</h3><p>跨域：域名不一致就是跨域，主要包括：</p><ul><li><p>域名不同： <a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a> 和 <a href="http://www.taobao.org" target="_blank" rel="noopener">www.taobao.org</a> 和 <a href="http://www.jd.com" target="_blank" rel="noopener">www.jd.com</a> 和 miaosha.jd.com</p></li><li><p>域名相同，端口不同：localhost:8080和localhost8081</p></li></ul><p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</p><p>解决方案：CORS可以查看<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><h3 id="3-6-3-解决跨域问题"><a href="#3-6-3-解决跨域问题" class="headerlink" title="3.6.3.解决跨域问题"></a>3.6.3.解决跨域问题</h3><p>在gateway服务的application.yml文件中，添加下面的配置：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 。。。</span>      <span class="token key atrule">globalcors</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 全局的跨域处理</span>        <span class="token key atrule">add-to-simple-url-handler-mapping</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 解决options请求被拦截问题</span>        <span class="token key atrule">corsConfigurations</span><span class="token punctuation">:</span>          '<span class="token punctuation">[</span>/**<span class="token punctuation">]</span>'<span class="token punctuation">:</span>            <span class="token key atrule">allowedOrigins</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 允许哪些网站的跨域请求 </span>              <span class="token punctuation">-</span> <span class="token string">"http://localhost:8090"</span>            <span class="token key atrule">allowedMethods</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 允许的跨域ajax的请求方式</span>              <span class="token punctuation">-</span> <span class="token string">"GET"</span>              <span class="token punctuation">-</span> <span class="token string">"POST"</span>              <span class="token punctuation">-</span> <span class="token string">"DELETE"</span>              <span class="token punctuation">-</span> <span class="token string">"PUT"</span>              <span class="token punctuation">-</span> <span class="token string">"OPTIONS"</span>            <span class="token key atrule">allowedHeaders</span><span class="token punctuation">:</span> <span class="token string">"*"</span> <span class="token comment" spellcheck="true"># 允许在请求中携带的头信息</span>            <span class="token key atrule">allowCredentials</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 是否允许携带cookie</span>            <span class="token key atrule">maxAge</span><span class="token punctuation">:</span> <span class="token number">360000 </span><span class="token comment" spellcheck="true"># 这次跨域检测的有效期</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos</title>
      <link href="/nacos.html"/>
      <url>/nacos.html</url>
      
        <content type="html"><![CDATA[<h1 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h1><h2 id="认识和安装Nacos"><a href="#认识和安装Nacos" class="headerlink" title="认识和安装Nacos"></a>认识和安装Nacos</h2><p><a href="https://nacos.io/" target="_blank" rel="noopener">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener">SpringCloud</a>中的一个组件。相比<a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">Eureka</a>功能更加丰富，在国内受欢迎程度较高。</p><p><img src="/nacos/image-20210713230444308.png" alt="image-20210713230444308"></p><h3 id="安装Nacos"><a href="#安装Nacos" class="headerlink" title="安装Nacos"></a>安装Nacos</h3><p>GitHub主页：<a href="https://github.com/alibaba/nacos" target="_blank" rel="noopener">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">https://github.com/alibaba/nacos/releases</a></p><p>解压</p><p><img src="/nacos/image-20210402161843337.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><h4 id="端口配置"><a href="#端口配置" class="headerlink" title="端口配置"></a>端口配置</h4><p>Nacos的默认端口是8848，如果电脑上的其它进程占用了8848端口，请先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p><p><img src="/nacos/image-20210402162008280.png" alt="image-20210402162008280"></p><p>修改其中的内容：</p><p><img src="/nacos/image-20210402162251093.png" alt="image-20210402162251093"></p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>启动非常简单，进入bin目录，结构如下：</p><p><img src="/nacos/image-20210402162350977.png" alt="image-20210402162350977"></p><p>然后执行命令即可：</p><ul><li><p>windows命令：</p><pre><code>startup.cmd -m standalone</code></pre></li></ul><p>执行后的效果如图：</p><p><img src="/nacos/image-20210402162526774.png" alt="image-20210402162526774"></p><h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos即可：" target="_blank" rel="noopener">http://127.0.0.1:8848/nacos即可：</a></p><p><img src="/nacos/image-20210402162630427.png" alt="image-20210402162630427"></p><p>默认的账号和密码都是nacos，进入后：</p><p><img src="/nacos/image-20210402162709515.png" alt="image-20210402162709515"></p><p>Linux和Windows差不多</p><p>就是下载安装包解压</p><p>Nacos依赖于JDK运行所以Linux上也需要安装JDK才行。</p><p>tar -xvf nacos-server-1.4.1.tar.gz</p><p><img src="/nacos/image-20210402164414827.png" alt="image-20210402164414827"></p><p>在nacos/bin目录中，输入命令启动Nacos：</p><pre class="line-numbers language-sh"><code class="language-sh">sh startup.sh -m standalone<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Nacos的依赖"><a href="#Nacos的依赖" class="headerlink" title="Nacos的依赖"></a>Nacos的依赖</h2><p>父工程：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-alibaba-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- nacos客户端依赖包 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="服务注册到nacos"><a href="#服务注册到nacos" class="headerlink" title="服务注册到nacos"></a>服务注册到nacos</h2><p>Nacos是SpringCloudAlibaba的组件，而SpringCloudAlibaba也遵循SpringCloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。</p><p>主要差异在于：</p><ul><li>依赖不同</li><li>服务地址不同</li></ul><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-alibaba-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在user-service和order-service中的pom文件中引入nacos-discovery依赖：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：不要忘了注释掉eureka的依赖。</p><h3 id="配置nacos地址"><a href="#配置nacos地址" class="headerlink" title="配置nacos地址"></a>配置nacos地址</h3><p>在user-service和order-service的application.yml中添加nacos地址：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：不要忘了注释掉eureka的地址</p></blockquote><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>重启微服务后，登录nacos管理页面，可以看到微服务信息：</p><p><img src="/nacos/image-20210713231439607.png" alt="image-20210713231439607"></p><h2 id="服务分级存储模型"><a href="#服务分级存储模型" class="headerlink" title="服务分级存储模型"></a>服务分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos就将同一机房内的实例 划分为一个<strong>集群</strong>。</p><p>也就是说，user-service是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p><p><img src="/nacos/image-20210713232522531.png" alt="image-20210713232522531"></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p><p><img src="/nacos/image-20210713232658928.png" alt="image-20210713232658928"></p><p>杭州机房内的order-service应该优先访问同机房的user-service。</p><h3 id="5-3-1-给user-service配置集群"><a href="#5-3-1-给user-service配置集群" class="headerlink" title="5.3.1.给user-service配置集群"></a>5.3.1.给user-service配置集群</h3><p>修改user-service的application.yml文件，添加集群配置：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>        <span class="token key atrule">cluster-name</span><span class="token punctuation">:</span> HZ <span class="token comment" spellcheck="true"># 集群名称</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启两个user-service实例后，我们可以在nacos控制台看到下面结果：</p><p><img src="/nacos/image-20210713232916215.png" alt="image-20210713232916215"></p><p>我们再次复制一个user-service启动配置，添加属性：</p><pre class="line-numbers language-sh"><code class="language-sh">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置如图所示：</p><p><img src="/nacos/image-20210713233528982.png" alt="image-20210713233528982"></p><p>启动UserApplication3后再次查看nacos控制台：</p><p><img src="/nacos/image-20210713233727923.png" alt="image-20210713233727923"></p><h3 id="同集群优先的负载均衡"><a href="#同集群优先的负载均衡" class="headerlink" title="同集群优先的负载均衡"></a>同集群优先的负载均衡</h3><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p><p>因此Nacos中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p><p>1）给order-service配置集群信息</p><p>修改order-service的application.yml文件，添加集群配置：</p><pre class="line-numbers language-sh"><code class="language-sh">spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        cluster-name: HZ # 集群名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）修改负载均衡规则</p><p>修改order-service的application.yml文件，修改负载均衡规则：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">userservice</span><span class="token punctuation">:</span>  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.alibaba.cloud.nacos.ribbon.NacosRule <span class="token comment" spellcheck="true"># 负载均衡规则 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="权重配置"><a href="#权重配置" class="headerlink" title="权重配置"></a>权重配置</h2><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p><p>但默认情况下NacosRule是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。</p><p>在nacos控制台，找到user-service的实例列表，点击编辑，即可修改权重：</p><p><img src="/nacos/image-20210713235133225.png" alt="image-20210713235133225"></p><p>在弹出的编辑窗口，修改权重：</p><p><img src="/nacos/image-20210713235235219.png" alt="image-20210713235235219"></p><blockquote><p><strong>注意</strong>：如果权重修改为0，则该实例永远不会被访问</p></blockquote><h2 id="环境隔离"><a href="#环境隔离" class="headerlink" title="环境隔离"></a>环境隔离</h2><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><p><img src="/nacos/image-20210714000101516.png" alt="image-20210714000101516"></p><h3 id="5-5-1-创建namespace"><a href="#5-5-1-创建namespace" class="headerlink" title="5.5.1.创建namespace"></a>5.5.1.创建namespace</h3><p>默认情况下，所有service、data、group都在同一个namespace，名为public：</p><p><img src="/nacos/image-20210714000414781.png" alt="image-20210714000414781"></p><p>我们可以点击页面新增按钮，添加一个namespace：</p><p><img src="/nacos/image-20210714000440143.png" alt="image-20210714000440143"></p><p>然后，填写表单：</p><p><img src="/nacos/image-20210714000505928.png" alt="image-20210714000505928"></p><p>就能在页面看到一个新的namespace：</p><p><img src="/nacos/image-20210714000522913.png" alt="image-20210714000522913"></p><h3 id="给微服务配置namespace"><a href="#给微服务配置namespace" class="headerlink" title="给微服务配置namespace"></a>给微服务配置namespace</h3><p>给微服务配置namespace只能通过修改配置来实现。</p><p>例如，修改order-service的application.yml文件：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>        <span class="token key atrule">cluster-name</span><span class="token punctuation">:</span> HZ        <span class="token key atrule">namespace</span><span class="token punctuation">:</span> 492a7d5d<span class="token punctuation">-</span>237b<span class="token punctuation">-</span>46a1<span class="token punctuation">-</span>a99a<span class="token punctuation">-</span>fa8e98e4b0f9 <span class="token comment" spellcheck="true"># 命名空间，填ID</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启order-service后，访问控制台，可以看到下面的结果：</p><p><img src="/nacos/image-20210714000830703.png" alt="image-20210714000830703"></p><p><img src="/nacos/image-20210714000837140.png" alt="image-20210714000837140"></p><p>此时访问order-service，因为namespace不同，会导致找不到userservice，控制台会报错：</p><p><img src="/nacos/image-20210714000941256.png" alt="image-20210714000941256"></p><h2 id="Nacos与Eureka的区别"><a href="#Nacos与Eureka的区别" class="headerlink" title="Nacos与Eureka的区别"></a>Nacos与Eureka的区别</h2><p>Nacos的服务实例分为两种l类型：</p><ul><li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p>配置一个服务实例为永久实例：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>        <span class="token key atrule">ephemeral</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true"># 设置为非临时实例</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Nacos和Eureka整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p><p><img src="/nacos/image-20210714001728017.png" alt="image-20210714001728017"></p><ul><li><p>Nacos与eureka的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p>Nacos与Eureka的区别</p><ul><li>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li></ul><h2 id="Nacos的服务注册表结构"><a href="#Nacos的服务注册表结构" class="headerlink" title="Nacos的服务注册表结构"></a>Nacos的服务注册表结构</h2><p>Nacos采用了数据的分级存储模型，最外层是Namespace，用来隔离环境。然后是Group，用来对服务分组。接下来就是服务（Service）了，一个服务包含多个实例，但是可能处于不同机房，因此Service下有多个集群（Cluster），Cluster下是不同的实例（Instance）。</p><p>对应到Java代码中，Nacos采用了一个多层的Map来表示。结构为Map&lt;String, Map&lt;String, Service&gt;&gt;，其中最外层Map的key就是namespaceId，值是一个Map。内层Map的key是group拼接serviceName，值是Service对象。Service对象内部又是一个Map，key是集群名称，值是Cluster对象。而Cluster对象内部维护了Instance的集合。</p><p><img src="/nacos/image-20210925215305446.png" alt="image-20210925215305446"></p><h2 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h2><h2 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h2><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</p><p><img src="/nacos/image-20210714164426792.png" alt="image-20210714164426792"></p><p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p><h3 id="在nacos中添加配置文件"><a href="#在nacos中添加配置文件" class="headerlink" title="在nacos中添加配置文件"></a>在nacos中添加配置文件</h3><p>如何在nacos中管理配置呢？</p><p><img src="/nacos/image-20210714164742924.png" alt="image-20210714164742924"></p><p>然后在弹出的表单中，填写配置信息：</p><p><img src="/nacos/image-20210714164856664.png" alt="image-20210714164856664"></p><blockquote><p>注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p></blockquote><h3 id="从微服务拉取配置"><a href="#从微服务拉取配置" class="headerlink" title="从微服务拉取配置"></a>从微服务拉取配置</h3><p>微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。</p><p>但如果尚未读取application.yml，又如何得知nacos地址呢？</p><p>因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取，流程如下：</p><p><img src="/nacos/L0iFYNF.png" alt="img"></p><p>1）引入nacos-config依赖</p><p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--nacos配置管理依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-alibaba-nacos-config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2）添加bootstrap.yaml</p><p>然后，在user-service中添加一个bootstrap.yaml文件，内容如下：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> userservice <span class="token comment" spellcheck="true"># 服务名称</span>  <span class="token key atrule">profiles</span><span class="token punctuation">:</span>    <span class="token key atrule">active</span><span class="token punctuation">:</span> dev <span class="token comment" spellcheck="true">#开发环境，这里是dev </span>  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848 </span><span class="token comment" spellcheck="true"># Nacos地址</span>      <span class="token key atrule">config</span><span class="token punctuation">:</span>        <span class="token key atrule">file-extension</span><span class="token punctuation">:</span> yaml <span class="token comment" spellcheck="true"># 文件后缀名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>spring:  application:    name: media-api //服务名  cloud:    nacos:      server-addr: 192.168.101.65:8848 //nacos的地址      discovery:         namespace: devXueCheng //服务发现的命名空间        group: xuecheng-plus-project //服务发现的组      config:        namespace: devXueCheng         group: xuecheng-plus-project        file-extension: yaml        refresh-enabled: true        extension-configs: //扩展的配置          - data-id: media-service-${spring.profiles.active}.yaml            group: xuecheng-plus-project            refresh: true        shared-configs:          - data-id: swagger-${spring.profiles.active}.yaml            group: xuecheng-plus-common            refresh: true          - data-id: logging-${spring.profiles.active}.yaml            group: xuecheng-plus-common            refresh: true  profiles:    active: dev  //开发</code></pre><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="/nacos/image-20210714174623557.png" alt="image-20210714174623557"></p><p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据</p><p><code>${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}</code>作为文件id，来读取配置。</p><p>本例中，就是去读取<code>userservice-dev.yaml</code>：</p><p><img src="/nacos/image-20210714170845901.png" alt="image-20210714170845901"></p><p>3）读取nacos配置</p><p>在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置：</p><p><img src="/nacos/image-20210714170337448.png" alt="image-20210714170337448"></p><p>完整代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>user<span class="token punctuation">.</span>web<span class="token punctuation">;</span><span class="token keyword">import</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>user<span class="token punctuation">.</span>pojo<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>user<span class="token punctuation">.</span>service<span class="token punctuation">.</span>UserService<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Slf4j<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Value<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>LocalDateTime<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>format<span class="token punctuation">.</span>DateTimeFormatter<span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${pattern.dateformat}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String dateformat<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"now"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>DateTimeFormatter<span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span>dateformat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// ...略</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在页面访问，可以看到效果：</p><p><img src="/nacos/image-20210714170449612.png" alt="image-20210714170449612"></p><h2 id="1-2-配置热更新"><a href="#1-2-配置热更新" class="headerlink" title="1.2.配置热更新"></a>1.2.配置热更新</h2><p>最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p><p>要实现配置热更新，可以使用两种方式：</p><h3 id="1-2-1-方式一"><a href="#1-2-1-方式一" class="headerlink" title="1.2.1.方式一"></a>1.2.1.方式一</h3><p>在@Value注入的变量所在类上添加注解@RefreshScope：</p><p><img src="/nacos/image-20210714171036335.png" alt="image-20210714171036335"></p><h3 id="1-2-2-方式二"><a href="#1-2-2-方式二" class="headerlink" title="1.2.2.方式二"></a>1.2.2.方式二</h3><p>使用@ConfigurationProperties注解代替@Value注解。</p><p>在user-service服务中，添加一个类，读取patterrn.dateformat属性：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>user<span class="token punctuation">.</span>config<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>Data<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>context<span class="token punctuation">.</span>properties<span class="token punctuation">.</span>ConfigurationProperties<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Component<span class="token punctuation">;</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"pattern"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PatternProperties</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String dateformat<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在UserController中使用这个类代替@Value：</p><p><img src="/nacos/image-20210714171316124.png" alt="image-20210714171316124"></p><p>完整代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>user<span class="token punctuation">.</span>web<span class="token punctuation">;</span><span class="token keyword">import</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>user<span class="token punctuation">.</span>config<span class="token punctuation">.</span>PatternProperties<span class="token punctuation">;</span><span class="token keyword">import</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>user<span class="token punctuation">.</span>pojo<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> cn<span class="token punctuation">.</span>itcast<span class="token punctuation">.</span>user<span class="token punctuation">.</span>service<span class="token punctuation">.</span>UserService<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Slf4j<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>GetMapping<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>PathVariable<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RequestMapping<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RestController<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>LocalDateTime<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>format<span class="token punctuation">.</span>DateTimeFormatter<span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> PatternProperties patternProperties<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"now"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>DateTimeFormatter<span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span>patternProperties<span class="token punctuation">.</span><span class="token function">getDateformat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 略</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-配置共享"><a href="#1-3-配置共享" class="headerlink" title="1.3.配置共享"></a>1.3.配置共享</h2><p>其实微服务启动时，会去nacos读取多个配置文件，例如：</p><ul><li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</p></li><li><p><code>[spring.application.name].yaml</code>，例如：userservice.yaml</p></li></ul><p>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。</p><p>下面我们通过案例来测试配置共享</p><h3 id="1）添加一个环境共享配置"><a href="#1）添加一个环境共享配置" class="headerlink" title="1）添加一个环境共享配置"></a>1）添加一个环境共享配置</h3><p>我们在nacos中添加一个userservice.yaml文件：</p><p><img src="/nacos/image-20210714173233650.png" alt="image-20210714173233650"></p><h3 id="2）在user-service中读取共享配置"><a href="#2）在user-service中读取共享配置" class="headerlink" title="2）在user-service中读取共享配置"></a>2）在user-service中读取共享配置</h3><p>在user-service服务中，修改PatternProperties类，读取新添加的属性：</p><p><img src="/nacos/image-20210714173324231.png" alt="image-20210714173324231"></p><p>在user-service服务中，修改UserController，添加一个方法：</p><p><img src="/nacos/image-20210714173721309.png" alt="image-20210714173721309"></p><h3 id="3）运行两个UserApplication，使用不同的profile"><a href="#3）运行两个UserApplication，使用不同的profile" class="headerlink" title="3）运行两个UserApplication，使用不同的profile"></a>3）运行两个UserApplication，使用不同的profile</h3><p>修改UserApplication2这个启动项，改变其profile值：</p><p><img src="/nacos/image-20210714173538538.png" alt="image-20210714173538538"></p><p><img src="/nacos/image-20210714173519963.png" alt="image-20210714173519963"></p><p>这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。</p><p>启动UserApplication和UserApplication2</p><p>访问<a href="http://localhost:8081/user/prop，结果：" target="_blank" rel="noopener">http://localhost:8081/user/prop，结果：</a></p><p><img src="/nacos/image-20210714174313344.png" alt="image-20210714174313344"></p><p>访问<a href="http://localhost:8082/user/prop，结果：" target="_blank" rel="noopener">http://localhost:8082/user/prop，结果：</a></p><p><img src="/nacos/image-20210714174424818.png" alt="image-20210714174424818"></p><p>可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。</p><h3 id="4）配置共享的优先级"><a href="#4）配置共享的优先级" class="headerlink" title="4）配置共享的优先级"></a>4）配置共享的优先级</h3><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="/nacos/image-20210714174623557.png" alt="image-20210714174623557"></p><h2 id="Nacos的服务注册表结构-1"><a href="#Nacos的服务注册表结构-1" class="headerlink" title="Nacos的服务注册表结构"></a>Nacos的服务注册表结构</h2><p>Nacos采用了数据的分级存储模型，最外层是Namespace，用来隔离环境。然后是Group，用来对服务分组。接下来就是服务（Service）了，一个服务包含多个实例，但是可能处于不同机房，因此Service下有多个集群（Cluster），Cluster下是不同的实例（Instance）。</p><p>对应到Java代码中，Nacos采用了一个多层的Map来表示。结构为Map&lt;String, Map&lt;String, Service&gt;&gt;，其中最外层Map的key就是namespaceId，值是一个Map。内层Map的key是group拼接serviceName，值是Service对象。Service对象内部又是一个Map，key是集群名称，值是Cluster对象。而Cluster对象内部维护了Instance的集合。</p><p>如图：</p><p><img src="/nacos/image-20210925215305446-1679578574632.png" alt="image-20210925215305446"></p><h2 id="Nacos如何支撑阿里内部数十万服务注册压力"><a href="#Nacos如何支撑阿里内部数十万服务注册压力" class="headerlink" title="Nacos如何支撑阿里内部数十万服务注册压力"></a>Nacos如何支撑阿里内部数十万服务注册压力</h2><p>Nacos内部接收到注册的请求时，不会立即写数据，而是将服务注册的任务放入一个阻塞队列就立即响应给客户端。然后利用线程池读取阻塞队列中的任务，异步来完成实例更新，从而提高并发写能力。</p><h2 id="Nacos如何避免并发读写冲突问题"><a href="#Nacos如何避免并发读写冲突问题" class="headerlink" title="Nacos如何避免并发读写冲突问题"></a>Nacos如何避免并发读写冲突问题</h2><p>Nacos在更新实例列表时，会采用CopyOnWrite技术，首先将旧的实例列表拷贝一份，然后更新拷贝的实例列表，再用更新后的实例列表来覆盖旧的实例列表。</p><p>这样在更新的过程中，就不会对读实例列表的请求产生影响，也不会出现脏读问题了。</p><h2 id="Nacos与Eureka的区别有哪些？"><a href="#Nacos与Eureka的区别有哪些？" class="headerlink" title="Nacos与Eureka的区别有哪些？"></a>Nacos与Eureka的区别有哪些？</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ribbon-LoadBalance</title>
      <link href="/ribbon-loadbalance.html"/>
      <url>/ribbon-loadbalance.html</url>
      
        <content type="html"><![CDATA[<h1 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h1><h2 id="负载均衡原理"><a href="#负载均衡原理" class="headerlink" title="负载均衡原理"></a>负载均衡原理</h2><p>SpringCloud底层其实是利用了一个名为Ribbon的组件，来实现负载均衡功能的。</p><p><img src="/ribbon-loadbalance/image-20210713224517686.png" alt="image-20210713224517686"></p><h2 id="源码跟踪"><a href="#源码跟踪" class="headerlink" title="源码跟踪"></a>源码跟踪</h2><p>为什么只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p><p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p><h3 id="1-LoadBalancerIntercepor"><a href="#1-LoadBalancerIntercepor" class="headerlink" title="1,LoadBalancerIntercepor"></a>1,LoadBalancerIntercepor</h3><p><img src="/ribbon-loadbalance/1525620483637.png" alt="1525620483637"></p><p>可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求uri，本例中就是 <a href="http://user-service/user/8" target="_blank" rel="noopener">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：获取uri路径的主机名，其实就是服务id，<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务id，和用户请求。</li></ul><p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型。</p><h3 id="2-LoadBalancerClient"><a href="#2-LoadBalancerClient" class="headerlink" title="2,LoadBalancerClient"></a>2,LoadBalancerClient</h3><p><img src="/ribbon-loadbalance/1525620787090.png" alt="1525620787090"></p><ul><li>getLoadBalancer(serviceId)：根据服务id获取ILoadBalancer，而ILoadBalancer会拿着服务id去eureka中获取服务列表并保存起来。</li><li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8082端口的服务</li></ul><p>放行后，再次访问并跟踪，发现获取的是8081</p><p><img src="/ribbon-loadbalance/1525620835911.png" alt="1525620835911"></p><p>果然实现了负载均衡。</p><h3 id="3-负载均衡策略IRule"><a href="#3-负载均衡策略IRule" class="headerlink" title="3,负载均衡策略IRule"></a>3,负载均衡策略IRule</h3><p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p><p><img src="/ribbon-loadbalance/1525620835911-1679574717984.png" alt="1525620835911"></p><p>继续跟踪</p><p><img src="/ribbon-loadbalance/1544361421671.png" alt="1544361421671"></p><p>继续跟踪源码chooseServer方法，发现这么一段代码：</p><p><img src="/ribbon-loadbalance/1525622652849.png" alt="1525622652849"></p><p>看看这个rule是谁：</p><p><img src="/ribbon-loadbalance/1525622699666.png" alt="1525622699666"></p><p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍</p><p><img src="/ribbon-loadbalance/1525622754316.png" alt="1525622754316"></p><p>轮询的意思</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SpringCloudRibbon的底层采用了一个拦截器，拦截了RestTemplate发出的请求，对地址做了修改。用一幅图来总结一下：</p><p><img src="/ribbon-loadbalance/image-20210713224724673.png" alt="image-20210713224724673"></p><p>基本流程如下：</p><ul><li>拦截我们的RestTemplate请求<a href="http://userservice/user/1" target="_blank" rel="noopener">http://userservice/user/1</a></li><li>RibbonLoadBalancerClient会从请求url中获取服务名称，也就是user-service</li><li>DynamicServerListLoadBalancer根据user-service到eureka拉取服务列表</li><li>eureka返回列表，localhost:8081、localhost:8082</li><li>IRule利用内置负载均衡规则，从列表中选择一个，例如localhost:8081</li><li>RibbonLoadBalancerClient修改请求地址，用localhost:8081替代userservice，得到<a href="http://localhost:8081/user/1，发起真实请求" target="_blank" rel="noopener">http://localhost:8081/user/1，发起真实请求</a></li></ul><h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><h3 id="负载均衡策略-1"><a href="#负载均衡策略-1" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>负载均衡的规则都定义在IRule接口中，而IRule有很多不同的实现类：</p><p><img src="/ribbon-loadbalance/image-20210713225653000.png" alt="image-20210713225653000"></p><p>不同规则的含义如下：</p><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略：   （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。  （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientname>.<clientconfignamespace>.ActiveConnectionsLimit属性进行配置。</clientconfignamespace></clientname></td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><p>默认的实现就是ZoneAvoidanceRule，是一种轮询方案</p><h3 id="自定义负载均衡策略"><a href="#自定义负载均衡策略" class="headerlink" title="自定义负载均衡策略"></a>自定义负载均衡策略</h3><p>通过定义IRule实现可以修改负载均衡规则，有两种方式：</p><p>代码方式：在order-service中的OrderApplication类中，定义一个新的IRule：</p><pre><code>@Beanpublic IRule randomRule(){    return new RandomRule();}</code></pre><p>配置文件方式：在order-service的application.yml文件中，添加新的配置也可以修改规则：</p><pre><code>userservice: # 给某个微服务配置负载均衡规则，这里是userservice服务  ribbon:    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 </code></pre><p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改</p><h2 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h2><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><pre><code>ribbon:  eager-load:    enabled: true    clients: userservice</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eureka注册中心</title>
      <link href="/eureka.html"/>
      <url>/eureka.html</url>
      
        <content type="html"><![CDATA[<h1 id="Eureka的结构和作用"><a href="#Eureka的结构和作用" class="headerlink" title="Eureka的结构和作用"></a>Eureka的结构和作用</h1><p><img src="/eureka/image-20210713220104956.png" alt="image-20210713220104956"></p><p>order-service如何得知user-service实例地址？</p><p>获取地址信息的流程如下：</p><ul><li>user-service服务实例启动后，将自己的信息注册到eureka-server（Eureka服务端）。这个叫服务注册</li><li>eureka-server保存服务名称到服务实例地址列表的映射关系</li><li>order-service根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li></ul><p>order-service如何从多个user-service实例中选择具体的实例？</p><ul><li>order-service从实例列表中利用负载均衡算法选中一个实例地址</li><li>向该实例地址发起远程调用</li></ul><p>order-service如何得知某个user-service实例是否依然健康，是不是已经宕机？</p><ul><li>user-service会每隔一段时间（默认30秒）向eureka-server发起请求，报告自己状态，称为心跳</li><li>当超过一定时间没有发送心跳时，eureka-server会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service拉取服务时，就能将故障实例排除了</li></ul><p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此eureka将服务注册、服务发现等功能统一封装到了eureka-client端</p><h1 id="搭建eureka-server"><a href="#搭建eureka-server" class="headerlink" title="搭建eureka-server"></a>搭建eureka-server</h1><p>首先注册中心服务端：eureka-server，这必须是一个独立的微服务</p><h2 id="创建eureka-server服务"><a href="#创建eureka-server服务" class="headerlink" title="创建eureka-server服务"></a>创建eureka-server服务</h2><p>在cloud-d<img src="/eureka/image-20210713220605881.png" alt="image-20210713220605881">emo父工程下，创建一个子模块：</p><h2 id="引入eureka依赖"><a href="#引入eureka依赖" class="headerlink" title="引入eureka依赖"></a>引入eureka依赖</h2><p>引入SpringCloud为eureka提供的starter依赖：</p><p>注意这里引入的依赖是server,注册的才是client</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="编写启动类"><a href="#编写启动类" class="headerlink" title="编写启动类"></a>编写启动类</h2><p>给eureka-server服务编写一个启动类，一定要添加一个@EnableEurekaServer注解，开启eureka的注册中心功能：</p><pre><code>package cn.itcast.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication {    public static void main(String[] args) {        SpringApplication.run(EurekaApplication.class, args);    }}</code></pre><h2 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h2><p>编写一个application.yml文件，内容如下</p><pre><code>server:  port: 10086spring:  application:    name: eureka-servereureka:  client:    service-url:       defaultZone: http://127.0.0.1:10086/eureka</code></pre><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>启动微服务，然后在浏览器访问：<a href="http://127.0.0.1:10086" target="_blank" rel="noopener">http://127.0.0.1:10086</a></p><p>看到下面结果应该是成功了：</p><p><img src="/eureka/image-20210713222157190.png" alt="image-20210713222157190"></p><h1 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h1><p>将user-service注册到eureka-server中去。</p><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>注意这里引入的依赖是Client,服务是server</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>文件，添加服务名称、eureka地址：</p><pre><code>spring:  application:    name: userserviceeureka:  client:    service-url:      defaultZone: http://127.0.0.1:10086/eureka</code></pre><h3 id="启动多个user-service实例"><a href="#启动多个user-service实例" class="headerlink" title="启动多个user-service实例"></a>启动多个user-service实例</h3><p>![image-20210713222656562](Eureka/image-20210713222656562.png</p><p><img src="/eureka/image-20210713222841951.png" alt="image-20210713222841951"></p><p><img src="/eureka/image-20210713223041491.png" alt="image-20210713223041491"></p><p>查看eureka-server管理页面：</p><p><img src="/eureka/image-20210713223150650.png" alt="image-20210713223150650"></p><h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p>将order-service的逻辑修改：向eureka-server拉取user-service的信息，实现服务发现。</p><h2 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>服务发现、服务注册统一都封装在eureka-client依赖，因此这一步与服务注册时一致。</p><p>在order-service的pom文件中，引入下面的eureka-client依赖：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h2><p>服务发现也需要知道eureka地址，因此第二步与服务注册一致，都是配置eureka信息：</p><p>在order-service中，修改application.yml文件，添加服务名称、eureka地址：</p><pre><code>spring:  application:    name: orderserviceeureka:  client:    service-url:      defaultZone: http://127.0.0.1:10086/eureka</code></pre><h2 id="服务拉取和负载均衡"><a href="#服务拉取和负载均衡" class="headerlink" title="服务拉取和负载均衡"></a>服务拉取和负载均衡</h2><p>最后要去eureka-server中拉取user-service服务的实例列表，并且实现负载均衡。</p><p>只需要添加一些注解即可。</p><p>在order-service的OrderApplication中，给RestTemplate这个Bean添加一个@LoadBalanced注解：</p><p><img src="/eureka/image-20210713224049419.png" alt="image-20210713224049419"></p><p>修改order-service服务中的cn.itcast.order.service包下的OrderService类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：</p><p><img src="/eureka/image-20210713224245731.png" alt="image-20210713224245731"></p><p>spring会自动从eureka-server端，根据userservice这个服务名称，获取实例列表，而后完成负载均衡。</p><p>如果使用Feign调用的话就不用@LoadBalanced了，因为Feign是自带负载均衡的。</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity</title>
      <link href="/springsecurity.html"/>
      <url>/springsecurity.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h1><p>Spring Security 是 Spring 家族中的一个安全管理框架，应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。Spring Security是针对Spring项目的安全框架，也是Spring Boot底层安全模块默认的技术选型</p><p>Spring Security 采用的是责任链的设计模式，它有一条很长的过滤器链。</p><h1 id="SpringSecurity执行流程图"><a href="#SpringSecurity执行流程图" class="headerlink" title="SpringSecurity执行流程图"></a>SpringSecurity执行流程图</h1><p><img src="/springsecurity/d359fe34bc7860c11a1b6e50bfd0e086.png" alt="img"></p><ol><li><p>WebAsyncManagerIntegrationFilter：将 Security 上下文与 Spring Web 中用于处理异步请求映射的 WebAsyncManager 进行集成。</p></li><li><p>SecurityContextPersistenceFilter：在每次请求处理之前将该请求相关的安全上下文信息加载到 SecurityContextHolder 中，然后在该次请求处理完成之后，将 SecurityContextHolder 中关于这次请求的信息存储到一个“仓储”中，然后将 SecurityContextHolder 中的信息清除，例如在Session中维护一个用户的安全信息就是这个过滤器处理的。默认是将SecurityContext存储在threadlocal中，可能是spring考虑到目前大多数为BS应用，一个应用同时可能有多个使用者，每个使用者又对应不同的安全上下，Security Context Holder为了保存这些安全上下文。</p></li><li><p>HeaderWriterFilter：用于将头信息加入响应中。</p></li><li><p>CsrfFilter：用于处理跨站请求伪造。</p></li><li><p>LogoutFilter：用于处理退出登录。</p></li><li><p>UsernamePasswordAuthenticationFilter：用于处理基于表单的登录请求，从表单中获取用户名和密码。默认情况下处理来自 /login 的请求。从表单中获取用户名和密码时，默认使用的表单 name 值为 username 和 password，这两个值可以通过设置这个过滤器的usernameParameter 和 passwordParameter 两个参数的值进行修改。</p></li><li><p>DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那系统初始化时就会配置这个过滤器，并且用于在需要进行登录时生成一个登录表单页面。</p></li><li><p>BasicAuthenticationFilter：检测和处理 http basic 认证。</p></li><li><p>RequestCacheAwareFilter：用来处理请求的缓存。</p></li><li><p>SecurityContextHolderAwareRequestFilter：主要是包装请求对象request。</p></li><li><p>AnonymousAuthenticationFilter：检测 SecurityContextHolder 中是否存在 Authentication 对象，如果不存在为其提供一个匿名 Authentication。</p></li><li><p>SessionManagementFilter：管理 session 的过滤器</p></li><li><p>ExceptionTranslationFilter：处理 AccessDeniedException 和 AuthenticationException 异常。</p></li><li><p>FilterSecurityInterceptor：可以看做过滤器链的出口。</p></li><li><p>RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时, 从 cookie 里找出用户的信息, 如果 Spring Security 能够识别出用户提供的remember me cookie, 用户将不必填写用户名和密码, 而是直接登录进入系统，该过滤器默认不开启。</p></li></ol><h1 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h1><p>客户端发起一个请求，进入 Security 过滤器链。</p><p>当到 LogoutFilter 的时候判断是否是登出路径，如果是登出路径则到 logoutHandler ，如果登出成功则到 logoutSuccessHandler 登出成功处理，如果登出失败则由 ExceptionTranslationFilter ；如果不是登出路径则直接进入下一个过滤器。</p><p>当到 UsernamePasswordAuthenticationFilter 的时候判断是否为登录路径，如果是，则进入该过滤器进行登录操作，如果登录失败则到 AuthenticationFailureHandler 登录失败处理器处理，如果登录成功则到 AuthenticationSuccessHandler 登录成功处理器处理，如果不是登录请求则不进入该过滤器。</p><p>当到 FilterSecurityInterceptor 的时候会拿到 uri ，根据 uri 去找对应的鉴权管理器，鉴权管理器做鉴权工作，鉴权成功则到 Controller 层否则到 AccessDeniedHandler 鉴权失败处理器处理。</p><h1 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h1><p>WebSecurityConfigurerAdapte 这个类将在5.7版本被<code>@Deprecated</code>所标记了，未来这个类将被移除。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>    <span class="token annotation punctuation">@EnableWebSecurity</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SecurityConfig</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>AuthenticationManagerBuilder auth<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        auth<span class="token punctuation">.</span><span class="token function">userDetailsService</span><span class="token punctuation">(</span>userDetailService<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">passwordEncoder</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BCryptPasswordEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//认证提供者</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>WebSecurity web<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>            web<span class="token punctuation">.</span><span class="token function">ignoring</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">antMatchers</span><span class="token punctuation">(</span><span class="token string">"/resources/**/*.html"</span><span class="token punctuation">,</span> <span class="token string">"/resources/**/*.js"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span>HttpSecurity http<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>           http           <span class="token punctuation">.</span><span class="token function">formLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token punctuation">.</span><span class="token function">loginPage</span><span class="token punctuation">(</span><span class="token string">"/login_page"</span><span class="token punctuation">)</span>           <span class="token punctuation">.</span><span class="token function">passwordParameter</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span>           <span class="token punctuation">.</span><span class="token function">passwordParameter</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span>           <span class="token punctuation">.</span><span class="token function">loginProcessingUrl</span><span class="token punctuation">(</span><span class="token string">"/sign_in"</span><span class="token punctuation">)</span>           <span class="token punctuation">.</span><span class="token function">permitAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authorizeRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">antMatchers</span><span class="token punctuation">(</span><span class="token string">"/test"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasRole</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//权限设置</span>       <span class="token punctuation">.</span><span class="token function">anyRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">accessDecisionManager</span><span class="token punctuation">(</span><span class="token function">accessDecisionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">logout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">logoutSuccessHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyLogoutSuccessHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">csrf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           http<span class="token punctuation">.</span><span class="token function">addFilterAt</span><span class="token punctuation">(</span><span class="token function">getAuthenticationFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>UsernamePasswordAuthenticationFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           http<span class="token punctuation">.</span><span class="token function">exceptionHandling</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">accessDeniedHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyAccessDeniedHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           http<span class="token punctuation">.</span><span class="token function">addFilterAfter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyFittler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> LogoutFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置介绍</p><p>@EnableWebSecurity</p><p> 加载了WebSecurityConfiguration配置类, 配置安全认证策略。2: 加载了AuthenticationConfiguration, 配置了认证信息。</p><p>configure(AuthenticationManagerBuilder auth)</p><p>AuthenticationManager 的建造器，配置 AuthenticationManagerBuilder 会让Security 自动构建一个 AuthenticationManager（该类的功能参考流程图）；</p><p>该接口的作用是对用户的未授信凭据进行认证，认证通过则返回授信状态的凭据，否则将抛出认证异常。</p><p>如果想要使用该功能需要配置一个 UserDetailService 和 PasswordEncoder。UserDetailsService 用于在认证器中根据用户传过来的用户名查找一个用户， PasswordEncoder 用于密码的加密与比对，我们存储用户密码的时候用PasswordEncoder.encode() 加密存储，在认证器里会调用 PasswordEncoder.matches() 方法进行密码比对。</p><p>如果重写了该方法，Security 会启用 DaoAuthenticationProvider 这个认证器，该认证就是先调用 UserDetailsService.loadUserByUsername 然后使用 PasswordEncoder.matches() 进行密码比对，如果认证成功成功则返回一个 Authentication 对象。</p><p>DaoAuthenticationProvider  实现了 AuthenticationProvider（鉴定提供者）</p><p>configure(WebSecurity web)</p><p>这个配置方法用于配置静态资源的处理方式，可使用 Ant 匹配规则。</p><p>configure(HttpSecurity http)</p><pre><code>http    .formLogin()    .loginPage(&quot;/login_page&quot;)    .passwordParameter(&quot;username&quot;)    .passwordParameter(&quot;password&quot;)    .loginProcessingUrl(&quot;/sign_in&quot;)    .permitAll()</code></pre><p>这是配置登录相关的操作从方法名可知，</p><p>配置了登录页请求路径.loginPage(“/login_page”)，</p><p>密码属性名，.passwordParameter(“username”)    </p><p>用户名属性名， .passwordParameter(“username”)    </p><p>登录请求路径，.loginProcessingUrl(“/sign_in”)     //就是验证成功后转跳的页面</p><p>permitAll()代表任意用户可访问。</p><pre><code>http    .authorizeRequests()    .antMatchers(&quot;/test&quot;).hasRole(&quot;test&quot;)    .anyRequest().authenticated()    .accessDecisionManager(accessDecisionManager());</code></pre><p>以上配置是权限相关的配置，</p><p>配置了一个 <code>/test</code> url 该有什么权限才能访问， </p><p>anyRequest() 表示所有请求，</p><p>authenticated() 表示已登录用户才能访问， </p><p>accessDecisionManager() 表示绑定在 url 上的鉴权管理器</p><pre><code>http    .logout()    .logoutUrl(&quot;/logout&quot;)    .logoutSuccessHandler(new MyLogoutSuccessHandler())</code></pre><p>登出相关配置，这里配置了登出 url 和登出成功处理器</p><pre><code>http    .exceptionHandling()    .accessDeniedHandler(new MyAccessDeniedHandler());</code></pre><p>代码是配置鉴权失败的处理器</p><pre><code>http.addFilterAfter(new MyFittler(), LogoutFilter.class);    http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</code></pre><p>上面代码展示如何在过滤器链中插入自己的过滤器，addFilterBefore 加在对应的过滤器之前，addFilterAfter 加在对应的过滤器之后，addFilterAt 加在过滤器同一位置，事实上框架原有的 Filter 在启动 HttpSecurity 配置的过程中，都由框架完成了其一定程度上固定的配置，是不允许更改替换的。根据测试结果来看，调用 addFilterAt 方法插入的 Filter ，会在这个位置上的原有 Filter 之前执行。</p><p>注：关于 HttpSecurity 使用的是链式编程，其中 http.xxxx.and.yyyyy 这种写法和 http.xxxx;http.yyyy 写法意义一样。</p><ul><li>自定义 AuthenticationManager 认证管理器 和 AccessDecisionManager 访问决策管理器</li></ul><p>重写 authenticationManagerBean() 方法，并构造一个 authenticationManager：</p><pre><code>@Override    public AuthenticationManager authenticationManagerBean() throws Exception {        ProviderManager authenticationManager = new ProviderManager(Arrays.asLis(getMyAuthenticationProvider(),daoAuthenticationProvider()));        return authenticationManager;    }</code></pre><p>authenticationManager 配置了两个认证器</p><pre><code>public AccessDecisionManager accessDecisionManager(){        List&lt;AccessDecisionVoter&lt;? extends Object&gt;&gt; decisionVoters                = Arrays.asList(                new MyExpressionVoter(),                new WebExpressionVoter(),                new RoleVoter(),                new AuthenticatedVoter());        return new UnanimousBased(decisionVoters);    }</code></pre><p>投票管理器会收集投票器投票结果做统计，最终结果大于等于0代表通过；每个投票器会返回三个结果：-1（反对），0（通过），1（赞成）。</p><h1 id="Security-权限系统"><a href="#Security-权限系统" class="headerlink" title="Security 权限系统"></a>Security 权限系统</h1><h2 id="UserDetails"><a href="#UserDetails" class="headerlink" title="UserDetails"></a>UserDetails</h2><p>该接口是提供用户<strong>信息</strong>的核心接口。该接口实现仅仅存储用户的信息。后续会将该接口提供的用户信息封装到认证对象<code>Authentication</code>中去。</p><p><code>UserDetails</code> 默认提供了：</p><ul><li>用户的权限集， 默认需要添加<code>ROLE_</code> 前缀</li><li>用户的加密后的密码， 不加密会使用<code>{noop}</code>前缀</li><li>应用内唯一的用户名</li><li>账户是否过期</li><li>账户是否锁定</li><li>凭证是否过期</li><li>用户是否可用</li></ul><p>如果以上的信息满足不了使用，可以自行实现扩展以存储更多的用户信息。比如用户的邮箱、手机号等等。通常使用其实现类</p><pre><code>org.springframework.security.core.userdetails.User</code></pre><p>该类内置一个建造器<code>UserBuilder</code> 会很方便地构建<code>UserDetails</code> 对象。</p><h2 id="GrantedAuthority"><a href="#GrantedAuthority" class="headerlink" title="GrantedAuthority"></a>GrantedAuthority</h2><pre><code>public interface GrantedAuthority extends Serializable {    String getAuthority();}</code></pre><p><img src="/springsecurity/image-20230323174655629.png" alt="image-20230323174655629"></p><p>自带了三个实现类</p><p>Security 中的用户权限接口，自定义权限需要实现该接口:</p><pre><code>public class MyGrantedAuthority implements GrantedAuthority {        private String authority;    }</code></pre><p>authority 表示权限字段，需要注意的是在 config 中配置的权限会被加上 ROLE_ 前缀，比如我们的配置 authorizeRequests().antMatchers(“/test”).hasRole(“test”)，配置了一个 test 权限但我们存储的权限字段（authority）应该是 ROLE_test 。</p><p>GrantedAuthority代表的就是一种权限对象，而一个 UserDetails 对象具备一个或多个 GrantedAuthority 对象。通过这种关联关系，实际上我们就可以对用户的权限做一些限制</p><p>Authentication 的 getAuthorities() 可以返回当前 Authentication 对象拥有的权限，即当前用户拥有的权限。其返回值是一个 GrantedAuthority 类型的数组，每一个 GrantedAuthority 对象代表赋予给当前用户的一种权限。GrantedAuthority 是一个接口，其通常是通过 UserDetailsService 进行加载，然后赋予给 UserDetails 的。</p><p>GrantedAuthority 中只定义了一个 getAuthority() 方法，该方法返回一个字符串，表示对应权限的字符串表示，如果对应权限不能用字符串表示，则应当返回 null。</p><p>Spring Security 针对 GrantedAuthority 有一个简单实现 SimpleGrantedAuthority。该类只是简单的接收一个表示权限的字符串。Spring Security 内部的所有 AuthenticationProvider 都是使用 SimpleGrantedAuthority 来封装 Authentication 对象。</p><h2 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h2><p><code>UserDetailsService</code>接口。该接口只提供了一个方法：</p><pre><code>public interface UserDetailsService {    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;}</code></pre><p>根据用户名来定位用户。在实际执行中，搜索可能是区分大小写的，也可能是不区分大小写的，这取决于执行实例是如何配置的。在这种情况下，返回的UserDetails对象可能有一个与实际请求的不同大小写的用户名。</p><p>loadUserByUsername的作用，就是根据用户名查询用户对象。</p><h2 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h2><p>用户在完成登录后 Security 会将用户信息存储到这个类中，之后其他流程需要得到用户信息时都是从这个类中获得，用户信息被封装成 SecurityContext ，而实际存储的类是 SecurityContextHolderStrategy ，默认的SecurityContextHolderStrategy 实现类是 ThreadLocalSecurityContextHolderStrategy 它使用了ThreadLocal来存储了用户信息。</p><h2 id="使用注解在方法上进行权限认"><a href="#使用注解在方法上进行权限认" class="headerlink" title="使用注解在方法上进行权限认"></a>使用注解在方法上进行权限认</h2><p>Spring Security<code>默认是禁用注解的，要想开启注解，要在继承</code>WebSecurityConfigurerAdapter<code>的类加</code>@EnableMethodSecurity<code>注解，并在该类中将</code>AuthenticationManager<code>定义为</code>Bean。</p><pre><code>@EnableWebSecurity@Configuration@EnableGlobalMethodSecurity(  prePostEnabled = true,   securedEnabled = true,   jsr250Enabled = true)public class SecurityConfig extends WebSecurityConfigurerAdapter {    @Bean    @Override    public AuthenticationManager authenticationManagerBean() throws Exception {        return super.authenticationManagerBean();    }}</code></pre><p>分别有prePostEnabled 、securedEnabled、jsr250Enabled三个字段，其中每个字段代码一种注解支持，默认为false，true为开启。那么我们就一一来说一下这三总注解支持。</p><p>prePostEnabled = true 的作用的是启用Spring Security的@PreAuthorize 以及@PostAuthorize 注解。</p><p>securedEnabled = true 的作用是启用Spring Security的@Secured 注解。</p><p>jsr250Enabled = true 的作用是启用@RoleAllowed 注解</p><h3 id="JSR-250注解"><a href="#JSR-250注解" class="headerlink" title="JSR-250注解"></a>JSR-250注解</h3><p>遵守了JSR-250标准注解</p><p>主要注解</p><ol><li>@DenyAll</li><li>@RolesAllowed</li><li>@PermitAll</li></ol><p>这里面<code>@DenyAll</code> 和 <code>@PermitAll</code> 相信就不用多说了 代表拒绝和通过。</p><p><code>@RolesAllowed</code> 使用示例</p><pre><code>@RolesAllowed(&quot;ROLE_VIEWER&quot;)public String getUsername2() {    //...}@RolesAllowed({ &quot;USER&quot;, &quot;ADMIN&quot; })public boolean isValidUsername2(String username) {    //...}</code></pre><p>代表标注的方法只要具有USER, ADMIN任意一种权限就可以访问。这里可以省略前缀ROLE_，实际的权限可能是ROLE_ADMIN</p><p>在功能及使用方法上与 <code>@Secured</code> 完全相同</p><h3 id="securedEnabled注解"><a href="#securedEnabled注解" class="headerlink" title="securedEnabled注解"></a>securedEnabled注解</h3><p>主要注解</p><p>@Secured</p><p>Spring Security的@Secured注解。注解规定了访问访方法的角色列表，在列表中最少指定一种角色</p><p>@Secured在方法上指定安全性，要求 角色/权限等 只有对应 角色/权限 的用户才可以调用这些方法。 如果有人试图调用一个方法，但是不拥有所需的 角色/权限，那会将会拒绝访问将引发异常。</p><pre><code>@Secured(&quot;ROLE_VIEWER&quot;)public String getUsername() {    SecurityContext securityContext = SecurityContextHolder.getContext();    return securityContext.getAuthentication().getName();}@Secured({ &quot;ROLE_DBA&quot;, &quot;ROLE_ADMIN&quot; })public String getUsername2() {    //...}</code></pre><p>@Secured(“ROLE_VIEWER”) 表示只有拥有ROLE_VIEWER角色的用户，才能够访问getUsername()方法。</p><p>@Secured({ “ROLE_DBA”, “ROLE_ADMIN” }) 表示用户拥有”ROLE_DBA”, “ROLE_ADMIN” 两个角色中的任意一个角色，均可访问 getUsername2 方法。</p><p>还有一点就是@Secured,不支持Spring EL表达式</p><h3 id="prePostEnabled注解"><a href="#prePostEnabled注解" class="headerlink" title="prePostEnabled注解"></a>prePostEnabled注解</h3><p>这个开启后支持Spring EL表达式 算是蛮厉害的。如果没有访问方法的权限，会抛出AccessDeniedException。</p><p>主要注解</p><p>@PreAuthorize –适合进入方法之前验证授权</p><p>@PostAuthorize –检查授权方法之后才被执行并且可以影响执行方法的返回值</p><p>@PostFilter –在方法执行之后执行，而且这里可以调用方法的返回值，然后对返回值进行过滤或处理或修改并返回</p><p>@PreFilter –在方法执行之前执行，而且这里可以调用方法的参数，然后对参数值进行过滤或处理或修改</p><h3 id="PreAuthorize注解使用"><a href="#PreAuthorize注解使用" class="headerlink" title="PreAuthorize注解使用"></a>PreAuthorize注解使用</h3><pre><code>@PreAuthorize(&quot;hasRole(&#39;ROLE_VIEWER&#39;)&quot;)public String getUsernameInUpperCase() {    return getUsername().toUpperCase();}</code></pre><p>@PreAuthorize(“hasRole(‘ROLE_VIEWER’)”) 相当于@Secured(“ROLE_VIEWER”)。</p><p>同样的@Secured({“ROLE_VIEWER”,”ROLE_EDITOR”}) 也可以替换为：@PreAuthorize(“hasRole(‘ROLE_VIEWER’) or hasRole(‘ROLE_EDITOR’)”)。</p><p>在方法执行之前执行，这里可以调用方法的参数，也可以得到参数值，这里利用JAVA8的参数名反射特性，如果没有JAVA8，那么也可以利用Spring Secuirty的@P标注参数，或利用Spring Data的@Param标注参数</p><pre><code>//无java8@PreAuthorize(&quot;#userId == authentication.principal.userId or hasAuthority(‘ADMIN’)&quot;)void changePassword(@P(&quot;userId&quot;) long userId ){}//有java8@PreAuthorize(&quot;#userId == authentication.principal.userId or hasAuthority(‘ADMIN’)&quot;)void changePassword(long userId ){}</code></pre><p>这里表示在<code>changePassword</code>方法执行之前，判断方法参数userId的值是否等于principal中保存的当前用户的userId，或者当前用户是否具有ROLE_ADMIN权限，两种符合其一，就可以访问该 方法。</p><h3 id="PostAuthorize注解使用"><a href="#PostAuthorize注解使用" class="headerlink" title="@PostAuthorize注解使用"></a>@PostAuthorize注解使用</h3><p>在方法执行之后执行可,以获取到方法的返回值，并且可以根据该方法来决定最终的授权结果（是允许访问还是不允许访问):</p><pre><code>@PostAuthorize  (&quot;returnObject.username == authentication.principal.nickName&quot;)public CustomUser loadUserDetail(String username) {    return userRoleRepository.loadUserByUserName(username);}</code></pre><p>上述代码中，仅当<code>loadUserDetail</code>方法的返回值中的username与当前登录用户的username相同时才被允许访问</p><h3 id="PreFilter以及-PostFilter注解使用"><a href="#PreFilter以及-PostFilter注解使用" class="headerlink" title="@PreFilter以及@PostFilter注解使用"></a>@PreFilter以及@PostFilter注解使用</h3><p>Spring Security提供了一个<code>@PreFilter</code> 注解来对传入的参数进行过滤：</p><pre><code>@PreFilter(&quot;filterObject != authentication.principal.username&quot;)public String joinUsernames(List&lt;String&gt; usernames) {    return usernames.stream().collect(Collectors.joining(&quot;;&quot;));}</code></pre><p>当usernames中的子项与当前登录用户的用户名不同时，则保留；当usernames中的子项与当前登录用户的用户名相同时，则移除。比如当前使用用户的用户名为zhangsan，此时usernames的值为{“zhangsan”, “lisi”, “wangwu”}，则经@PreFilter过滤后，实际传入的usernames的值为{“lisi”, “wangwu”}</p><p>如果执行方法中包含有多个类型为Collection的参数，filterObject 就不太清楚是对哪个Collection参数进行过滤了。此时，便需要加入 filterTarget 属性来指定具体的参数名称：</p><pre><code>@PreFilter  (value = &quot;filterObject != authentication.principal.username&quot;,  filterTarget = &quot;usernames&quot;)public String joinUsernamesAndRoles(  List&lt;String&gt; usernames, List&lt;String&gt; roles) {    return usernames.stream().collect(Collectors.joining(&quot;;&quot;))       + &quot;:&quot; + roles.stream().collect(Collectors.joining(&quot;;&quot;));}</code></pre><p>同样的我们还可以使用@PostFilter注解来过返回的Collection进行过滤：</p><pre><code>@PostFilter(&quot;filterObject != authentication.principal.username&quot;)public List&lt;String&gt; getAllUsernamesExceptCurrent() {    return userRoleRepository.getAllUsernames();}</code></pre><p>此时 filterObject 代表返回值。如果按照上述代码则实现了：移除掉返回值中与当前登录用户的用户名相同的子项。</p><p>手动填充 SecurityContextHolder 示例：</p><pre><code>UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(&quot;test&quot;,&quot;test&quot;,list);    SecurityContextHolder.getContext().setAuthentication(token);</code></pre><p>对于使用 token 鉴权的系统，就可以验证token后手动填充SecurityContextHolder，填充时机只要在执行投票器之前即可，或者干脆可以在投票器中填充，然后在登出操作中清空SecurityContextHolder。</p><h1 id="Authority、Role的区别"><a href="#Authority、Role的区别" class="headerlink" title="Authority、Role的区别"></a>Authority、Role的区别</h1><p>可以看到，hasRole 的处理逻辑和 hasAuthority 似乎一模一样，不同的是，hasRole 这里会自动给传入的字符串加上 ROLE_ 前缀，所以在数据库中的权限字符串需要加上 ROLE_ 前缀。即数据库中存储的用户角色如果是 ROLE_admin，这里就是 admin。</p><p>在调用 hasAuthority 方法时，如果数据是从数据库中查询出来的，这里的权限和数据库中保存一致即可，可以不加 ROLE_ 前缀。即数据库中存储的用户角色如果是 admin，这里就是 admin</p><p>。</p><p>也就是说，使用 hasAuthority 更具有一致性，你不用考虑要不要加 ROLE_ 前缀，数据库什么样这里就是什么样！而 hasRole 则不同，代码里如果写的是 admin，框架会自动加上 ROLE_ 前缀，所以数据库就必须是 ROLE_admin。</p><p><img src="/springsecurity/image-20230323195413928.png" alt="image-20230323195413928"></p><p>使用方法</p><h1 id="Security-扩展"><a href="#Security-扩展" class="headerlink" title="Security 扩展"></a>Security 扩展</h1><p>Security 可扩展的有</p><ol><li><p>鉴权失败处理器</p></li><li><p>验证器</p></li><li><p>登录成功处理器</p></li><li><p>投票器</p></li><li><p>自定义token处理过滤器</p></li><li><p>登出成功处理器</p></li><li><p>登录失败处理器</p></li><li><p>自定义 UsernamePasswordAuthenticationFilter</p></li></ol><p>鉴权失败处理器</p><p>Security 鉴权失败默认跳转登录页面，我们可以实现 AccessDeniedHandler 接口，重写 handle() 方法来自定义处理逻辑；然后参考配置类说明将处理器加入到配置当中。</p><p>验证器</p><p>实现 AuthenticationProvider 接口来实现自己验证逻辑。需要注意的是在这个类里面就算你抛出异常，也不会中断验证流程，而是算你验证失败，我们由流程图知道，只要有一个验证器验证成功，就算验证成功，所以你需要留意这一点。</p><p>登录成功处理器</p><p>在 Security 中验证成功默认跳转到上一次请求页面或者路径为 “/“ 的页面，我们同样可以自定义：继承 SimpleUrlAuthenticationSuccessHandler 这个类或者实现 AuthenticationSuccessHandler 接口。我这里建议采用继承的方式,SimpleUrlAuthenticationSuccessHandler 是默认的处理器，采用继承可以契合里氏替换原则，提高代码的复用性和避免不必要的错误。</p><p>投票器</p><p>投票器可继承 WebExpressionVoter 或者实现 AccessDecisionVoter接口；WebExpressionVoter 是 Security 默认的投票器；我这里同样建议采用继承的方式；添加到配置的方式参考 上文；</p><p>注意：投票器 vote 方法返回一个int值；-1代表反对，0代表弃权，1代表赞成；投票管理器收集投票结果，如果最终结果大于等于0则放行该请求。</p><p>自定义token处理过滤器</p><p>自定义 token 处理器继承自 OncePerRequestFilter 或者 GenericFilterBean 或者 Filter 都可以，在这个处理器里面需要完成的逻辑是：获取请求里的 token，验证 token 是否合法然后填充 SecurityContextHolder ，虽然说过滤器只要添加在投票器之前就可以，但我这里还是建议添加在 http.addFilterAfter(new MyFittler(), LogoutFilter.class);</p><p>登出成功处理器</p><p>实现LogoutSuccessHandler接口，添加到配置的方式参考上文。</p><p>登录失败处理器</p><p>登录失败默认跳转到登录页，我们同样可以自定义。继承 SimpleUrlAuthenticationFailureHandler 或者实现 AuthenticationFailureHandler，建议采用继承。</p><p>自定义UsernamePasswordAuthenticationFilter</p><p>我们自定义UsernamePasswordAuthenticationFilter可以极大提高我们 Security的灵活性（比如添加验证验证码是否正确的功能）。</p><p>我们直接继承 UsernamePasswordAuthenticationFilter ，然后在配置类中初始化这个过滤器，给这个过滤器添加登录失败处理器，登录成功处理器，登录管理器，登录请求 url 。</p><p>这里配置略微复杂，贴一下代码清单</p><p>初始化过滤器：</p><pre><code>MyUsernamePasswordAuthenticationFilte getAuthenticationFilter(){        MyUsernamePasswordAuthenticationFilter myUsernamePasswordAuthenticationFilter = new MyUsernamePasswordAuthenticationFilter(redisService);        myUsernamePasswordAuthenticationFilter.setAuthenticationFailureHandler(new MyUrlAuthenticationFailureHandler());        myUsernamePasswordAuthenticationFilter.setAuthenticationSuccessHandler(new MyAuthenticationSuccessHandler());        myUsernamePasswordAuthenticationFilter.setFilterProcessesUrl(&quot;/sign_in&quot;);        myUsernamePasswordAuthenticationFilter.setAuthenticationManager(getAuthenticationManager());        return myUsernamePasswordAuthenticationFilter;    }</code></pre><p>添加到配置：</p><pre><code>http.addFilterAt(getAuthenticationFilter(),UsernamePasswordAuthenticationFilter.class);</code></pre><p>总结<br>对于 Security 的扩展配置关键在于 configure(HttpSecurityhttp) 方法；扩展认证方式可以自定义 authenticationManager 并加入自己验证器，在验证器中抛出异常不会终止验证流程；扩展鉴权方式可以自定义 accessDecisionManager 然后添加自己的投票器并绑定到对应的 url（url 匹配方式为 ant）上，投票器 vote(Authenticationauthentication,FilterInvocationfi,Collection<configattribute>attributes) 方法返回值为三种：-1 0 1，分别表示反对弃权赞成。</configattribute></p><p>对于 token 认证的校验方式，可以暴露一个获取的接口，或者重写 UsernamePasswordAuthenticationFilter 过滤器和扩展登录成功处理器来获取 token，然后在 LogoutFilter 之后添加一个自定义过滤器，用于校验和填充 SecurityContextHolder。</p><p>另外，Security 的处理器大部分都是重定向的，我们的项目如果是前后端分离的话，我们希望无论什么情况都返回 json ,那么就需要重写各个处理器了。</p>]]></content>
      
      
      <categories>
          
          <category> Auth </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecuritt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT</title>
      <link href="/jwt.html"/>
      <url>/jwt.html</url>
      
        <content type="html"><![CDATA[<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><h2 id="JWT介绍"><a href="#JWT介绍" class="headerlink" title="JWT介绍"></a>JWT介绍</h2><p>JWT(json web token)是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。<br> JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用户登录。在传统的用户登录认证中，因为http是无状态的，所以都是采用session方式。用户登录成功，服务端会保存一个session，服务端会返回给客户端一个sessionId，客户端会把sessionId保存在cookie中，每次请求都会携带这个sessionId。</p><p> cookie+session这种模式通常是保存在内存中，而且服务从单服务到多服务会面临的session共享问题。虽然目前存在使用Redis进行Session共享的机制，但是随着用户量和访问量的增加，Redis中保存的数据会越来越多，开销就会越来越大，多服务间的耦合性也会越来越大，Redis中的数据也很难进行管理，例如当Redis集群服务器出现Down机的情况下，整个业务系统随之将变为不可用的状态。而JWT不是这样的，只需要服务端生成token，客户端保存这个token，每次请求携带这个token，服务端认证解析就可。</p><h2 id="JWT的结构"><a href="#JWT的结构" class="headerlink" title="JWT的结构"></a>JWT的结构</h2><p><img src="/jwt/image-20230322191935818.png" alt="image-20230322191935818"></p><p> 第一部分称它为头部（header),第二部分称其为载荷（payload)，第三部分是签证（signature)</p><ul><li><strong>header</strong> jwt的头部承载两部分信息： 1.声明类型，这里是jwt 2.声明加密的算法 通常直接使用 HMAC SHA256</li></ul><p>完整的头部就像下面这样的JSON：</p><pre><code>{ &quot;typ&quot;: &quot;JWT&quot;,&quot;alg&quot;: &quot;HS256&quot;}</code></pre><p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分：</p><pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code></pre><ul><li><strong>playload</strong> 载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分：标准中注册的声明、公共的声明、私有的声明。</li></ul><ol><li>标准中注册的声明 (建议但不强制使用) ： iss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的. iat: jwt的签发时间 jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li><li>公共的声明 ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。</li><li>私有的声明 ： 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。 </li><li>此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。</li></ol><p>定义一个payload：</p><pre><code>{ &quot;uid&quot;:&quot;e12a34b56c78d9e0f&quot;,&quot;name&quot;:&quot;ramostear&quot;,&quot;role&quot;:&quot;admin&quot;}</code></pre><p>然后将其进行base64加密，得到Jwt的第二部分：</p><pre><code>eyJvcmciOiLku4rml6XlpLTmnaEiLCJuYW1lIjoiRnJlZeeggeWGnCIsImV4cCI6MTUxNDM1NjEwMywiaWF0IjoxNTE0MzU2MDQzLCJhZ2UiOiIyOCJ9</code></pre><ul><li><p><strong>signature</strong> jwt的第三部分是一个签证信息，这个签证信息由三部分组成：header (base64后的)、 payload (base64后的)、secret。</p><p>此部分用于防止jwt内容被篡改。这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明签名算法进行签名。然后就构成了jwt的第三部分：</p></li></ul><pre><code>49UF72vSkj-sA4aHHiYN5eoZ9Nb4w5Vb45PsLF7x_NY</code></pre><pre><code>  HMACSHA256(    base64UrlEncode(header) + &quot;.&quot; +    base64UrlEncode(payload),    secret)</code></pre><p>base64UrlEncode(header)：jwt令牌的第一部分。</p><p>base64UrlEncode(payload)：jwt令牌的第二部分。</p><p>secret：签名所使用的密钥。</p><h2 id="为什么JWT可以防止篡改？"><a href="#为什么JWT可以防止篡改？" class="headerlink" title="为什么JWT可以防止篡改？"></a>为什么JWT可以防止篡改？</h2><p>第三部分使用签名算法对第一部分和第二部分的内容进行签名，常用的签名算法是 HS256，常见的还有md5,sha 等，签名算法需要使用密钥进行签名，密钥不对外公开，并且签名是不可逆的，如果第三方更改了内容那么服务器验证签名就会失败，要想保证验证签名正确必须保证内容、密钥与签名前一致。</p><p><img src="/jwt/image-20230322194425426.png" alt="image-20230322194425426"></p><p>从上图可以看出认证服务和资源服务使用相同的密钥，这叫对称加密，对称加密效率高，如果一旦密钥泄露可以伪造jwt令牌。</p><p>JWT还可以使用非对称加密，认证服务自己保留私钥，将公钥下发给受信任的客户端、资源服务，公钥和私钥是配对的，成对的公钥和私钥才可以正常加密和解密，非对称加密效率低但相比对称加密非对称加密更安全一些。</p><h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><p>首先，前端通过Web表单将自己的用户名和密码发送到后端的接口。这一过程一般是一个HTTP POST请求。建议的方式是通过SSL加密的传输（https协议），从而避免敏感信息被嗅探。<br>后端核对用户名和密码成功后，将用户的id等其他信息作为JWT Payload（负载），将其与头部分别进行Base64编码拼接后签名，形成一个JWT（Token）。形成的JWT就是一个形同lll.zzz.xxx的字符串。<br>后端将JWT字符串作为登录成功的返回结果返回给前端。前端可以将返回的结果保存在localStorage或sessionStorage上，退出登录时前端删除保存的JWT即可。<br>前端在每次请求时将JWT放入HTTP Header中的Authorization位。（解决XSS和XSRF问题）<br>后端检查是否存在，如存在验证JWT的有效性。例如：检查签名是否正确；检查Token是否过期；检查Token的接收方是否是自己（可选）。<br>验证通过后后端使用JWT中包含的用户信息进行其他逻辑操作，返回相应结果</p><p>JWT解决了什么问题</p><p>用户认证通过后会得到一个JWT令牌，JWT令牌中已经包括了用户相关的信息，客户端只需要携带JWT访问资源服务，资源服务根据事先约定的算法自行完成令牌校验，无需每次都请求认证服务完成授权。</p><h2 id="使用jwt"><a href="#使用jwt" class="headerlink" title="使用jwt"></a>使用jwt</h2><p>1,导入依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.auth0&lt;/groupId&gt;     &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;     &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt;</code></pre><p>2，生成Token</p><pre><code>Calendar instance = Calendar.getInstance();      instance.add(Calendar.SECOND,90); //设置过期时间      //生成令牌      String token = JWT.create()              .withClaim(&quot;username&quot;, &quot;张三&quot;)//设置自定义用户名              .withClaim(&quot;userid&quot;, 1)//设置自定义id              .withExpiresAt(instance.getTime())//设置过期时间              .sign(Algorithm.HMAC256(&quot;token!Q2W#E$RW&quot;));//设置签名 保密 复杂</code></pre><p>3.根据令牌解析数据</p><pre><code> //创建验证对象       JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(&quot;token!Q2W#E$RW&quot;)).build();       DecodedJWT decodedJWT = jwtVerifier.verify(&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2MDQ4ODU1NzAsInVzZXJJZCI6MSwidXNlcm5hbWUiOiLlvKDkuIkifQ.s4YAv6EWqZQA4eO2uTwJkAoR45AZUOGMDskjvzoaW-s&quot;);       System.out.println(&quot;用户名：&quot;+decodedJWT.getClaim(&quot;username&quot;).asString());</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Oauth</title>
      <link href="/oauth.html"/>
      <url>/oauth.html</url>
      
        <content type="html"><![CDATA[<h1 id="Oauth"><a href="#Oauth" class="headerlink" title="Oauth"></a>Oauth</h1><h2 id="什么是OAuth"><a href="#什么是OAuth" class="headerlink" title="什么是OAuth?"></a>什么是OAuth?</h2><p>一个验证授权(Authorization)的开放标准，所有人都有基于这个标准实现自己的OAuth。</p><p>更具体来说，OAuth是一个标准，app可以用来实现<code>secure delegated access</code>. OAuth基于HTTPS，以及APIs，Service应用使用<code>access token</code>来进行身份验证。</p><p>OAuth主要有OAuth 1.0a和OAuth 2.0两个版本，并且二者完全不同，且不兼容。OAuth2.0 是目前广泛使用的版本，</p><p><strong>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</strong></p><h2 id="令牌与密码"><a href="#令牌与密码" class="headerlink" title="令牌与密码"></a>令牌与密码</h2><p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p><p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p><p>（2）令牌可以被数据所有者撤销，会立即失效。</p><p>（3）令牌有权限范围（scope），对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p><p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。</p><p>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以<strong>令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。</strong> 这也是为什么令牌的有效期，一般都设置得很短的原因。</p><h2 id="OAuth四种获取令牌的模式"><a href="#OAuth四种获取令牌的模式" class="headerlink" title="OAuth四种获取令牌的模式"></a>OAuth四种获取令牌的模式</h2><p>不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p><ul><li>授权码（authorization-code）</li><li>隐藏式（implicit）</li><li>密码式（password）：</li><li>客户端凭证（client credentials</li></ul><h3 id="授权码"><a href="#授权码" class="headerlink" title="授权码"></a>授权码</h3><p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</strong></p><p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p><p><img src="/oauth/1571688-20190506180810029-1179611880.png" alt="img"></p><p>简单的流程</p><p>第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。</p><pre><code>https://b.com/oauth/authorize?  response_type=code&amp;  client_id=CLIENT_ID&amp;  redirect_uri=CALLBACK_URL&amp;  scope=read</code></pre><p>上面 URL 中，<code>response_type</code>参数表示要求返回授权码（<code>code</code>），<code>client_id</code>参数让 B 知道是谁在请求，<code>redirect_uri</code>参数是 B 接受或拒绝请求后的跳转网址，<code>scope</code>参数表示要求的授权范围（这里是只读）。</p><p><img src="/oauth/image-20230322002441924.png" alt="image-20230322002441924"></p><p>第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码，就像下面这样。</p><pre><code>https://a.com/callback?code=AUTHORIZATION_CODE</code></pre><p>上面 URL 中，<code>code</code>参数就是授权码。</p><p><img src="/oauth/image-20230322002815995.png" alt="image-20230322002815995"></p><p>第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌.</p><pre><code>https://b.com/oauth/token? client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; grant_type=authorization_code&amp; code=AUTHORIZATION_CODE&amp; redirect_uri=CALLBACK_URL</code></pre><p>上面 URL 中，<code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，<code>redirect_uri</code>参数是令牌颁发后的回调网址。</p><p><img src="/oauth/image-20230322003624932.png" alt="image-20230322003624932"></p><p>第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据。</p><pre><code>{      &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,  &quot;token_type&quot;:&quot;bearer&quot;,  &quot;expires_in&quot;:2592000,  &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,  &quot;scope&quot;:&quot;read&quot;,  &quot;uid&quot;:100101,  &quot;info&quot;:{...}}</code></pre><p>上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。</p><p><img src="/oauth/image-20230322003851943.png" alt="image-20230322003851943"></p><h3 id="隐藏式"><a href="#隐藏式" class="headerlink" title="隐藏式"></a>隐藏式</h3><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</p><p>第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。</p><pre class="line-numbers language-javascript"><code class="language-javascript">https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>b<span class="token punctuation">.</span>com<span class="token operator">/</span>oauth<span class="token operator">/</span>authorize<span class="token operator">?</span>  response_type<span class="token operator">=</span>token<span class="token operator">&amp;</span>  client_id<span class="token operator">=</span>CLIENT_ID<span class="token operator">&amp;</span>  redirect_uri<span class="token operator">=</span>CALLBACK_URL<span class="token operator">&amp;</span>  scope<span class="token operator">=</span>read<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> URL 中，<code>response_type</code>参数为<code>token</code>，表示要求直接返回令牌。</p><p>第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回<code>redirect_uri</code>参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</p><p><img src="/oauth/image-20230322173835499.png" alt="image-20230322173835499"></p><h3 id="密码式"><a href="#密码式" class="headerlink" title="密码式"></a>密码式</h3><p><strong>允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</strong></p><p>第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。</p><pre class="line-numbers language-javascript"><code class="language-javascript">https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>oauth<span class="token punctuation">.</span>b<span class="token punctuation">.</span>com<span class="token operator">/</span>token<span class="token operator">?</span>  grant_type<span class="token operator">=</span>password<span class="token operator">&amp;</span>  username<span class="token operator">=</span>USERNAME<span class="token operator">&amp;</span>  password<span class="token operator">=</span>PASSWORD<span class="token operator">&amp;</span>  client_id<span class="token operator">=</span>CLIENT_ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面 URL 中，<code>grant_type</code>参数是授权方式，这里的<code>password</code>表示”密码式”，<code>username</code>和<code>password</code>是 B 的用户名和密码。</p><p>第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</p><p>这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用</p><h3 id="凭证式"><a href="#凭证式" class="headerlink" title="凭证式"></a>凭证式</h3><p><strong>最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。</strong></p><p>第一步，A 应用在命令行向 B 发出请求。‘</p><pre><code>https://oauth.b.com/token?  grant_type=client_credentials&amp;  client_id=CLIENT_ID&amp;  client_secret=CLIENT_SECRET</code></pre><p>上面 URL 中，<code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式，<code>client_id</code>和<code>client_secret</code>用来让 B 确认 A 的身份。</p><p>第二步，B 网站验证通过以后，直接返回令牌。</p><p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p><h2 id="令牌的使用"><a href="#令牌的使用" class="headerlink" title="令牌的使用"></a>令牌的使用</h2><p>A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。</p><p>此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个<code>Authorization</code>字段，令牌就放在这个字段里面。</p><pre class="line-numbers language-bash"><code class="language-bash">curl -H <span class="token string">"Authorization: Bearer ACCESS_TOKEN"</span> \<span class="token string">"https://api.b.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h2><p>令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。</p><p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p><pre class="line-numbers language-javascript"><code class="language-javascript">https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>b<span class="token punctuation">.</span>com<span class="token operator">/</span>oauth<span class="token operator">/</span>token<span class="token operator">?</span>  grant_type<span class="token operator">=</span>refresh_token<span class="token operator">&amp;</span>  client_id<span class="token operator">=</span>CLIENT_ID<span class="token operator">&amp;</span>  client_secret<span class="token operator">=</span>CLIENT_SECRET<span class="token operator">&amp;</span>  refresh_token<span class="token operator">=</span>REFRESH_TOKEN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面 URL 中，<code>grant_type</code>参数为<code>refresh_token</code>表示要求更新令牌，<code>client_id</code>参数和<code>client_secret</code>参数用于确认身份，<code>refresh_token</code>参数就是用于更新令牌的令牌。</p><p>B 网站验证通过以后，就会颁发新的令牌。</p>]]></content>
      
      
      <categories>
          
          <category> Auth </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oauth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Controller实现Feign 简化代码</title>
      <link href="/feign-simplification.html"/>
      <url>/feign-simplification.html</url>
      
        <content type="html"><![CDATA[<h1 id="Feign简化-feign的接口抽取成公共的api"><a href="#Feign简化-feign的接口抽取成公共的api" class="headerlink" title="Feign简化  feign的接口抽取成公共的api"></a>Feign简化  feign的接口抽取成公共的api</h1><p>加@EnableFeignClients注解</p><p><img src="/feign-simplification/image-20230320211401433.png" alt="image-20230320211401433"></p><p><img src="/feign-simplification/image-20230320210509772.png" alt="image-20230320210509772"></p><p>先抽取出Feign</p><p>用Controller实现Feign类</p><p><img src="/feign-simplification/image-20230320210604423.png" alt="image-20230320210604423"></p><p>简单例子</p><p>项目结构与说明：<br>feign-provider-api（公用接口依赖模块）</p><p>feign-provider-service（feign-provider-api的接口实现模块）</p><p>feign-consumer-service（引用feign-provider-api依赖调用Feign）</p><p>Feign服务提供者</p><p>在feign-provider-api创建feign接口</p><pre><code>@FeignClient(name = &quot;feign-provider-service&quot;)public interface DemoFeign {    @RequestMapping(&quot;demo&quot;)    String demo();}</code></pre><p>在feign-provider-service创建Controller实现DemoFeign接口:</p><pre><code>@RestControllerpublic class DemoFeignController implements DemoFeign {    @Override    public String demo() {        return &quot;this demo feign.&quot;;    }}</code></pre><p>Feign服务消费者：</p><p>在feign-consumer-service单元测试引入feign-provider-api依赖直接调用DemoFeign接口:</p><pre><code>@RunWith(SpringRunner.class)@SpringBootTestpublic class FeignTest {    @Autowired    private DemoFeign demoFeign;    @Test    public void demo(){        System.out.println(demoFeign.demo());    }}</code></pre><p>启动报bean重复创建的错在配置文件加上</p><pre><code>spring.main.allow-bean-definition-overriding: true</code></pre><h1 id="通常的Feign调用"><a href="#通常的Feign调用" class="headerlink" title="通常的Feign调用"></a>通常的Feign调用</h1><p>引入依赖</p><p><img src="/feign-simplification/image-20230320212216979.png" alt="image-20230320212216979"></p><p>要在gulimall-member模块调用gulimall-coupon模块中的coupon/coupon/member/list接口</p><p><img src="/feign-simplification/image-20230320212241761.png" alt="image-20230320212241761"></p><p>在gulimall-member的启动类上加注解@EnableDiscoveryClient，告诉member是一个远程调用客户端</p><p><img src="/feign-simplification/image-20230320212301480.png" alt="image-20230320212301480"></p><p>将要调用的接口新建一个interface文件，在interface中写入要调用远程接口的函数体即可</p><p><img src="/feign-simplification/image-20230320212327191.png" alt="image-20230320212327191"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>community</title>
      <link href="/community.html"/>
      <url>/community.html</url>
      
        <content type="html"><![CDATA[<h1 id="community项目"><a href="#community项目" class="headerlink" title="community项目"></a>community项目</h1>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社区项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-03</title>
      <link href="/mysql-03.html"/>
      <url>/mysql-03.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-日志"><a href="#1-日志" class="headerlink" title="1.日志"></a>1.日志</h1><h2 id="1-1-错误日志"><a href="#1-1-错误日志" class="headerlink" title="1.1 错误日志"></a>1.1 错误日志</h2><p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过 程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，建议首先查看此日 志。 该日志是默认开启的，默认存放目录 /var/log/，默认的日志文件名为 mysqld.log 。查看日志 位置：</p><pre><code>show variables like &#39;%log_error%&#39;;</code></pre><p><img src="/mysql-03/image-20230320140656699.png" alt="image-20230320140656699"></p><h2 id="1-2-二进制日志"><a href="#1-2-二进制日志" class="headerlink" title="1.2 二进制日志"></a>1.2 二进制日志</h2><h3 id="1-2-1-介绍"><a href="#1-2-1-介绍" class="headerlink" title="1.2.1 介绍"></a>1.2.1 介绍</h3><p>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但 不包括数据查询（SELECT、SHOW）语句。</p><p> 作用：①. 灾难时的数据恢复；②. MySQL的主从复制。在MySQL8版本中，默认二进制日志是开启着 的，涉及到的参数如下：</p><pre><code> show variables like &#39;%log_bin%&#39;;</code></pre><p><img src="/mysql-03/image-20230320140852143.png" alt="image-20230320140852143"></p><p>参数说明：</p><ul><li>log_bin_basename：当前数据库服务器的binlog日志的基础名称(前缀)，具体的binlog文 件名需要再该basename的基础上加上编号(编号从000001开始)。</li><li>log_bin_index：binlog的索引文件，里面记录了当前服务器关联的binlog文件有哪些。</li></ul><h3 id="1-2-2-格式"><a href="#1-2-2-格式" class="headerlink" title="1.2.2 格式"></a>1.2.2 格式</h3><p>MySQL服务器中提供了多种格式来记录二进制日志，具体格式及特点如下：</p><table><thead><tr><th>日志格式</th><th>含义</th></tr></thead><tbody><tr><td>STATEMENT</td><td>基于SQL语句的日志记录，记录的是SQL语句，对数据进行修改的SQL都会记录在 日志文件中。</td></tr><tr><td>ROW</td><td>基于行的日志记录，记录的是每一行的数据变更。（默认）</td></tr><tr><td>MIXED</td><td>混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会 自动切换为ROW进行记录。</td></tr></tbody></table><pre><code>show variables like &#39;%binlog_format%&#39;;</code></pre><p><img src="/mysql-03/image-20230320141427815.png" alt="image-20230320141427815"></p><p>需要配置二进制日志的格式，只需要在 /etc/my.cnf 中配置 binlog_format 参数即 可。</p><h3 id="1-2-3-查看"><a href="#1-2-3-查看" class="headerlink" title="1.2.3 查看"></a>1.2.3 查看</h3><p>由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具 mysqlbinlog 来查 看，具体语法：</p><pre><code>mysqlbinlog [ 参数选项 ] logfilename参数选项：-d 指定数据库名称，只列出指定的数据库相关操作。-o 忽略掉日志中的前n行命令。-v 将行事件(数据变更)重构为SQL语句-vv 将行事件(数据变更)重构为SQL语句，并输出注释信息</code></pre><h3 id="1-2-4-删除"><a href="#1-2-4-删除" class="headerlink" title="1.2.4 删除"></a>1.2.4 删除</h3><p>对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空 间。可以通过以下几种方式清理日志：</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>reset master</td><td>删除全部 binlog 日志，删除之后，日志编号，将 从 binlog.000001重新开始</td></tr><tr><td>purge master logs to ‘binlog.*’</td><td>删除 * 编号之前的所有日志</td></tr><tr><td>purge master logs before ‘yyyy-mm-dd hh24:mi:ss’</td><td>删除日志为 “yyyy-mm-dd hh24:mi:ss” 之前 产生的所有日志</td></tr></tbody></table><p>也可以在mysql的配置文件中配置二进制日志的过期时间，设置了之后，二进制日志过期会自动删除。</p><pre><code>show variables like &#39;%binlog_expire_logs_seconds%&#39;;</code></pre><h2 id="1-3-查询日志"><a href="#1-3-查询日志" class="headerlink" title="1.3 查询日志"></a>1.3 查询日志</h2><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。默认情况下， 查询日志是未开启的。</p><p><img src="/mysql-03/image-20230320141813340.png" alt="image-20230320141813340"></p><p>如果需要开启查询日志，可以修改MySQL的配置文件 /etc/my.cnf 文件，添加如下内容：</p><pre><code>#该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启general_log=1#设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.loggeneral_log_file=mysql_query.log</code></pre><p>开启了查询日志之后，在MySQL的数据存放目录，也就是 /var/lib/mysql/ 目录下就会出现 mysql_query.log 文件。之后所有的客户端的增删改查操作都会记录在该日志文件之中，长时间运 行后，该日志文件将会非常大。</p><h2 id="1-4-慢查询日志"><a href="#1-4-慢查询日志" class="headerlink" title="1.4 慢查询日志"></a>1.4 慢查询日志</h2><p>慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的SQL语句的日志，默认未开启。long_query_time 默认为 10 秒，最小为 0， 精度可以到微秒。 如果需要开启慢查询日志，需要在MySQL的配置文件 /etc/my.cnf 中配置如下参数：</p><pre><code>#慢查询日志slow_query_log=1#执行时间参数long_query_time=2</code></pre><p>默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用 log_slow_admin_statements和 更改此行为 log_queries_not_using_indexes，如下所 述。</p><pre><code>#记录执行较慢的管理语句log_slow_admin_statements =1#记录执行较慢的未使用索引的语句log_queries_not_using_indexes = 1</code></pre><p>上述所有的参数配置完成之后，都需要重新启动MySQL服务器才可以生效。</p><h1 id="2-主从复制"><a href="#2-主从复制" class="headerlink" title="2.主从复制"></a>2.主从复制</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><p>主从复制是指将主数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这 些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。 MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状 复制。</p><p><img src="/mysql-03/image-20230320142319910.png" alt="image-20230320142319910"></p><p>MySQL 复制的优点主要包含以下三个方面：</p><ul><li>主库出现问题，可以快速切换到从库提供服务。</li><li>实现读写分离，降低主库的访问压力。</li><li>可以在从库中执行备份，以避免备份期间影响主库服务。</li></ul><h2 id="2-2-原理"><a href="#2-2-原理" class="headerlink" title="2.2 原理"></a>2.2 原理</h2><p>MySQL主从复制的核心就是 二进制日志，具体的过程如下:</p><p><img src="/mysql-03/image-20230320142705600.png" alt="image-20230320142705600"></p><p>从上图来看，复制分成三步：</p><ol><li>Master 主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</li><li>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</li><li>slave重做中继日志中的事件，将改变反映它自己的数据。</li></ol><h2 id="2-3-搭建"><a href="#2-3-搭建" class="headerlink" title="2.3 搭建"></a>2.3 搭建</h2><h3 id="2-3-2-主库配置"><a href="#2-3-2-主库配置" class="headerlink" title="2.3.2 主库配置"></a>2.3.2 主库配置</h3><ol><li>修改配置文件 /etc/my.cnf</li></ol><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 232-1，默认为1server-id=1#是否只读,1 代表只读, 0 代表读写read-only=0#忽略的数据, 指不需要同步的数据库#binlog-ignore-db=mysql#指定同步的数据库#binlog-do-db=db01</code></pre><ol start="2"><li>重启MySQL服务器</li></ol><pre><code>systemctl restart mysqld</code></pre><ol start="3"><li>登录mysql，创建远程连接的账号，并授予主从复制权限</li></ol><pre><code>#创建用户，并设置密码，该用户可在任意主机连接该MySQL服务CREATE USER &#39;用户名&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;Root@123456&#39;;#为 &#39;用户名&#39;@&#39;%&#39; 用户分配主从复制权限GRANT REPLICATION SLAVE ON *.* TO &#39;用户名&#39;@&#39;%&#39;;</code></pre><ol start="4"><li>通过指令，查看二进制日志坐标</li></ol><pre><code>show master status ;</code></pre><p><img src="/mysql-03/image-20230320143411901.png" alt="image-20230320143411901"></p><p>字段含义说明：</p><p>file : 从哪个日志文件开始推送日志文件 </p><p>position ： 从哪个位置开始推送日志 </p><p>binlog_ignore_db : 指定不需要同步的数据库</p><h3 id="2-3-3-从库配置"><a href="#2-3-3-从库配置" class="headerlink" title="2.3.3 从库配置"></a>2.3.3 从库配置</h3><ol><li>修改配置文件 /etc/my.cnf</li></ol><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，和主库不一样即可server-id=2#是否只读,1 代表只读, 0 代表读写read-only=1</code></pre><ol start="2"><li>重新启动MySQL服务</li></ol><pre><code>systemctl restart mysqld</code></pre><ol start="3"><li>登录mysql，设置主库配置</li></ol><pre><code>CHANGE REPLICATION SOURCE TO SOURCE_HOST=&#39;192.168.200.200（主的IP）&#39;, SOURCE_USER=&#39;主机配置的主从权限的用户名&#39;,SOURCE_PASSWORD=&#39;Root@123456&#39;, SOURCE_LOG_FILE=&#39;binlog.000004&#39;,SOURCE_LOG_POS=663;</code></pre><p>上述是8.0.23中的语法。如果mysql是 8.0.23 之前的版本，执行如下SQL：</p><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.200.200&#39;, MASTER_USER=&#39;主机配置的主从权限的用户名&#39;,MASTER_PASSWORD=&#39;Root@123456&#39;, MASTER_LOG_FILE=&#39;binlog.000004&#39;,MASTER_LOG_POS=663;</code></pre><table><thead><tr><th>参数名</th><th>含义</th><th>8.0.23之前</th></tr></thead><tbody><tr><td>SOURCE_HOST</td><td>主库IP地址</td><td>MASTER_HOST</td></tr><tr><td>SOURCE_USER</td><td>连接主库的用户名</td><td>MASTER_USER</td></tr><tr><td>SOURCE_PASSWORD</td><td>连接主库的密码</td><td>MASTER_PASSWORD</td></tr><tr><td>SOURCE_LOG_FILE</td><td>binlog日志文件名</td><td>MASTER_LOG_FILE</td></tr><tr><td>SOURCE_LOG_POS</td><td>binlog日志文件位置</td><td>MASTER_LOG_POS</td></tr></tbody></table><ol start="4"><li>开启同步操作</li></ol><pre><code>start replica ; #8.0.22之后start slave ; #8.0.22之前</code></pre><ol start="5"><li>查看主从同步状态</li></ol><pre><code>show replica status ; #8.0.22之后show slave status ; #8.0.22之前</code></pre><p><img src="/mysql-03/image-20230320144151638.png" alt="image-20230320144151638"></p><h1 id="3-分库分表"><a href="#3-分库分表" class="headerlink" title="3.分库分表"></a>3.分库分表</h1><h2 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h2><h3 id="3-1-1-问题分析"><a href="#3-1-1-问题分析" class="headerlink" title="3.1.1 问题分析"></a>3.1.1 问题分析</h3><p><img src="/mysql-03/image-20230320144250086.png" alt="image-20230320144250086"></p><p>随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存 储，存在以下性能瓶颈：</p><ol><li>IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。 请求数据太多，带宽 不够，网络IO瓶颈。</li><li>CPU瓶颈：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出 现瓶颈。</li></ol><p>为了解决上述问题，需要对数据库进行分库分表处理。</p><p><img src="/mysql-03/image-20230320144509133.png" alt="image-20230320144509133"></p><p>分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能 问题，从而达到提升数据库性能的目的。</p><h3 id="3-1-2-拆分策略"><a href="#3-1-2-拆分策略" class="headerlink" title="3.1.2 拆分策略"></a>3.1.2 拆分策略</h3><p>分库分表的形式，主要是两种：垂直拆分和水平拆分。而拆分的粒度，一般又分为分库和分表，所以组 成的拆分策略最终如下:</p><p><img src="/mysql-03/image-20230320145312892.png" alt="image-20230320145312892"></p><h3 id="3-1-3-垂直拆分"><a href="#3-1-3-垂直拆分" class="headerlink" title="3.1.3 垂直拆分"></a>3.1.3 垂直拆分</h3><ol><li>垂直分库</li></ol><p><img src="/mysql-03/image-20230320145342887.png" alt="image-20230320145342887"></p><p>垂直分库：以表为依据，根据业务将不同表拆分到不同库中。</p><p>特点：</p><ul><li>每个库的表结构都不一样。 </li><li>每个库的数据也不一样。</li><li>所有库的并集是全量数据。</li></ul><ol start="2"><li>垂直分表</li></ol><p><img src="/mysql-03/image-20230320145429454.png" alt="image-20230320145429454"></p><p>垂直分表：以字段为依据，根据字段属性将不同字段拆分到不同表中。</p><p>特点： </p><ul><li>每个表的结构都不一样。</li><li>每个表的数据也不一样，一般通过一列（主键/外键）关联。</li><li>所有表的并集是全量数据。</li></ul><h3 id="3-1-4-水平拆分"><a href="#3-1-4-水平拆分" class="headerlink" title="3.1.4 水平拆分"></a>3.1.4 水平拆分</h3><ol><li>水平分库</li></ol><p><img src="/mysql-03/image-20230320145608750.png" alt="image-20230320145608750"></p><p>水平分库：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中。</p><p>特点：</p><ul><li>每个库的表结构都一样。 </li><li>每个库的数据都不一样。 </li><li>所有库的并集是全量数据。</li></ul><ol start="2"><li>水平分表</li></ol><p><img src="/mysql-03/image-20230320145849506.png" alt="image-20230320145849506"></p><p>水平分表：以字段为依据，按照一定策略，将一个表的数据拆分到多个表中。</p><p>特点：</p><ul><li>每个表的表结构都一样。</li><li>每个表的数据都不一样。 </li><li>所有表的并集是全量数据。</li></ul><p>在业务系统中，为了缓解磁盘IO及CPU的性能瓶颈，到底是垂直拆分，还是水平拆分；具体是分 库，还是分表，都需要根据具体的业务需求具体分析。</p><h3 id="3-1-5-实现技术"><a href="#3-1-5-实现技术" class="headerlink" title="3.1.5 实现技术"></a>3.1.5 实现技术</h3><ul><li>shardingJDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处 理。需要自行编码配置实现，只支持java语言，性能较高。</li><li>MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者</li></ul><p><img src="/mysql-03/image-20230320150320070.png" alt="image-20230320150320070"></p><h2 id="3-2-MyCat概述"><a href="#3-2-MyCat概述" class="headerlink" title="3.2 MyCat概述"></a>3.2 MyCat概述</h2><h3 id="3-2-1-介绍"><a href="#3-2-1-介绍" class="headerlink" title="3.2.1 介绍"></a>3.2.1 介绍</h3><p>Mycat是开源的、活跃的、基于Java语言编写的MySQL数据库中间件。可以像使用mysql一样来使用 mycat，对于开发人员来说根本感觉不到mycat的存在。 开发人员只需要连接MyCat即可，而具体底层用到几台数据库，每一台数据库服务器里面存储了什么数 据，都无需关心。 具体的分库分表的策略，只需要在MyCat中配置即可。</p><p><img src="/mysql-03/image-20230320150523355.png" alt="image-20230320150523355"></p><h3 id="3-2-2-下载"><a href="#3-2-2-下载" class="headerlink" title="3.2.2 下载"></a>3.2.2 下载</h3><p><a href="http://dl.mycat.org.cn/" target="_blank" rel="noopener">Index of / (mycat.org.cn)</a></p><p><a href="http://www.mycat.org.cn/" target="_blank" rel="noopener">上海云业网络科技有限公司 (mycat.org.cn)</a></p><h3 id="3-2-3-安装"><a href="#3-2-3-安装" class="headerlink" title="3.2.3 安装"></a>3.2.3 安装</h3><p>Mycat是采用java语言开发的开源的数据库中间件，支持Windows和Linux运行环境，下面介绍 MyCat的Linux中的环境搭建。</p><h3 id="3-2-4-目录介绍"><a href="#3-2-4-目录介绍" class="headerlink" title="3.2.4 目录介绍"></a>3.2.4 目录介绍</h3><p><img src="/mysql-03/image-20230320150737718.png" alt="image-20230320150737718"></p><p>bin : 存放可执行文件，用于启动停止mycat </p><p>conf：存放mycat的配置文件 </p><p>lib：存放mycat的项目依赖包（jar）</p><p> logs：存放mycat的日志文件</p><h3 id="3-2-5-概念介绍"><a href="#3-2-5-概念介绍" class="headerlink" title="3.2.5 概念介绍"></a>3.2.5 概念介绍</h3><p>在MyCat的整体结构中，分为两个部分：上面的逻辑结构、下面的物理结构。</p><p><img src="/mysql-03/image-20230320150825985.png" alt="image-20230320150825985"></p><p>在MyCat的逻辑结构主要负责逻辑库、逻辑表、分片规则、分片节点等逻辑结构的处理，而具体的数据 存储还是在物理结构，也就是数据库服务器中存储的。</p><h2 id="3-3-MyCat入门"><a href="#3-3-MyCat入门" class="headerlink" title="3.3 MyCat入门"></a>3.3 MyCat入门</h2><h3 id="3-3-1-需求"><a href="#3-3-1-需求" class="headerlink" title="3.3.1 需求"></a>3.3.1 需求</h3><p>由于 tb_order 表中数据量很大，磁盘IO及容量都到达了瓶颈，现在需要对 tb_order 表进行数 据分片，分为三个数据节点，每一个节点主机位于不同的服务器上, 具体的结构，参考下图:</p><p><img src="/mysql-03/image-20230320150915592.png" alt="image-20230320150915592"></p><h3 id="3-3-2-环境准备"><a href="#3-3-2-环境准备" class="headerlink" title="3.3.2 环境准备"></a>3.3.2 环境准备</h3><p>准备3台服务器</p><p>192.168.200.210：MyCat中间件服务器，同时也是第一个分片服务器。 </p><p>192.168.200.213：第二个分片服务器。 </p><p>192.168.200.214：第三个分片服务器</p><p><img src="/mysql-03/image-20230320150949987.png" alt="image-20230320150949987"></p><h3 id="3-3-3-配置"><a href="#3-3-3-配置" class="headerlink" title="3.3.3 配置"></a>3.3.3 配置</h3><p>1). schema.xml</p><p>在schema.xml中配置逻辑库、逻辑表、数据节点、节点主机等相关信息。具体的配置如下：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?></span><span class="token doctype">&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mycat:</span>schema</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>mycat</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://io.mycat/<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>schema</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>DB01<span class="token punctuation">"</span></span> <span class="token attr-name">checkSQLschema</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">sqlMaxLimit</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>TB_ORDER<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1,dn2,dn3<span class="token punctuation">"</span></span> <span class="token attr-name">rule</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>auto-sharding-long<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>schema</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost1<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>db01<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn2<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost2<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>db01<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost3<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>db01<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    &lt;dataHost name="dhost1" maxCon="1000" minCon="10" balance="0"writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"slaveThreshold="100">        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.210:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span>    &lt;dataHost name="dhost2" maxCon="1000" minCon="10" balance="0"writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"slaveThreshold="100">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.213:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span>    &lt;dataHost name="dhost3" maxCon="1000" minCon="10" balance="0"writeType="0" dbType="mysql" dbDriver="jdbc" switchType="1"slaveThreshold="100">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.214:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mycat:</span>schema</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2). server.xml</p><p>需要在server.xml中配置用户名、密码，以及用户的访问权限信息，具体的配置如下：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">defaultAccount</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>DB01<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 表级 DML 权限设置 --></span><span class="token comment" spellcheck="true">&lt;!--&lt;privileges check="true">&lt;schema name="DB01" dml="0110" >&lt;table name="TB_ORDER" dml="1110">&lt;/table>&lt;/schema>&lt;/privileges>--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>DB01<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>readOnly<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述的配置表示，定义了两个用户 root 和 user ，这两个用户都可以访问 DB01 这个逻辑库，访 问密码都是123456，但是root用户访问DB01逻辑库，既可以读，又可以写，但是 user用户访问 DB01逻辑库是只读的。</p><h3 id="3-3-4-测试"><a href="#3-3-4-测试" class="headerlink" title="3.3.4 测试"></a>3.3.4 测试</h3><h5 id="3-3-4-1-启动"><a href="#3-3-4-1-启动" class="headerlink" title="3.3.4.1 启动"></a>3.3.4.1 启动</h5><p>配置完毕后，先启动涉及到的3台分片服务器，然后启动MyCat服务器。切换到Mycat的安装目录，执 行如下指令，启动Mycat：</p><pre><code>#启动bin/mycat start#停止bin/mycat stop</code></pre><p>Mycat启动之后，占用端口号 8066。 启动完毕之后，可以查看logs目录下的启动日志，查看Mycat是否启动完成。</p><p><img src="/mysql-03/image-20230320151743184.png" alt="image-20230320151743184"></p><h5 id="3-3-4-2-测试"><a href="#3-3-4-2-测试" class="headerlink" title="3.3.4.2 测试"></a>3.3.4.2 测试</h5><p>1). 连接MyCat 通过如下指令，就可以连接并登陆MyCat。</p><pre><code>mysql -h 192.168.200.210 -P 8066 -uroot -p123456</code></pre><p>通过MySQL的指令来连接的MyCat，因为MyCat在底层实际上是模拟了MySQL的协议。</p><h2 id="3-4-MyCat配置"><a href="#3-4-MyCat配置" class="headerlink" title="3.4 MyCat配置"></a>3.4 MyCat配置</h2><h3 id="3-4-1-schema-xml"><a href="#3-4-1-schema-xml" class="headerlink" title="3.4.1 schema.xml"></a>3.4.1 schema.xml</h3><p>schema.xml 作为MyCat中最重要的配置文件之一 , 涵盖了MyCat的逻辑库 、 逻辑表 、 分片规 则、分片节点及数据源的配置。</p><p><img src="/mysql-03/image-20230320155347462.png" alt="image-20230320155347462"></p><p>主要包含以下三组标签：</p><ul><li>schema标签 </li><li>datanode标签 </li><li>datahost标签</li></ul><h4 id="3-4-1-1-schema标签"><a href="#3-4-1-1-schema标签" class="headerlink" title="3.4.1.1 schema标签"></a>3.4.1.1 schema标签</h4><p>1). schema 定义逻辑库</p><p><img src="/mysql-03/image-20230320155440593.png" alt="image-20230320155440593"></p><p>schema 标签用于定义 MyCat实例中的逻辑库 , 一个MyCat实例中, 可以有多个逻辑库 , 可以通 过 schema 标签来划分不同的逻辑库。MyCat中的逻辑库的概念，等同于MySQL中的database概念 , 需要操作某个逻辑库下的表时, 也需要切换逻辑库(use xxx)。</p><p>核心属性：</p><ul><li>name：指定自定义的逻辑库库名 </li><li>checkSQLschema：在SQL语句操作时指定了数据库名称，执行时是否自动去除；true：自动去 除，false：不自动去除 </li><li>sqlMaxLimit：如果未指定limit进行查询，列表查询模式查询多少条记录</li></ul><p>2). schema 中的table定义逻辑表</p><p><img src="/mysql-03/image-20230320155722222.png" alt="image-20230320155722222"></p><ul><li>table 标签定义了MyCat中逻辑库schema下的逻辑表 , 所有需要拆分的表都需要在table标签中定义 </li><li>name：定义逻辑表表名，在该逻辑库下唯一 </li><li>dataNode：定义逻辑表所属的dataNode，该属性需要与dataNode标签中name对应；多个 dataNode逗号分隔 </li><li>rule：分片规则的名字，分片规则名字是在rule.xml中定义的</li><li>primaryKey：逻辑表对应真实表的主键</li><li>type：逻辑表的类型，目前逻辑表只有全局表和普通表，如果未配置，就是普通表；全局表，配 置为 global</li></ul><h4 id="3-4-1-2-datanode标签"><a href="#3-4-1-2-datanode标签" class="headerlink" title="3.4.1.2 datanode标签"></a>3.4.1.2 datanode标签</h4><p><img src="/mysql-03/image-20230320155909258.png" alt="image-20230320155909258"></p><p>核心属性：</p><ul><li>name：定义数据节点名称 </li><li>dataHost：数据库实例主机名称，引用自 dataHost 标签中name属性 </li><li>database：定义分片所属数据库</li></ul><h4 id="3-4-1-3-datahost标签"><a href="#3-4-1-3-datahost标签" class="headerlink" title="3.4.1.3 datahost标签"></a>3.4.1.3 datahost标签</h4><p><img src="/mysql-03/image-20230320160009277.png" alt="image-20230320160009277"></p><p>该标签在MyCat逻辑库中作为底层标签存在, 直接定义了具体的数据库实例、读写分离、心跳语句。</p><p>核心属性：</p><ul><li>name：唯一标识，供上层标签使用 </li><li>maxCon/minCon：最大连接数/最小连接数 </li><li>balance：负载均衡策略，取值 0,1,2,3 </li><li>writeType：写操作分发方式（0：写操作转发到第一个writeHost，第一个挂了，切换到第二 个；1：写操作随机分发到配置的writeHost） </li><li>dbDriver：数据库驱动，支持 native、jdbc</li></ul><h3 id="3-4-2-rule-xml"><a href="#3-4-2-rule-xml" class="headerlink" title="3.4.2 rule.xml"></a>3.4.2 rule.xml</h3><p>rule.xml中定义所有拆分表的规则, 在使用过程中可以灵活的使用分片算法, 或者对同一个分片算法 使用不同的参数, 它让分片过程可配置化。主要包含两类标签：tableRule、Function。</p><p><img src="/mysql-03/image-20230320161120658.png" alt="image-20230320161120658"></p><h3 id="3-4-3-server-xml"><a href="#3-4-3-server-xml" class="headerlink" title="3.4.3 server.xml"></a>3.4.3 server.xml</h3><p>server.xml配置文件包含了MyCat的系统配置信息，主要有两个重要的标签：system、user。</p><p>1). system标签</p><p><img src="/mysql-03/image-20230320161144281.png" alt="image-20230320161144281"></p><p>主要配置MyCat中的系统配置信息，对应的系统配置项及其含义，如下：</p><p><img src="/mysql-03/image-20230320161525830.png" alt="image-20230320161525830"></p><p><img src="/mysql-03/image-20230320161540434.png" alt="image-20230320161540434"></p><p><img src="/mysql-03/image-20230320161552677.png" alt="image-20230320161552677"></p><p><img src="/mysql-03/image-20230320161602557.png" alt="image-20230320161602557"></p><p><img src="/mysql-03/image-20230320161610512.png" alt="image-20230320161610512"></p><p>2). user标签 配置MyCat中的用户、访问密码，以及用户针对于逻辑库、逻辑表的权限信息，具体的权限描述方式及 配置说明如下：</p><p><img src="/mysql-03/image-20230320161624635.png" alt="image-20230320161624635"></p><p>在测试权限操作时，只需要将 privileges 标签的注释放开。 在 privileges 下的schema 标签中配置的dml属性配置的是逻辑库的权限。 在privileges的schema下的table标签的dml属性 中配置逻辑表的权限。</p><h2 id="3-5-MyCat分片"><a href="#3-5-MyCat分片" class="headerlink" title="3.5 MyCat分片"></a>3.5 MyCat分片</h2><h3 id="3-5-1-垂直拆分"><a href="#3-5-1-垂直拆分" class="headerlink" title="3.5.1 垂直拆分"></a>3.5.1 垂直拆分</h3><h4 id="3-5-1-1-场景"><a href="#3-5-1-1-场景" class="headerlink" title="3.5.1.1 场景"></a>3.5.1.1 场景</h4><p>在业务系统中, 涉及以下表结构 ,但是由于用户与订单每天都会产生大量的数据, 单台服务器的数据 存储及处理能力是有限的, 可以对数据库表进行拆分, 原有的数据库表如下。</p><p><img src="/mysql-03/image-20230320161732844.png" alt="image-20230320161732844"></p><p>现在考虑将其进行垂直分库操作，将商品相关的表拆分到一个数据库服务器，订单表拆分的一个数据库 服务器，用户及省市区表拆分到一个服务器。最终结构如下：</p><p><img src="/mysql-03/image-20230320161813202.png" alt="image-20230320161813202"></p><h4 id="3-5-1-2-准备"><a href="#3-5-1-2-准备" class="headerlink" title="3.5.1.2 准备"></a>3.5.1.2 准备</h4><p><img src="/mysql-03/image-20230320161837383.png" alt="image-20230320161837383"></p><p>并且在192.168.200.210，192.168.200.213, 192.168.200.214上面创建数据库 shopping。</p><h4 id="3-5-1-3-配置"><a href="#3-5-1-3-配置" class="headerlink" title="3.5.1.3 配置"></a>3.5.1.3 配置</h4><p>1). schema.xml</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>schema</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>SHOPPING<span class="token punctuation">"</span></span> <span class="token attr-name">checkSQLschema</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">sqlMaxLimit</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_goods_base<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_goods_brand<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_goods_cat<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_goods_desc<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>goods_id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_goods_item<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_order_item<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn2<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_order_master<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn2<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>order_id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_order_pay_log<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn2<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>out_trade_no<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_user<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_user_address<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_areas_provinces<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_areas_city<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tb_areas_region<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">primaryKey</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>schema</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn1<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost1<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>shopping<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn2<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost2<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>shopping<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn3<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost3<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>shopping<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataHost</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost1<span class="token punctuation">"</span></span> <span class="token attr-name">maxCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span> <span class="token attr-name">minCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">balance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token attr-name">writeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">dbType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span> <span class="token attr-name">dbDriver</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc<span class="token punctuation">"</span></span> <span class="token attr-name">switchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token attr-name">slaveThreshold</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.210:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataHost</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost2<span class="token punctuation">"</span></span> <span class="token attr-name">maxCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span> <span class="token attr-name">minCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">balance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token attr-name">writeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">dbType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span> <span class="token attr-name">dbDriver</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc<span class="token punctuation">"</span></span> <span class="token attr-name">switchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token attr-name">slaveThreshold</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.213:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataHost</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost3<span class="token punctuation">"</span></span> <span class="token attr-name">maxCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span> <span class="token attr-name">minCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">balance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token attr-name">writeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token attr-name">dbType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span> <span class="token attr-name">dbDriver</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc<span class="token punctuation">"</span></span> <span class="token attr-name">switchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token attr-name">slaveThreshold</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.214:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2). server.xml</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">defaultAccount</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>SHOPPING<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 表级 DML 权限设置 --></span><span class="token comment" spellcheck="true">&lt;!--&lt;privileges check="true">&lt;schema name="DB01" dml="0110" >&lt;table name="TB_ORDER" dml="1110">&lt;/table>&lt;/schema>&lt;/privileges>--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>schemas<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>SHOPPING<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>readOnly<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>user</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-5-1-4-测试"><a href="#3-5-1-4-测试" class="headerlink" title="3.5.1.4 测试"></a>3.5.1.4 测试</h4><p>重新启动MyCat后，在mycat的命令行中，通过source指令导入表结构，以及对应的数据，查看数据 分布情况。</p><pre><code>source /root/shopping-table.sqlsource /root/shopping-insert.sql</code></pre><p>将表结构及对应的测试数据导入之后，可以检查一下各个数据库服务器中的表结构分布情况。 检查是 否和我们准备工作中规划的服务器一致。</p><p><img src="/mysql-03/image-20230320162038225.png" alt="image-20230320162038225"></p><p>订单相关的表结构是在 192.168.200.213 数据库服务器中，而省市区的数 据库表是在 192.168.200.214 数据库服务器中。会出现问题</p><p>因为MyCat在执行该SQL语句时，需要往具体的数 据库服务器中路由，而当前没有一个数据库服务器完全包含了订单以及省市区的表结构，造成SQL语句失败报错。</p><p>可以使用全局表</p><h4 id="3-5-1-5-全局表"><a href="#3-5-1-5-全局表" class="headerlink" title="3.5.1.5 全局表"></a>3.5.1.5 全局表</h4><p>对于省、市、区/县表tb_areas_provinces , tb_areas_city , tb_areas_region，是属于 数据字典表，在多个业务模块中都可能会遇到，可以将其设置为全局表，利于业务操作。</p><p>修改schema.xml中的逻辑表的配置，修改 tb_areas_provinces、tb_areas_city、 tb_areas_region 三个逻辑表，增加 type 属性，配置为global，就代表该表是全局表，就会在 所涉及到的dataNode中创建给表。对于当前配置来说，也就意味着所有的节点中都有该表了。</p><pre><code>&lt;table name=&quot;tb_areas_provinces&quot; dataNode=&quot;dn1,dn2,dn3&quot; primaryKey=&quot;id&quot;type=&quot;global&quot;/&gt;&lt;table name=&quot;tb_areas_city&quot; dataNode=&quot;dn1,dn2,dn3&quot; primaryKey=&quot;id&quot;type=&quot;global&quot;/&gt;&lt;table name=&quot;tb_areas_region&quot; dataNode=&quot;dn1,dn2,dn3&quot; primaryKey=&quot;id&quot;type=&quot;global&quot;/&gt;</code></pre><p><img src="/mysql-03/image-20230320162458936.png" alt="image-20230320162458936"></p><p>配置完毕后，重新启动MyCat。</p><p>1). 删除原来每一个数据库服务器中的所有表结构</p><p>2). 通过source指令，导入表及数据</p><pre><code>source /root/shopping-table.sqlsource /root/shopping-insert.sql</code></pre><p>3). 检查每一个数据库服务器中的表及数据分布，看到三个节点中都有这三张全局表 4). 然后再次执行上面的多表联查的SQL语句</p><pre><code>SELECT order_id , payment ,receiver, province , city , area FROM tb_order_master o, tb_areas_provinces p , tb_areas_city c , tb_areas_region r WHEREo.receiver_province = p.provinceid AND o.receiver_city = c.cityid ANDo.receiver_region = r.areaid ;</code></pre><p><img src="/mysql-03/image-20230320162600231.png" alt="image-20230320162600231"></p><p>是可以正常执行成功的。</p><p> 5). 当在MyCat中更新全局表的时候，我们可以看到，所有分片节点中的数据都发生了变化，每个节 点的全局表数据时刻保持一致。</p><h3 id="3-5-2-水平拆分"><a href="#3-5-2-水平拆分" class="headerlink" title="3.5.2 水平拆分"></a>3.5.2 水平拆分</h3><h4 id="3-5-2-1-场景"><a href="#3-5-2-1-场景" class="headerlink" title="3.5.2.1 场景"></a>3.5.2.1 场景</h4><p>在业务系统中, 有一张表(日志表), 业务系统每天都会产生大量的日志数据 , 单台服务器的数据存 储及处理能力是有限的, 可以对数据库表进行拆分。</p><p><img src="/mysql-03/image-20230320162710396.png" alt="image-20230320162710396"></p><h4 id="3-5-2-2-准备"><a href="#3-5-2-2-准备" class="headerlink" title="3.5.2.2 准备"></a>3.5.2.2 准备</h4><p>准备三台服务器，具体的结构如下：</p><p><img src="/mysql-03/image-20230320162730435.png" alt="image-20230320162730435"></p><h4 id="3-5-2-3-配置"><a href="#3-5-2-3-配置" class="headerlink" title="3.5.2.3 配置"></a>3.5.2.3 配置</h4><p>1). schema.xml</p><pre><code>&lt;schema name=&quot;ITCAST&quot; checkSQLschema=&quot;true&quot; sqlMaxLimit=&quot;100&quot;&gt;&lt;table name=&quot;tb_log&quot; dataNode=&quot;dn4,dn5,dn6&quot; primaryKey=&quot;id&quot; rule=&quot;mod-long&quot; /&gt;&lt;/schema&gt;&lt;dataNode name=&quot;dn4&quot; dataHost=&quot;dhost1&quot; database=&quot;itcast&quot; /&gt;&lt;dataNode name=&quot;dn5&quot; dataHost=&quot;dhost2&quot; database=&quot;itcast&quot; /&gt;&lt;dataNode name=&quot;dn6&quot; dataHost=&quot;dhost3&quot; database=&quot;itcast&quot; /&gt;</code></pre><p>tb_log表最终落在3个节点中，分别是 dn4、dn5、dn6 ，而具体的数据分别存储在 dhost1、 dhost2、dhost3的itcast数据库中。</p><p>2). server.xml</p><p>配置root用户既可以访问 SHOPPING 逻辑库，又可以访问ITCAST逻辑库。</p><pre><code>&lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;&lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;&lt;property name=&quot;schemas&quot;&gt;SHOPPING,ITCAST&lt;/property&gt;&lt;!-- 表级 DML 权限设置 --&gt;&lt;!--&lt;privileges check=&quot;true&quot;&gt;&lt;schema name=&quot;DB01&quot; dml=&quot;0110&quot; &gt;&lt;table name=&quot;TB_ORDER&quot; dml=&quot;1110&quot;&gt;&lt;/table&gt;&lt;/schema&gt;&lt;/privileges&gt;--&gt;&lt;/user&gt;</code></pre><h3 id="3-5-3-分片规则"><a href="#3-5-3-分片规则" class="headerlink" title="3.5.3 分片规则"></a>3.5.3 分片规则</h3><h4 id="3-5-3-1-范围分片"><a href="#3-5-3-1-范围分片" class="headerlink" title="3.5.3.1 范围分片"></a>3.5.3.1 范围分片</h4><p>1). 介绍</p><p>根据指定的字段及其配置的范围与数据节点的对应情况， 来决定该数据属于哪一个分片。</p><p><img src="/mysql-03/image-20230320164124963.png" alt="image-20230320164124963"></p><p>2). 配置</p><p>schema.xml逻辑表配置：</p><pre><code>&lt;table name=&quot;TB_ORDER&quot; dataNode=&quot;dn1,dn2,dn3&quot; rule=&quot;auto-sharding-long&quot; /&gt;</code></pre><p>schema.xml数据节点配置：</p><pre><code>&lt;dataNode name=&quot;dn1&quot; dataHost=&quot;dhost1&quot; database=&quot;db01&quot; /&gt;&lt;dataNode name=&quot;dn2&quot; dataHost=&quot;dhost2&quot; database=&quot;db01&quot; /&gt;&lt;dataNode name=&quot;dn3&quot; dataHost=&quot;dhost3&quot; database=&quot;db01&quot; /&gt;</code></pre><p>rule.xml分片规则配置：</p><pre><code>&lt;tableRule name=&quot;auto-sharding-long&quot;&gt;&lt;rule&gt;&lt;columns&gt;id&lt;/columns&gt;&lt;algorithm&gt;rang-long&lt;/algorithm&gt;&lt;/rule&gt;&lt;/tableRule&gt;&lt;function name=&quot;rang-long&quot; class=&quot;io.mycat.route.function.AutoPartitionByLong&quot;&gt;&lt;property name=&quot;mapFile&quot;&gt;autopartition-long.txt&lt;/property&gt;&lt;property name=&quot;defaultNode&quot;&gt;0&lt;/property&gt;&lt;/function&gt;</code></pre><p>分片规则配置属性含义：</p><p><img src="/mysql-03/image-20230320164320830.png" alt="image-20230320164320830"></p><p>在rule.xml中配置分片规则时，关联了一个映射配置文件 autopartition-long.txt，该配置文 件的配置如下：</p><pre><code># range start-end ,data node index# K=1000,M=10000.0-500M=0500M-1000M=11000M-1500M=2</code></pre><p>含义：0-500万之间的值，存储在0号数据节点(数据节点的索引从0开始) ； 500万-1000万之间的 数据存储在1号数据节点 ； 1000万-1500万的数据节点存储在2号节点 ；该分片规则，主要是针对于数字类型的字段适用。 </p><h4 id="3-5-3-2-取模分片"><a href="#3-5-3-2-取模分片" class="headerlink" title="3.5.3.2 取模分片"></a>3.5.3.2 取模分片</h4><p>1). 介绍</p><p>根据指定的字段值与节点数量进行求模运算，根据运算结果， 来决定该数据属于哪一个分片。</p><p><img src="/mysql-03/image-20230320164524561.png" alt="image-20230320164524561"></p><p>2). 配置</p><p>schema.xml逻辑表配置：</p><pre><code>&lt;table name=&quot;tb_log&quot; dataNode=&quot;dn4,dn5,dn6&quot; primaryKey=&quot;id&quot; rule=&quot;mod-long&quot; /&gt;</code></pre><p>schema.xml数据节点配置：</p><pre><code>&lt;dataNode name=&quot;dn4&quot; dataHost=&quot;dhost1&quot; database=&quot;itcast&quot; /&gt;&lt;dataNode name=&quot;dn5&quot; dataHost=&quot;dhost2&quot; database=&quot;itcast&quot; /&gt;&lt;dataNode name=&quot;dn6&quot; dataHost=&quot;dhost3&quot; database=&quot;itcast&quot; /&gt;</code></pre><p>rule.xml分片规则配置：</p><pre><code>&lt;tableRule name=&quot;mod-long&quot;&gt;&lt;rule&gt;&lt;columns&gt;id&lt;/columns&gt;&lt;algorithm&gt;mod-long&lt;/algorithm&gt;&lt;/rule&gt;&lt;/tableRule&gt;&lt;function name=&quot;mod-long&quot; class=&quot;io.mycat.route.function.PartitionByMod&quot;&gt;&lt;property name=&quot;count&quot;&gt;3&lt;/property&gt;&lt;/function&gt;</code></pre><p>分片规则属性说明如下：</p><p><img src="/mysql-03/image-20230320164606426.png" alt="image-20230320164606426"></p><p>该分片规则，主要是针对于数字类型的字段适用。 在前面水平拆分的演示中，我们选择的就是取模分 片。</p><p>更多规则可看管网</p><p><a href="https://www.yuque.com/ccazhw/ml3nkf/fd9bb7d92f18138725bd53bae67d1d98" target="_blank" rel="noopener">分片算法简介 (yuque.com)</a></p><h2 id="3-6-MyCat管理及监控"><a href="#3-6-MyCat管理及监控" class="headerlink" title="3.6 MyCat管理及监控"></a>3.6 MyCat管理及监控</h2><h3 id="3-6-1-MyCat原理"><a href="#3-6-1-MyCat原理" class="headerlink" title="3.6.1 MyCat原理"></a>3.6.1 MyCat原理</h3><p><img src="/mysql-03/image-20230320164824809.png" alt="image-20230320164824809"></p><p>在MyCat中，当执行一条SQL语句时，MyCat需要进行SQL解析、分片分析、路由分析、读写分离分析 等操作，最终经过一系列的分析决定将当前的SQL语句到底路由到那几个(或哪一个)节点数据库，数据 库将数据执行完毕后，如果有返回的结果，则将结果返回给MyCat，最终还需要在MyCat中进行结果合 并、聚合处理、排序处理、分页处理等操作，最终再将结果返回给客户端。 而在MyCat的使用过程中，MyCat官方也提供了一个管理监控平台MyCat-Web（MyCat-eye）。 Mycat-web 是 Mycat 可视化运维的管理和监控平台，弥补了 Mycat 在监控上的空白。帮 Mycat 分担统计任务和配置管理任务。Mycat-web 引入了 ZooKeeper 作为配置中心，可以管理多个节 点。Mycat-web 主要管理和监控 Mycat 的流量、连接、活动线程和内存等，具备 IP 白名单、邮 件告警等模块，还可以统计 SQL 并分析慢 SQL 和高频 SQL 等。为优化 SQL 提供依据。</p><h3 id="3-6-2-MyCat管理"><a href="#3-6-2-MyCat管理" class="headerlink" title="3.6.2 MyCat管理"></a>3.6.2 MyCat管理</h3><p>Mycat默认开通2个端口，可以在server.xml中进行修改。 </p><p>8066 数据访问端口，即进行 DML 和 DDL 操作。 </p><p>9066 数据库管理端口，即 mycat 服务管理控制功能，用于管理mycat的整个集群状态 </p><p>连接MyCat的管理控制台：</p><pre><code>1 mysql -h 192.168.200.210 -p 9066 -uroot -p123456</code></pre><p><img src="/mysql-03/image-20230320164926322.png" alt="image-20230320164926322"></p><h3 id="3-6-3-MyCat-eye"><a href="#3-6-3-MyCat-eye" class="headerlink" title="3.6.3 MyCat-eye"></a>3.6.3 MyCat-eye</h3><h4 id="3-6-3-1-介绍"><a href="#3-6-3-1-介绍" class="headerlink" title="3.6.3.1 介绍"></a>3.6.3.1 介绍</h4><p>Mycat-web(Mycat-eye)是对mycat-server提供监控服务，功能不局限于对mycat-server使 用。他通过JDBC连接对Mycat、Mysql监控，监控远程服务器(目前仅限于linux系统)的cpu、内 存、网络、磁盘。 Mycat-eye运行过程中需要依赖zookeeper，因此需要先安装zookeeper。</p><h1 id="4-读写分离"><a href="#4-读写分离" class="headerlink" title="4.读写分离"></a>4.读写分离</h1><h2 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h2><p>读写分离,简单地说是把对数据库的读和写操作分开,以对应不同的数据库服务器。主数据库提供写操 作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。 通过MyCat即可轻易实现上述功能，不仅可以支持MySQL，也可以支持Oracle和SQL Server。</p><p><img src="/mysql-03/image-20230320165609781.png" alt="image-20230320165609781"></p><h2 id="4-2-一主一从"><a href="#4-2-一主一从" class="headerlink" title="4.2 一主一从"></a>4.2 一主一从</h2><h3 id="4-2-1-原理"><a href="#4-2-1-原理" class="headerlink" title="4.2.1 原理"></a>4.2.1 原理</h3><p>MySQL的主从复制，是基于二进制日志（binlog）实现的。</p><p><img src="/mysql-03/image-20230320165744188.png" alt="image-20230320165744188"></p><p>4.2.2 准备</p><p><img src="/mysql-03/image-20230320165754344.png" alt="image-20230320165754344"></p><p>主从复制的搭建，可以参考前面课程中 主从复制 章节讲解的步骤操作。</p><h2 id="4-3-一主一从读写分离"><a href="#4-3-一主一从读写分离" class="headerlink" title="4.3 一主一从读写分离"></a>4.3 一主一从读写分离</h2><p>MyCat控制后台数据库的读写分离和负载均衡由schema.xml文件datahost标签的balance属性控制。</p><h4 id="4-3-1-schema-xml配置"><a href="#4-3-1-schema-xml配置" class="headerlink" title="4.3.1 schema.xml配置"></a>4.3.1 schema.xml配置</h4><pre class="line-numbers language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置逻辑库 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>schema</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ITCAST_RW<span class="token punctuation">"</span></span> <span class="token attr-name">checkSQLschema</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">sqlMaxLimit</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span> <span class="token attr-name">dataNode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn7<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>schema</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataNode</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dn7<span class="token punctuation">"</span></span> <span class="token attr-name">dataHost</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost7<span class="token punctuation">"</span></span> <span class="token attr-name">database</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>itcast<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataHost</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dhost7<span class="token punctuation">"</span></span> <span class="token attr-name">maxCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span> <span class="token attr-name">minCon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">balance</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">writeType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token attr-name">dbType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mysql<span class="token punctuation">"</span></span> <span class="token attr-name">dbDriver</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc<span class="token punctuation">"</span></span> <span class="token attr-name">switchType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span> <span class="token attr-name">slaveThreshold</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>heartbeat</span><span class="token punctuation">></span></span>select user()<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>heartbeat</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>writeHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>master1<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.211:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>readHost</span> <span class="token attr-name">host</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>slave1<span class="token punctuation">"</span></span> <span class="token attr-name">url</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jdbc:mysql://192.168.200.212:3306?useSSL<span class="token punctuation">=</span>false&amp;amp;serverTimezone<span class="token punctuation">=</span>Asia/Shanghai&amp;amp;characterEncoding<span class="token punctuation">=</span>utf8<span class="token punctuation">"</span></span><span class="token attr-name">user</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span> <span class="token attr-name">password</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1234<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>writeHost</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataHost</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述配置的具体关联对应情况如下：</p><p><img src="/mysql-03/image-20230320165949477.png" alt="image-20230320165949477"></p><p>writeHost代表的是写操作对应的数据库，readHost代表的是读操作对应的数据库。 所以要想 实现读写分离，就得配置writeHost关联的是主库，readHost关联的是从库。 而仅仅配置好了writeHost以及readHost还不能完成读写分离，还需要配置一个非常重要的负责均衡 的参数 balance，取值有4种，具体含义如下：</p><p><img src="/mysql-03/image-20230320170029317.png" alt="image-20230320170029317"></p><p>所以，在一主一从模式的读写分离中，balance配置1或3都是可以完成读写分离的。</p><h4 id="4-3-2-server-xml配置"><a href="#4-3-2-server-xml配置" class="headerlink" title="4.3.2 server.xml配置"></a>4.3.2 server.xml配置</h4><p>配置root用户可以访问SHOPPING、ITCAST 以及 ITCAST_RW逻辑库。</p><pre><code>&lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;&lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;&lt;property name=&quot;schemas&quot;&gt;SHOPPING,ITCAST,ITCAST_RW&lt;/property&gt;&lt;!-- 表级 DML 权限设置 --&gt;&lt;!--&lt;privileges check=&quot;true&quot;&gt;&lt;schema name=&quot;DB01&quot; dml=&quot;0110&quot; &gt;&lt;table name=&quot;TB_ORDER&quot; dml=&quot;1110&quot;&gt;&lt;/table&gt;&lt;/schema&gt;&lt;/privileges&gt;--&gt;&lt;/user&gt;</code></pre><h2 id="4-4-双主双从"><a href="#4-4-双主双从" class="headerlink" title="4.4 双主双从"></a>4.4 双主双从</h2><h3 id="4-4-1-介绍"><a href="#4-4-1-介绍" class="headerlink" title="4.4.1 介绍"></a>4.4.1 介绍</h3><p>一个主机 Master1 用于处理所有写请求，它的从机 Slave1 和另一台主机 Master2 还有它的从 机 Slave2 负责所有读请求。当 Master1 主机宕机后，Master2 主机负责写请求，Master1 、 Master2 互为备机。架构图如下:</p><p><img src="/mysql-03/image-20230320170501362.png" alt="image-20230320170501362"></p><h3 id="4-4-2-准备"><a href="#4-4-2-准备" class="headerlink" title="4.4.2 准备"></a>4.4.2 准备</h3><p>需要准备5台服务器，具体的服务器及软件安装情况如下：</p><p><img src="/mysql-03/image-20230320170523699.png" alt="image-20230320170523699"></p><h3 id="4-4-3-搭建"><a href="#4-4-3-搭建" class="headerlink" title="4.4.3 搭建"></a>4.4.3 搭建</h3><h4 id="4-4-3-1-主库配置"><a href="#4-4-3-1-主库配置" class="headerlink" title="4.4.3.1 主库配置"></a>4.4.3.1 主库配置</h4><p>1). Master1(192.168.200.211)</p><p><img src="/mysql-03/image-20230320170609174.png" alt="image-20230320170609174"></p><p>A. 修改配置文件 /etc/my.cnf</p><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，默认为1server-id=1#指定同步的数据库binlog-do-db=db01binlog-do-db=db02binlog-do-db=db03# 在作为从数据库的时候，有写入操作也要更新二进制日志文件log-slave-update</code></pre><p>B. 重启MySQL服务器</p><pre><code>systemctl restart mysqld</code></pre><p>C. 创建账户并授权</p><pre><code>#创建itcast用户，并设置密码，该用户可在任意主机连接该MySQL服务CREATE USER &#39;itcast&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;Root@123456&#39;;#为 &#39;itcast&#39;@&#39;%&#39; 用户分配主从复制权限GRANT REPLICATION SLAVE ON *.* TO &#39;itcast&#39;@&#39;%&#39;;</code></pre><p>通过指令，查看两台主库的二进制日志坐标</p><pre><code>show master status ;</code></pre><p><img src="/mysql-03/image-20230320170857167.png" alt="image-20230320170857167"></p><p>2). Master2(192.168.200.213)</p><p><img src="/mysql-03/image-20230320170926570.png" alt="image-20230320170926570"></p><p>A. 修改配置文件 /etc/my.cnf</p><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，默认为1server-id=3#指定同步的数据库binlog-do-db=db01binlog-do-db=db02binlog-do-db=db03# 在作为从数据库的时候，有写入操作也要更新二进制日志文件log-slave-updates</code></pre><p>B. 重启MySQL服务器</p><p>C. 创建账户并授权</p><p>通过指令，查看两台主库的二进制日志坐标</p><h4 id="4-4-3-2-从库配置"><a href="#4-4-3-2-从库配置" class="headerlink" title="4.4.3.2 从库配置"></a>4.4.3.2 从库配置</h4><p><img src="/mysql-03/image-20230320171028146.png" alt="image-20230320171028146"></p><p>A. 修改配置文件 /etc/my.cnf</p><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 232-1，默认为1server-id=2</code></pre><p>B. 重新启动MySQL服务器</p><p>2). Slave2(192.168.200.214)</p><p><img src="/mysql-03/image-20230320171052260.png" alt="image-20230320171052260"></p><p>A. 修改配置文件 /etc/my.cnf</p><pre><code>#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 232-1，默认为1server-id=4</code></pre><p>B. 重新启动MySQL服务器</p><h4 id="4-4-3-3-从库关联主库"><a href="#4-4-3-3-从库关联主库" class="headerlink" title="4.4.3.3 从库关联主库"></a>4.4.3.3 从库关联主库</h4><p>1). 两台从库配置关联的主库</p><p><img src="/mysql-03/image-20230320171126319.png" alt="image-20230320171126319"></p><p>slave1绑的是master1，slave2绑的是master2。</p><p>A. 在 slave1(192.168.200.212)上执行</p><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.200.211&#39;, MASTER_USER=&#39;itcast&#39;,MASTER_PASSWORD=&#39;Root@123456&#39;, MASTER_LOG_FILE=&#39;binlog.000002&#39;,MASTER_LOG_POS=663;</code></pre><p>B. 在 slave2(192.168.200.214)上执行</p><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.200.213&#39;, MASTER_USER=&#39;itcast&#39;,MASTER_PASSWORD=&#39;Root@123456&#39;, MASTER_LOG_FILE=&#39;binlog.000002&#39;,MASTER_LOG_POS=663;</code></pre><p>C. 启动两台从库主从复制，查看从库状态</p><pre><code>start slave;show slave status \G;</code></pre><p><img src="/mysql-03/image-20230320171537700.png" alt="image-20230320171537700"></p><p>2). 两台主库相互复</p><p><img src="/mysql-03/image-20230320171552428.png" alt="image-20230320171552428"></p><p>Master2 复制 Master1，Master1 复制 Master2。</p><p>A. 在 Master1(192.168.200.211)上执行</p><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.200.213&#39;, MASTER_USER=&#39;itcast&#39;,MASTER_PASSWORD=&#39;Root@123456&#39;, MASTER_LOG_FILE=&#39;binlog.000002&#39;,MASTER_LOG_POS=663;</code></pre><p>B. 在 Master2(192.168.200.213)上执行</p><pre><code>CHANGE MASTER TO MASTER_HOST=&#39;192.168.200.211&#39;, MASTER_USER=&#39;itcast&#39;,MASTER_PASSWORD=&#39;Root@123456&#39;, MASTER_LOG_FILE=&#39;binlog.000002&#39;,MASTER_LOG_POS=663;</code></pre><p>C. 启动两台从库主从复制，查看从库状态</p><pre><code>start slave;show slave status \G;</code></pre><p><img src="/mysql-03/image-20230320171650604.png" alt="image-20230320171650604"></p><h2 id="4-5-双主双从读写分离"><a href="#4-5-双主双从读写分离" class="headerlink" title="4.5 双主双从读写分离"></a>4.5 双主双从读写分离</h2><h3 id="4-5-1-配置"><a href="#4-5-1-配置" class="headerlink" title="4.5.1 配置"></a>4.5.1 配置</h3><p>MyCat控制后台数据库的读写分离和负载均衡由schema.xml文件datahost标签的balance属性控 制，通过writeType及switchType来完成失败自动切换的。</p><p>1). schema.xml</p><p>配置逻辑库：</p><pre><code>&lt;schema name=&quot;ITCAST_RW2&quot; checkSQLschema=&quot;true&quot; sqlMaxLimit=&quot;100&quot; dataNode=&quot;dn7&quot;&gt;&lt;/schema</code></pre><p>配置数据节点：</p><pre><code>&lt;dataNode name=&quot;dn7&quot; dataHost=&quot;dhost7&quot; database=&quot;db01&quot; /&gt;</code></pre><p>配置节点主机：</p><pre><code>&lt;dataHost name=&quot;dhost7&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;1&quot; writeType=&quot;0&quot;dbType=&quot;mysql&quot; dbDriver=&quot;jdbc&quot; switchType=&quot;1&quot; slaveThreshold=&quot;100&quot;&gt;&lt;heartbeat&gt;select user()&lt;/heartbeat&gt;&lt;writeHost host=&quot;master1&quot; url=&quot;jdbc:mysql://192.168.200.211:3306?useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf8&quot;user=&quot;root&quot; password=&quot;1234&quot; &gt;&lt;readHost host=&quot;slave1&quot; url=&quot;jdbc:mysql://192.168.200.212:3306?useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf8&quot;user=&quot;root&quot; password=&quot;1234&quot; /&gt;&lt;/writeHost&gt;&lt;writeHost host=&quot;master2&quot; url=&quot;jdbc:mysql://192.168.200.213:3306?useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf8&quot;user=&quot;root&quot; password=&quot;1234&quot; &gt;&lt;readHost host=&quot;slave2&quot; url=&quot;jdbc:mysql://192.168.200.214:3306?useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;characterEncoding=utf8&quot;user=&quot;root&quot; password=&quot;1234&quot; /&gt;&lt;/writeHost&gt;&lt;/dataHost&gt;</code></pre><p>具体的对应情况如下：</p><p><img src="/mysql-03/image-20230320172202322.png" alt="image-20230320172202322"></p><p>属性说明：</p><p>balance=”1” 代表全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡，简 单的说，当双主双从模式(M1-&gt;S1，M2-&gt;S2，并且 M1 与 M2 互为主备)，正常情况下， M2,S1,S2 都参与 select 语句的负载均衡 </p><p>writeType 0 : 写操作都转发到第1台writeHost, writeHost1挂了, 会切换到writeHost2上; 1 : 所有的写操作都随机地发送到配置的writeHost上 ;</p><p>switchType -1 : 不自动切换 1 : 自动切换</p><p>2). user.xml</p><p>配置root用户也可以访问到逻辑库 ITCAST_RW2。</p><pre><code>&lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;&lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;&lt;property name=&quot;schemas&quot;&gt;SHOPPING,ITCAST,ITCAST_RW2&lt;/property&gt;&lt;!-- 表级 DML 权限设置 --&gt;&lt;!--&lt;privileges check=&quot;true&quot;&gt;&lt;schema name=&quot;DB01&quot; dml=&quot;0110&quot; &gt;&lt;table name=&quot;TB_ORDER&quot; dml=&quot;1110&quot;&gt;&lt;/table&gt;&lt;/schema&gt;&lt;/privileges&gt;--&gt;&lt;/user&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-02</title>
      <link href="/mysql-02.html"/>
      <url>/mysql-02.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1.存储引擎"></a>1.存储引擎</h1><h2 id="1-1-MySQL体系结构"><a href="#1-1-MySQL体系结构" class="headerlink" title="1.1 MySQL体系结构"></a>1.1 MySQL体系结构</h2><p><img src="/mysql-02/image-20230318181430255.png" alt="image-20230318181430255"></p><p>1). 连接层</p><p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程 池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务 器也会为安全接入的每个客户端验证它所具有的操作权限。</p><p>2). 服务层</p><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部 分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解 析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大， 这样在解决大量读操作的环境中能够很好的提升系统的性能。</p><p>3). 引擎层</p><p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通 信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库 中的索引是在存储引擎层实现的。</p><p>4). 存储层</p><p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询 日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</p><p>和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要 体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。 这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><h2 id="1-2-存储引擎介绍"><a href="#1-2-存储引擎介绍" class="headerlink" title="1.2 存储引擎介绍"></a>1.2 存储引擎介绍</h2><p>对于存储引擎，也是一样，他是mysql数据库的核心，需要在合适的场景选择合适的存储引 擎。接下来就来介绍一下存储引擎。 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是 基于库的，所以存储引擎也可被称为表类型。可以在创建表的时候，来指定选择的存储引擎，如果 没有指定将自动选择默认的存储引擎。</p><p>1). 建表时指定存储引擎</p><pre><code>CREATE TABLE 表名(字段1 字段1类型 [ COMMENT 字段1注释 ] ,......字段n 字段n类型 [COMMENT 字段n注释 ]) ENGINE = INNODB [ COMMENT 表注释 ] ;</code></pre><p>2). 查询当前数据库支持的存储引擎</p><pre><code> show engines;</code></pre><p>示例演示:</p><p>A. 查询建表语句 — 默认存储引擎: InnoDB</p><pre><code> show create table account;</code></pre><p><img src="/mysql-02/image-20230318182248843.png" alt="image-20230318182248843"></p><p>创建表时，即使没有指定存储疫情，数据库也会自动选择默认的存储引擎。</p><p>B. 查询当前数据库支持的存储引擎</p><pre><code>show engines ;</code></pre><p><img src="/mysql-02/image-20230318182342529.png" alt="image-20230318182342529"></p><p>C. 创建表 my_myisam , 并指定MyISAM存储引擎</p><pre><code>create table my_myisam(id int,name varchar(10)) engine = MyISAM ;</code></pre><h2 id="1-3-存储引擎特点"><a href="#1-3-存储引擎特点" class="headerlink" title="1.3 存储引擎特点"></a>1.3 存储引擎特点</h2><h3 id="1-3-1-InnoDB"><a href="#1-3-1-InnoDB" class="headerlink" title="1.3.1 InnoDB"></a>1.3.1 InnoDB</h3><p>1). 介绍</p><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。</p><p>2). 特点</p><ul><li>DML操作遵循ACID模型，支持事务； </li><li>行级锁，提高并发访问性能； </li><li>支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</li></ul><p>3). 文件</p><p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结 构（frm-早期的 、sdi-新版的）、数据和索引。</p><p>参数：innodb_file_per_table</p><pre><code>show variables like &#39;innodb_file_per_table&#39;</code></pre><p><img src="/mysql-02/image-20230318182528184.png" alt="image-20230318182528184"></p><p>如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 直接打开MySQL的 数据存放目录： C:\ProgramData\MySQL\MySQL Server 8.0\Data ， 这个目录下有很多文件 夹，不同的文件夹代表不同的数据库。</p><p><img src="/mysql-02/image-20230318182600816.png" alt="image-20230318182600816"></p><p>可以看到里面有很多的ibd文件，每一个ibd文件就对应一张表，比如：有一张表 account，就 有这样的一个account.ibd文件，而在这个ibd文件中不仅存放表结构、数据，还会存放该表对应的 索引信息。 而该文件是基于二进制存储的，不能直接基于记事本打开，我们可以使用mysql提供的一 个指令 ibd2sdi ，通过该指令就可以从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。</p><p><img src="/mysql-02/image-20230318182704471.png" alt="image-20230318182704471"></p><p>4). 逻辑存储结构</p><p><img src="/mysql-02/image-20230318182718828.png" alt="image-20230318182718828"></p><ul><li>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以 包含多个Segment段。 </li><li>段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管 理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。 </li><li>区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为 16K， 即一个区中一共有64个连续的页。</li><li>页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默 认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li><li>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时 所指定的字段以外，还包含两个隐藏字段。</li></ul><h3 id="1-3-2-MyISAM"><a href="#1-3-2-MyISAM" class="headerlink" title="1.3.2 MyISAM"></a>1.3.2 MyISAM</h3><p>1). 介绍</p><p>MyISAM是MySQL早期的默认存储引擎</p><p>2). 特点 </p><p>不支持事务，</p><p>不支持外键</p><p> 支持表锁，不支持行锁 </p><p>访问速度快</p><p>3). 文件</p><p>xxx.sdi：存储表结构信息</p><p> xxx.MYD: 存储数据 </p><p>xxx.MYI: 存储索引</p><p><img src="/mysql-02/image-20230318182949362.png" alt="image-20230318182949362"></p><h3 id="1-3-3-Memory"><a href="#1-3-3-Memory" class="headerlink" title="1.3.3 Memory"></a>1.3.3 Memory</h3><p>1). 介绍</p><p>Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为 临时表或缓存使用。</p><p>2). 特点</p><p> 内存存放</p><p> hash索引（默认）</p><p>3).文件</p><p>xxx.sdi：存储表结构信息</p><h3 id="1-3-4-区别及特点"><a href="#1-3-4-区别及特点" class="headerlink" title="1.3.4 区别及特点"></a>1.3.4 区别及特点</h3><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持(5.6版本之后)</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>高</td><td>低</td><td>N/A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table><p>InnoDB引擎与MyISAM引擎的区别 ? </p><p>①. InnoDB引擎, 支持事务, 而MyISAM不支持。 </p><p>②. InnoDB引擎, 支持行锁和表锁, 而MyISAM仅支持表锁, 不支持行锁。 </p><p>③. InnoDB引擎, 支持外键, 而MyISAM是不支持的。 </p><p>主要是上述三点区别，当然也可以从索引结构、存储限制等方面，更加深入的回答，具体参 考如下官方文档：</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html</a></p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html</a></p><h3 id="1-4-存储引擎选择"><a href="#1-4-存储引擎选择" class="headerlink" title="1.4 存储引擎选择"></a>1.4 存储引擎选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据 实际情况选择多种存储引擎进行组合。 </p><p>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要 求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操 作，那么InnoDB存储引擎是比较合适的选择。 </p><p>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完 整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。 </p><p>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是 对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</p><h1 id="2-索引"><a href="#2-索引" class="headerlink" title="2.索引"></a>2.索引</h1><h3 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h3><h4 id="2-1-1-介绍"><a href="#2-1-1-介绍" class="headerlink" title="2.1.1 介绍"></a>2.1.1 介绍</h4><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足 特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构 上实现高级查找算法，这种数据结构就是索引。</p><h4 id="2-2-演示"><a href="#2-2-演示" class="headerlink" title="2.2 演示"></a>2.2 演示</h4><p>表结构及其数据如下：</p><p><img src="/mysql-02/image-20230318194855504.png" alt="image-20230318194855504"></p><p>假如要执行的SQL语句为 ： select * from user where age = 45</p><p>1). 无索引情况</p><p><img src="/mysql-02/image-20230318194914129.png" alt="image-20230318194914129"></p><p>在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，我们称之为 全表扫描，性能很 低。</p><p>2). 有索引情况</p><p>如果针对于这张表建立了索引，假设索引结构就是二叉树，那么也就意味着，会对age这个字段建 立一个二叉树的索引结构。</p><p><img src="/mysql-02/image-20230318194942971.png" alt="image-20230318194942971"></p><p>此时进行查询时，只需要扫描三次就可以找到数据了，极大的提高的查询的效率。</p><h4 id="2-3-特点"><a href="#2-3-特点" class="headerlink" title="2.3 特点"></a>2.3 特点</h4><table><thead><tr><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>提高数据检索的效率，降低数据库 的IO成本</td><td>索引列也是要占用空间的。</td></tr><tr><td>通过索引列对数据进行排序，降低 数据排序的成本，降低CPU的消 耗。</td><td>索引大大提高了查询效率，同时却也降低更新表的速度， 如对表进行INSERT、UPDATE、DELETE时，效率降低。</td></tr></tbody></table><h3 id="2-2-索引结构"><a href="#2-2-索引结构" class="headerlink" title="2.2 索引结构"></a>2.2 索引结构</h3><h4 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1 概述"></a>2.2.1 概述</h4><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree索引</td><td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td></tr><tr><td>Hash索引</td><td>底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不 支持范围查询</td></tr><tr><td>R-tree(空间索 引）</td><td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类 型，通常使用较少</td></tr><tr><td>Full-text(全文 索引)</td><td>是一种通过建立倒排索引,快速匹配文档的方式。类似于 Lucene,Solr,ES</td></tr></tbody></table><p>上述是MySQL中所支持的所有的索引结构.</p><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6版本之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h4 id="2-2-2-二叉树"><a href="#2-2-2-二叉树" class="headerlink" title="2.2.2 二叉树"></a>2.2.2 二叉树</h4><p>假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下:</p><p><img src="/mysql-02/image-20230318195506632.png" alt="image-20230318195506632"></p><p>如果主键是顺序插入的，则会形成一个单向链表，结构如下：</p><p><img src="/mysql-02/image-20230318195523470.png" alt="image-20230318195523470"></p><p>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p><ul><li>顺序插入时，会形成一个链表，查询性能大大降低。 </li><li>大数据量情况下，层级较深，检索速度慢。</li></ul><p>可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数 据，最终形成的数据结构也是一颗平衡的二叉树,结构如下</p><p><img src="/mysql-02/image-20230318195600407.png" alt="image-20230318195600407"></p><p>但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：</p><ul><li>大数据量情况下，层级较深，检索速度慢。</li></ul><p>所以，在MySQL的索引结构中，并没有选择二叉树或者红黑树，而选择的是B+Tree.</p><h4 id="2-2-3-B-Tree"><a href="#2-2-3-B-Tree" class="headerlink" title="2.2.3 B-Tree"></a>2.2.3 B-Tree</h4><p>B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。</p><p>以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5 个指针：</p><p><img src="/mysql-02/image-20230318200101312.png" alt="image-20230318200101312"></p><p>树的度数指的是一个节点的子节点个数。</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html" target="_blank" rel="noopener">B-Tree Visualization (usfca.edu)</a></p><p>演示</p><p><img src="/mysql-02/image-20230318200153552.png" alt="image-20230318200153552"></p><p><img src="/mysql-02/image-20230318200233820.png" alt="image-20230318200233820"></p><p>特点：</p><ul><li>5阶的B树，每一个节点最多存储4个key，对应5个指针。 </li><li>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。 </li><li>在B树中，非叶子节点和叶子节点都会存放数据。</li></ul><h4 id="2-2-4-B-Tree"><a href="#2-2-4-B-Tree" class="headerlink" title="2.2.4 B+Tree"></a>2.2.4 B+Tree</h4><p>B+Tree是B-Tree的变种，以一颗最大度数（max-degree）为4（4阶）的b+tree为例，</p><p><img src="/mysql-02/image-20230318201225101.png" alt="image-20230318201225101"></p><p>可以看到，两部分： </p><p>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。 </p><p>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</p><p><img src="/mysql-02/image-20230318201257821.png" alt="image-20230318201257821"></p><p>B+Tree 与 B-Tree相比，主要有以下三点区别： </p><ul><li>所有的数据都会出现在叶子节点。 </li><li>叶子节点形成一个单向链表。 </li><li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</li></ul><p>MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点 的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。</p><p><img src="/mysql-02/image-20230318201350644.png" alt="image-20230318201350644"></p><h4 id="2-2-5-Hash"><a href="#2-2-5-Hash" class="headerlink" title="2.2.5 Hash"></a>2.2.5 Hash</h4><p>MySQL中除了支持B+Tree索引，还支持一种索引类型—Hash索引。</p><p>1). 结构 哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash表中。</p><p><img src="/mysql-02/image-20230318201435838.png" alt="image-20230318201435838"></p><p>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可 以通过链表来解决。</p><p><img src="/mysql-02/image-20230318201504428.png" alt="image-20230318201504428"></p><p>2). 特点 </p><p>A. Hash索引只能用于对等比较(=，in)，不支持范围查询（between，&gt;，&lt; ，…）</p><p>B. 无法利用索引完成排序操作 C. 查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索引</p><p>3). 存储引擎支持</p><p> 在MySQL中，支持hash索引的是Memory存储引擎。 而InnoDB中具有自适应hash功能，hash索引是 InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的。</p><h3 id="2-3-索引分类"><a href="#2-3-索引分类" class="headerlink" title="2.3 索引分类"></a>2.3 索引分类</h3><h4 id="2-3-1-索引分类"><a href="#2-3-1-索引分类" class="headerlink" title="2.3.1 索引分类"></a>2.3.1 索引分类</h4><p>在MySQL数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键 索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建, 只能 有一个</td><td>PRIMARY</td></tr><tr><td>唯一 索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规 索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文 索引</td><td>全文索引查找的是文本中的关键词，而不是比 较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><h4 id="2-3-2-聚集索引-amp-二级索引"><a href="#2-3-2-聚集索引-amp-二级索引" class="headerlink" title="2.3.2 聚集索引&amp;二级索引"></a>2.3.2 聚集索引&amp;二级索引</h4><p>而在在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据</td><td>必须有,而且只 有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>聚集索引选取规则:</p><ul><li>如果存在主键，主键索引就是聚集索引。</li></ul><ul><li><p>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p></li><li><p>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p></li></ul><p>聚集索引选取规则:</p><ul><li>如果存在主键，主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索 引。</li></ul><p>聚集索引和二级索引的具体结构如下：</p><p><img src="/mysql-02/image-20230318221645990.png" alt="image-20230318221645990"></p><ul><li>聚集索引的叶子节点下挂的是这一行的数据 。 </li><li>二级索引的叶子节点下挂的是该字段值对应的主键值。</li></ul><p>执行如下的SQL语句时，具体的查找过程是什么样子的。</p><p><img src="/mysql-02/image-20230318221907869.png" alt="image-20230318221907869"></p><p>具体过程如下:</p><p>①. 由于是根据name字段进行查询，所以先根据name=’Arm’到name字段的二级索引中进行匹配查 找。但是在二级索引中只能查找到 Arm 对应的主键值10</p><p>②. 由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最 终找到10对应的行row。</p><p>③. 最终拿到这一行的数据，直接返回即可。</p><p>回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取 数据的方式，就称之为回表查询。</p><p><img src="/mysql-02/image-20230318222059039.png" alt="image-20230318222059039"></p><p>假设:</p><p>一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空 间，主键即使为bigint，占用字节数为8。</p><p>高度为2：</p><p>​        n * 8 + (n + 1) * 6 = 16*1024 , 算出n约为 1170</p><p>​        1171* 16 = 18736</p><p>也就是说，如果树的高度为2，则可以存储 18000 多条记录。</p><p>高度为3：</p><p>1171 * 1171 * 16 = 21939856</p><p>也就是说，如果树的高度为3，则可以存储 2200w 左右的记录。</p><h3 id="2-4-索引语法"><a href="#2-4-索引语法" class="headerlink" title="2.4 索引语法"></a>2.4 索引语法</h3><p>1). 创建索引</p><pre><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,... ) ;</code></pre><p>2). 查看索引</p><pre><code> SHOW INDEX FROM table_name ;</code></pre><p>3). 删除索引</p><pre><code>DROP INDEX index_name ON table_name ;</code></pre><p>演示表</p><pre><code>create table tb_user(id int primary key auto_increment comment &#39;主键&#39;,name varchar(50) not null comment &#39;用户名&#39;,phone varchar(11) not null comment &#39;手机号&#39;,email varchar(100) comment &#39;邮箱&#39;,profession varchar(11) comment &#39;专业&#39;,age tinyint unsigned comment &#39;年龄&#39;,gender char(1) comment &#39;性别 , 1: 男, 2: 女&#39;,status char(1) comment &#39;状态&#39;,createtime datetime comment &#39;创建时间&#39;) comment &#39;系统用户表&#39;</code></pre><p><img src="/mysql-02/image-20230318222406413.png" alt="image-20230318222406413"></p><p>A. name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。</p><pre><code>CREATE INDEX idx_user_name ON tb_user(name);</code></pre><p>B. phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引。</p><pre><code>CREATE UNIQUE INDEX idx_user_phone ON tb_user(phone);</code></pre><p>C. 为profession、age、status创建联合索引。</p><pre><code>CREATE INDEX idx_user_pro_age_sta ON tb_user(profession,age,status);</code></pre><p>D. 为email建立合适的索引来提升查询效率</p><pre><code>CREATE INDEX idx_email ON tb_user(email)</code></pre><p><img src="/mysql-02/image-20230318222612965.png" alt="image-20230318222612965"></p><h3 id="2-5-SQL性能分析"><a href="#2-5-SQL性能分析" class="headerlink" title="2.5 SQL性能分析"></a>2.5 SQL性能分析</h3><h4 id="2-5-1-SQL执行频率"><a href="#2-5-1-SQL执行频率" class="headerlink" title="2.5.1 SQL执行频率"></a>2.5.1 SQL执行频率</h4><p>通过 show [session|global] status 命令可以提供服务器状态信 息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：</p><pre><code>-- session 是查看当前会话 ;-- global 是查询全局数据 ;SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;;</code></pre><p><img src="/mysql-02/image-20230318222752012.png" alt="image-20230318222752012"></p><p>查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，可以考虑不对其进行索引的优化。 如果是以查询为主，那么就要考虑对数据库的索引进行优化了。</p><h4 id="2-5-2-慢查询日志"><a href="#2-5-2-慢查询日志" class="headerlink" title="2.5.2 慢查询日志"></a>2.5.2 慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志</p><p>MySQL的慢查询日志默认没有开启，</p><p><img src="/mysql-02/image-20230318224609961.png" alt="image-20230318224609961"></p><p>如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p><pre><code># 开启MySQL慢日志查询开关slow_query_log=1# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志long_query_time=2</code></pre><p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息</p><p>/var/lib/mysql/localhost-slow.log。</p><pre><code>systemctl restart mysqld</code></pre><p>然后，再次查看开关情况，慢查询日志就已经打开了。</p><p><img src="/mysql-02/image-20230318224945351.png" alt="image-20230318224945351"></p><p>A. 执行如下SQL语句 ：</p><pre><code>select * from tb_user; -- 这条SQL执行效率比较高, 执行耗时 0.00secselect count(*) from tb_sku; -- 由于tb_sku表中, 预先存入了1000w的记录, count一次,耗时13.35sec</code></pre><p>B. 检查慢查询日志 ：在慢查询日志中，只会记录执行时间超多预设时间（2s）的SQL，执行较快的SQL 是不会记录的。</p><p><img src="/mysql-02/image-20230318225343630.png" alt="image-20230318225343630"></p><h4 id="2-5-3-profile详情"><a href="#2-5-3-profile详情" class="headerlink" title="2.5.3 profile详情"></a>2.5.3 profile详情</h4><p>show profiles 能够在做SQL优化时帮助了解时间都耗费到哪里去了。通过have_profiling 参数，能够看到当前MySQL是否支持profile操作：</p><pre><code>SELECT @@have_profiling ;</code></pre><p><img src="/mysql-02/image-20230318225426205.png" alt="image-20230318225426205"></p><p>可以看到，当前MySQL是支持 profile操作的，但是开关是关闭的。可以通过set语句在 session/global级别开启profiling：</p><pre><code>SET profiling = 1;</code></pre><p>开关已经打开了，接下来，执行的SQL语句，都会被MySQL记录，并记录执行时间消耗到哪儿去 了。 </p><p>执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时：</p><pre><code>-- 查看每一条SQL的耗时基本情况show profiles;-- 查看指定query_id的SQL语句各个阶段的耗时情况show profile for query query_id;-- 查看指定query_id的SQL语句CPU的使用情况show profile cpu for query query_id;</code></pre><p><img src="/mysql-02/image-20230318225648176.png" alt="image-20230318225648176"></p><p>查看指定SQL各个阶段的耗时情况 :  query_id为16的情况</p><p><img src="/mysql-02/image-20230318225705567.png" alt="image-20230318225705567"></p><h4 id="2-5-4-explain"><a href="#2-5-4-explain" class="headerlink" title="2.5.4 explain"></a>2.5.4 explain</h4><p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行 过程中表如何连接和连接的顺序。</p><p>语法:</p><pre><code>-- 直接在select语句之前加上关键字 explain / descEXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;</code></pre><p><img src="/mysql-02/image-20230318225806472.png" alt="image-20230318225806472"></p><p>Explain 执行计划中各个字段的含义:</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序 (id相同，执行顺序从上到下；id不同，值越大，越先执行)。</td></tr><tr><td>select_type</td><td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接 或者子查询）、PRIMARY（主查询，即外层的查询）、 UNION（UNION 中的第二个或者后面的查询语句）、 SUBQUERY（SELECT/WHERE之后包含了子查询）等</td></tr><tr><td>type</td><td>表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。</td></tr><tr><td>possible_key</td><td>显示可能应用在这张表上的索引，一个或多个。</td></tr><tr><td>key</td><td>实际使用的索引，如果为NULL，则没有使用索引。</td></tr><tr><td>key_len</td><td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。</td></tr><tr><td>rows</td><td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值， 可能并不总是准确的。</td></tr><tr><td>filtered</td><td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</td></tr></tbody></table><h3 id="2-6-索引使用"><a href="#2-6-索引使用" class="headerlink" title="2.6 索引使用"></a>2.6 索引使用</h3><h4 id="2-6-1-验证索引效率"><a href="#2-6-1-验证索引效率" class="headerlink" title="2.6.1 验证索引效率"></a>2.6.1 验证索引效率</h4><p>这表中有1000W的记录</p><p>这张表中id为主键，有主键索引，而其他字段是没有建立索引的。 先来查询其中的一条记录，看 看里面的字段情况，执行如下SQL：</p><pre><code>select * from tb_sku where id = 1\G;\G是垂直显示</code></pre><p><img src="/mysql-02/image-20230318230447872.png" alt="image-20230318230447872"></p><p>可以看到即使有1000w的数据,根据id进行数据查询,性能依然很快，因为主键id是有索引的。</p><pre><code>SELECT * FROM tb_sku WHERE sn = &#39;100000003145001&#39;;</code></pre><p><img src="/mysql-02/image-20230318230511242.png" alt="image-20230318230511242"></p><p>可以看到根据sn字段进行查询，查询返回了一条数据，结果耗时 20.78sec，就是因为sn没有索 引，而造成查询效率很低。 可以针对于sn字段，建立一个索引，建立了索引之后，再次根据sn进行查询，再来看一 下查询耗时情况。</p><p>创建索引：</p><pre><code>create index idx_sku_sn on tb_sku(sn) ;</code></pre><p><img src="/mysql-02/image-20230318230652231.png" alt="image-20230318230652231"></p><p>然后再次执行相同的SQL语句，再次查看SQL的耗时。</p><pre><code>SELECT * FROM tb_sku WHERE sn = &#39;100000003145001&#39;;</code></pre><p><img src="/mysql-02/image-20230318230724284.png" alt="image-20230318230724284"></p><p>明显会看到，sn字段建立了索引之后，查询性能大大提升。建立索引前后，查询耗时都不是一个数 量级的。</p><h4 id="2-6-2-最左前缀法则"><a href="#2-6-2-最左前缀法则" class="headerlink" title="2.6.2 最左前缀法则"></a>2.6.2 最左前缀法则</h4><p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。</p><p>以 tb_user 表为例，</p><p><img src="/mysql-02/image-20230318230807101.png" alt="image-20230318230807101"></p><p>在 tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession， age，status。 对于最左前缀法则指的是，查询时，最左边的列，也就是profession必须存在，否则索引全部失效。 而且中间不能跳过某一列，否则该列后面的字段索引将失效。</p><p>当执行SQL语句: explain select * from tb_user where age = 31 and status = ‘0’ and profession = ‘软件工程’； 时，是否满足最左前缀法则，走不走 上述的联合索引，索引长度？</p><p><img src="/mysql-02/image-20230318230911191.png" alt="image-20230318230911191"></p><p>可以看到，是完全满足最左前缀法则的，索引长度54，联合索引是生效的。</p><p>注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是 第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p><h4 id="2-6-3-范围查询"><a href="#2-6-3-范围查询" class="headerlink" title="2.6.3 范围查询"></a>2.6.3 范围查询</h4><p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效。</p><pre><code>explain select * from tb_user where profession = &#39;软件工程&#39; and age &gt; 30 and status= &#39;0&#39;;</code></pre><p><img src="/mysql-02/image-20230318231120926.png" alt="image-20230318231120926"></p><p>当范围查询使用&gt; 或 &lt; 时，走联合索引了，但是索引的长度为49，就说明范围查询右边的status字 段是没有走索引的。</p><pre><code>explain select * from tb_user where profession = &#39;软件工程&#39; and age &gt;= 30 andstatus = &#39;0&#39;;</code></pre><p><img src="/mysql-02/image-20230318231212418.png" alt="image-20230318231212418"></p><p>当范围查询使用&gt;= 或 &lt;= 时，走联合索引了，但是索引的长度为54，就说明所有的字段都是走索引 的。 所以，在业务允许的情况下，尽可能的使用类似于 &gt;= 或 &lt;= 这类的范围查询，而避免使用 &gt; 或 &lt; 。</p><h4 id="2-6-4-索引失效情况"><a href="#2-6-4-索引失效情况" class="headerlink" title="2.6.4 索引失效情况"></a>2.6.4 索引失效情况</h4><h5 id="2-6-4-1-索引列运算"><a href="#2-6-4-1-索引列运算" class="headerlink" title="2.6.4.1 索引列运算"></a>2.6.4.1 索引列运算</h5><p>不要在索引列上进行运算操作， 索引将失效。</p><p>在tb_user表中，除了前面介绍的联合索引之外，还有一个索引，是phone字段的单列索引。</p><p><img src="/mysql-02/image-20230318231259493.png" alt="image-20230318231259493"></p><p>A. 当根据phone字段进行等值匹配查询时, 索引生效。</p><pre><code>explain select * from tb_user where phone = &#39;17799990015&#39;;</code></pre><p>B. 当根据phone字段进行函数运算操作之后，索引失效。</p><pre><code>explain select * from tb_user where substring(phone,10,2) = &#39;15&#39;</code></pre><p><img src="/mysql-02/image-20230318231423997.png" alt="image-20230318231423997"></p><h5 id="2-6-4-2-字符串不加引号"><a href="#2-6-4-2-字符串不加引号" class="headerlink" title="2.6.4.2 字符串不加引号"></a>2.6.4.2 字符串不加引号</h5><p>字符串类型字段使用时，不加引号，索引将失效。</p><pre><code>explain select * from tb_user where profession = &#39;软件工程&#39; and age = 31 and status= &#39;0&#39;;explain select * from tb_user where profession = &#39;软件工程&#39; and age = 31 and status= 0;</code></pre><p><img src="/mysql-02/image-20230318231630498.png" alt="image-20230318231630498"></p><pre><code>explain select * from tb_user where phone = &#39;17799990015&#39;;explain select * from tb_user where phone = 17799990015;</code></pre><p><img src="/mysql-02/image-20230318231652044.png" alt="image-20230318231652044"></p><p>经过上面两组示例，会明显的发现，如果字符串不加单引号，对于查询结果，没什么影响，但是数 据库存在隐式类型转换，索引将失效。</p><h5 id="2-6-4-3-模糊查询"><a href="#2-6-4-3-模糊查询" class="headerlink" title="2.6.4.3 模糊查询"></a>2.6.4.3 模糊查询</h5><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><p>由于下面查询语句中，都是根据profession字段查询，符合最左前缀法则，联合索引是可以生效的， 主要看一下，模糊查询时，%加在关键字之前，和加在关键字之后的影响。</p><pre><code>explain select * from tb_user where profession like &#39;软件%&#39;;explain select * from tb_user where profession like &#39;%工程&#39;;explain select * from tb_user where profession like &#39;%工%&#39;;</code></pre><p><img src="/mysql-02/image-20230318231758572.png" alt="image-20230318231758572"></p><p>经过上述的测试，在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字 前面加了%，索引将会失效。</p><h5 id="3-6-4-4-or连接条件"><a href="#3-6-4-4-or连接条件" class="headerlink" title="3.6.4.4 or连接条件"></a>3.6.4.4 or连接条件</h5><p>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会 被用到。</p><pre><code>xplain select * from tb_user where id = 10 or age = 23;explain select * from tb_user where phone = &#39;17799990017&#39; or age = 23;</code></pre><p><img src="/mysql-02/image-20230318231912002.png" alt="image-20230318231912002"></p><p>由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。</p><p>然后，可以对age字段建立索引。</p><pre><code>create index idx_user_age on tb_user(age)</code></pre><p><img src="/mysql-02/image-20230318231942043.png" alt="image-20230318231942043"></p><p>建立了索引之后，再次执行上述的SQL语句，看看前后执行计划的变化。</p><p><img src="/mysql-02/image-20230318231954670.png" alt="image-20230318231954670"></p><p>当or连接的条件，左右两侧字段都有索引时，索引才会生效。</p><h5 id="3-6-4-5-数据分布影响"><a href="#3-6-4-5-数据分布影响" class="headerlink" title="3.6.4.5 数据分布影响"></a>3.6.4.5 数据分布影响</h5><pre><code>select * from tb_user where phone &gt;= &#39;17799990005&#39;;select * from tb_user where phone &gt;= &#39;17799990015&#39;;</code></pre><p><img src="/mysql-02/image-20230318232049614.png" alt="image-20230318232049614"></p><p>相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样</p><p>因为MySQL在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃 索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不 如走全表扫描来的快，此时索引就会失效。</p><p> is null 与 is not null 操作是否走索引。</p><p>执行如下两条语句 ：</p><pre><code>explain select * from tb_user where profession is null;explain select * from tb_user where profession is not null;</code></pre><p><img src="/mysql-02/image-20230318232202493.png" alt="image-20230318232202493"></p><p>将profession字段值全部更新为null。</p><p><img src="/mysql-02/image-20230318232214786.png" alt="image-20230318232214786"></p><p>然后，再次执行上述的两条SQL，查看SQL语句的执行计划。</p><p>最终看到，一模一样的SQL语句，先后执行了两次，结果查询计划是不一样的，为什么会出现这种 现象，这是和数据库的数据分布有关系。查询时MySQL会评估，走索引快，还是全表扫描快，如果全表 扫描更快，则放弃索引走全表扫描。 因此，is null 、is not null是否走索引，得具体情况具体 分析，并不是固定的。</p><h5 id="2-6-5-SQL提示"><a href="#2-6-5-SQL提示" class="headerlink" title="2.6.5 SQL提示"></a>2.6.5 SQL提示</h5><p>目前tb_user表的数据情况如下:</p><p><img src="/mysql-02/image-20230318232304149.png" alt="image-20230318232304149"></p><p>索引情况如下:</p><p><img src="/mysql-02/image-20230318232313580.png" alt="image-20230318232313580"></p><p>把上述的 idx_user_age, idx_email 这两个之前测试使用过的索引直接删除。</p><pre><code>drop index idx_user_age on tb_user;drop index idx_email on tb_user;</code></pre><p>A. 执行SQL : explain select * from tb_user where profession = ‘软件工程’;</p><p><img src="/mysql-02/image-20230318232402315.png" alt="image-20230318232402315"></p><p>查询走了联合索引。</p><p>B. 执行SQL，创建profession的单列索引：create index idx_user_pro on tb_user(profession);</p><p><img src="/mysql-02/image-20230318232418417.png" alt="image-20230318232418417"></p><p>C. 创建单列索引后，再次执行A中的SQL语句，查看执行计划，看看到底走哪个索引。</p><p><img src="/mysql-02/image-20230318232427617.png" alt="image-20230318232427617"></p><p>可以看到，possible_keys中 idx_user_pro_age_sta,idx_user_pro 这两个 索引都可能用到，最终MySQL选择了idx_user_pro_age_sta索引。这是MySQL自动选择的结果。</p><p>手动指定使用索引</p><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优 化操作的目的。</p><p>1). use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进 行评估）。</p><pre><code>explain select * from tb_user use index(idx_user_pro) where profession = &#39;软件工程&#39;;</code></pre><p>2). ignore index ： 忽略指定的索引。</p><pre><code>explain select * from tb_user ignore index(idx_user_pro) where profession = &#39;软件工程&#39;;</code></pre><p>3). force index ： 强制使用索引。</p><pre><code>explain select * from tb_user force index(idx_user_pro) where profession = &#39;软件工程&#39;;</code></pre><h5 id="2-6-6-覆盖索引"><a href="#2-6-6-覆盖索引" class="headerlink" title="2.6.6 覆盖索引"></a>2.6.6 覆盖索引</h5><p>尽量使用覆盖索引，减少select *。 那么什么是覆盖索引呢？ 覆盖索引是指 查询使用了索引，并 且需要返回的列，在该索引中已经全部能够找到 。</p><p>执行下述sql语句</p><pre><code>explain select id, profession from tb_user where profession = &#39;软件工程&#39; and age =31 and status = &#39;0&#39; ;explain select id,profession,age, status from tb_user where profession = &#39;软件工程&#39;and age = 31 and status = &#39;0&#39; ;explain select id,profession,age, status, name from tb_user where profession = &#39;软件工程&#39; and age = 31 and status = &#39;0&#39; ;explain select * from tb_user where profession = &#39;软件工程&#39; and age = 31 and status= &#39;0&#39;;</code></pre><p>上述这几条SQL的执行结果为:</p><p><img src="/mysql-02/image-20230318232641116.png" alt="image-20230318232641116"></p><p>从上述的执行计划我们可以看到，这四条SQL语句的执行计划前面所有的指标都是一样的，看不出来差 异。但是此时主要关注的是后面的Extra，前面两天SQL的结果为 Using where; Using Index ; 而后面两条SQL的结果为: Using index condition 。</p><table><thead><tr><th>Extra</th><th>含义</th></tr></thead><tbody><tr><td>Using where; Using Index</td><td>查找使用了索引，但是需要的数据都在索引列中能找到，所以不需 要回表查询数据</td></tr><tr><td>Using index condition</td><td>查找使用了索引，但是需要回表查询数据</td></tr></tbody></table><p>因为，在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段 profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主 键id。</p><p> 所以当查询返回的数据在 id、profession、age、status 之中，则直接走二级索引 直接返回数据了。 如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据 ，这个过程就是回表。 而如果一直使用select * 查询返回所有字段值，很容易就会造成回表 查询（除非是根据主键查询，此时只会扫描聚集索引）。</p><p>A. 表结构及索引示意图:</p><p><img src="/mysql-02/image-20230319123949489.png" alt="image-20230319123949489"></p><p><img src="/mysql-02/image-20230319123957065.png" alt="image-20230319123957065"></p><p>id是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）。</p><p>B. 执行SQL : select * from tb_user where id = 2;</p><p><img src="/mysql-02/image-20230319124138268.png" alt="image-20230319124138268"></p><p>根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p><p>C. 执行SQL：selet id,name from tb_user where name = ‘Arm’</p><p><img src="/mysql-02/image-20230319124238772.png" alt="image-20230319124238772"></p><p>虽然是根据name字段查询，查询二级索引，但是由于查询返回在字段为 id，name，在name的二级索 引中，这两个值都是可以直接获取到的，因为覆盖索引，所以不需要回表查询，性能高。</p><p>D. 执行SQL：selet id,name,gender from tb_user where name = ‘Arm’;</p><p><img src="/mysql-02/image-20230319124305169.png" alt="image-20230319124305169"></p><p>由于在name的二级索引中，不包含gender，所以，需要两次索引扫描，也就是需要回表查询，性能相 对较差一点。</p><p>例如</p><p>一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对 以下SQL语句进行优化, </p><p> select id,username,password from tb_user where username = ‘itcast’; </p><p>针对于 username, password建立联合索引, sql为: create index idx_user_name_pass on tb_user(username,password); </p><p>这样可以避免上述的SQL语句，在查询的过程中，出现回表查询</p><h5 id="2-6-7-前缀索引"><a href="#2-6-7-前缀索引" class="headerlink" title="2.6.7 前缀索引"></a>2.6.7 前缀索引</h5><p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让 索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建 立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>1). 语法</p><pre><code>create index idx_xxxx on table_name(column(n)) ;</code></pre><p>示例:</p><p>为tb_user表的email字段，建立长度为5的前缀索引。</p><pre><code>create index idx_email_5 on tb_user(email(5));</code></pre><p><img src="/mysql-02/image-20230319125857546.png" alt="image-20230319125857546"></p><p>2). 前缀长度</p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值， 索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><pre><code>select count(distinct email) / count(*) from tb_user ;select count(distinct substring(email,1,5)) / count(*) from tb_user ;</code></pre><p>3). 前缀索引的查询流程</p><p><img src="/mysql-02/image-20230319130224881.png" alt="image-20230319130224881"></p><h5 id="2-6-8-单列索引与联合索引"><a href="#2-6-8-单列索引与联合索引" class="headerlink" title="2.6.8 单列索引与联合索引"></a>2.6.8 单列索引与联合索引</h5><p>单列索引：即一个索引只包含单个列。</p><p>联合索引：即一个索引包含了多个列。</p><p><img src="/mysql-02/image-20230319130401139.png" alt="image-20230319130401139"></p><p>在查询出来的索引中，既有单列索引，又有联合索引。</p><p><img src="/mysql-02/image-20230319130514769.png" alt="image-20230319130514769"></p><p>通过上述执行计划可以看出来，在and连接的两个字段 phone、name上都是有单列索引的，但是 最终mysql只会选择一个索引，也就是说，只能走一个字段的索引，此时是会回表查询的。</p><p>紧接着，再来创建一个phone和name字段的联合索引来查询一下执行计划。</p><pre><code>create unique index idx_user_phone_name on tb_user(phone,name)</code></pre><p><img src="/mysql-02/image-20230319130604210.png" alt="image-20230319130604210"></p><p>此时，查询时，就走了联合索引，而在联合索引中包含 phone、name的信息，在叶子节点下挂的是对 应的主键id，所以查询是无需回表查询的。</p><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引， 而非单列索引。</p><p>如果查询使用的是联合索引，具体的结构示意图如下：</p><p><img src="/mysql-02/image-20230319130818720.png" alt="image-20230319130818720"></p><h3 id="2-7-索引设计原则"><a href="#2-7-索引设计原则" class="headerlink" title="2.7 索引设计原则"></a>2.7 索引设计原则</h3><p>1). 针对于数据量较大，且查询比较频繁的表建立索引。</p><p>2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索 引。</p><p>3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p><p>4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p><p>5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。</p><p>6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增 删改的效率。</p><p>7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p><h1 id="3-SQL优化"><a href="#3-SQL优化" class="headerlink" title="3.SQL优化"></a>3.SQL优化</h1><h2 id="3-1-插入数据"><a href="#3-1-插入数据" class="headerlink" title="3.1 插入数据"></a>3.1 插入数据</h2><h3 id="3-1-1-insert"><a href="#3-1-1-insert" class="headerlink" title="3.1.1 insert"></a>3.1.1 insert</h3><p>如果需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。</p><pre><code>insert into tb_test values(1,&#39;tom&#39;);insert into tb_test values(2,&#39;cat&#39;);insert into tb_test values(3,&#39;jerry&#39;);.....</code></pre><p>1). 优化方案一</p><p>批量插入数据</p><pre><code>Insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;);</code></pre><p>2). 优化方案二</p><p>手动控制事务</p><pre><code>start transaction;insert into tb_test values(1,&#39;Tom&#39;),(2,&#39;Cat&#39;),(3,&#39;Jerry&#39;);insert into tb_test values(4,&#39;Tom&#39;),(5,&#39;Cat&#39;),(6,&#39;Jerry&#39;);insert into tb_test values(7,&#39;Tom&#39;),(8,&#39;Cat&#39;),(9,&#39;Jerry&#39;);commit;</code></pre><p>3). 优化方案三</p><p>主键顺序插入，性能要高于乱序插入。</p><pre><code>主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89</code></pre><h3 id="3-1-2-大批量插入数据"><a href="#3-1-2-大批量插入数据" class="headerlink" title="3.1.2 大批量插入数据"></a>3.1.2 大批量插入数据</h3><p>如果一次性需要插入大批量数据(比如: 几百万的记录)，使用insert语句插入性能较低，此时可以使 用MySQL数据库提供的load指令进行插入。操作如下：</p><p><img src="/mysql-02/image-20230319131426081.png" alt="image-20230319131426081"></p><p>可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</p><pre><code>-- 客户端连接服务端时，加上参数 -–local-infilemysql –-local-infile -u root -p-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关set global local_infile = 1;-- 执行load指令将准备好的数据，加载到表结构中load data local infile &#39;/root/sql1.log&#39; into table tb_user fieldsterminated by &#39;,&#39; lines terminated by &#39;\n&#39; ;</code></pre><p>主键顺序插入性能高于乱序插入</p><p>在load时，主键顺序插入性能高于乱序插入</p><h2 id="3-2-主键优化"><a href="#3-2-主键优化" class="headerlink" title="3.2 主键优化"></a>3.2 主键优化</h2><p>1). 数据组织方式</p><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表 (index organized table IOT)。</p><p><img src="/mysql-02/image-20230319131635559.png" alt="image-20230319131635559"></p><p>行数据，都是存储在聚集索引的叶子节点上的。</p><p><img src="/mysql-02/image-20230319131651509.png" alt="image-20230319131651509"></p><p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。 那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储 到下一个页中，页与页之间会通过指针连接。</p><p>2). 页分裂</p><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行 溢出)，根据主键排列。</p><p>A. 主键顺序插入效果</p><p>①. 从磁盘中申请页， 主键顺序插</p><p><img src="/mysql-02/image-20230319131730097.png" alt="image-20230319131730097"></p><p>②. 第一个页没有满，继续往第一页插入</p><p><img src="/mysql-02/image-20230319131743300.png" alt="image-20230319131743300"></p><p>③. 当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</p><p><img src="/mysql-02/image-20230319131755919.png" alt="image-20230319131755919"></p><p>④. 当第二页写满了，再往第三页写入</p><p><img src="/mysql-02/image-20230319131808096.png" alt="image-20230319131808096"></p><p>B. 主键乱序插入效果</p><p>①. 加入1#,2#页都已经写满了，存放了如图所示的数据</p><p><img src="/mysql-02/image-20230319131820529.png" alt="image-20230319131820529"></p><p>②. 此时再插入id为50的记录，会发生什么现象</p><p><img src="/mysql-02/image-20230319131849019.png" alt="image-20230319131849019"></p><p>不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后。</p><p><img src="/mysql-02/image-20230319131901394.png" alt="image-20230319131901394"></p><p>但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。</p><p><img src="/mysql-02/image-20230319131913267.png" alt="image-20230319131913267"></p><p>但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。</p><p><img src="/mysql-02/image-20230319131934335.png" alt="image-20230319131934335"></p><p><img src="/mysql-02/image-20230319131941911.png" alt="image-20230319131941911"></p><p>移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个 页，应该是3#， 3#的下一个页是2#。 所以，此时，需要重新设置链表指针。</p><p>上述的这种现象，称之为 “页分裂”，是比较耗费性能的操作。</p><p>3). 页合并</p><p>目前表中已有数据的索引结构(叶子节点)如下：</p><p><img src="/mysql-02/image-20230319132139676.png" alt="image-20230319132139676"></p><p>对已有数据进行删除时，具体的效果如下: 当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间 变得允许被其他记录声明使用。</p><p><img src="/mysql-02/image-20230319132202748.png" alt="image-20230319132202748"></p><p>继续删除2#的数据记录</p><p><img src="/mysql-02/image-20230319132214171.png" alt="image-20230319132214171"></p><p><img src="/mysql-02/image-20230319132310575.png" alt="image-20230319132310575"></p><p>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前 或后）看看是否可以将两个页合并以优化空间使用。</p><p><img src="/mysql-02/image-20230319132502279.png" alt="image-20230319132502279"></p><p>删除数据，并将页合并之后，再次插入新的数据21，则直接插入3#页</p><p><img src="/mysql-02/image-20230319132513231.png" alt="image-20230319132513231"></p><p>这个里面所发生的合并页的这个现象，就称之为 “页合并”。</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</p><p>4). 索引设计原则</p><ul><li><p>满足业务需求的情况下，尽量降低主键的长度。</p></li><li><p>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键</p></li><li><p>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</p></li><li><p>业务操作时，避免对主键的修改。</p></li></ul><p><img src="/mysql-02/image-20230319132620948.png" alt="image-20230319132620948"></p><h2 id="3-3-order-by优化"><a href="#3-3-order-by优化" class="headerlink" title="3.3 order by优化"></a>3.3 order by优化</h2><p>MySQL的排序，有两种方式：</p><p>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</p><p>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要 额外排序，操作效率高。</p><p>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，在优化排序 操作时，尽量要优化为 Using index。</p><p>C. 创建索引</p><pre><code>-- 创建索引create index idx_user_age_phone_aa on tb_user(age,phone);</code></pre><p>D. 创建索引后，根据age, phone进行升序排序</p><pre><code>explain select id,age,phone from tb_user order by age;</code></pre><p><img src="/mysql-02/image-20230319133656461.png" alt="image-20230319133656461"></p><p><img src="/mysql-02/image-20230319133721578.png" alt="image-20230319133721578"></p><p>建立索引之后，再次进行排序查询，就由原来的Using filesort， 变为了 Using index，性能 就是比较高的了。</p><p>E. 创建索引后，根据age, phone进行降序排序</p><pre><code>explain select id,age,phone from tb_user order by age desc , phone desc ;</code></pre><p><img src="/mysql-02/image-20230319133749616.png" alt="image-20230319133749616"></p><p>也出现 Using index， 但是此时Extra中出现了 Backward index scan，这个代表反向扫描索 引，因为在MySQL中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序 时，是从大到小，所以，在扫描时，就是反向扫描，就会出现 Backward index scan。 在 MySQL8版本中，支持降序索引，我们也可以创建降序索引。</p><p>F. 根据phone，age进行升序排序，phone在前，age在后。</p><pre><code>explain select id,age,phone from tb_user order by phone , age</code></pre><p><img src="/mysql-02/image-20230319133818129.png" alt="image-20230319133818129"></p><p>排序时,也需要满足最左前缀法则,否则也会出现 filesort。因为在创建索引的时候， age是第一个 字段，phone是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现 Using filesort。</p><p>F. 根据age, phone进行降序一个升序，一个降序</p><pre><code>explain select id,age,phone from tb_user order by age asc , phone desc ;</code></pre><p><img src="/mysql-02/image-20230319133847158.png" alt="image-20230319133847158"></p><p>因为创建索引时，如果未指定顺序，默认都是按照升序排序的，而查询时，一个升序，一个降序，此时 就会出现Using filesort。</p><p><img src="/mysql-02/image-20230319133858645.png" alt="image-20230319133858645"></p><p>G. 创建联合索引(age 升序排序，phone 倒序排序)</p><pre><code>create index idx_user_age_phone_ad on tb_user(age asc ,phone desc);</code></pre><p><img src="/mysql-02/image-20230319134002511.png" alt="image-20230319134002511"></p><p>H. 然后再次执行如下SQL</p><pre><code>explain select id,age,phone from tb_user order by age asc , phone desc ;</code></pre><p><img src="/mysql-02/image-20230319134017143.png" alt="image-20230319134017143"></p><p>升序/降序联合索引结构图示:</p><p><img src="/mysql-02/image-20230319155114654.png" alt="image-20230319155114654"></p><p><img src="/mysql-02/image-20230319155120751.png" alt="image-20230319155120751"></p><p>由上述的测试,我们得出order by优化原则:</p><p>A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p><p>B. 尽量使用覆盖索引。</p><p>C. 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</p><p>D. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。</p><h2 id="3-4-group-by优化"><a href="#3-4-group-by优化" class="headerlink" title="3.4 group by优化"></a>3.4 group by优化</h2><p>在没有索引的情况下，执行如下SQL，查询执行计划：</p><pre><code>explain select profession , count(*) from tb_user group by profession ;</code></pre><p><img src="/mysql-02/image-20230319155255946.png" alt="image-20230319155255946"></p><p>针对于 profession ， age， status 创建一个联合索引。</p><pre><code>create index idx_user_pro_age_sta on tb_user(profession , age , status);</code></pre><p>再执行前面相同的SQL查看执行计划。</p><pre><code>explain select profession , count(*) from tb_user group by profession ;</code></pre><p><img src="/mysql-02/image-20230319155359691.png" alt="image-20230319155359691"></p><p><img src="/mysql-02/image-20230319155546400.png" alt="image-20230319155546400"></p><p><img src="/mysql-02/image-20230319155556578.png" alt="image-20230319155556578"></p><p>如果仅仅根据age分组，就会出现 Using temporary ；而如果是 根据 profession,age两个字段同时分组，则不会出现 Using temporary。原因是因为对于分组操作， 在联合索引中，也是符合最左前缀法则的。</p><p>所以，在分组操作中需要通过以下两点进行优化，以提升性能： </p><p>A. 在分组操作时，可以通过索引来提高效率。 </p><p>B. 分组操作时，索引的使用也是满足最左前缀法则的。</p><h2 id="3-5-limit优化"><a href="#3-5-limit优化" class="headerlink" title="3.5 limit优化"></a>3.5 limit优化</h2><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p><p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查 询形式进行优化。</p><pre><code> select * from tb_sku t , (select id from tb_sku order by idlimit 2000000,10) a where t.id = a.id;</code></pre><h2 id="3-6-count优化"><a href="#3-6-count优化" class="headerlink" title="3.6 count优化"></a>3.6 count优化</h2><h3 id="3-6-1-概述"><a href="#3-6-1-概述" class="headerlink" title="3.6.1 概述"></a>3.6.1 概述</h3><pre><code>select count(*) from tb_user ;</code></pre><ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(<em>) 的时候会直接返回这个 数，效率很高； 但是如果是带条件的count，MyISAM也慢。 I</em></li><li><em>nnoDB 引擎就麻烦了，它执行 count(</em>) 的时候，需要把数据一行一行地从引擎里面读出 来，然后累积计数。 </li></ul><p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数 据库进行,但是如果是带条件的count又比较麻烦了)。</p><h3 id="3-6-2-count用法"><a href="#3-6-2-count用法" class="headerlink" title="3.6.2 count用法"></a>3.6.2 count用法</h3><p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加，最后返回累计值。</p><p>用法：count（*）、count（主键）、count（字段）、count（数字）</p><table><thead><tr><th>count用 法</th><th>含义</th></tr></thead><tbody><tr><td>count(主 键)</td><td>InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。 服务层拿到主键后，直接按行进行累加(主键不可能为null)</td></tr><tr><td>count(字 段)</td><td>没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出 来，返回给服务层，服务层判断是否为null，不为null，计数累加。 有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返 回给服务层，直接按行进行累加。</td></tr><tr><td>count(数 字)</td><td>InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1” 进去，直接按行进行累加。</td></tr><tr><td>count(*)</td><td>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接 按行进行累加。</td></tr></tbody></table><p>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(<em>)，所以尽 量使用 count(</em>)。</p><h2 id="3-7-update优化"><a href="#3-7-update优化" class="headerlink" title="3.7 update优化"></a>3.7 update优化</h2><pre><code>update course set name = &#39;javaEE&#39; where id = 1 ;</code></pre><p>在执行删除的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放</p><p>但是当在执行如下SQL时:</p><pre><code>update course set name = &#39;SpringBoot&#39; where name = &#39;PHP&#39; </code></pre><p>开启多个事务，在执行上述的SQL时，行锁升级为了表锁。 导致该update语句的性能 大大降低。</p><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁 升级为表锁 。</p><h1 id="4-视图-存储过程-触发器"><a href="#4-视图-存储过程-触发器" class="headerlink" title="4.视图/存储过程/触发器"></a>4.视图/存储过程/触发器</h1><h2 id="4-1-视图"><a href="#4-1-视图" class="headerlink" title="4.1 视图"></a>4.1 视图</h2><h3 id="4-1-1-介绍"><a href="#4-1-1-介绍" class="headerlink" title="4.1.1 介绍"></a>4.1.1 介绍</h3><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视 图的查询中使用的表，并且是在使用视图时动态生成的。 通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><h3 id="4-1-2-语法"><a href="#4-1-2-语法" class="headerlink" title="4.1.2 语法"></a>4.1.2 语法</h3><p>1). 创建</p><pre><code>CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [CASCADED | LOCAL ] CHECK OPTION ]</code></pre><p>2). 查询</p><pre><code>查看创建视图语句：SHOW CREATE VIEW 视图名称;查看视图数据：SELECT * FROM 视图名称 ...... ;</code></pre><p>3). 修改</p><pre><code>方式一：CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH[ CASCADED | LOCAL ] CHECK OPTION ]方式二：ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED |LOCAL ] CHECK OPTION ]</code></pre><p>4). 删除</p><pre><code>DROP VIEW [IF EXISTS] 视图名称 [,视图名称] ..</code></pre><p>演示示例：</p><pre><code>-- 创建视图create or replace view stu_v_1 as select id,name from student where id &lt;= 10;-- 查询视图show create view stu_v_1;-- 修改视图create or replace view stu_v_1 as select id,name,no from student where id &lt;= 10;alter view stu_v_1 as select id,name from student where id &lt;= 10;-- 删除视图drop view if exists stu_v_1;</code></pre><p>通过视图来插入、更新数据</p><pre><code>create or replace view stu_v_1 as select id,name from student where id &lt;= 10 ;select * from stu_v_1;insert into stu_v_1 values(6,&#39;Tom&#39;);insert into stu_v_1 values(17,&#39;Tom22&#39;);</code></pre><p><img src="/mysql-02/image-20230319162630797.png" alt="image-20230319162630797"></p><p>因为在创建视图的时候，指定的条件为 id&lt;=10, id为17的数据，是不符合条件的，所以没有查 询出来，但是这条数据确实是已经成功的插入到了基表中。  </p><p>如果在定义视图时，如果指定了条件，然后在插入、修改、删除数据时，是否可以做到必须满足 条件才能操作，否则不能够操作呢？ 答案是可以的，这就需要借助于视图的检查选项了。</p><h3 id="4-1-3-检查选项"><a href="#4-1-3-检查选项" class="headerlink" title="4.1.3 检查选项"></a>4.1.3 检查选项</h3><p>当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如 插 入，更新，删除，以使其符合视图的定义。 MySQL允许基于另一个视图创建视图，它还会检查依赖视 图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项： CASCADED 和 LOCAL ，默认值为 CASCADED 。</p><p>1). CASCADED</p><p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 cascaded，但是v1视图 创建时未指定检查选项。 则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1。</p><p><img src="/mysql-02/image-20230319162933805.png" alt="image-20230319162933805"></p><p>2). LOCAL</p><p>本地。 </p><p>比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创 建时未指定检查选项。 则在执行检查时，只会检查v2，不会检查v2的关联视图v1。</p><p><img src="/mysql-02/image-20230319163019438.png" alt="image-20230319163019438"></p><h3 id="4-1-4-视图的更新"><a href="#4-1-4-视图的更新" class="headerlink" title="4.1.4 视图的更新"></a>4.1.4 视图的更新</h3><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一 项，则该视图不可更新：</p><p>A. 聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等） </p><p>B. DISTINCT</p><p> C. GROUP BY </p><p>D. HAVING </p><p>E. UNION 或者 UNION ALL</p><p>示例演示:</p><pre><code>create view stu_v_count as select count(*) from student;</code></pre><p>上述的视图中，就只有一个单行单列的数据，如果对这个视图进行更新或插入的，将会报错。</p><p><img src="/mysql-02/image-20230319163324871.png" alt="image-20230319163324871"></p><p><img src="/mysql-02/image-20230319163331287.png" alt="image-20230319163331287"></p><h3 id="4-1-5-视图作用"><a href="#4-1-5-视图作用" class="headerlink" title="4.1.5 视图作用"></a>4.1.5 视图作用</h3><p>1). 简单</p><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视 图，从而使得用户不必为以后的操作每次指定全部的条件。</p><h4 id="2-安全"><a href="#2-安全" class="headerlink" title="2). 安全"></a>2). 安全</h4><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见 到的数据</p><h4 id="3-数据独立"><a href="#3-数据独立" class="headerlink" title="3). 数据独立"></a>3). 数据独立</h4><p>视图可帮助用户屏蔽真实表结构变化带来的影响。</p><h3 id="4-1-6-案例"><a href="#4-1-6-案例" class="headerlink" title="4.1.6 案例"></a>4.1.6 案例</h3><p>1). 为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽 手机号和邮箱两个字段。</p><pre><code>create view tb_user_view as select id,name,profession,age,gender,status,createtimefrom tb_user;select * from tb_user_view;</code></pre><p>2). 查询每个学生所选修的课程（三张表联查），这个功能在很多的业务中都有使用到，为了简化操 作，定义一个视图。</p><pre><code>create view tb_stu_course_view as select s.name student_name , s.no student_no ,c.name course_name from student s, student_course sc , course c where s.id =sc.studentid and sc.courseid = c.id;select * from tb_stu_course_view;</code></pre><h2 id="4-2-存储过程"><a href="#4-2-存储过程" class="headerlink" title="4.2 存储过程"></a>4.2 存储过程</h2><h3 id="4-2-1-介绍"><a href="#4-2-1-介绍" class="headerlink" title="4.2.1 介绍"></a>4.2.1 介绍</h3><p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发 人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。 存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p><p><img src="/mysql-02/image-20230319164940096.png" alt="image-20230319164940096"></p><p>特点:</p><ul><li>封装，复用 ———————–&gt; 可以把某一业务SQL封装在存储过程中，需要用到 的时候直接调用即可。 </li><li>可以接收参数，也可以返回数据 ——–&gt; 再存储过程中，可以传递参数，也可以接收返回 值。 </li><li>减少网络交互，效率提升 ————-&gt; 如果涉及到多条SQL，每执行一次都是一次网络传 输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。</li></ul><h3 id="4-2-2-基本语法"><a href="#4-2-2-基本语法" class="headerlink" title="4.2.2 基本语法"></a>4.2.2 基本语法</h3><p>1). 创建</p><pre><code>CREATE PROCEDURE 存储过程名称 ([ 参数列表 ])BEGIN-- SQL语句END ;</code></pre><p>2). 调用</p><pre><code>CALL 名称 ([ 参数 ]);</code></pre><p>3). 查看</p><pre><code>SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#39;xxx&#39;; -- 查询指定数据库的存储过程及状态信息SHOW CREATE PROCEDURE 存储过程名称 ; -- 查询某个存储过程的定义</code></pre><p>4). 删除</p><pre><code>DROP PROCEDURE [ IF EXISTS ] 存储过程名称 ；</code></pre><pre><code>在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的结束符。</code></pre><p>演示示例:</p><pre><code>-- 存储过程基本语法-- 创建create procedure p1()beginselect count(*) from student;end;-- 调用call p1();-- 查看select * from information_schema.ROUTINES where ROUTINE_SCHEMA = &#39;数据库名字&#39;;show create procedure p1;-- 删除drop procedure if exists p1;</code></pre><h3 id="4-2-3-变量"><a href="#4-2-3-变量" class="headerlink" title="4.2.3 变量"></a>4.2.3 变量</h3><p>在MySQL中变量分为三种类型: 系统变量、用户定义变量、局部变量。</p><h4 id="4-2-3-1-系统变量"><a href="#4-2-3-1-系统变量" class="headerlink" title="4.2.3.1 系统变量"></a>4.2.3.1 系统变量</h4><p>系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话 变量（SESSION）。</p><p>1). 查看系统变量</p><pre><code>SHOW [ SESSION | GLOBAL ] VARIABLES ; -- 查看所有系统变量SHOW [ SESSION | GLOBAL ] VARIABLES LIKE &#39;......&#39;; -- 可以通过LIKE模糊匹配方式查找变量SELECT @@[SESSION | GLOBAL] 系统变量名; -- 查看指定变量的值</code></pre><p>2). 设置系统变量</p><pre><code>SET [ SESSION | GLOBAL ] 系统变量名 = 值 ;SET @@[SESSION | GLOBAL]系统变量名 = 值 ;</code></pre><p>如果没有指定SESSION/GLOBAL，默认是SESSION，会话变量。</p><p>mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 /etc/my.cnf 中配置。</p><p>A. 全局变量(GLOBAL): 全局变量针对于所有的会话。 B. 会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了。</p><p>演示示例:</p><pre><code>-- 查看系统变量show session variables ;show session variables like &#39;auto%&#39;;show global variables like &#39;auto%&#39;;select @@global.autocommit;select @@session.autocommit;-- 设置系统变量set session autocommit = 1;insert into course(id, name) VALUES (6, &#39;ES&#39;);set global autocommit = 0;select @@global.autocommit;</code></pre><h4 id="4-2-3-2-用户定义变量"><a href="#4-2-3-2-用户定义变量" class="headerlink" title="4.2.3.2 用户定义变量"></a>4.2.3.2 用户定义变量</h4><p>用户定义变量 是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 “@变量 名” 使用就可以。其作用域为当前连接。 </p><p>1). 赋值 </p><p>方式一:</p><pre><code>SET @var_name = expr [, @var_name = expr] ... ;SET @var_name := expr [, @var_name := expr] ... ;</code></pre><p>赋值时，可以使用 = ，也可以使用 := 。</p><p>方式二:</p><pre><code>SELECT @var_name := expr [, @var_name := expr] ... ;SELECT 字段名 INTO @var_name FROM 表名;</code></pre><p>2). 使用</p><pre><code>SELECT @var_name ;</code></pre><p>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</p><p>演示示例:</p><pre><code>-- 赋值set @myname = &#39;ccc&#39;;set @myage := 10;set @mygender := &#39;男&#39;,@myhobby := &#39;java&#39;;select @mycolor := &#39;red&#39;;select count(*) into @mycount from tb_user;-- 使用select @myname,@myage,@mygender,@myhobby;select @mycolor , @mycount;</code></pre><h4 id="4-2-3-3-局部变量"><a href="#4-2-3-3-局部变量" class="headerlink" title="4.2.3.3 局部变量"></a>4.2.3.3 局部变量</h4><p>局部变量 是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的 局部变量和输入参数，局部变量的范围是在其内声明的BEGIN … END块。</p><p>1). 声明</p><pre><code>DECLARE 变量名 变量类型 [DEFAULT ... ] ;</code></pre><p>变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。</p><p>2). 赋值</p><pre><code>SET 变量名 = 值 ;SET 变量名 := 值 ;SELECT 字段名 INTO 变量名 FROM 表名 ... ;</code></pre><p>演示示例:</p><pre><code>-- 声明局部变量 - declare-- 赋值create procedure p2()begindeclare stu_count int default 0;select count(*) into stu_count from student;select stu_count;end;call p2();</code></pre><h4 id="4-2-4-if"><a href="#4-2-4-if" class="headerlink" title="4.2.4 if"></a>4.2.4 if</h4><p>1). 介绍</p><p>if 用于做条件判断，具体的语法结构为：</p><pre><code>IF 条件1 THEN.....ELSEIF 条件2 THEN -- 可选.....ELSE -- 可选.....END IF;</code></pre><p>在if条件判断的结构中，ELSE IF 结构可以有多个，也可以没有。 ELSE结构可以有，也可以没有。</p><p>2). 案例</p><p> 根据定义的分数score变量，判定当前分数对应的分数等级。</p><p> score &gt;= 85分，等级为优秀。 </p><p>score &gt;= 60分 且 score &lt; 85分，等级为及格。</p><p> score &lt; 60分，等级为不及格。</p><pre><code>create procedure p3()begindeclare score int default 58;declare result varchar(10);if score &gt;= 85 thenset result := &#39;优秀&#39;;elseif score &gt;= 60 thenset result := &#39;及格&#39;;elseset result := &#39;不及格&#39;;end if;select result;end;call p3();</code></pre><h4 id="4-2-5-参数"><a href="#4-2-5-参数" class="headerlink" title="4.2.5 参数"></a>4.2.5 参数</h4><p>1). 介绍</p><p>参数的类型，主要分为以下三种：IN、OUT、INOUT。 具体的含义如下：</p><table><thead><tr><th>类型</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>IN</td><td>该类参数作为输入，也就是需要调用时传入值</td><td>默认</td></tr><tr><td>OUT</td><td>该类参数作为输出，也就是该参数可以作为返回值</td><td></td></tr><tr><td>INOUT</td><td>既可以作为输入参数，也可以作为输出参数</td><td></td></tr></tbody></table><p>用法：</p><pre><code>CREATE PROCEDURE 存储过程名称 ([ IN/OUT/INOUT 参数名 参数类型 ])BEGIN-- SQL语句END ;</code></pre><p>2). 案例</p><p>将传入的200分制的分数，进行换算，换算成百分制，然后返回。</p><pre><code>create procedure p5(inout score double)beginset score := score * 0.5;end;set @score = 198;call p5(@score);select @score;</code></pre><p>根据传入参数score，判定当前分数对应的分数等级，并返回。 </p><p>score &gt;= 85分，等级为优秀。 </p><p>score &gt;= 60分 且 score &lt; 85分，等级为及格。 </p><p>score &lt; 60分，等级为不及格。</p><pre><code>create procedure p4(in score int, out result varchar(10))beginif score &gt;= 85 thenset result := &#39;优秀&#39;;elseif score &gt;= 60 thenset result := &#39;及格&#39;;elseset result := &#39;不及格&#39;;end if;end;-- 定义用户变量 @result来接收返回的数据, 用户变量可以不用声明call p4(18, @result);select @result;</code></pre><h4 id="4-2-6-case"><a href="#4-2-6-case" class="headerlink" title="4.2.6 case"></a>4.2.6 case</h4><p>1). 介绍 case结构及作用。有两种语法格式： 语法1：</p><pre><code>-- 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，执行statement_list2， 否则就执行 statement_listCASE case_valueWHEN when_value1 THEN statement_list1[ WHEN when_value2 THEN statement_list2] ...[ ELSE statement_list ]END CASE;</code></pre><p>语法2：</p><pre><code>-- 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成立时，执行statement_list2， 否则就执行 statement_listCASEWHEN search_condition1 THEN statement_list1[WHEN search_condition2 THEN statement_list2] ...[ELSE statement_list]END CASE;</code></pre><p>如果判定条件有多个，多个条件之间，可以使用 and 或 or 进行连接。</p><h4 id="4-2-7-while"><a href="#4-2-7-while" class="headerlink" title="4.2.7 while"></a>4.2.7 while</h4><p>1). 介绍</p><p>while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</p><pre><code>-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑WHILE 条件 DOSQL逻辑...END WHILE;</code></pre><h4 id="4-2-8-repeat"><a href="#4-2-8-repeat" class="headerlink" title="4.2.8 repeat"></a>4.2.8 repeat</h4><p>1). 介绍</p><p>repeat是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环 。具体语法为：</p><pre><code>-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环REPEATSQL逻辑...UNTIL 条件END REPEAT;</code></pre><h4 id="4-2-9-loop"><a href="#4-2-9-loop" class="headerlink" title="4.2.9 loop"></a>4.2.9 loop</h4><p>1). 介绍</p><p>LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。 LOOP可以配合一下两个语句使用： </p><p>LEAVE ：配合循环使用，退出循环。 </p><p>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</p><pre><code>[begin_label:] LOOPSQL逻辑...END LOOP [end_label];</code></pre><pre><code>LEAVE label; -- 退出指定标记的循环体ITERATE label; -- 直接进入下一次循环</code></pre><p>上述语法中出现的 begin_label，end_label，label 指的都是自定义的标记。</p><p>2). 案例一</p><p>计算从1累加到n的值，n为传入的参数值。</p><pre><code>-- A. 定义局部变量, 记录累加之后的值;-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xxcreate procedure p9(in n int)begindeclare total int default 0;sum:loopif n&lt;=0 thenleave sum;end if;set total := total + n;set n := n - 1;end loop sum;select total;end;call p9(100);</code></pre><p>3). 案例二</p><p>计算从1到n之间的偶数累加的值，n为传入的参数值。</p><pre><code>-- A. 定义局部变量, 记录累加之后的值;-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xx-- C. 如果当次累加的数据是奇数, 则直接进入下一次循环. --------&gt; iterate xxcreate procedure p10(in n int)begindeclare total int default 0;sum:loopif n&lt;=0 thenleave sum;end if;if n%2 = 1 thenset n := n - 1;iterate sum;end if;set total := total + n;set n := n - 1;end loop sum;select total;end;call p10(100);</code></pre><h4 id="4-2-10-游标"><a href="#4-2-10-游标" class="headerlink" title="4.2.10 游标"></a>4.2.10 游标</h4><p>1). 介绍 游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进 行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p><p>A. 声明游标</p><pre><code>DECLARE 游标名称 CURSOR FOR 查询语句 ;</code></pre><p>B. 打开游标</p><pre><code> OPEN 游标名称 ;</code></pre><p>C. 获取游标记录</p><pre><code>FETCH 游标名称 INTO 变量 [, 变量 ] ;</code></pre><p>D. 关闭游标</p><pre><code>CLOSE 游标名称 ;</code></pre><p>2). 案例</p><p>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名 （name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表 (id,name,profession)中。</p><pre><code>-- 逻辑:-- A. 声明游标, 存储查询结果集-- B. 准备: 创建表结构-- C. 开启游标-- D. 获取游标中的记录-- E. 插入数据到新表中-- F. 关闭游标create procedure p11(in uage int)begindeclare uname varchar(100);declare upro varchar(100);declare u_cursor cursor for select name,profession from tb_user where age &lt;=uage;drop table if exists tb_user_pro;create table if not exists tb_user_pro(id int primary key auto_increment,name varchar(100),profession varchar(100));open u_cursor;while true dofetch u_cursor into uname,upro;insert into tb_user_pro values (null, uname, upro);end while;close u_cursor;end;call p11(30)；</code></pre><p>上述的存储过程，最终我们在调用的过程中，会报错，之所以报错是因为上面的while循环中，并没有 退出条件。当游标的数据集获取完毕之后，再次获取数据，就会报错，从而终止了程序的执行。</p><p><img src="/mysql-02/image-20230319172816754.png" alt="image-20230319172816754"></p><p>但是此时，tb_user_pro表结构及其数据都已经插入成功了，可以直接刷新表结构，检查表结构 中的数据。</p><p><img src="/mysql-02/image-20230319172837052.png" alt="image-20230319172837052"></p><p>要想解决这个问题，就需要通过MySQL中提供的 条件处理程序 Handle（条件处理程序）来解决。</p><h4 id="4-2-11-条件处理程序"><a href="#4-2-11-条件处理程序" class="headerlink" title="4.2.11 条件处理程序"></a>4.2.11 条件处理程序</h4><p>1). 介绍</p><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体 语法为</p><pre><code>DECLARE handler_action HANDLER FOR condition_value [, condition_value]... statement ;handler_action 的取值：CONTINUE: 继续执行当前程序EXIT: 终止执行当前程序condition_value 的取值：SQLSTATE sqlstate_value: 状态码，如 02000SQLWARNING: 所有以01开头的SQLSTATE代码的简写NOT FOUND: 所有以02开头的SQLSTATE代码的简写SQLEXCEPTION: 所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写</code></pre><p>2). 案例</p><p>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名 （name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表 (id,name,profession)中。</p><p>A. 通过SQLSTATE指定具体的状态码</p><pre><code>-- 逻辑:-- A. 声明游标, 存储查询结果集-- B. 准备: 创建表结构-- C. 开启游标-- D. 获取游标中的记录-- E. 插入数据到新表中-- F. 关闭游标create procedure p11(in uage int)begindeclare uname varchar(100);declare upro varchar(100);declare u_cursor cursor for select name,profession from tb_user where age &lt;=uage;-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02000时，将关闭游标u_cursor，并退出declare exit handler for SQLSTATE &#39;02000&#39; close u_cursor;drop table if exists tb_user_pro;create table if not exists tb_user_pro(id int primary key auto_increment,name varchar(100),profession varchar(100));open u_cursor;while true dofetch u_cursor into uname,upro;insert into tb_user_pro values (null, uname, upro);end while;close u_cursor;end;call p11(30);</code></pre><p>B. 通过SQLSTATE的代码简写方式 NOT FOUND</p><p>02 开头的状态码，代码简写为 NOT FOUND</p><pre><code>create procedure p12(in uage int)begindeclare uname varchar(100);declare upro varchar(100);declare u_cursor cursor for select name,profession from tb_user where age &lt;=uage;-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02开头时，将关闭游标u_cursor，并退出declare exit handler for not found close u_cursor;drop table if exists tb_user_pro;create table if not exists tb_user_pro(id int primary key auto_increment,name varchar(100),profession varchar(100));open u_cursor;while true dofetch u_cursor into uname,upro;insert into tb_user_pro values (null, uname, upro);end while;close u_cursor;end;call p12(30);</code></pre><p>具体的错误状态码，可以参考官方文档：</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html" target="_blank" rel="noopener">MySQL :: MySQL 8.0 Reference Manual :: 13.6.7.2 DECLARE … HANDLER Statement</a></p><p><a href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html" target="_blank" rel="noopener">MySQL :: MySQL 8.0 Error Reference :: 2 Server Error Message Reference</a></p><h2 id="4-3-存储函数"><a href="#4-3-存储函数" class="headerlink" title="4.3 存储函数"></a>4.3 存储函数</h2><p>1). 介绍 存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：</p><pre><code>CREATE FUNCTION 存储函数名称 ([ 参数列表 ])RETURNS type [characteristic ...]BEGIN-- SQL语句RETURN ...;END ;</code></pre><p>characteristic说明： </p><ul><li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li><li>NO SQL ：不包含 SQL 语句。 </li><li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句。</li></ul><p>2). 案例</p><p>计算从1累加到n的值，n为传入的参数值。</p><pre><code>create function fun1(n int)returns int deterministicbegindeclare total int default 0;while n&gt;0 doset total := total + n;set n := n - 1;end while;return total;end;select fun1(50)</code></pre><p>在mysql8.0版本中binlog默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定 characteristic特性，否则就会报如下错误：</p><p><img src="/mysql-02/image-20230319174608555.png" alt="image-20230319174608555"></p><h2 id="4-4-触发器"><a href="#4-4-触发器" class="headerlink" title="4.4 触发器"></a>4.4 触发器</h2><h3 id="4-4-1-介绍"><a href="#4-4-1-介绍" class="headerlink" title="4.4.1 介绍"></a>4.4.1 介绍</h3><p>触发器是与表有关的数据库对象，指在insert/update/delete之前(BEFORE)或之后(AFTER)，触 发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。 使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还 只支持行级触发，不支持语句级触发。</p><table><thead><tr><th>触发器类型</th><th>NEW 和 OLD</th></tr></thead><tbody><tr><td>INSERT 型触发器</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>UPDATE 型触发器</td><td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td></tr><tr><td>DELETE 型触发器</td><td>OLD 表示将要或者已经删除的数据</td></tr></tbody></table><h3 id="4-4-2-语法"><a href="#4-4-2-语法" class="headerlink" title="4.4.2 语法"></a>4.4.2 语法</h3><p>1). 创建</p><pre><code>CREATE TRIGGER trigger_nameBEFORE/AFTER INSERT/UPDATE/DELETEON tbl_name FOR EACH ROW -- 行级触发器BEGINtrigger_stmt ;END;</code></pre><p>2). 查看</p><pre><code>SHOW TRIGGERS ;</code></pre><p>3). 删除</p><pre><code>DROP TRIGGER [schema_name.]trigger_name ; -- 如果没有指定 schema_name，默认为当前数据库 。</code></pre><h3 id="4-4-3-案例"><a href="#4-4-3-案例" class="headerlink" title="4.4.3 案例"></a>4.4.3 案例</h3><p>通过触发器记录 tb_user 表的数据变更日志，将变更日志插入到日志表user_logs中, 包含增加, 修改 , 删除 ; 表结构准备:</p><pre><code>-- 准备工作 : 日志表 user_logscreate table user_logs(id int(11) not null auto_increment,operation varchar(20) not null comment &#39;操作类型, insert/update/delete&#39;,operate_time datetime not null comment &#39;操作时间&#39;,operate_id int(11) not null comment &#39;操作的ID&#39;,operate_params varchar(500) comment &#39;操作参数&#39;,primary key(`id`))engine=innodb default charset=utf8;</code></pre><p>A. 插入数据触发器</p><pre><code>create trigger tb_user_insert_triggerafter insert on tb_user for each rowbegininsert into user_logs(id, operation, operate_time, operate_id, operate_params)VALUES(null, &#39;insert&#39;, now(), new.id, concat(&#39;插入的数据内容为:id=&#39;,new.id,&#39;,name=&#39;,new.name, &#39;, phone=&#39;, NEW.phone, &#39;, email=&#39;, NEW.email, &#39;,profession=&#39;, NEW.profession));end;</code></pre><p>测试:</p><pre><code>-- 查看show triggers ;-- 插入数据到tb_userinsert into tb_user(id, name, phone, email, profession, age, gender, status,createtime) VALUES (26,&#39;三皇子&#39;,&#39;18809091212&#39;,&#39;erhuangzi@163.com&#39;,&#39;软件工程&#39;,23,&#39;1&#39;,&#39;1&#39;,now());</code></pre><p>测试完毕之后，检查日志表中的数据是否可以正常插入，以及插入数据的正确性。</p><p>B. 修改数据触发器</p><pre><code>create trigger tb_user_update_triggerafter update on tb_user for each rowbegininsert into user_logs(id, operation, operate_time, operate_id, operate_params)VALUES(null, &#39;update&#39;, now(), new.id,concat(&#39;更新之前的数据: id=&#39;,old.id,&#39;,name=&#39;,old.name, &#39;, phone=&#39;,old.phone, &#39;, email=&#39;, old.email, &#39;, profession=&#39;, old.profession,&#39; | 更新之后的数据: id=&#39;,new.id,&#39;,name=&#39;,new.name, &#39;, phone=&#39;,NEW.phone, &#39;, email=&#39;, NEW.email, &#39;, profession=&#39;, NEW.profession));end;</code></pre><p>测试:</p><pre><code>-- 查看show triggers ;-- 更新update tb_user set profession = &#39;会计&#39; where id = 23;update tb_user set profession = &#39;会计&#39; where id &lt;= 5;</code></pre><p>测试完毕之后，检查日志表中的数据是否可以正常插入，以及插入数据的正确性。</p><p>C. 删除数据触发器</p><pre><code>create trigger tb_user_delete_triggerafter delete on tb_user for each rowbegininsert into user_logs(id, operation, operate_time, operate_id, operate_params)VALUES(null, &#39;delete&#39;, now(), old.id,concat(&#39;删除之前的数据: id=&#39;,old.id,&#39;,name=&#39;,old.name, &#39;, phone=&#39;,old.phone, &#39;, email=&#39;, old.email, &#39;, profession=&#39;, old.profession));end;</code></pre><p>测试:</p><pre><code>-- 查看show triggers ;-- 删除数据delete from tb_user where id = 26;</code></pre><h1 id="5-锁"><a href="#5-锁" class="headerlink" title="5.锁"></a>5.锁</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、 RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有 效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个 角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><pre><code>全局锁：锁定数据库中的所有表。表级锁：每次操作锁住整张表。行级锁：每次操作锁住对应的行数据。</code></pre><h2 id="5-2-全局锁"><a href="#5-2-全局锁" class="headerlink" title="5.2 全局锁"></a>5.2 全局锁</h2><h3 id="5-2-1-介绍"><a href="#5-2-1-介绍" class="headerlink" title="5.2.1 介绍"></a>5.2.1 介绍</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语 句，已经更新操作的事务提交语句都将被阻塞。 其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整 性。</p><p>不加全局锁，可能存在的问题。</p><p><img src="/mysql-02/image-20230319183403451.png" alt="image-20230319183403451"></p><ul><li>在进行数据备份时，先备份了tb_stock库存表。</li><li>然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入 tb_order表）。</li><li>然后再执行备份 tb_order表的逻辑。 </li><li>业务中执行插入订单日志操作。 </li><li>最后，又备份了tb_orderlog表。</li></ul><p>此时备份出来的数据，是存在问题的。因为备份出来的数据，tb_stock表与tb_order表的数据不一 致(有最新操作的订单信息,但是库存数没减)。</p><p>那如何来规避这种问题呢? 此时就可以借助于MySQL的全局锁来解决。</p><p>B. 再来分析一下加了全局锁后的情况</p><p><img src="/mysql-02/image-20230319184239125.png" alt="image-20230319184239125"></p><p>对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、 DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。 那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性 和完整性</p><h3 id="5-2-2-语法"><a href="#5-2-2-语法" class="headerlink" title="5.2.2 语法"></a>5.2.2 语法</h3><p>1). 加全局锁</p><pre><code>flush tables with read lock ;</code></pre><p>2). 数据备份</p><pre><code>mysqldump -uroot –p1234 备份的数据库名 &gt; 备份到的名称.sql</code></pre><p>3). 释放锁</p><pre><code>unlock tables ;</code></pre><h3 id="5-2-3-特点"><a href="#5-2-3-特点" class="headerlink" title="5.2.3 特点"></a>5.2.3 特点</h3><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导 致主从延迟。 </li></ul><p>在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致 性数据备份。</p><pre><code>mysqldump --single-transaction -uroot –p123456 备份的数据库名 &gt; 备份到的名称.sql</code></pre><h2 id="5-3-表级锁"><a href="#5-3-表级锁" class="headerlink" title="5.3 表级锁"></a>5.3 表级锁</h2><h3 id="5-3-1-介绍"><a href="#5-3-1-介绍" class="headerlink" title="5.3.1 介绍"></a>5.3.1 介绍</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、 InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ul><li>表锁 </li><li>元数据锁（meta data lock，MDL） </li><li>意向锁</li></ul><h3 id="5-3-2-表锁"><a href="#5-3-2-表锁" class="headerlink" title="5.3.2 表锁"></a>5.3.2 表锁</h3><p>对于表锁，分为两类：</p><ul><li>表共享读锁（read lock） </li><li>表独占写锁（write lock）</li></ul><p>语法： </p><p>加锁：lock tables 表名… read/write。 </p><p>释放锁：unlock tables / 客户端断开连接 。</p><p>特点:</p><p>A. 读锁</p><p><img src="/mysql-02/image-20230319185630541.png" alt="image-20230319185630541"></p><p><img src="/mysql-02/image-20230319185720262.png" alt="image-20230319185720262"></p><p>B. 写锁</p><p><img src="/mysql-02/image-20230319185826564.png" alt="image-20230319185826564"></p><p>左侧为客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写。</p><p><img src="/mysql-02/image-20230319185842742.png" alt="image-20230319185842742"></p><p>读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞 其他客户端的写。</p><h3 id="5-3-3-元数据锁"><a href="#5-3-3-元数据锁" class="headerlink" title="5.3.3 元数据锁"></a>5.3.3 元数据锁</h3><p>meta data lock , 元数据锁，简写MDL。</p><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维 护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与 DDL冲突，保证读写的正确性。 </p><p>这里的元数据，可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务 时，是不能够修改这张表的表结构的。</p><p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)；当对表结构进行变 更操作的时候，加MDL写锁(排他)</p><p>常见的SQL操作时，所添加的元数据锁</p><table><thead><tr><th>对应SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td>lock tables xxx read / write</td><td>SHARED_READ_ONLY / SHARED_NO_READ_WRITE</td><td></td></tr><tr><td>select 、select … lock in share mode</td><td>SHARED_READ</td><td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td></tr><tr><td>insert 、update、 delete、select … for update</td><td>SHARED_WRITE</td><td>与SHARED_READ、 SHARED_WRITE兼容，与 EXCLUSIVE互斥</td></tr><tr><td>alter table …</td><td>EXCLUSIVE</td><td>与其他的MDL都互斥</td></tr></tbody></table><p>演示：</p><p> 当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ / SHARED_WRITE），之间是兼容的。</p><p><img src="/mysql-02/image-20230319192508226.png" alt="image-20230319192508226"></p><p>当执行SELECT语句时，添加的是元数据共享锁（SHARED_READ），会阻塞元数据排他锁 （EXCLUSIVE），之间是互斥的。</p><p><strong><img src="/mysql-02/image-20230319210202353.png" alt="image-20230319210202353"></strong></p><h3 id="5-3-4-意向锁"><a href="#5-3-4-意向锁" class="headerlink" title="5.3.4 意向锁"></a>5.3.4 意向锁</h3><p>1). 介绍</p><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行 数据是否加锁，使用意向锁来减少表锁的检查。</p><p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一 下：</p><p>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。</p><p><img src="/mysql-02/image-20230319210333562.png" alt="image-20230319210333562"></p><p>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就 会从第一行数据，检查到最后一行数据，效率较低。</p><p><img src="/mysql-02/image-20230319210346840.png" alt="image-20230319210346840"></p><p>有了意向锁之后 :</p><p>客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。</p><p><img src="/mysql-02/image-20230319210406968.png" alt="image-20230319210406968"></p><p>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而 不用逐行判断行锁情况了。</p><p><img src="/mysql-02/image-20230319210613130.png" alt="image-20230319210613130"></p><p>2). 分类</p><ul><li>意向共享锁(IS): 由语句select … lock in share mode添加 。 与 表锁共享锁 (read)兼容，与表锁排他锁(write)互斥。</li><li>意向排他锁(IX): 由insert、update、delete、select…for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。</li></ul><p>一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。</p><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><pre><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data fromperformance_schema.data_locks;</code></pre><p>A. 意向共享锁与表读锁是兼容的</p><p><img src="/mysql-02/image-20230319210911250.png" alt="image-20230319210911250"></p><p>B. 意向排他锁与表读锁、写锁都是互斥的</p><p><img src="/mysql-02/image-20230319210922329.png" alt="image-20230319210922329"></p><h2 id="5-4-行级锁"><a href="#5-4-行级锁" class="headerlink" title="5.4 行级锁"></a>5.4 行级锁</h2><h3 id="5-4-1-介绍"><a href="#5-4-1-介绍" class="headerlink" title="5.4.1 介绍"></a>5.4.1 介绍</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的 锁。对于行级锁，主要分为以下三类</p><p>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在 RC、RR隔离级别下都支持。</p><p><img src="/mysql-02/image-20230319211512113.png" alt="image-20230319211512113"></p><p>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事 务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</p><p><img src="/mysql-02/image-20230319211522999.png" alt="image-20230319211522999"></p><p>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。 在RR隔离级别下支持。</p><p><img src="/mysql-02/image-20230319211611369.png" alt="image-20230319211611369"></p><h3 id="5-4-2-行锁"><a href="#5-4-2-行锁" class="headerlink" title="5.4.2 行锁"></a>5.4.2 行锁</h3><p>1). 介绍</p><p>InnoDB实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。 </li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他 锁。</li></ul><p>两种行锁的兼容情况如下:</p><p><img src="/mysql-02/image-20230319212308484.png" alt="image-20230319212308484"></p><p>常见的SQL语句，在执行时，所加的行锁如下：</p><table><thead><tr><th>SQL</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td>INSERT …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>UPDATE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>DELETE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>SELECT（正常）</td><td>不加任何 锁</td><td></td></tr><tr><td>SELECT … LOCK IN SHARE MODE</td><td>共享锁</td><td>需要手动在SELECT之后加LOCK IN SHARE MODE</td></tr><tr><td>SELECT … FOR UPDATE</td><td>排他锁</td><td>需要手动在SELECT之后加FOR UPDATE</td></tr></tbody></table><p>2). 演示</p><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜 索和索引扫描，以防止幻读。</p><ul><li><p>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p></li><li><p>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记 录加锁，此时 就会升级为表锁。</p></li></ul><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><pre><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data fromperformance_schema.data_locks;</code></pre><p>示例演示 数据准备:</p><pre><code>CREATE TABLE `stu` (`id` int NOT NULL PRIMARY KEY AUTO_INCREMENT,`name` varchar(255) DEFAULT NULL,`age` int NOT NULL) ENGINE = InnoDB CHARACTER SET = utf8mb4;INSERT INTO `stu` VALUES (1, &#39;tom&#39;, 1);INSERT INTO `stu` VALUES (3, &#39;cat&#39;, 3);INSERT INTO `stu` VALUES (8, &#39;rose&#39;, 8);INSERT INTO `stu` VALUES (11, &#39;jetty&#39;, 11);INSERT INTO `stu` VALUES (19, &#39;lily&#39;, 19);INSERT INTO `stu` VALUES (25, &#39;luci&#39;, 25);</code></pre><p>A. 普通的select语句，执行时，不会加锁。</p><p><img src="/mysql-02/image-20230319213654433.png" alt="image-20230319213654433"></p><p>B. select…lock in share mode，加共享锁，共享锁与共享锁之间兼容。</p><p><img src="/mysql-02/image-20230319213856151.png" alt="image-20230319213856151"></p><p>共享锁与排他锁之间互斥。</p><p><img src="/mysql-02/image-20230319213929646.png" alt="image-20230319213929646"></p><p>客户端一获取的是id为1这行的共享锁，客户端二是可以获取id为3这行的排它锁的，因为不是同一行 数据。 而如果客户端二想获取id为1这行的排他锁，会处于阻塞状态，以为共享锁与排他锁之间互 斥。</p><p>C. 排它锁与排他锁之间互斥</p><p><img src="/mysql-02/image-20230319213947892.png" alt="image-20230319213947892"></p><p>当客户端一，执行update语句，会为id为1的记录加排他锁； 客户端二，如果也执行update语句更 新id为1的数据，也要为id为1的数据加排他锁，但是客户端二会处于阻塞状态，因为排他锁之间是互 斥的。 直到客户端一，把事务提交了，才会把这一行的行锁释放，此时客户端二，解除阻塞。</p><p>D. 无索引行锁升级为表锁</p><p>stu表中数据如下:</p><p><img src="/mysql-02/image-20230319214028644.png" alt="image-20230319214028644"></p><p><img src="/mysql-02/image-20230319214319115.png" alt="image-20230319214319115"></p><p>在客户端一中，开启事务，并执行update语句，更新name为Lily的数据，也就是id为19的记录 。 然后在客户端二中更新id为3的记录，却不能直接执行，会处于阻塞状态，为什么呢？ 原因就是因为此时，客户端一，根据name字段进行更新时，name字段是没有索引的，如果没有索引， 此时行锁会升级为表锁(因为行锁是对索引项加的锁，而name没有索引)。</p><p>针对name字段建立索引，索引建立之后，再次做一个测试：</p><p><img src="/mysql-02/image-20230319214352192.png" alt="image-20230319214352192"></p><p>客户端一，开启事务，然后依然是根据name进行更新。而客户端二，在更新id为3 的数据时，更新成功，并未进入阻塞状态。 这样就说明，根据索引字段进行更新操作，就可以避 免行锁升级为表锁的情况。</p><h3 id="5-4-3-间隙锁-amp-临键锁"><a href="#5-4-3-间隙锁-amp-临键锁" class="headerlink" title="5.4.3 间隙锁&amp;临键锁"></a>5.4.3 间隙锁&amp;临键锁</h3><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key（临键锁） 锁进行搜 索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。 </li><li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。 </li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li></ul><p>间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会 阻止另一个事务在同一间隙上采用间隙锁。</p><p><img src="/mysql-02/image-20230319215902885.png" alt="image-20230319215902885"></p><p>B. 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。 </p><p>InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，要根据这个二级索引查询值 为18的数据，并加上共享锁，只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个 结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也 就是29）。此时会对18加临键锁，并对29之前的间隙加锁。</p><p><img src="/mysql-02/image-20230319220818787.png" alt="image-20230319220818787"></p><p><img src="/mysql-02/image-20230319220847147.png" alt="image-20230319220847147"></p><p>C. 索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</p><p><img src="/mysql-02/image-20230319221216040.png" alt="image-20230319221216040"></p><p>查询的条件为id&gt;=19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部 分：[19] (19,25] (25,+∞]</p><p>所以数据库数据在加锁是，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临 键锁(正无穷及之前的间隙)。</p><h1 id="6-InnoDB引擎"><a href="#6-InnoDB引擎" class="headerlink" title="6.InnoDB引擎"></a>6.InnoDB引擎</h1><h2 id="6-1-逻辑存储结构"><a href="#6-1-逻辑存储结构" class="headerlink" title="6.1 逻辑存储结构"></a>6.1 逻辑存储结构</h2><p>InnoDB的逻辑存储结构如下图所示:</p><p><img src="/mysql-02/image-20230319221704166.png" alt="image-20230319221704166"></p><p>1). 表空间</p><p>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在 8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空 间，用于存储记录、索引等数据。</p><p>2). 段</p><p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段 （Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的 非叶子节点。段用来管理多个Extent（区）。</p><p>3). 区</p><p>区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一 个区中一共有64个连续的页。</p><p>4). 页</p><p>页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性， InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p><p>5). 行</p><p>行，InnoDB 存储引擎数据是按行进行存放的。 在行中，默认有两个隐藏字段： Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。 Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个 隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p><h2 id="6-2-架构"><a href="#6-2-架构" class="headerlink" title="6.2 架构"></a>6.2 架构</h2><h3 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1 概述"></a>6.2.1 概述</h3><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发 中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。</p><p><img src="/mysql-02/image-20230319223436173.png" alt="image-20230319223436173"></p><h3 id="6-2-2-内存结构"><a href="#6-2-2-内存结构" class="headerlink" title="6.2.2 内存结构"></a>6.2.2 内存结构</h3><p><img src="/mysql-02/image-20230319223451003.png" alt="image-20230319223451003"></p><p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。</p><p>1). Buffer Pool</p><p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能 弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁 盘I/O。</p><p>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及 InnoDB的锁信息等等。</p><p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增 删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频 率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型： </p><p>• free page：空闲page，未被使用。</p><p> • clean page：被使用page，数据没有被修改过。</p><p> • dirty page：脏页，被使用page，数据被修改过，其中数据与磁盘的数据产生了不一致。</p><p>在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。参数设置： show variables like ‘innodb_buffer_pool_size’;</p><p><img src="/mysql-02/image-20230319225434479.png" alt="image-20230319225434479"></p><p>2). Change Buffer</p><p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page 没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer 中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p>Change Buffer的意义</p><p><img src="/mysql-02/image-20230319225518087.png" alt="image-20230319225518087"></p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新 可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了 ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p><p>3). Adaptive Hash Index</p><p>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持 hash索引，但是给我们提供了一个功能就是这个自适应hash索引。hash索引在 进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需 要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。 InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度， 则建立hash索引，称之为自适应hash索引</p><p>适应哈希索引，无需人工干预，是系统根据情况自动完成。</p><p>参数： adaptive_hash_index</p><p>4). Log Buffer</p><p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log）， 默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事 务，增加日志缓冲区的大小可以节省磁盘 I/O。 </p><p>参数: </p><p>innodb_log_buffer_size：缓冲区大小 </p><p>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：</p><p> 1: 日志在每次事务提交时写入并刷新到磁盘，默认值。</p><p> 0: 每秒将日志写入并刷新到磁盘一次</p><p>2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</p><h3 id="6-2-3-磁盘结构"><a href="#6-2-3-磁盘结构" class="headerlink" title="6.2.3 磁盘结构"></a>6.2.3 磁盘结构</h3><p><img src="/mysql-02/image-20230319225851507.png" alt="image-20230319225851507"></p><p>1). System Tablespace</p><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建 的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等) </p><p>参数：innodb_data_file_path</p><p><img src="/mysql-02/image-20230319225941139.png" alt="image-20230319225941139"></p><p>系统表空间，默认的文件名叫 ibdata1。</p><p>2). File-Per-Table Tablespaces</p><p>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索 引 ，并存储在文件系统上的单个数据文件中。 开关参数：innodb_file_per_table ，该参数默认开启。</p><p><img src="/mysql-02/image-20230319230007205.png" alt="image-20230319230007205"></p><p>那也就是说，每创建一个表，都会产生一个表空间文件，如图：</p><p><img src="/mysql-02/image-20230319230041529.png" alt="image-20230319230041529"></p><p>3). General Tablespaces</p><p>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空 间。</p><p>A. 创建表空间、</p><pre><code>CREATE TABLESPACE ts_name ADD DATAFILE &#39;file_name&#39; ENGINE = engine_name;</code></pre><p><img src="/mysql-02/image-20230319230149322.png" alt="image-20230319230149322"></p><p>B. 创建表时指定表空间</p><pre><code>CREATE TABLE xxx ... TABLESPACE ts_name；</code></pre><p><img src="/mysql-02/image-20230319230236014.png" alt="image-20230319230236014"></p><p>4). Undo Tablespaces</p><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储 undo log日志。</p><p>5). Temporary Tablespaces</p><p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><p>6). Doublewrite Buffer Files</p><p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件 中，便于系统异常时恢复数据。</p><p><img src="/mysql-02/image-20230319230341360.png" alt="image-20230319230341360"></p><p>7). Redo Log</p><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所 有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。 以循环方式写入重做日志文件，涉及两个文件：</p><p><img src="/mysql-02/image-20230319232634292.png" alt></p><p><img src="/mysql-02/image-20230319232657863.png" alt="image-20230319232657863"></p><h3 id="6-2-4-后台线程"><a href="#6-2-4-后台线程" class="headerlink" title="6.2.4 后台线程"></a>6.2.4 后台线程</h3><p><img src="/mysql-02/image-20230319232718514.png" alt="image-20230319232718514"></p><p>在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、 Page Cleaner Thread。</p><p>1). Master Thread 核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性， 还包括脏页的刷新、合并插入缓存、undo页的回收 。</p><p> 2). IO Thread 在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。</p><table><thead><tr><th>线程类型</th><th>默认个数</th><th>职责</th></tr></thead><tbody><tr><td>Read thread</td><td>4</td><td>负责读操作</td></tr><tr><td>Write thread</td><td>4</td><td>负责写操作</td></tr><tr><td>Log thread</td><td>1</td><td>负责将日志缓冲区刷新到磁盘</td></tr><tr><td>Insert buffer thread</td><td>1</td><td>负责将写缓冲区内容刷新到磁盘</td></tr></tbody></table><p>可以通过以下的这条指令，查看到InnoDB的状态信息，其中就包含IO Thread信息</p><pre><code>show engine innodb status \G;</code></pre><p><img src="/mysql-02/image-20230319233258967.png" alt="image-20230319233258967"></p><p>3). Purge Thread</p><p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回 收。</p><p>4). Page Cleaner Thread</p><p>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻 塞。</p><h2 id="6-3-事务原理"><a href="#6-3-事务原理" class="headerlink" title="6.3 事务原理"></a>6.3 事务原理</h2><p>1). 事务 事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>2). 特性</p><ul><li><p>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 </p></li><li><p>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</p></li><li><p>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。 </p></li><li><p>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p></li></ul><p>对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的 两份日志来保证的，一份是redo log日志，一份是undo log日志。 而持久性是通过数据库的锁， 加上MVCC来保证的。</p><p><img src="/mysql-02/image-20230320125859308.png" alt="image-20230320125859308"></p><h3 id="6-3-2-redo-log"><a href="#6-3-2-redo-log" class="headerlink" title="6.3.2 redo log"></a>6.3.2 redo log</h3><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。 </p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用 于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p>在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数 据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果 缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中 的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘 中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后 将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却 没有持久化下来，这就出现问题了，没有保证事务的持久性。</p><p><img src="/mysql-02/image-20230320130234652.png" alt="image-20230320130234652"></p><p>如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，</p><p><img src="/mysql-02/image-20230320130303560.png" alt="image-20230320130303560"></p><p>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。 过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据 恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此 时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。</p><p>为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新 到磁盘呢 ? 因为在业务操作中，操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这 种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p><h3 id="6-3-3-undo-log"><a href="#6-3-3-undo-log" class="headerlink" title="6.3.3 undo log"></a>6.3.3 undo log</h3><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和 MVCC(多版本并发控制) 。 undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的 update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些 日志可能还用于MVCC。</p><p>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment。</p><h3 id="6-4-MVCC"><a href="#6-4-MVCC" class="headerlink" title="6.4 MVCC"></a>6.4 MVCC</h3><h4 id="6-4-1-基本概念"><a href="#6-4-1-基本概念" class="headerlink" title="6.4.1 基本概念"></a>6.4.1 基本概念</h4><p>1). 当前读</p><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加 锁。对于我们日常的操作，如：select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读。</p><p>测试：</p><p><img src="/mysql-02/image-20230320132044636.png" alt="image-20230320132044636"></p><p>在测试中可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内 容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。</p><p>2). 快照读</p><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据， 不加锁，是非阻塞读。</p><ul><li><p>Read Committed：每次select，都生成一个快照读。</p></li><li><p>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</p></li><li><p>Serializable：快照读会退化为当前读。</p></li></ul><p><img src="/mysql-02/image-20230320132658484.png" alt="image-20230320132658484"></p><p>看到即使事务B提交了数据,事务A中也查询不到。 原因就是因为普通的select是快照 读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同 的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。</p><p>3). MVCC</p><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本， 使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需 要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><h4 id="6-4-2-隐藏字段"><a href="#6-4-2-隐藏字段" class="headerlink" title="6.4.2 隐藏字段"></a>6.4.2 隐藏字段</h4><h5 id="6-4-2-1-介绍"><a href="#6-4-2-1-介绍" class="headerlink" title="6.4.2.1 介绍"></a>6.4.2.1 介绍</h5><p><img src="/mysql-02/image-20230320132925148.png" alt="image-20230320132925148"></p><p>际上除了 这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p><table><thead><tr><th>隐藏字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</td></tr><tr><td>DB_ROLL_PTR</td><td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版 本。</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td></tr></tbody></table><h4 id="6-4-3-undolog"><a href="#6-4-3-undolog" class="headerlink" title="6.4.3 undolog"></a>6.4.3 undolog</h4><h5 id="6-4-3-1-介绍"><a href="#6-4-3-1-介绍" class="headerlink" title="6.4.3.1 介绍"></a>6.4.3.1 介绍</h5><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。 </p><p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即 被删除。</p><h5 id="6-4-3-2-版本链"><a href="#6-4-3-2-版本链" class="headerlink" title="6.4.3.2 版本链"></a>6.4.3.2 版本链</h5><p>有一张表原始数据为：</p><p><img src="/mysql-02/image-20230320133520301.png" alt="image-20230320133520301"></p><p>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是 自增的。 DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</p><p>然后，有四个并发事务同时在访问这张表。</p><p>A. 第一步</p><p><img src="/mysql-02/image-20230320133629860.png" alt="image-20230320133629860"></p><p>当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录， 并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/mysql-02/image-20230320133646700.png" alt="image-20230320133646700"></p><p>B.第二步</p><p><img src="/mysql-02/image-20230320133743966.png" alt="image-20230320133743966"></p><p>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记 录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/mysql-02/image-20230320133920671.png" alt="image-20230320133920671"></p><p>C. 第三步</p><p><img src="/mysql-02/image-20230320133931367.png" alt="image-20230320133931367"></p><p>当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记 录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/mysql-02/image-20230320133949503.png" alt="image-20230320133949503"></p><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条 记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><h4 id="6-4-4-readview"><a href="#6-4-4-readview" class="headerlink" title="6.4.4 readview"></a>6.4.4 readview</h4><p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务 （未提交的）id。</p><p>ReadView中包含了四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务ID集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务ID</td></tr><tr><td>max_trx_id</td><td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td></tr><tr><td>creator_trx_id</td><td>ReadView创建者的事务ID</td></tr></tbody></table><p>而在readview中就规定了版本链数据的访问规则：</p><p>trx_id 代表当前undolog版本链对应事务ID。</p><table><thead><tr><th>条件</th><th>是否可以访问</th><th>说明</th></tr></thead><tbody><tr><td>trx_id == creator_trx_id</td><td>可以访问该版本</td><td>成立，说明数据是当前这个事 务更改的。</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>可以访问该版本</td><td>成立，说明数据已经提交了。</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>不可以访问该版本</td><td>成立，说明该事务是在 ReadView生成后才开启。</td></tr><tr><td>min_trx_id &lt;= trx_id &lt;= max_trx_id</td><td>如果trx_id不在m_ids中， 是可以访问该版本的</td><td>成立，说明数据已经提交。</td></tr></tbody></table><p>不同的隔离级别，生成ReadView的时机不同：</p><ul><li><p>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。 </p></li><li><p>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</p></li></ul><h4 id="6-4-5-原理分析"><a href="#6-4-5-原理分析" class="headerlink" title="6.4.5 原理分析"></a>6.4.5 原理分析</h4><h5 id="6-4-5-1-RC隔离级别"><a href="#6-4-5-1-RC隔离级别" class="headerlink" title="6.4.5.1 RC隔离级别"></a>6.4.5.1 RC隔离级别</h5><p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView.</p><p>在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读 都会生成一个ReadView，那么两次生成的ReadView如下。</p><p><img src="/mysql-02/image-20230320135113643.png" alt="image-20230320135113643"></p><p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则， 到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p><p>A. 先来看第一次快照读具体的读取过程：</p><p><img src="/mysql-02/image-20230320135113643.png" alt="image-20230320135113643"></p><p><img src="/mysql-02/image-20230320135211340.png" alt="image-20230320135211340"></p><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><p>先匹配<img src="/mysql-02/image-20230320135227208.png" alt="image-20230320135227208"></p><p>这条记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</p><p>再匹配第二条<img src="/mysql-02/image-20230320135247714.png" alt="image-20230320135247714"></p><p>这条 记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也 不满足 ，都不满足，则继续匹配undo log版本链的下一条</p><p>再匹配第三条<img src="/mysql-02/image-20230320135302226.png" alt="image-20230320135302226"></p><p>这条记 录对应的trx_id为2，也就是将2带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照 读，返回的数据就是版本链中记录的这条数据。</p><p>B. 再来看第二次快照读具体的读取过程:</p><p><img src="/mysql-02/image-20230320135452732.png" alt="image-20230320135452732"></p><p><img src="/mysql-02/image-20230320135458225.png" alt="image-20230320135458225"></p><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><p>先匹配<img src="/mysql-02/image-20230320135516089.png" alt="image-20230320135516089"></p><p>这条记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</p><p>再匹配第二条<img src="/mysql-02/image-20230320135536540.png" alt="image-20230320135536540"></p><p>这条 记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次 快照读，返回的数据就是版本链中记录的这条数据。</p><h5 id="6-4-5-3-RR隔离级别"><a href="#6-4-5-3-RR隔离级别" class="headerlink" title="6.4.5.3 RR隔离级别"></a>6.4.5.3 RR隔离级别</h5><p>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可 重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p><p><img src="/mysql-02/image-20230320135625996.png" alt="image-20230320135625996"></p><p>在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该 ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返 回的结果也是一样的。 所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。 而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p><p><img src="/mysql-02/image-20230320135646957.png" alt="image-20230320135646957"></p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-01</title>
      <link href="/mysql-01.html"/>
      <url>/mysql-01.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-MySQL概述"><a href="#1-MySQL概述" class="headerlink" title="1.MySQL概述"></a>1.MySQL概述</h1><h2 id="1-1-数据库相关概念"><a href="#1-1-数据库相关概念" class="headerlink" title="1.1 数据库相关概念"></a>1.1 数据库相关概念</h2><table><thead><tr><th>名称</th><th>全称</th><th>简称</th></tr></thead><tbody><tr><td>数据库</td><td>存储数据的仓库，数据是有组织的进行存储</td><td>DataBase（DB）</td></tr><tr><td>数据库管理系统</td><td>操纵和管理数据库的大型软件</td><td>DataBase Management System (DBMS)</td></tr><tr><td>SQL</td><td>操作关系型数据库的编程语言，定义了一套操作 关系型数据库统一标准</td><td>Structured Query Language (SQL)</td></tr></tbody></table><h3 id="1-1-1mysql数据库连接"><a href="#1-1-1mysql数据库连接" class="headerlink" title="1.1.1mysql数据库连接"></a>1.1.1mysql数据库连接</h3><ol><li>使用MySQL提供的客户端命令行工具</li><li>使用系统自带的命令行工具执行指令</li></ol><pre><code>mysql [-h 127.0.0.1] [-P 3306] -u root -p参数：-h : MySQL服务所在的主机IP-P : MySQL服务端口号， 默认3306-u : MySQL数据库用户名-p ： MySQL数据库用户名对应的密码</code></pre><p>[]内为可选参数，如果需要连接远程的MySQL，需要加上这两个参数来指定远程主机IP、端口，如果 连接本地的MySQL，则无需指定这两个参数。</p><h3 id="1-1-2-数据模型"><a href="#1-1-2-数据模型" class="headerlink" title="1.1.2 数据模型"></a>1.1.2 数据模型</h3><p>1). 关系型数据库（RDBMS） 概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。 而所谓二维表，指的是由行和列组成的表，如下图（就类似于Excel表格数据，有表头、有列、有行， 还可以通过一列关联另外一个表格中的某一列数据）。MySQL、Oracle、DB2、 SQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。简单说，基于二维表存储 数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库。</p><p><img src="/mysql-01/image-20230317200345320.png" alt="image-20230317200345320"></p><p>特点： A. 使用表存储数据，格式统一，便于维护。 </p><p>​            B. 使用SQL语言操作，标准统一，使用方便。</p><p>2). 数据模型 MySQL是关系型数据库，是基于二维表进行数据存储的，具体的结构图下:</p><p><img src="/mysql-01/image-20230317200415240.png" alt="image-20230317200415240"></p><p>可以通过MySQL客户端连接数据库管理系统DBMS，然后通过DBMS操作数据库。 </p><p>可以使用SQL语句，通过数据库管理系统操作数据库，以及操作数据库中的表结构及数据。 一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包 含多行记录。</p><h1 id="2-SQL"><a href="#2-SQL" class="headerlink" title="2.SQL"></a>2.SQL</h1><p>全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了 一套操作关系型数据库统一标准 。</p><h2 id="2-1-SQL通用语法"><a href="#2-1-SQL通用语法" class="headerlink" title="2.1 SQL通用语法"></a>2.1 SQL通用语法</h2><ol><li>SQL语句可以单行或多行书写，以分号结尾。</li><li>SQL语句可以使用空格/缩进来增强语句的可读性。</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</li><li>注释： 单行注释：– 注释内容 或 # 注释内容 多行注释：/* 注释内容 */</li></ol><h2 id="2-2-sql分类"><a href="#2-2-sql分类" class="headerlink" title="2.2 sql分类"></a>2.2 sql分类</h2><p>SQL语句，根据其功能，主要分为四类：DDL、DML、DQL、DCL。</p><table><thead><tr><th>分类</th><th>全称</th><th>说明</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>数据定义语言，用来定义数据库对象(数据库，表， 字段)</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>数据操作语言，用来对数据库表中的数据进行增删改</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据查询语言，用来查询数据库中表的记录</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>数据控制语言，用来创建数据库用户、控制数据库的 访问权限</td></tr></tbody></table><h2 id="2-3-DDL"><a href="#2-3-DDL" class="headerlink" title="2.3 DDL"></a>2.3 DDL</h2><p>Data Definition Language，数据定义语言，用来定义数据库对象(数据库，表，字段) 。</p><h3 id="2-3-1-数据库操作"><a href="#2-3-1-数据库操作" class="headerlink" title="2.3.1 数据库操作"></a>2.3.1 数据库操作</h3><p>1). 查询所有数据库</p><pre><code>show databases ;</code></pre><p>2). 查询当前数据库</p><pre><code>select database() ;</code></pre><p>3). 创建数据库</p><pre><code>create database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ;</code></pre><p>在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。</p><p>可以通过if not exists 参数来解决这个问题，数据库不存在, 则创建该数据库，如果存在，则不 创建。</p><pre><code>create database if not extists itcast;</code></pre><p>B. 创建一个itheima数据库，并且指定字符集</p><pre><code>create database 数据库名称 default charset utf8mb4;</code></pre><p>4). 删除数据库</p><pre><code> drop database [ if exists ] 数据库名 ;</code></pre><p>如果删除一个不存在的数据库，将会报错。此时，可以加上参数 if exists ，如果数据库存在，再 执行删除，否则不执行删除。</p><p>5). 切换数据库</p><pre><code>use 数据库名 ;</code></pre><p>要操作某一个数据库下的表时，就需要通过该指令，切换到对应的数据库下，否则是不能操作的。</p><h3 id="2-3-2-表操作"><a href="#2-3-2-表操作" class="headerlink" title="2.3.2 表操作"></a>2.3.2 表操作</h3><h4 id="2-3-2-1-表操作-查询创建"><a href="#2-3-2-1-表操作-查询创建" class="headerlink" title="2.3.2.1 表操作-查询创建"></a>2.3.2.1 表操作-查询创建</h4><p>1). 查询当前数据库所有表</p><pre><code>show tables;</code></pre><p>2). 查看指定表结构</p><pre><code>desc 表名 ;</code></pre><p>3). 查询指定表的建表语句</p><pre><code>show create table 表名 ;</code></pre><p>4). 创建表结构</p><pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE 表名(字段1 字段1类型 [ COMMENT 字段1注释 ],字段2 字段2类型 [COMMENT 字段2注释 ],字段3 字段3类型 [COMMENT 字段3注释 ],......字段n 字段n类型 [COMMENT 字段n注释 ]) [ COMMENT 表注释 ] ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意: […] 内为可选参数，最后一个字段后面没有逗号</p><p>比如，创建一张表 tb_user ，对应的结构如下，那么建表语句为：</p><p><img src="/mysql-01/image-20230318122920257.png" alt="image-20230318122920257"></p><pre class="line-numbers language-mysql"><code class="language-mysql">create table tb_user(id int comment '编号',name varchar(50) comment '姓名',age int comment '年龄',gender varchar(1) comment '性别') comment '用户表';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-2-2-表操作-数据类型"><a href="#2-3-2-2-表操作-数据类型" class="headerlink" title="2.3.2.2 表操作-数据类型"></a>2.3.2.2 表操作-数据类型</h4><p> MySQL中的数据类型有很多，主要分为三类：数值类型、字符串类型、日期时间类型。</p><p>1). 数值类型</p><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">范围（有符号）</th><th align="left">范围（无符号）</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1 Bytes</td><td align="left">(-128，127)</td><td align="left">(0，255)</td><td align="left">小整数值</td></tr><tr><td align="left">SMALLINT</td><td align="left">2 Bytes</td><td align="left">(-32 768，32 767)</td><td align="left">(0，65 535)</td><td align="left">大整数值</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3 Bytes</td><td align="left">(-8 388 608，8 388 607)</td><td align="left">(0，16 777 215)</td><td align="left">大整数值</td></tr><tr><td align="left">INT或INTEGER</td><td align="left">4 Bytes</td><td align="left">(-2 147 483 648，2 147 483 647)</td><td align="left">(0，4 294 967 295)</td><td align="left">大整数值</td></tr><tr><td align="left">BIGINT</td><td align="left">8 Bytes</td><td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td align="left">(0，18 446 744 073 709 551 615)</td><td align="left">极大整数值</td></tr><tr><td align="left">FLOAT</td><td align="left">4 Bytes</td><td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="left">单精度 浮点数值</td></tr><tr><td align="left">DOUBLE</td><td align="left">8 Bytes</td><td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">双精度 浮点数值</td></tr><tr><td align="left">DECIMAL</td><td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="left">依赖于M和D的值</td><td align="left">依赖于M和D的值</td><td align="left">小数值</td></tr></tbody></table><pre><code>如:1). 年龄字段 -- 不会出现负数, 而且人的年龄不会太大age tinyint unsigned2). 分数 -- 总分100分, 最多出现一位小数score double(4,1)</code></pre><p>2). 字符串类型</p><table><thead><tr><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 bytes</td><td>定长字符串(需要指定长度)</td></tr><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串(需要指定长度)</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过255个字符的二进制数据</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table><p>char 与 varchar 都可以描述字符串，char是定长字符串，指定长度多长，就占用多少个字符，和 字段值的长度无关 。而varchar是变长字符串，指定的长度为最大占用长度 。相对来说，char的性 能会更高些。</p><pre><code>如：1). 用户名 username ------&gt; 长度不定, 最长不会超过50username varchar(50)2). 性别 gender ---------&gt; 存储值, 不是男,就是女gender char(1)3). 手机号 phone --------&gt; 固定长度为11phone char(11)</code></pre><p>3). 日期时间类型</p><table><thead><tr><th align="left">类型</th><th align="left">大小 ( bytes)</th><th align="left">范围</th><th align="left">格式</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01/9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="left">日期值</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’/‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="left">时间值或持续时间</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901/2155</td><td align="left">YYYY</td><td align="left">年份值</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="left">混合日期和时间值</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="left">YYYY-MM-DD hh:mm:ss</td><td align="left">混合日期和时间值，时间戳</td></tr></tbody></table><pre><code>1). 生日字段 birthdaybirthday date2). 创建时间 createtimecreatetime datetime</code></pre><p>2.3.2.3 表操作-案例 设计一张员工信息表，要求如下：</p><ol><li>编号（纯数字） </li><li>员工工号 (字符串类型，长度不超过10位) </li><li>员工姓名（字符串类型，长度不超过10位）</li><li>性别（男/女，存储一个汉字） </li><li>年龄（正常人年龄，不可能存储负数）</li><li>身份证号（二代身份证号均为18位，身份证中有X这样的字符） </li><li>入职时间（取值年月日即可）</li></ol><pre><code>create table emp(    id int comment &quot;编号&quot;,    workno varchar(10) comment&#39;工号&#39;,    name varchar(10) comment&#39;姓名&#39;,    gender char(1) comment &#39;性别&#39;,    age tinyint unsigned comment &#39;年龄&#39;,    idcard char(10) comment &#39;身份证号&#39;,    entrydate date comment &#39;入职时间&#39;)comment &#39;员工表&#39;,</code></pre><h4 id="2-3-2-4-表操作-修改"><a href="#2-3-2-4-表操作-修改" class="headerlink" title="2.3.2.4 表操作-修改"></a>2.3.2.4 表操作-修改</h4><p>1). 添加字段</p><pre><code>ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</code></pre><p>案例:</p><p>为emp表增加一个新的字段”昵称”为nickname，类型为varchar(20)</p><pre><code>ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;</code></pre><p>2). 修改数据类型</p><pre><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型（长度);</code></pre><p>3). 修改字段名和字段类型</p><pre><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];</code></pre><p>案例: 将emp表的nickname字段修改为username，类型为varchar(30)</p><pre><code>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;</code></pre><p>4). 删除字段</p><pre><code>ALTER TABLE 表名 DROP 字段名</code></pre><p>案例: </p><p>将emp表的字段username删除</p><pre><code>ALTER TABLE emp DROP username</code></pre><p>5). 修改表名</p><pre><code>ALTER TABLE 表名 RENAME TO 新表名;</code></pre><p>案例: </p><p>将emp表的表名修改为 employee</p><pre><code> ALTER TABLE emp RENAME TO employee;</code></pre><h4 id="2-3-2-5-表操作-删除"><a href="#2-3-2-5-表操作-删除" class="headerlink" title="2.3.2.5 表操作-删除"></a>2.3.2.5 表操作-删除</h4><pre><code>DROP TABLE [ IF EXISTS ] 表名;</code></pre><p>可选项 IF EXISTS 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不 加该参数项，删除一张不存在的表，执行将会报错)。 案例: 如果tb_user表存在，则删除tb_user表</p><pre><code>DROP TABLE IF EXISTS tb_user;</code></pre><p>2). 删除指定表, 并重新创建表</p><pre><code>TRUNCATE TABLE 表名</code></pre><p>注意: 在删除表的时候，表中的全部数据也都会被删除。</p><h2 id="2-4-图形化界面工具"><a href="#2-4-图形化界面工具" class="headerlink" title="2.4 图形化界面工具"></a>2.4 图形化界面工具</h2><p><img src="/mysql-01/image-20230318143403192.png" alt="image-20230318143403192"></p><p>个人感觉DataGrip好用</p><h2 id="2-5-DML"><a href="#2-5-DML" class="headerlink" title="2.5 DML"></a>2.5 DML</h2><p>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进 行增、删、改操作。</p><ul><li>添加数据（INSERT）</li><li>修改数据（UPDATE） </li><li>删除数据（DELETE）</li></ul><h3 id="2-5-1-添加数据"><a href="#2-5-1-添加数据" class="headerlink" title="2.5.1 添加数据"></a>2.5.1 添加数据</h3><p> 1). 给指定字段添加数据</p><pre><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code></pre><p>给employee表所有的字段添加数据 ；</p><pre><code>insert into employee(id,workno,name,gender,age,idcard,entrydate)values(1,&#39;1&#39;,&#39;Itcast&#39;,&#39;男&#39;,10,&#39;123456789012345678&#39;,&#39;2000-01-01&#39;);</code></pre><p>2). 给全部字段添加数据</p><pre><code>INSERT INTO 表名 VALUES (值1, 值2, ...);</code></pre><p>插入数据到employee表，具体的SQL如下：</p><pre><code>insert into employee values(2,&#39;2&#39;,&#39;张无忌&#39;,&#39;男&#39;,18,&#39;123456789012345670&#39;,&#39;2005-01-01&#39;);</code></pre><p>3). 批量添加数据</p><pre><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;</code></pre><pre><code>INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...) ;</code></pre><p>注意事项: </p><ul><li>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。</li><li>字符串和日期型数据应该包含在引号中。 </li><li>插入的数据大小，应该在字段的规定范围内。</li></ul><h3 id="2-5-2-修改数据"><a href="#2-5-2-修改数据" class="headerlink" title="2.5.2 修改数据"></a>2.5.2 修改数据</h3><p>修改数据的具体语法为:</p><pre><code>UPDATE 表名 SET 字段名1 = 值1 , 字段名2 = 值2 , .... [ WHERE 条件 ] ;</code></pre><p>案例:</p><p>A. 修改id为1的数据，将name修改为nametest</p><pre><code>update employee set name = &#39;nametest&#39; where id = 1;</code></pre><p>B. 修改id为1的数据, 将name修改为小昭, gender修改为 女</p><pre><code>update employee set name = &#39;小昭&#39; , gender = &#39;女&#39; where id = 1;</code></pre><p>C. 将所有的员工入职日期修改为 2008-01-01</p><pre><code> update employee set entrydate = &#39;2008-01-01&#39;;</code></pre><p>注意事项: 修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。</p><h3 id="2-5-3-删除数据"><a href="#2-5-3-删除数据" class="headerlink" title="2.5.3 删除数据"></a>2.5.3 删除数据</h3><p>删除数据的具体语法为：</p><pre><code> DELETE FROM 表名 [ WHERE 条件 ] ;</code></pre><p>案例: A. 删除gender为女的员工</p><pre><code> delete from employee where gender = &#39;女&#39;;</code></pre><p>B. 删除所有员工</p><pre><code>delete from employee</code></pre><p>注意事项:</p><ul><li>DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数 据。</li><li>DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即 可)。 </li><li>当进行删除全部数据操作时，datagrip会提示，询问是否确认删除，直接点击 Execute即可。</li></ul><h2 id="2-6-DQL"><a href="#2-6-DQL" class="headerlink" title="2.6 DQL"></a>2.6 DQL</h2><p>DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记 录。</p><p>查询关键字: SELECT</p><p>数据准备</p><pre><code>drop table if exists employee;create table emp(id int comment &#39;编号&#39;,workno varchar(10) comment &#39;工号&#39;,name varchar(10) comment &#39;姓名&#39;,gender char(1) comment &#39;性别&#39;,age tinyint unsigned comment &#39;年龄&#39;,idcard char(18) comment &#39;身份证号&#39;,workaddress varchar(50) comment &#39;工作地址&#39;,entrydate date comment &#39;入职时间&#39;)comment &#39;员工表&#39;;INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (1, &#39;00001&#39;, &#39;柳岩666&#39;, &#39;女&#39;, 20, &#39;123456789012345678&#39;, &#39;北京&#39;, &#39;2000-01-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (2, &#39;00002&#39;, &#39;张无忌&#39;, &#39;男&#39;, 18, &#39;123456789012345670&#39;, &#39;北京&#39;, &#39;2005-09-01&#39;)INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (3, &#39;00003&#39;, &#39;韦一笑&#39;, &#39;男&#39;, 38, &#39;123456789712345670&#39;, &#39;上海&#39;, &#39;2005-08-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (4, &#39;00004&#39;, &#39;赵敏&#39;, &#39;女&#39;, 18, &#39;123456757123845670&#39;, &#39;北京&#39;, &#39;2009-12-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (5, &#39;00005&#39;, &#39;小昭&#39;, &#39;女&#39;, 16, &#39;123456769012345678&#39;, &#39;上海&#39;, &#39;2007-07-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (6, &#39;00006&#39;, &#39;杨逍&#39;, &#39;男&#39;, 28, &#39;12345678931234567X&#39;, &#39;北京&#39;, &#39;2006-01-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (7, &#39;00007&#39;, &#39;范瑶&#39;, &#39;男&#39;, 40, &#39;123456789212345670&#39;, &#39;北京&#39;, &#39;2005-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (8, &#39;00008&#39;, &#39;黛绮丝&#39;, &#39;女&#39;, 38, &#39;123456157123645670&#39;, &#39;天津&#39;, &#39;2015-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (9, &#39;00009&#39;, &#39;范凉凉&#39;, &#39;女&#39;, 45, &#39;123156789012345678&#39;, &#39;北京&#39;, &#39;2010-04-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (10, &#39;00010&#39;, &#39;陈友谅&#39;, &#39;男&#39;, 53, &#39;123456789012345670&#39;, &#39;上海&#39;, &#39;2011-01-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (11, &#39;00011&#39;, &#39;张士诚&#39;, &#39;男&#39;, 55, &#39;123567897123465670&#39;, &#39;江苏&#39;, &#39;2015-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (12, &#39;00012&#39;, &#39;常遇春&#39;, &#39;男&#39;, 32, &#39;123446757152345670&#39;, &#39;北京&#39;, &#39;2004-02-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (13, &#39;00013&#39;, &#39;张三丰&#39;, &#39;男&#39;, 88, &#39;123656789012345678&#39;, &#39;江苏&#39;, &#39;2020-11-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (14, &#39;00014&#39;, &#39;灭绝&#39;, &#39;女&#39;, 65, &#39;123456719012345670&#39;, &#39;西安&#39;, &#39;2019-05-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (15, &#39;00015&#39;, &#39;胡青牛&#39;, &#39;男&#39;, 70, &#39;12345674971234567X&#39;, &#39;西安&#39;, &#39;2018-04-01&#39;);INSERT INTO emp (id, workno, name, gender, age, idcard, workaddress, entrydate)VALUES (16, &#39;00016&#39;, &#39;周芷若&#39;, &#39;女&#39;, 18, null, &#39;北京&#39;, &#39;2012-06-01&#39;);</code></pre><h3 id="2-6-1-基本语法"><a href="#2-6-1-基本语法" class="headerlink" title="2.6.1 基本语法"></a>2.6.1 基本语法</h3><p>DQL 查询语句，语法结构如下：</p><pre><code>SELECT    字段列表FROM    表名列表WHERE    条件列表GROUP BY    分组字段列表HAVING    分组后条件列表ORDER BY    排序字段列表LIMIT    分页参数</code></pre><h3 id="2-6-2-基础查询"><a href="#2-6-2-基础查询" class="headerlink" title="2.6.2 基础查询"></a>2.6.2 基础查询</h3><p>1). 查询多个字段</p><pre><code>SELECT 字段1, 字段2, 字段3 ... FROM 表名 ;</code></pre><pre><code>SELECT * FROM 表名 ；</code></pre><p>注意 : * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。</p><p>2). 字段设置别名</p><pre><code> SELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] ... FROM 表名;</code></pre><pre><code> SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] ... FROM 表名;</code></pre><p>3). 去除重复记录</p><pre><code>SELECT DISTINCT 字段列表 FROM 表名;</code></pre><h3 id="2-6-3-条件查询"><a href="#2-6-3-条件查询" class="headerlink" title="2.6.3 条件查询"></a>2.6.3 条件查询</h3><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 WHERE 条件列表 ;</code></pre><p>2). 条件</p><table><thead><tr><th align="left">操作符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">等号，检测两个值是否相等，如果相等返回true</td><td align="left">(A = B) 返回false。</td></tr><tr><td align="left">&lt;&gt;, !=</td><td align="left">不等于，检测两个值是否相等，如果不相等返回true</td><td align="left">(A != B) 返回 true。</td></tr><tr><td align="left">&gt;</td><td align="left">大于号，检测左边的值是否大于右边的值, 如果左边的值大于右边的值返回true</td><td align="left">(A &gt; B) 返回false。</td></tr><tr><td align="left">&lt;</td><td align="left">小于号，检测左边的值是否小于右边的值, 如果左边的值小于右边的值返回true</td><td align="left">(A &lt; B) 返回 true。</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于号，检测左边的值是否大于或等于右边的值, 如果左边的值大于或等于右边的值返回true</td><td align="left">(A &gt;= B) 返回false。</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于号，检测左边的值是否小于或等于右边的值, 如果左边的值小于或等于右边的值返回true</td><td align="left">(A &lt;= B) 返回 true。</td></tr><tr><td align="left">BETWEEN … AND …</td><td align="left">在某个范围之内(含最小、最大值)</td><td align="left">(between15 and 20) 返回15到20之间</td></tr><tr><td align="left">IN(…)</td><td align="left">在in之后的列表中的值，多选一</td><td align="left">[in(18,80,40) ] 返回18，20，40</td></tr><tr><td align="left">LIKE 占位符</td><td align="left">模糊匹配(_匹配单个字符, %匹配任意个字符)</td><td align="left"></td></tr><tr><td align="left">IS NULL</td><td align="left">是NULL</td><td align="left"></td></tr></tbody></table><h3 id="2-6-4-聚合函数"><a href="#2-6-4-聚合函数" class="headerlink" title="2.6.4 聚合函数"></a>2.6.4 聚合函数</h3><p>1). 介绍</p><p>将一列数据作为一个整体，进行纵向计算 。</p><p>2). 常见的聚合函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p>3). 语法</p><pre><code> SELECT 聚合函数(字段列表) FROM 表名 ;</code></pre><p>注意 : NULL值是不参与所有聚合函数运算的。</p><p>案例：</p><p>A. 统计该企业员工数量</p><pre><code>select count(*) from emp; -- 统计的是总记录数select count(idcard) from emp; -- 统计的是idcard字段不为null的记录数</code></pre><p>对于count聚合函数，统计符合条件的总记录数，还可以通过 count(数字/字符串)的形式进行统计 查询，比如：</p><pre><code> select count(1) from emp;</code></pre><h3 id="2-6-5-分组查询"><a href="#2-6-5-分组查询" class="headerlink" title="2.6.5 分组查询"></a>2.6.5 分组查询</h3><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后过滤条件 ];</code></pre><p>2). where与having区别 执行时机不同：</p><ul><li>where是分组之前进行过滤，不满足where条件，不参与分组；</li><li>而having是分组 之后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><p>案例:</p><p>A. 根据性别分组 , 统计男性员工 和 女性员工的数量</p><pre><code>select gender, count(*) from emp group by gender ;</code></pre><p>B. 根据性别分组 , 统计男性员工 和 女性员工的平均年龄</p><pre><code> select gender, avg(age) from emp group by gender ;</code></pre><p>C. 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址</p><pre><code>select workaddress, count(*) address_count from emp where age &lt; 45 group byworkaddress having address_count &gt;= 3;</code></pre><p>D. 统计各个工作地址上班的男性及女性员工的数量</p><pre><code>select workaddress, gender, count(*) &#39;数量&#39; from emp group by gender , workaddress;</code></pre><h3 id="2-6-6-排序查询"><a href="#2-6-6-排序查询" class="headerlink" title="2.6.6 排序查询"></a>2.6.6 排序查询</h3><p>排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序</p><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ;</code></pre><p>2). 排序方式</p><ul><li>ASC : 升序(默认值) </li><li>DESC: 降序</li></ul><p>注意事项：</p><ul><li>如果是升序, 可以不指定排序方式ASC ; </li><li>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;</li></ul><h3 id="2-6-7-分页查询"><a href="#2-6-7-分页查询" class="headerlink" title="2.6.7 分页查询"></a>2.6.7 分页查询</h3><p>1). 语法</p><pre><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;</code></pre><p>注意事项: </p><p>起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数。 </p><p>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。 </p><p>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</p><p>案例: </p><p>A. 查询第1页员工数据, 每页展示10条记录</p><pre><code>select * from emp limit 0,10;select * from emp limit 10;</code></pre><p>B. 查询第2页员工数据, 每页展示10条记录 ——–&gt; (页码-1)*页展示记录数</p><pre><code> select * from emp limit 10,10;</code></pre><h3 id="2-6-9-执行顺序"><a href="#2-6-9-执行顺序" class="headerlink" title="2.6.9 执行顺序"></a>2.6.9 执行顺序</h3><p><img src="/mysql-01/image-20230318153026758.png" alt="image-20230318153026758"></p><p>执行顺序为</p><p>from … where … group by … having … select … order by … limit …</p><h2 id="2-7-DCL"><a href="#2-7-DCL" class="headerlink" title="2.7 DCL"></a>2.7 DCL</h2><p>DCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访 问权限。</p><h3 id="2-7-1-管理用户"><a href="#2-7-1-管理用户" class="headerlink" title="2.7.1 管理用户"></a>2.7.1 管理用户</h3><p>1). 查询用户</p><pre><code>select * from mysql.user;</code></pre><p><img src="/mysql-01/image-20230318153333941.png" alt="image-20230318153333941"></p><p>其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以 远程访问的。 User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一 个用户。</p><p>2). 创建用户</p><pre><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></pre><p>3). 修改用户密码</p><pre><code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39; ;</code></pre><p>4). 删除用户</p><pre><code>DROP USER &#39;用户名&#39;@&#39;主机名&#39; ;</code></pre><p>注意事项:</p><ul><li>在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。</li><li>主机名可以使用 % 通配。 </li></ul><h3 id="2-7-2-权限控制"><a href="#2-7-2-权限控制" class="headerlink" title="2.7.2 权限控制"></a>2.7.2 权限控制</h3><p>Mysql中常用的的权限</p><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL, ALL PRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库/表/视图</td></tr><tr><td>CREATE</td><td>创建数据库/表</td></tr></tbody></table><p><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" target="_blank" rel="noopener">MySQL :: MySQL 8.0 Reference Manual :: 6.2.2 Privileges Provided by MySQL</a></p><p>1). 查询权限</p><pre><code> SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39; ;</code></pre><p>2). 授予权限</p><pre><code> GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>3). 撤销权限</p><pre><code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>注意事项： • 多个权限之间，使用逗号分隔 • 授权时， 数据库名和表名可以使用 * 进行通配，代表所有。</p><h1 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h1><p>函数 是指一段可以直接被另一段程序调用的程序或代码。 也就意味着，这一段程序或代码在MySQL中 已经给我们提供了，我们要做的就是在合适的业务场景调用对应的函数完成对应的业务需求即可</p><p>MySQL中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数。</p><h2 id="3-1-字符串函数"><a href="#3-1-字符串函数" class="headerlink" title="3.1 字符串函数"></a>3.1 字符串函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(S1,S2,…Sn)</td><td>字符串拼接，将S1，S2，… Sn拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串str全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串str全部转为大写</td></tr><tr><td>LPAD(str,n,pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符 串长度</td></tr><tr><td>RPAD(str,n,pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符 串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str,start,len)</td><td>返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><p>lpad : 左填充</p><pre><code>select lpad(&#39;01&#39;, 5, &#39;-&#39;);</code></pre><p>trim : 去除空格</p><pre><code>select trim(&#39; Hello MySQL &#39;)</code></pre><p>substring : 截取子字符串</p><pre><code> select substring(&#39;Hello MySQL&#39;,1,5);</code></pre><h2 id="3-2-数值函数"><a href="#3-2-数值函数" class="headerlink" title="3.2 数值函数"></a>3.2 数值函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x,y)</td><td>返回x/y的模</td></tr><tr><td>RAND()</td><td>返回0~1内的随机数</td></tr><tr><td>ROUND(x,y)</td><td>求参数x的四舍五入的值，保留y位小数</td></tr></tbody></table><h2 id="3-3-日期函数"><a href="#3-3-日期函数" class="headerlink" title="3.3 日期函数"></a>3.3 日期函数</h2><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定date的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定date的月份</td></tr><tr><td>DAY(date)</td><td>获取指定date的日期</td></tr><tr><td>DATE_ADD(date, INTERVAL expr type)</td><td>返回一个日期/时间值加上一个时间间隔expr后的 时间值</td></tr><tr><td>DATEDIFF(date1,date2)</td><td>返回起始时间date1 和 结束时间date2之间的天 数</td></tr></tbody></table><h2 id="3-4-流程函数"><a href="#3-4-流程函数" class="headerlink" title="3.4 流程函数"></a>3.4 流程函数</h2><p>流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value , t , f)</td><td>如果value为true，则返回t，否则返回 f</td></tr><tr><td>IFNULL(value1 , value2)</td><td>如果value1不为空，返回value1，否则 返回value2</td></tr><tr><td>CASE WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td><td>如果val1为true，返回res1，… 否 则返回default默认值</td></tr><tr><td>CASE [ expr ] WHEN [ val1 ] THEN [res1] … ELSE [ default ] END</td><td>如果expr的值等于val1，返回 res1，… 否则返回default默认值</td></tr></tbody></table><p>需求: 查询emp表的员工姓名和工作地址 (北京/上海 —-&gt; 一线城市 , 其他 —-&gt; 二线城市)</p><pre><code>selectname,( case workaddress when &#39;北京&#39; then &#39;一线城市&#39; when &#39;上海&#39; then &#39;一线城市&#39; else&#39;二线城市&#39; end ) as &#39;工作地址&#39;from emp;</code></pre><h1 id="4-约束"><a href="#4-约束" class="headerlink" title="4.约束"></a>4.约束</h1><p>概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。</p><p> 目的：保证数据库中数据的正确、有效性和完整性。</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束(8.0.16版本 之后)</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张表的数据之间建立连接，保证数据的一致 性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><p>注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。</p><h2 id="4-3-外键约束"><a href="#4-3-外键约束" class="headerlink" title="4.3 外键约束"></a>4.3 外键约束</h2><p>外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</p><p><img src="/mysql-01/image-20230318161258249.png" alt="image-20230318161258249"></p><p>左侧的emp表是员工表，里面存储员工的基本信息，包含员工的ID、姓名、年龄、职位、薪资、入职日 期、上级主管ID、部门ID，在员工的信息中存储的是部门的ID dept_id，而这个部门的ID是关联的 部门表dept的主键id，那emp表的dept_id就是外键,关联的是另一张表的主键。</p><p>注意：目前上述两张表，只是在逻辑上存在这样一层关系；在数据库层面，并未建立外键关联， 所以是无法保证数据的一致性和完整性的。</p><h3 id="4-3-2-语法"><a href="#4-3-2-语法" class="headerlink" title="4.3.2 语法"></a>4.3.2 语法</h3><p>1). 添加外键</p><pre><code>CREATE TABLE 表名(    字段名 数据类型,    ...    [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名));</code></pre><pre><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名)REFERENCES 主表 (主表列名) ;</code></pre><p>为emp表的dept_id字段添加外键约束,关联dept表的主键id。</p><pre><code>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id);</code></pre><p><img src="/mysql-01/image-20230318161641788.png" alt="image-20230318161641788"></p><p>添加了外键约束之后，到dept表(父表)删除id为1的记录。 此时 将会报错，不能删除或更新父表记录，因为存在外键约束。</p><p>2). 删除外键</p><pre><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</code></pre><p>案例： 删除emp表的外键fk_emp_dept_id。</p><pre><code>alter table emp drop foreign key fk_emp_dept_id;</code></pre><h3 id="4-3-3-删除-更新行为"><a href="#4-3-3-删除-更新行为" class="headerlink" title="4.3.3 删除/更新行为"></a>4.3.3 删除/更新行为</h3><p>添加了外键之后，再删除父表数据时产生的约束行为，称为删除/更新行为。具体的删除/更新行 为有以下几种</p><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 RESTRICT 一致) 默认行为</td></tr><tr><td>RESTRICT</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不 允许删除/更新。 (与 NO ACTION 一致) 默认行为</td></tr><tr><td>CASCADE</td><td>当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有，则 也删除/更新外键在子表中的记录。</td></tr><tr><td>SET NULL</td><td>当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表 中该外键值为null（这就要求该外键允许取null）。</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键列设置成一个默认的值 (Innodb不支持)</td></tr></tbody></table><p>具体语法为:</p><pre><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;</code></pre><p>演示如下：</p><p>1). CASCADE</p><pre><code>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id) on update cascade on delete cascade ;</code></pre><p>A. 修改父表id为1的记录，将id修改为6</p><p><img src="/mysql-01/image-20230318162417947.png" alt="image-20230318162417947"></p><p>原来在子表中dept_id值为1的记录，现在也变为6了，这就是cascade级联的效果。</p><p>在一般的业务系统中，不会修改一张表的主键值。</p><p>B. 删除父表id为6的记录</p><p><img src="/mysql-01/image-20230318162446703.png" alt="image-20230318162446703"></p><p>父表的数据删除成功了，但是子表中关联的记录也被级联删除了。</p><p>2). SET NULL</p><pre><code>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id) on update set null on delete set null ;</code></pre><p><img src="/mysql-01/image-20230318162633853.png" alt="image-20230318162633853"></p><p>父表的记录是可以正常的删除的，父表的数据删除之后，再打开子表 emp，发现子表emp 的dept_id字段，原来dept_id为1的数据，现在都被置为NULL了。</p><p><img src="/mysql-01/image-20230318162649038.png" alt="image-20230318162649038"></p><h1 id="5-多表查询"><a href="#5-多表查询" class="headerlink" title="5.多表查询"></a>5.多表查询</h1><h2 id="5-1-多表关系"><a href="#5-1-多表关系" class="headerlink" title="5.1 多表关系"></a>5.1 多表关系</h2><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结 构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：</p><ul><li>一对多(多对一)</li><li>多对多</li><li>一对一</li></ul><h3 id="5-1-1-一对多"><a href="#5-1-1-一对多" class="headerlink" title="5.1.1 一对多"></a>5.1.1 一对多</h3><ul><li>案例: 部门 与 员工的关系</li><li>关系: 一个部门对应多个员工，一个员工对应一个部门 </li><li>实现: 在多的一方建立外键，指向一的一方的主键</li></ul><p><img src="/mysql-01/image-20230318163215620.png" alt="image-20230318163215620"></p><h3 id="5-1-2-多对多"><a href="#5-1-2-多对多" class="headerlink" title="5.1.2 多对多"></a>5.1.2 多对多</h3><ul><li>案例: 学生 与 课程的关系 </li><li>关系: 一个学生可以选修多门课程，一门课程也可以供多个学生选择 </li><li>实现: 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</li></ul><p><img src="/mysql-01/image-20230318163305957.png" alt="image-20230318163305957"></p><p>约束语句：</p><pre><code>constraint fk_courseid foreign key (courseid) references course (id),constraint fk_studentid foreign key (studentid) references student (id)</code></pre><h3 id="5-1-3-一对一"><a href="#5-1-3-一对一" class="headerlink" title="5.1.3 一对一"></a>5.1.3 一对一</h3><p>案例: 用户 与 用户详情的关系 关系:</p><p> 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另 一张表中，以提升操作效率 </p><p>实现: 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</p><p><img src="/mysql-01/image-20230318163537120.png" alt="image-20230318163537120"></p><h2 id="5-2-多表查询"><a href="#5-2-多表查询" class="headerlink" title="5.2 多表查询"></a>5.2 多表查询</h2><h3 id="5-2-2-概述"><a href="#5-2-2-概述" class="headerlink" title="5.2.2 概述"></a>5.2.2 概述</h3><p>多表查询就是指从多张表中查询数据。</p><p>原来查询单表数据，执行的SQL形式为：select * from emp;</p><p>那么我们要执行多表查询，就只需要使用逗号分隔多张表即可，如： select * from emp , dept ; 具体的执行结果如下:</p><p><img src="/mysql-01/image-20230318163656019.png" alt="image-20230318163656019"></p><p>此时,查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录 (17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。</p><p>笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况。</p><p><img src="/mysql-01/image-20230318163727372.png" alt="image-20230318163727372"></p><p>而在多表查询中，是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。</p><p><img src="/mysql-01/image-20230318163744086.png" alt="image-20230318163744086"></p><p>给多表查询加上连接查询的条件，消除笛卡尔集。</p><pre><code>select * from emp , dept where emp.dept_id = dept.id;</code></pre><p><img src="/mysql-01/image-20230318163821696.png" alt="image-20230318163821696"></p><p>而由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询 到。</p><h3 id="5-2-3-分类"><a href="#5-2-3-分类" class="headerlink" title="5.2.3 分类"></a>5.2.3 分类</h3><p>连接查询 </p><p>​    内连接：相当于查询A、B交集部分数据     </p><p>​    外连接：     </p><p>​        左外连接：查询左表所有数据，以及两张表交集部分数据     </p><p>​        右外连接：查询右表所有数据，以及两张表交集部分数据     </p><p>​    自连接：当前表与自身的连接查询，自连接必须使用表别名</p><ul><li>子查询</li></ul><p><img src="/mysql-01/image-20230318164141106.png" alt="image-20230318164141106"></p><h2 id="5-3-内连接"><a href="#5-3-内连接" class="headerlink" title="5.3 内连接"></a>5.3 内连接</h2><p><img src="/mysql-01/image-20230318164353496.png" alt="image-20230318164353496"></p><p>内连接查询的是两张表交集部分的数 据。(也就是绿色部分的数据) 内连接的语法分为两种: 隐式内连接、显式内连接。</p><p>1). 隐式内连接</p><pre><code>SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 ... ;</code></pre><p>2). 显式内连接</p><pre><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ... ;</code></pre><p>案例: </p><p>A. 查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现) </p><p>表结构: emp , dept </p><p>连接条件: emp.dept_id = dept.id</p><pre><code>select emp.name , dept.name from emp , dept where emp.dept_id = dept.id ;-- 为每一张表起别名,简化SQL编写select e.name,d.name from emp e , dept d where e.dept_id = d.id;</code></pre><p>B. 查询每一个员工的姓名 , 及关联的部门的名称 (显式内连接实现) — INNER JOIN … ON …</p><p>​    表结构: emp , dept </p><p>​    连接条件: emp.dept_id = dept.id</p><pre><code>select e.name, d.name from emp e inner join dept d on e.dept_id = d.id;-- 为每一张表起别名,简化SQL编写select e.name, d.name from emp e join dept d on e.dept_id = d.id;</code></pre><p>注意事项:一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字 段。</p><h2 id="5-4-外连接"><a href="#5-4-外连接" class="headerlink" title="5.4 外连接"></a>5.4 外连接</h2><p><img src="/mysql-01/image-20230318165025944.png" alt="image-20230318165025944"></p><p>外连接分为两种，分别是：左外连接 和 右外连接。具体的语法结构为：</p><p>1). 左外连接</p><pre><code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ;</code></pre><p>左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。</p><p>2). 右外连接</p><pre><code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ... ;</code></pre><p>右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。</p><p>案例:</p><p>A.     查询emp表的所有数据, 和对应的部门信息 </p><p>​        由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。         表结构: emp, dept 连接条件: emp.dept_id = dept.id</p><p>​        连接条件: emp.dept_id = dept.id</p><pre><code>select e.*, d.name from emp e left outer join dept d on e.dept_id = d.id;select e.*, d.name from emp e left join dept d on e.dept_id = d.id;</code></pre><p>​    B. 查询dept表的所有数据, 和对应的员工信息(右外连接)</p><p>由于需求中提到，要查询dept表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查 询。 </p><p>​    表结构: emp, dept </p><p>​    连接条件: emp.dept_id = dept.id</p><pre><code>select d.*, e.* from emp e right outer join dept d on e.dept_id = d.id;select d.*, e.* from dept d left outer join emp e on e.dept_id = d.id;</code></pre><p>注意事项： 左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺 序就可以了。日常开发使用时，更偏向于左外连接。</p><h2 id="5-5-自连接"><a href="#5-5-自连接" class="headerlink" title="5.5 自连接"></a>5.5 自连接</h2><h3 id="5-5-1-自连接查询"><a href="#5-5-1-自连接查询" class="headerlink" title="5.5.1 自连接查询"></a>5.5.1 自连接查询</h3><p>自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。</p><pre><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ... ;</code></pre><p>而对于自连接查询，可以是内连接查询，也可以是外连接查询。</p><p>案例： </p><p>A. 查询员工 及其 所属领导的名字 </p><p>表结构: emp</p><pre><code>select a.name , b.name from emp a , emp b where a.managerid = b.id;</code></pre><p>B. 查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来 </p><p>表结构: emp a , emp b</p><p>注意事项: 在自连接查询中，必须要为表起别名，要不然不清楚所指定的条件、返回的字段，到底 是哪一张表的字段</p><h3 id="5-5-2-联合查询"><a href="#5-5-2-联合查询" class="headerlink" title="5.5.2 联合查询"></a>5.5.2 联合查询</h3><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p><pre><code>SELECT 字段列表 FROM 表A ...UNION [ ALL ]SELECT 字段列表 FROM 表B ....;</code></pre><ul><li>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。</li><li>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。</li></ul><p>案例: A. 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来. </p><p>当前对于这个需求，可以直接使用多条件查询，使用逻辑运算符 or 连接即可。 也可以通过union/union all来联合查询.</p><p><img src="/mysql-01/image-20230318171722519.png" alt="image-20230318171722519"></p><p>union all查询出来的结果，仅仅进行简单的合并，并未去重</p><pre><code>select * from emp where salary &lt; 5000unionselect * from emp where age &gt; 50;</code></pre><p><img src="/mysql-01/image-20230318171749423.png" alt="image-20230318171749423"></p><p>union 联合查询，会对查询出来的结果进行去重处理。</p><p>注意： 如果多条查询语句查询出来的结果，字段数量不一致，在进行union/union all联合查询时，将会报错。如：</p><p><img src="/mysql-01/image-20230318171808521.png" alt="image-20230318171808521"></p><h2 id="5-6-子查询"><a href="#5-6-子查询" class="headerlink" title="5.6 子查询"></a>5.6 子查询</h2><h3 id="5-6-1-概述"><a href="#5-6-1-概述" class="headerlink" title="5.6.1 概述"></a>5.6.1 概述</h3><p>1). 概念</p><p>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</p><pre><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 );</code></pre><p>子查询外部的语句可以是INSERT / UPDATE / DELETE / SELECT 的任何一个。</p><p>2). 分类</p><p>根据子查询结果不同，分为：</p><p>A. 标量子查询（子查询结果为单个值）</p><p>B. 列子查询(子查询结果为一列) </p><p>C. 行子查询(子查询结果为一行) </p><p>D. 表子查询(子查询结果为多行多列)</p><p>根据子查询位置，分为： </p><p>A. WHERE之后 </p><p>B. FROM之后 </p><p>C. SELECT之后</p><h3 id="5-6-2-标量子查询"><a href="#5-6-2-标量子查询" class="headerlink" title="5.6.2 标量子查询"></a>5.6.2 标量子查询</h3><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。 常用的操作符：= &lt;&gt; &gt; &gt;= &lt; &lt;= </p><p>案例: </p><p>A. 查询 “销售部” 的所有员工信息 </p><p>完成这个需求时，可以将需求分解为两步：</p><p>①. 查询 “销售部” 部门ID</p><pre><code>select id from dept where name = &#39;销售部&#39;;</code></pre><p>②. 根据 “销售部” 部门ID, 查询员工信息</p><pre><code>select * from emp where dept_id = (select id from dept where name = &#39;销售部&#39;);</code></pre><p>B. 查询在 “方东白” 入职之后的员工信息 </p><p>完成这个需求时，可以将需求分解为两步：</p><p>①. 查询 方东白 的入职日期</p><pre><code>select entrydate from emp where name = &#39;方东白&#39;;</code></pre><p>②. 查询指定入职日期之后入职的员工信息</p><pre><code>select * from emp where entrydate &gt; (select entrydate from emp where name = &#39;方东白&#39;);</code></pre><h3 id="5-6-3-列子查询"><a href="#5-6-3-列子查询" class="headerlink" title="5.6.3 列子查询"></a>5.6.3 列子查询</h3><p>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。</p><p>常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的集合范围之内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围之内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><p>案例: </p><p>A. 查询 “销售部” 和 “市场部” 的所有员工信息</p><p>分解为以下两步:</p><p> ①. 查询 “销售部” 和 “市场部” 的部门ID</p><pre><code>select id from dept where name = &#39;销售部&#39; or name = &#39;市场部&#39;;</code></pre><p>②. 根据部门ID, 查询员工信息</p><pre><code>select * from emp where dept_id in (select id from dept where name = &#39;销售部&#39; orname = &#39;市场部&#39;);</code></pre><p>B. 查询比 财务部 所有人工资都高的员工信息</p><p>分解为以下两步: ①. 查询所有 财务部 人员工资</p><pre><code>select id from dept where name = &#39;财务部&#39;;select salary from emp where dept_id = (select id from dept where name = &#39;财务部&#39;);</code></pre><p>②. 比 财务部 所有人工资都高的员工信息</p><pre><code>select * from emp where salary &gt; all ( select salary from emp where dept_id =(select id from dept where name = &#39;财务部&#39;) );</code></pre><p>C. 查询比研发部其中任意一人工资高的员工信息</p><p>分解为以下两步:</p><p>①. 查询研发部所有人工资</p><pre><code>select salary from emp where dept_id = (select id from dept where name = &#39;研发部&#39;);</code></pre><p>②. 比研发部其中任意一人工资高的员工信息</p><pre><code>select * from emp where salary &gt; any ( select salary from emp where dept_id =(select id from dept where name = &#39;研发部&#39;) );</code></pre><h3 id="5-6-4-行子查询"><a href="#5-6-4-行子查询" class="headerlink" title="5.6.4 行子查询"></a>5.6.4 行子查询</h3><p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。</p><p> 常用的操作符：= 、&lt;&gt; 、IN 、NOT IN</p><p>案例: </p><p>A. 查询与 “张无忌” 的薪资及直属领导相同的员工信息 ; </p><p>这个需求同样可以拆解为两步进行: </p><p>①. 查询 “张无忌” 的薪资及直属领导</p><pre><code> select salary, managerid from emp where name = &#39;张无忌&#39;;</code></pre><p>②. 查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;</p><pre><code>select * from emp where (salary,managerid) = (select salary, managerid from empwhere name = &#39;张无忌&#39;);</code></pre><h3 id="5-6-5-表子查询"><a href="#5-6-5-表子查询" class="headerlink" title="5.6.5 表子查询"></a>5.6.5 表子查询</h3><p>子查询返回的结果是多行多列，这种子查询称为表子查询。 </p><p>常用的操作符：IN</p><p>案例: </p><p>A. 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><p> 分解为两步执行:</p><p>①. 查询 “鹿杖客” , “宋远桥” 的职位和薪资</p><pre><code>select job, salary from emp where name = &#39;鹿杖客&#39; or name = &#39;宋远桥&#39;;</code></pre><p>②. 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息</p><pre><code>select * from emp where (job,salary) in ( select job, salary from emp where name =&#39;鹿杖客&#39; or name = &#39;宋远桥&#39; );</code></pre><p>B. 查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息</p><p>分解为两步执行:</p><p>①. 入职日期是 “2006-01-01” 之后的员工信息</p><pre><code>select * from emp where entrydate &gt; &#39;2006-01-01&#39;;</code></pre><p>②. 查询这部分员工, 对应的部门信息;</p><pre><code>select e.*, d.* from (select * from emp where entrydate &gt; &#39;2006-01-01&#39;) e leftjoin dept d on e.dept_id = d.id ;</code></pre><h1 id="6-事务"><a href="#6-事务" class="headerlink" title="6.事务"></a>6.事务</h1><h2 id="6-1-事务简介"><a href="#6-1-事务简介" class="headerlink" title="6.1 事务简介"></a>6.1 事务简介</h2><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系 统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>就比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加 1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。</p><p><img src="/mysql-01/image-20230318175145463.png" alt="image-20230318175145463"></p><p>正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四 增加1000, 转账成功 :</p><p><img src="/mysql-01/image-20230318175413465.png" alt="image-20230318175413465"></p><p>异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张 三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了。</p><p><img src="/mysql-01/image-20230318175427146.png" alt="image-20230318175427146"></p><p>为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行 完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态。</p><p><img src="/mysql-01/image-20230318175441174.png" alt="image-20230318175441174"></p><p>注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐 式的提交事务。</p><h2 id="6-2-事务操作"><a href="#6-2-事务操作" class="headerlink" title="6.2 事务操作"></a>6.2 事务操作</h2><h3 id="6-2-1-未控制事务"><a href="#6-2-1-未控制事务" class="headerlink" title="6.2.1 未控制事务"></a>6.2.1 未控制事务</h3><p>正常执行</p><p><img src="/mysql-01/image-20230318175558427.png" alt="image-20230318175558427"></p><p> 测试异常情况</p><pre><code>-- 1. 查询张三余额select * from account where name = &#39;张三&#39;;-- 2. 张三的余额减少1000update account set money = money - 1000 where name = &#39;张三&#39;;出错了....-- 3. 李四的余额增加1000update account set money = money + 1000 where name = &#39;李四&#39;;</code></pre><p><img src="/mysql-01/image-20230318175542807.png" alt="image-20230318175542807"></p><p>检查最终的数据情况, 发现数据在操作前后不一致了。</p><h3 id="6-2-2-控制事务一"><a href="#6-2-2-控制事务一" class="headerlink" title="6.2.2 控制事务一"></a>6.2.2 控制事务一</h3><p>1). 查看/设置事务提交方式</p><pre><code>SELECT @@autocommit ;SET @@autocommit = 0 ;</code></pre><p>2). 提交事务</p><pre><code>COMMIT;</code></pre><p>3). 回滚事务</p><pre><code>ROLLBACK;</code></pre><p>注意：上述的这种方式，是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提 交, 此时执行的DML语句都不会提交, 需要手动的执行commit进行提交。</p><h3 id="6-2-3-控制事务二"><a href="#6-2-3-控制事务二" class="headerlink" title="6.2.3 控制事务二"></a>6.2.3 控制事务二</h3><p>1). 开启事务</p><pre><code>START TRANSACTION 或 BEGIN ;</code></pre><p>2). 提交事务</p><pre><code>COMMIT;</code></pre><p>3). 回滚事务</p><pre><code>ROLLBACK;</code></pre><p>转账案例：</p><pre><code>-- 开启事务start transaction-- 1. 查询张三余额select * from account where name = &#39;张三&#39;;-- 2. 张三的余额减少1000update account set money = money - 1000 where name = &#39;张三&#39;;-- 3. 李四的余额增加1000update account set money = money + 1000 where name = &#39;李四&#39;;-- 如果正常执行完毕, 则提交事务commit;-- 如果执行过程中报错, 则回滚事务-- rollback;</code></pre><h3 id="6-3-事务四大特性"><a href="#6-3-事务四大特性" class="headerlink" title="6.3 事务四大特性"></a>6.3 事务四大特性</h3><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 </li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><p><img src="/mysql-01/image-20230318180214740.png" alt="image-20230318180214740"></p><h3 id="6-4-并发事务问题"><a href="#6-4-并发事务问题" class="headerlink" title="6.4 并发事务问题"></a>6.4 并发事务问题</h3><p>1). 赃读：一个事务读到另外一个事务还没有提交的数据。</p><p><img src="/mysql-01/image-20230318180237160.png" alt="image-20230318180237160"></p><p>比如B读取到了A未提交的数据。</p><p>2). 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p><p><img src="/mysql-01/image-20230318180253685.png" alt="image-20230318180253685"></p><p> 事务A两次读取同一条记录，但是读取到的数据却是不一样的。</p><p>3). 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 “幻影”。</p><p><img src="/mysql-01/image-20230318180423731.png" alt="image-20230318180423731"></p><h3 id="6-5-事务隔离级别"><a href="#6-5-事务隔离级别" class="headerlink" title="6.5 事务隔离级别"></a>6.5 事务隔离级别</h3><p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read(默认)</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>1). 查看事务隔离级别</p><pre><code>SELECT @@TRANSACTION_ISOLATION;</code></pre><p>2). 设置事务隔离级别</p><pre><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED |READ COMMITTED | REPEATABLE READ | SERIALIZABLE }</code></pre><p>注意：事务隔离级别越高，数据越安全，但是性能越低。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
